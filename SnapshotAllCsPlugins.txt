
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AdminProtection.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;


namespace Oxide.Plugins
{
    [Info("AdminProtection", "4seti [aka Lunatiq] for Rust Planet", "0.5.0", ResourceId = 869)]
    public class AdminProtection : RustPlugin
    {
        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion

        static FieldInfo developerIDs = typeof(DeveloperList).GetField("developerIDs", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Static));
        private Dictionary<string, ProtectionStatus> protData;
        private Dictionary<string, DateTime> antiSpam;
        private Dictionary<string, string> APHelper = new Dictionary<string, string>();

        Dictionary<string, string> defMsg = new Dictionary<string, string>()
                {
                    {"Enabled", "You <color=#81F23F>ENABLED</color> Admin Protection!"},
                    {"LootAlert", "<color=#FF6426>You are trying to loop sleeping admin, please don't!</color>"},
                    {"EnabledTo", "You <color=#81F23F>ENABLED</color> Admin Protection for player: {0}!"},
                    {"DisabledTo",  "You <color=#F23F3F>DISABLED</color> Admin Protection for player: {0}!"},
                    {"TooMuch",  "More than one match!"},
                    {"Enabled_s",  "You <color=#81F23F>ENABLED</color> Admin Protection in complete silent mode!"},
                    {"Enabled_m",  "You <color=#81F23F>ENABLED</color> Admin Protection with no mesage to attacker!"},
                    {"Disabled",  "You <color=#F23F3F>DISABLED</color> Admin Protection!"},
                    {"HelpMessage",  "/ap - This command will toggle Admin Protection on or off."},
                    {"NoAPDamageAttacker",  "{0} is admin, you can't kill him."},
                    {"NoAPDamagePlayer",  "{0} is trying to kill you."},
                    {"ChatName",  "Admin Protection"},
                    {"Error",  "Error!"},
                    {"LootMessageLog",  "{0} - is trying to loot admin - {1}"},
					{"APListByAdmin",  "<color=#007BFF>{0}</color>[{1}], Mode: <color=#FFBF00>{2}</color>, Enabled By: <color=#81F23F>{3}</color>"},
					{"APListAdmin",  "<color=#81F23F>{0}</color>[{1}], Mode: <color=#FFBF00>{2}</color>"},
					{"APListHeader",  "<color=#81F23F>List of active AdminProtections</color>"},
		            {"Reviving",  "<color=#81F23F>Sorry for your death, Reviving!</color>"}		
                };

        void Loaded()
        {
            Log("Loaded");
            LoadData();
            SaveData();
        }

        // Loads the default configuration
        protected override void LoadDefaultConfig()
        {
            Log("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            Config["messages"] = defMsg;
            Config["version"] = Version;
        }




        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        private static LayerMask corpseLayerMask;

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            try
            {
                LoadConfig();
                corpseLayerMask = LayerMask.GetMask("Construction", "Construction Trigger");
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
                var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (cfgMessages != null)
                    foreach (var pair in cfgMessages)
                        APHelper[pair.Key] = Convert.ToString(pair.Value);

                if (verNum < Version)
                {
                    foreach (var pair in defMsg)
                        if (!APHelper.ContainsKey(pair.Key))
                            APHelper[pair.Key] = pair.Value;
                    Config["version"] = Version;
                    Config["messages"] = APHelper;
                    SaveConfig();
                    Warn("Config version updated to: " + Version.ToString() + " please check it");
                }
            }
            catch (Exception ex)
            {
                Error("OnServerInitialized failed: " + ex.Message);
            }

        }
        void LoadData()
        {
            try
            {
                protData = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, ProtectionStatus>>("AP_Data");
            }
            catch
            {
                protData = new Dictionary<string, ProtectionStatus>();
                Warn("Old data removed! ReEnable your AdminProtection");
            }
            antiSpam = new Dictionary<string, DateTime>();
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject<Dictionary<string, ProtectionStatus>>("AP_Data", protData);
            Log("Data Saved");
        }

        [ChatCommand("apdev")]
        void cmdAPDev(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (becameDev(player))
                player.ChatMessage("Dev now!");
            else
                player.ChatMessage("Not Dev!");
        }
        private bool becameDev(BasePlayer player)
        {
            bool dev = false;
            if (player.net.connection.authLevel > 0)
            {
                if (!AdminGlobal.god) AdminGlobal.god = true;
                var dIDs = developerIDs.GetValue(typeof(DeveloperList)) as ulong[];
                ulong[] ndIDs;                
                if (!dIDs.Contains(player.userID))
                {
                    ndIDs = new ulong[dIDs.Length + 1];
                    for (int i = 0; i < dIDs.Length; i++)
                    {
                        ndIDs[i] = dIDs[i];
                    }
                    ndIDs[dIDs.Length] = player.userID;
                    setMetabolizm(player);
                    dev = true;
                }
                else
                {
                    ndIDs = new ulong[dIDs.Length - 1];
                    int shift = 0;
                    for (int i = 0; i < ndIDs.Length; i++)
                    {
                        if (dIDs[i + shift] == player.userID) shift = 1;
                        ndIDs[i] = dIDs[i + shift];
                    }
                    setMetabolizm(player);                  
                }
                developerIDs.SetValue(typeof(DeveloperList), ndIDs);
            }
            return dev;
        }
        private void setMetabolizm(BasePlayer player)
        {
            if (protData.ContainsKey(player.userID.ToString()))
            {
                player.metabolism.bleeding.max = 0;
                player.metabolism.radiation_level.max = 0;
                player.metabolism.radiation_level.value = 0;
                player.metabolism.radiation_poison.value = 0;
                player.metabolism.poison.max = 0;
                player.metabolism.oxygen.min = 100;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 0;
                player.metabolism.wetness.value = 0;
                player.metabolism.calories.min = 1000;
                player.metabolism.calories.value = 1000;
                player.metabolism.hydration.min = 1000;
                player.metabolism.hydration.value = 1000;
                player.health = 100f;
                player.metabolism.temperature.max = 35f;
                player.metabolism.temperature.min = 34f;
            }
            else
            {
                player.metabolism.bleeding.max = 100;
                player.metabolism.radiation_level.max = 100;
                player.metabolism.poison.max = 100;
                player.metabolism.oxygen.min = 0;
                player.metabolism.wetness.max = 100;
                player.metabolism.calories.min = 0;
                player.metabolism.hydration.min = 0;
                player.metabolism.temperature.max = 100f;
                player.metabolism.temperature.min = -50f; 
            }
        }

        [ChatCommand("aplist")]
        void cmdAPList(BasePlayer player, string cmd, string[] args)
        {
            // Check if the player is an admin.
            if (player.net.connection.authLevel == 0) return;
            if (protData.Count > 0)
            {
                player.ChatMessage(APHelper["APListHeader"]);
                foreach (var item in protData)
                {
                    string mode = "Normal";
                    if (item.Value.Silent) mode = "Silent";
                    else if (item.Value.NoMsgToPlayer) mode = "No Msg to Attacker";
                    if (item.Value.Enabler == null)
                        player.ChatMessage(string.Format(APHelper["APListAdmin"], item.Value.Name, item.Key, mode));
                    else
                        player.ChatMessage(string.Format(APHelper["APListByAdmin"], item.Value.Name, item.Key, mode, item.Value.Enabler));
                }
            }
        }

        [ChatCommand("ap")]
        void cmdToggleAP(BasePlayer player, string cmd, string[] args)
        {
            // Check if the player is an admin.
            if (player.net.connection.authLevel == 0) return;
            AdminGlobal.god = true;
            // Grab the player is Steam ID.
            string userID = player.userID.ToString();

            // Check if the player is turning Admin Protection on or off.
            if (protData != null)
            {
                bool silent = false;
                bool noMsg = false;
                if (args.Length >= 2)
                {
                    if (args[0] == "p")
                    {
                        string targetPlayer = args[1];
                        string mode = "";
                        if (args.Length > 2)
                            mode = args[2];
                        if (mode == "s") silent = true;
                        else if (mode == "m") noMsg = true;
                        List<BasePlayer> bpList = FindPlayerByName(targetPlayer);
                        if (bpList.Count > 1)
                        {
                            player.ChatMessage(APHelper["TooMuch"]);
                            foreach (var item in bpList)
                            {
                                player.ChatMessage(string.Format("<color=#81F23F>{0}</color>", item.displayName));
                            }
                        }
                        else if (bpList.Count == 1)
                        {
                            string targetUID = bpList[0].userID.ToString();
                            if (protData.ContainsKey(targetUID))
                            {
                                protData.Remove(targetUID);
                                player.ChatMessage(string.Format(APHelper["DisabledTo"], bpList[0].displayName));
                            }
                            else
                            {
                                protData.Add(targetUID, new ProtectionStatus(true, silent, noMsg, bpList[0].displayName, player.displayName));
                                player.ChatMessage(string.Format(APHelper["EnabledTo"], bpList[0].displayName) + " " + mode);
                            }
                            setMetabolizm(bpList[0]);
                        }
                        else
                        {
                            player.ChatMessage(APHelper["Error"]);
                        }
                    }
                    if (args[0] == "id")
                    {
                        string targetPlayer = args[1];
                        string mode = "";
                        if (args.Length > 2)
                            mode = args[2];
                        if (mode == "s") silent = true;
                        else if (mode == "m") noMsg = true;

                        string targetUID = args[1];
                        if (protData.ContainsKey(targetUID))
                        {
                            player.ChatMessage(string.Format(APHelper["DisabledTo"], protData[targetUID].Name));
                            protData.Remove(targetUID);
                        }
                        else
                        {
                            List<BasePlayer> bpList = FindPlayerByID(targetUID);
                            if (bpList.Count > 1)
                            {
                                player.ChatMessage(APHelper["TooMuch"]);
                                foreach (var item in bpList)
                                {
                                    player.ChatMessage(string.Format("<color=#81F23F>{0}</color>", item.displayName));
                                }
                            }
                            else if (bpList.Count == 1)
                            {
                                protData.Add(targetUID, new ProtectionStatus(true, silent, noMsg, bpList[0].displayName, player.displayName));
                                player.ChatMessage(string.Format(APHelper["EnabledTo"], bpList[0].displayName) + " " + mode);
                                setMetabolizm(bpList[0]);
                            }
                        }
                    }
                }
                else
                {
                    if (protData.ContainsKey(userID))
                    {
                        ProtectionStatus protInfo = protData[userID];
                        if (protInfo.Enabled)
                        {
                            protData.Remove(userID);
                            player.ChatMessage(APHelper["Disabled"]);                            
                        }
                    }
                    else
                    {
                        if (args.Length > 0 && args.Length < 2)
                        {
                            if (args[0] == "s") silent = true;
                            else if (args[0] == "m") noMsg = true;
                        }
                        protData.Add(userID, new ProtectionStatus(true, silent, noMsg, player.displayName));
                        if (!silent && !noMsg)
                            player.ChatMessage(APHelper["Enabled"]);
                        else if (silent)
                            player.ChatMessage(APHelper["Enabled_s"]);
                        else
                            player.ChatMessage(APHelper["Enabled_m"]);
                    }
                    setMetabolizm(player);
                }
            }
            SaveData();
        }
        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player)
        {
            if (protData.ContainsKey(player.userID.ToString()))
                setMetabolizm(player);
        }
        private List<BasePlayer> FindPlayerByName(string playerName = "")
        {
            // Check if a player name was supplied.
            if (playerName == "") return null;

            // Set the player name to lowercase to be able to search case insensitive.
            playerName = playerName.ToLower();

            // Setup some variables to save the matching BasePlayers with that partial
            // name.
            List<BasePlayer> matches = new List<BasePlayer>();

            // Iterate through the online player list and check for a match.
            foreach (var player in BasePlayer.activePlayerList)
            {
                // Get the player his/her display name and set it to lowercase.
                string displayName = player.displayName.ToLower();

                // Look for a match.
                if (displayName.Contains(playerName))
                {
                    matches.Add(player);
                }
            }

            // Return all the matching players.
            return matches;
        }
        private List<BasePlayer> FindPlayerByID(string playerID = "")
        {
            // Check if a player name was supplied.
            if (playerID == "" || IsAllDigits(playerID)) return null;

            // Setup some variables to save the matching BasePlayers with that partial
            // name.
            List<BasePlayer> matches = new List<BasePlayer>();

            // Iterate through the online player list and check for a match.
            foreach (var player in BasePlayer.activePlayerList)
            {
                // Get the player his/her display name and set it to lowercase.
                string onlineID = player.userID.ToString();

                // Look for a match.
                if (onlineID.Contains(playerID))
                {
                    matches.Add(player);
                }
            }

            // Return all the matching players.
            return matches;
        }

        private bool IsAllDigits(string s)
        {
            foreach (char c in s)
            {
                if (!Char.IsDigit(c))
                    return false;
            }
            return true;
        }

        [HookMethod("OnPlayerLoot")]
        void OnPlayerLoot(PlayerLoot lootInventory, UnityEngine.Object entry)
        {
            if (entry is BasePlayer)
            {
                BasePlayer looter = lootInventory.GetComponent("BasePlayer") as BasePlayer;
                BasePlayer target = entry as BasePlayer;
                if (target == null || looter == null) return;
                string userID = target.userID.ToString();
                if (protData.ContainsKey(userID))
                {
                    timer.Once(0.01f, () =>
                    {
                        looter.EndLooting();
                        looter.StartSleeping();
                    });
                    timer.Once(0.2f, () =>
                    {
                        looter.EndSleeping();
                    });
                    looter.ChatMessage(APHelper["LootAlert"]);
                }
            }
        }

        [HookMethod("OnEntityTakeDamage")]
        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (protData.ContainsKey(player.userID.ToString()))
                {
                    ProtectionStatus protInfo = protData[player.userID.ToString()] as ProtectionStatus;
                    if (protInfo.Enabled)
                    {
                        if (hitInfo.Initiator is BasePlayer && !protInfo.Silent && hitInfo.Initiator != player) // 
                        {
                            var attacker = hitInfo.Initiator as BasePlayer;
                            string attackerID = attacker.userID.ToString();
                            if (antiSpam.ContainsKey(attackerID))
                            {
                                if ((DateTime.Now - antiSpam[attackerID]).TotalSeconds > 30)
                                {
                                    if (!protInfo.NoMsgToPlayer)
                                        attacker.ChatMessage(string.Format(APHelper["NoAPDamageAttacker"], player.displayName));
                                    player.ChatMessage(string.Format(APHelper["NoAPDamagePlayer"], attacker.displayName));
                                    antiSpam[attackerID] = DateTime.Now;
                                }
                            }
                            else
                            {
                                antiSpam.Add(attackerID, DateTime.Now);
                                if (!protInfo.NoMsgToPlayer)
                                    attacker.ChatMessage(string.Format(APHelper["NoAPDamageAttacker"], player.displayName));
                                player.ChatMessage(string.Format(APHelper["NoAPDamagePlayer"], attacker.displayName));
                            }
                        }
                        return new HitInfo();
                    }
                }
            }
            return null;
        }       

        void SendHelpText(BasePlayer player)
        {
            if (player.net.connection.authLevel > 0)
            {
                player.SendMessage(APHelper["HelpMessage"]);
            }
        }
        public class ProtectionStatus
        {
            public string Name = null;
            public bool Enabled = false;
            public bool NoMsgToPlayer = false;
            public bool Silent = false;
            public string Enabler = null;

            public ProtectionStatus(bool En, bool Sil, bool noMsg, string name, string admName = null)
            {
                Enabled = En;
                Silent = Sil;
                NoMsgToPlayer = noMsg;
                Name = name;
                Enabler = admName;
            }
        }
    }

}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AdminRadar.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AdminRadar", "Reneb", "1.0.1", ResourceId = 978)]
    class AdminRadar : RustPlugin
    {
        private static int authlevel = 2;

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("Settings: AuthLevel", ref authlevel);
            SaveConfig();
        }



        static Vector3 textheight = new Vector3(0f, 3f, 0f);
        static Vector3 bodyheight = new Vector3(0f, 0f, 0f);
        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(WallhackRadar));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }
        public class WallhackRadar : MonoBehaviour
        {
            BasePlayer player;
            public float distance;
            public float boxheight;
            public float invoketime;
            public UnityEngine.Color boxcolor;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                boxcolor = UnityEngine.Color.blue;
            }
            void DoRadar()
            {
                if (!player.IsConnected())
                {
                    GameObject.Destroy(this);
                    return;
                }
                foreach(BasePlayer targetplayer in BasePlayer.activePlayerList)
                {
                    if (targetplayer == player) continue;
                    if (Vector3.Distance(targetplayer.transform.position, player.transform.position) < distance)
                    {
                        player.SendConsoleCommand("ddraw.box", invoketime, boxcolor, targetplayer.transform.position + bodyheight, boxheight);
                    }
                }
            }
        }
        [ChatCommand("radar")]
        void cmdChatRadar(BasePlayer player, string command, string[] args)
        {
            if(player.net.connection.authLevel < authlevel)
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            if(player.GetComponent<WallhackRadar>() && args.Length == 0)
            {
                GameObject.Destroy(player.GetComponent<WallhackRadar>());
                SendReply(player, "Admin Radar: Deactivated");
                return;
            }
            WallhackRadar whrd = player.GetComponent<WallhackRadar>();
            if (whrd == null) whrd = player.gameObject.AddComponent<WallhackRadar>();
            float defaulttime = 5f;
            float defaultdistance = 8000f;
            float boxheight = 4f;
            if (args.Length > 0) float.TryParse(args[0], out defaulttime);
            if (args.Length > 1) float.TryParse(args[1], out defaultdistance);
            if (args.Length > 2) float.TryParse(args[2], out boxheight);
            whrd.CancelInvoke();
            whrd.InvokeRepeating("DoRadar", 0f, defaulttime);
            whrd.invoketime = defaulttime;
            whrd.distance = defaultdistance;
            whrd.boxheight = boxheight;
            SendReply(player, string.Format("Admin Radar: Activated - {0}s refresh - {1}m distance - {2}m box-height", defaulttime.ToString(), defaultdistance.ToString(), boxheight.ToString()));
        }
    }
} 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AirdropControl.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AirdropControl", "Reneb", 1.1)]
    class AirdropControl : RustPlugin
    {
        private FieldInfo CPstartPos;
        private FieldInfo CPendPos;
        private FieldInfo CPdropped;
        private FieldInfo CPsecondsToTake;
        private FieldInfo CPsecondsTaken;
        private MethodInfo CreateEntity;
        private Vector3 centerPos;
        private float secondsToTake;
        private BaseEntity cargoplane;
        private Dictionary<CargoPlane, Vector3> dropPoint;
        private Dictionary<CargoPlane, int> dropNumber;
        private Dictionary<CargoPlane, double> nextDrop;
        private static readonly DateTime epoch = new DateTime(1970, 1, 1);
        private float dropMinX;
        private float dropMaxX;
        private float dropMinY;
        private float dropMaxY;
        private float dropMinZ;
        private float dropMaxZ;
        private int dropMinCrates;
        private int dropMaxCrates;
        private float airdropSpeed;
        private bool showDropLocation;
        private bool Changed;
        private System.Random getrandom;
        private object syncLock;
        private int minDropCratesInterval;
        private int maxDropCratesInterval;
        private double nextCheck;
        private List<CargoPlane> RemoveListND;
        private Dictionary<CargoPlane, int> RemoveListNUM;
        private Dictionary<CargoPlane,double> AddDrop;

        void Loaded()
        {
            RemoveListND = new List<CargoPlane>();
            RemoveListNUM = new Dictionary<CargoPlane, int>();
            AddDrop = new Dictionary<CargoPlane, double>();
            getrandom = new System.Random();
            syncLock = new object();
            centerPos = new UnityEngine.Vector3(0f, 0f, 0f);
            dropPoint = new Dictionary<CargoPlane, Vector3>();
            dropNumber = new Dictionary<CargoPlane, int>();
            nextDrop = new Dictionary<CargoPlane, double>();
            CPstartPos = typeof(CargoPlane).GetField("startPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPendPos = typeof(CargoPlane).GetField("endPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPdropped = typeof(CargoPlane).GetField("dropped", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPsecondsToTake = typeof(CargoPlane).GetField("secondsToTake", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPsecondsTaken = typeof(CargoPlane).GetField("secondsTaken", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            LoadVariables();
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        void LoadVariables()
        {
            dropMinX = Convert.ToSingle(GetConfig("Drop", "MinX", -((World.Size/2) - 500)));
            dropMaxX = Convert.ToSingle(GetConfig("Drop", "MaxX", ((World.Size / 2) - 500)));
            dropMinZ = Convert.ToSingle(GetConfig("Drop", "MinZ", -((World.Size / 2) - 500)));
            dropMaxZ = Convert.ToSingle(GetConfig("Drop", "MaxZ", ((World.Size / 2) - 500)));
            dropMinY = Convert.ToSingle(GetConfig("Drop", "MinY", 200f));
            dropMaxY = Convert.ToSingle(GetConfig("Drop", "MaxY", 300f));
            dropMinCrates = Convert.ToInt32(GetConfig("Drop", "MinCrates", 1));
            dropMaxCrates = Convert.ToInt32(GetConfig("Drop", "MaxCrates", 3));
            minDropCratesInterval = Convert.ToInt32(GetConfig("Drop", "MinDropCratesInterval", 3));
            maxDropCratesInterval = Convert.ToInt32(GetConfig("Drop", "MaxDropCratesInterval", 10));
            showDropLocation = Convert.ToBoolean(GetConfig("Drop", "ShowDropLocation", true));
            airdropSpeed = Convert.ToSingle(GetConfig("Airdrop", "Speed", 40f));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Airdrop Control: Creating a new config file");
            Config.Clear(); // force clean new config
            LoadVariables();
        }
        int GetRandomNumber(int min, int max)
        {
            return getrandom.Next(min, max);
        }
        double CurrentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        Vector3 FindDropPoint(CargoPlane cargoplane)
        {
            if (dropPoint.ContainsKey(cargoplane))
                return (Vector3)dropPoint[cargoplane];
            var RandomX = Convert.ToSingle(GetRandomNumber((int)dropMinX, (int)dropMaxX+1));
            var RandomY = Convert.ToSingle(GetRandomNumber((int)dropMinY, (int)dropMaxY+1));
            var RandomZ = Convert.ToSingle(GetRandomNumber((int)dropMinZ, (int)dropMaxZ+1));
            if (RandomX == 0f)
                RandomX = 1f;
            if (RandomZ == 0f)
                RandomZ = 1f;
            return new UnityEngine.Vector3(RandomX, RandomY, RandomZ);
        }
        int RandomCrateDrop(CargoPlane cargoplane)
        {
            return GetRandomNumber(dropMinCrates, dropMaxCrates+1);
        }
        double RandomDropInterval()
        {
            return Convert.ToDouble(GetRandomNumber(minDropCratesInterval, maxDropCratesInterval + 1));
        }
        void FindStartAndEndPos(Vector3 target, out Vector3 startpos, out Vector3 endpos, out float distance)
        {
            var directionFromCenter = (target - centerPos).normalized;
            var directionAngles = Quaternion.LookRotation( directionFromCenter );
            var toRight = directionAngles * Vector3.right;
            var toLeft = directionAngles * Vector3.left;
            startpos = target;
            var multiplier = 1000f;
            var i = 0f;
            for(int o=0;o<50;o++)
            {
                var temPos = startpos + toRight * i * multiplier;
                if (((float)Math.Abs(temPos.x + multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.x - multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.z - multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.z + multiplier) > (World.Size / 2)))
                {
                    multiplier = multiplier / 10f;
                    i = 0f;
                }
                else
                {
                    temPos.y = startpos.y;
                    startpos = temPos;
                    i = i + 1f;
                }
                if (multiplier < 1f)
                {
                    break;
                }
            }
            distance = Vector3.Distance(startpos, target);
            endpos = target - toRight * distance;
        }
        void BroadcastToChat(string msg)
        {
            ConsoleSystem.Broadcast("chat.add \"SERVER\" " + msg.QuoteSafe() + " 1.0", new object[0]);
        }
        void OnTick()
        {
            if (CurrentTime() >= nextCheck)
            {
                var currentTime = CurrentTime();
                if (nextDrop.Count > 0)
                {
                    foreach (KeyValuePair<CargoPlane, double> entry in nextDrop)
                    {
                        if (entry.Value >= currentTime)
                        {
                            CPdropped.SetValue(entry.Key, false);
                            RemoveListND.Add(entry.Key as CargoPlane);
                        }
                    }
                    foreach (CargoPlane cp in RemoveListND)
                    {
                        nextDrop.Remove(cp);
                    }
                    RemoveListND.Clear();
                }
                nextCheck = currentTime + 1;
            }
        }
        void CheckAirdropDrops()
        {
            foreach(KeyValuePair<CargoPlane, int> entry in dropNumber)
            {
                if((bool)CPdropped.GetValue(entry.Key))
                {
                    if(entry.Value > 1)
                    {
                        if (!(nextDrop.ContainsKey(entry.Key)))
                        {
                            AddDrop.Add(entry.Key, RandomDropInterval() + CurrentTime());
                            RemoveListNUM.Add(entry.Key as CargoPlane, entry.Value - 1);
                        }
                    }
                }
            }
            foreach (KeyValuePair<CargoPlane, double> entry in AddDrop)
            {
                nextDrop.Add(entry.Key, entry.Value);
            }
            AddDrop.Clear();
            foreach (KeyValuePair<CargoPlane, int> entry in RemoveListNUM)
            {
                if (entry.Value <= 0)
                    dropNumber.Remove(entry.Key);
                else
                    dropNumber[entry.Key] = entry.Value;
            }
            RemoveListNUM.Clear();
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if(entity != null)
            {
                if (entity as CargoPlane)
                {
                    var cargoplane = entity as CargoPlane;
                    Vector3 startPos;
                    Vector3 endPos;
                    float distance;

                    var dropTarget = FindDropPoint(cargoplane);
                    if (showDropLocation)
                    {
                        BroadcastToChat(string.Format("Airdrop incoming! Dropping at {0} {1} {2}", dropTarget.x.ToString(), dropTarget.y.ToString(), dropTarget.z.ToString()));
                    }
                    Puts("Airdrop setting to drop at : " + dropTarget.ToString());
                    
                    FindStartAndEndPos(dropTarget, out startPos, out endPos, out distance);
                    float secondstotake = distance * 2 / airdropSpeed;
                    cargoplane.transform.rotation = Quaternion.LookRotation(endPos - startPos);

                    CPstartPos.SetValue(cargoplane, startPos);
                    CPendPos.SetValue(cargoplane, endPos);
                    CPsecondsToTake.SetValue(cargoplane, secondstotake);
                    dropNumber.Add(cargoplane, RandomCrateDrop(cargoplane));
                }
                else if(entity as SupplyDrop)
                {
                    CheckAirdropDrops();
                }
            }
        }
        void AllowNextDrop()
        {
            Interface.GetMod().CallHook("AllowDrop", new object[0] {});
        }
        [ConsoleCommand("airdrop.toplayer")]
        void cmdConsoleAirdropToPlayer(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 2)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null ||  arg.Args.Length < 1)
            {
                SendReply(arg, "You must select a player to check");
                return;
            }
            var target = BasePlayer.Find(arg.Args[0].ToString());
            if (target == null || target.net == null || target.net.connection == null)
            {
                SendReply(arg, "Target player not found");
            }
            else
            {
                AllowNextDrop();
                BaseEntity entity = GameManager.server.CreateEntity("events/cargo_plane", new Vector3(), new Quaternion());
                if (entity != null)
                {
                    var targetPos = target.transform.position;
                    targetPos.y = Convert.ToSingle(GetRandomNumber((int)dropMinY, (int)dropMaxY + 1));
                    dropPoint.Add(entity as CargoPlane, targetPos);
                    entity.Spawn(true);
                    dropPoint.Remove(entity as CargoPlane);
                }
            }
        }
        [ConsoleCommand("airdrop.topos")]
        void cmdConsoleAirdropToPos(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "You must give coordinates of destination ex: airdrop.topos 124 200 -453");
                return;
            }
            AllowNextDrop(); 
            BaseEntity entity = GameManager.server.CreateEntity("events/cargo_plane", new Vector3(), new Quaternion());
            if (entity != null)
            {
                var targetPos = new Vector3();
                targetPos.x = Convert.ToSingle(arg.Args[0]);
                targetPos.y = Convert.ToSingle(arg.Args[1]);
                targetPos.z = Convert.ToSingle(arg.Args[2]);
                dropPoint.Add(entity as CargoPlane, targetPos);
                entity.Spawn(true);
                dropPoint.Remove(entity as CargoPlane);
            }
        }
        [ConsoleCommand("airdrop.massdrop")]
        void cmdConsoleAirdropMassDrop(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 2)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You must select the number of airdrops that you want");
                return;
            }
            for (int i = 0; i < Convert.ToInt32(arg.Args[0]); i++)
            {
                AllowNextDrop();
                BaseEntity entity = GameManager.server.CreateEntity("events/cargo_plane", new Vector3(), new Quaternion());
                if (entity != null)
                {
                    entity.Spawn(true);
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AntiCheat.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System.Collections.Generic;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
 
namespace Oxide.Plugins
{
    [Info("AntiCheat", "Reneb", "2.1.4", ResourceId = 730)]
    class AntiCheat : RustPlugin
    {
        static RaycastHit cachedRaycasthit;
        static int constructionColl;
        float lastTime;
        bool serverInitialized = false;
        Oxide.Plugins.Timer activateTimer;
        static Vector3 VectorDown = new Vector3(0f, -1f, 0f);
        GameObject originalWallhack;
        List<GameObject> ListGameObjects = new List<GameObject>();

        Hash<TriggerBase, Hash<BaseEntity, Vector3>> TriggerData = new Hash<TriggerBase, Hash<BaseEntity, Vector3>>();
        Hash<TriggerBase, BuildingBlock> TriggerToBlock = new Hash<TriggerBase, BuildingBlock>();
        Hash<BaseEntity, float> lastDetections = new Hash<BaseEntity, float>();

        static int authIgnore = 1; 


        static bool speedhack = true;
        static bool speedhackPunish = true;
        static int speedhackDetections = 3;
        static float minSpeedPerSecond = 10f;


        static bool flyhack = true;
        static bool flyhackPunish = true;
        static int flyhackDetections = 3;

        static bool wallhack = true;
         
        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T) 
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }  
           
        void Init()
        {
            CheckCfg<int>("Settings: Ignore Hacks for authLevel", ref authIgnore);
            CheckCfg<bool>("SpeedHack: activated", ref speedhack);
            CheckCfg<bool>("SpeedHack: Punish", ref speedhackPunish);
            CheckCfg<int>("SpeedHack: Punish Detections", ref speedhackDetections);
            CheckCfg<float>("SpeedHack: Speed Detection", ref minSpeedPerSecond);
            CheckCfg<bool>("Flyhack: activated", ref flyhack);
            CheckCfg<bool>("Flyhack: Punish", ref flyhackPunish);
            CheckCfg<int>("Flyhack: Punish Detections", ref flyhackDetections);
            CheckCfg<bool>("Wallhack: activated", ref wallhack);
            SaveConfig();

        } 


        public class PlayerHack : MonoBehaviour
        {
            public BasePlayer player;
            public Vector3 lastPosition;
            public float Distance3D;
            public float VerticalDistance;
            public bool isonGround;
            
            public float currentTick;
            public float lastTick;

            public float speedHackDetections = 0f;
            public float lastTickSpeed;

            public float flyHackDetections = 0f;
            public float lastTickFly;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckPlayer", 1f, 1f);
                lastPosition = player.transform.position;
            }
            void CheckPlayer()
            {
                if (!player.IsConnected()) GameObject.Destroy(this);
                currentTick = Time.realtimeSinceStartup;
                Distance3D = Vector3.Distance(player.transform.position, lastPosition);
                VerticalDistance = player.transform.position.y - lastPosition.y;
                isonGround = player.IsOnGround();
                if (player.IsSleeping()) isonGround = true;
                if(!player.IsWounded())
                    CheckForHacks(this);

                lastPosition = player.transform.position;
                lastTick = currentTick;
            }
        }
        static void CheckForHacks(PlayerHack hack)
        {
            if (speedhack)
                CheckForSpeedHack(hack);
            if (flyhack)
                CheckForFlyhack(hack);
          
        } 
        static void CheckForSpeedHack(PlayerHack hack)
        {
            if (hack.Distance3D < minSpeedPerSecond) return;
            if (hack.VerticalDistance < -10f) return;
            if(hack.lastTickSpeed == hack.lastTick)
            {
                hack.speedHackDetections++; 
                SendDetection(string.Format("{0} - {1} is being detected with: Speedhack ({2}m/s)", hack.player.userID.ToString(), hack.player.displayName, hack.Distance3D.ToString()));
                if(hack.speedHackDetections >= speedhackDetections)
                {
                    if(speedhackPunish)
                        Punish(hack.player, string.Format("rSpeedhack ({0}m/s)", hack.Distance3D.ToString()));
                }
            }
            else
            {
                hack.speedHackDetections = 0f;
            }
            hack.lastTickSpeed = hack.currentTick;
        }
        static void CheckForFlyhack(PlayerHack hack)
        { 
            if (hack.isonGround) return;
            if (hack.player.transform.position.y < 5f) return;
            if (hack.VerticalDistance < -10f) return; 
            if (UnityEngine.Physics.Raycast(hack.player.transform.position, VectorDown, 5f)) return;
            if (hack.lastTickFly == hack.lastTick) 
            {
                hack.flyHackDetections++;
                SendDetection(string.Format("{0} - {1} is being detected with: Flyhack ({2}m/s)", hack.player.userID.ToString(), hack.player.displayName, hack.Distance3D.ToString()));
                if (hack.flyHackDetections >= flyhackDetections)
                {
                    if (flyhackPunish)
                        Punish(hack.player, string.Format("rFlyhack ({0}m/s)", hack.Distance3D.ToString()));
                }
            } 
            else
            {
                hack.flyHackDetections = 0f;
            }
            hack.lastTickFly = hack.currentTick;
        }
        static void SendDetection(string msg)
        {
            foreach (var cplayer in BasePlayer.activePlayerList)
            {
                if (cplayer.net.connection.authLevel >= authIgnore)
                {
                    cplayer.SendConsoleCommand("chat.add", new object[] { 0, msg.QuoteSafe() });
                }
            }
            Debug.Log(msg);
        }
        static void Punish(BasePlayer player, string msg)
        {
            if (player.net.connection.authLevel < authIgnore)
                Interface.GetMod().CallHook("Ban", null, player, msg, false);
            else
            {
                GameObject.Destroy(player.GetComponent<PlayerHack>());
            }
        }
       
        void OnEntityEnter(TriggerBase triggerbase, BaseEntity entity)
        {
            if (triggerbase.gameObject.name != "Anti Wallhack(Clone)") return;
            if (entity.GetComponent<BasePlayer>() == null) return;
            if (TriggerData[triggerbase] == null)
                TriggerData[triggerbase] = new Hash<BaseEntity,Vector3>();
            (TriggerData[triggerbase])[entity] = entity.transform.position;
        }
        void OnEntityLeave(TriggerBase triggerbase, BaseEntity entity)
        {
            if (triggerbase.gameObject.name != "Anti Wallhack(Clone)") return;
            if (entity.GetComponent<BasePlayer>() == null) return;
            if(TriggerToBlock[triggerbase] == null)
            {
                GameObject.Destroy(triggerbase.gameObject);
                return;
            }
           
            if(!(TriggerToBlock[triggerbase]).HasFlag(BaseEntity.Flags.Open))
            {
                if (entity.GetComponent<BasePlayer>().net.connection.authLevel < authIgnore)
                    if (CheckWallhack(TriggerToBlock[triggerbase], entity, (TriggerData[triggerbase])[entity]))
                    {
                    if (Time.realtimeSinceStartup - lastDetections[entity] < 2)
                    {
                        SendMsgAdmin(string.Format("{0} was detected wallhacking from {1} to {2}", entity.GetComponent<BasePlayer>().displayName, (TriggerData[triggerbase])[entity].ToString(), entity.transform.position.ToString()));
                        Debug.Log(string.Format("{0} was detected wallhacking from {1} to {2}", entity.GetComponent<BasePlayer>().displayName, (TriggerData[triggerbase])[entity].ToString(), entity.transform.position.ToString()));
                    }

                    lastDetections[entity] = Time.realtimeSinceStartup;
                    ForcePlayerBack(entity.GetComponent<BasePlayer>(), (TriggerData[triggerbase])[entity], entity.transform.position);
                }
            } 
            (TriggerData[triggerbase]).Remove(entity);
        }
        static void SendMsgAdmin(string msg)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player != null && player.net != null)
                {
                    if (player.net.connection.authLevel > 0)
                    {
                        player.SendConsoleCommand("chat.add", new object[] { 0, msg.QuoteSafe() });
                    }
                }
            }
        }
        bool CheckWallhack(BuildingBlock buildingblock, BaseEntity col, Vector3 initialPos)
        {
            Vector3 cachedDiff = col.transform.position - initialPos;
            if (initialPos.y - buildingblock.transform.position.y > 2) return false;

            if (UnityEngine.Physics.Linecast(initialPos, col.transform.position, out cachedRaycasthit, constructionColl))
            {
                if (cachedRaycasthit.collider.GetComponentInParent<BuildingBlock>() == buildingblock)
                {
                    return true;
                }
            }
            return false;
        }
        void Loaded()
        {
            constructionColl = LayerMask.GetMask( new string[] { "Construction" });
        }
        void ForcePlayerBack(BasePlayer player, Vector3 entryposition, Vector3 exitposition)
        {
            var distance = Vector3.Distance(exitposition, entryposition) + 0.5f;
            var direction = (entryposition - exitposition).normalized;
            ForcePlayerPosition(player, exitposition + (direction * distance));
        }
        void OnServerInitialized()
        { 
            serverInitialized = true;
            originalWallhack = new UnityEngine.GameObject("Anti Wallhack");
            originalWallhack.AddComponent<MeshCollider>();
            originalWallhack.AddComponent<TriggerBase>();
            originalWallhack.gameObject.layer = UnityEngine.LayerMask.NameToLayer("Trigger");
            var newlayermask = new UnityEngine.LayerMask();
            newlayermask.value = 133120;
            originalWallhack.GetComponent<TriggerBase>().interestLayers = newlayermask;
            RefreshAllWalls(); 
            RefreshPlayers();
        }  
        void Unload()
        {
            foreach(GameObject gameObj in ListGameObjects)
            { 
                GameObject.Destroy(gameObj);
            } 
            var objects = GameObject.FindObjectsOfType(typeof(PlayerHack));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
            if (activateTimer != null)
                activateTimer.Destroy();
        } 
        void ForcePlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.transform.position = destination;
            player.ClientRPC(null, player, "ForcePositionTo", new object[] { destination });
            player.TransformChanged();
        }
        void RefreshPlayers()
        {
            if (!speedhack && !flyhack) return;
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.GetComponent<PlayerHack>() != null) GameObject.Destroy(player.GetComponent<PlayerHack>());
                if (player.net.connection.authLevel > authIgnore) continue;
                player.gameObject.AddComponent<PlayerHack>();
            }
        } 
        void RefreshAllWalls()
        {
            if (!wallhack) return;
            var allbuildings = UnityEngine.Resources.FindObjectsOfTypeAll<BuildingBlock>();
            var currenttime = Time.realtimeSinceStartup;
            foreach (BuildingBlock block in allbuildings)
            {
                if (block.blockDefinition != null && (block.blockDefinition.hierachyName == "wall" || block.blockDefinition.hierachyName == "door.hinged"))
                {
                    CreateNewProtectionFromBlock(block, true);
                }
            } 
            Debug.Log(string.Format("AntiCheat: Took {0} seconds to protect all walls & doors", (Time.realtimeSinceStartup - currenttime).ToString()));
        }
        void CreateNewProtectionFromBlock(BuildingBlock buildingblock, bool Immediate)
        {
            var newgameobject = UnityEngine.Object.Instantiate(originalWallhack);
            ListGameObjects.Add(newgameobject);
            var mesh = newgameobject.GetComponent<MeshCollider>();
            newgameobject.transform.position = buildingblock.transform.position;
            newgameobject.transform.rotation = buildingblock.transform.rotation;
            mesh.convex = false;
            mesh.sharedMesh = buildingblock.GetComponentInChildren<UnityEngine.MeshCollider>().sharedMesh;
            mesh.enabled = true;
            if (Immediate) newgameobject.SetActive(true);
            else
            {
                newgameobject.SetActive(false);
                timer.Once(20f, () => ActivateGameObject(newgameobject));
            }
            TriggerToBlock[newgameobject.GetComponent<TriggerBase>()] = buildingblock;
        }
        void ActivateGameObject(UnityEngine.GameObject gameObj)
        {
            if (gameObj == null) return;
            gameObj.SetActive(true);
        }
        void OnPlayerRespawned(BasePlayer  player)
        {
            if (player.net.connection.authLevel >= authIgnore) return;
            if (player.GetComponent<PlayerHack>() == null)
            {
                player.gameObject.AddComponent<PlayerHack>();
            } 
        }
        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (!serverInitialized) return;
            if (!wallhack) return;
            var buildingblock = gameobject.GetComponentInParent<BuildingBlock>();
            if (buildingblock == null) return;
            if (buildingblock.blockDefinition.hierachyName == "wall" || buildingblock.blockDefinition.hierachyName == "door.hinged")
            {
                CreateNewProtectionFromBlock(buildingblock, false);
            }
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AntiSpeedHack.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Newtonsoft.Json
// Reference: Oxide.Ext.Rust
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AntiSpeedHack", "Steven", 0.2)]
    class AntiSpeedHack : RustPlugin
    {		
		/*
		 * Start Of Configurable options
		 */
		private static int BlockAfterDetectionAmount = 3;
		private static bool AutoBan = true;
		/*
		 * End Of Configurable options
		 */
		
        System.Timers.Timer timer;
		
        private static long GetTimestamp()
        {
            return long.Parse(System.DateTime.Now.ToString("yyyyMMddHHmmssffff"));
        }

		static void SendMsgAdmin(string msg)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.GetComponent<BaseNetworkable>().net.connection.authLevel > 0)
                {
                    player.SendConsoleCommand("chat.add \"AntiCheat\" " + msg.QuoteSafe() + " 1.0");
                }
            }
        }
		
        class LastPosData
        {
            public int Warnings;
			public BasePlayer Player;
			public Vector3 Pos;
            public LastPosData(BasePlayer p)
            {
				Pos = p.transform.position;
				Warnings = 0;
				Player = p;
            }
			
            public bool Check()
            {
                if (Vector3.Distance(Pos, Player.transform.position) >= 35)
                {
                    Warnings++;                   
                } 
				else if(Warnings >= 1)
				{
					Warnings--;
				}
				Pos = Player.transform.position;
                if (Warnings >= BlockAfterDetectionAmount)
                {
                    return true;
                }
                return false;
            }
        };
        private Dictionary<string, LastPosData> AntiSpeedHacking;
		private List<string> Checking;
		int Checks = 4, IndexChecker = 0;
		
		private void timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
			int Count = AntiSpeedHacking.Count;
			if(Count >= 1)
			{
				if(Checks >= 4)
				{
					if(IndexChecker>=Count)
					{
						IndexChecker = 0;
						Checks = 4;
					}
					Checking.Clear();
					int i=1;
					foreach (string key in AntiSpeedHacking.Keys)
					{
						if(i<=IndexChecker) continue;
						if(Checking.Count < 5)
						{
							Checking.Add(key);
							IndexChecker = i;
						} else break;
						i++;
					}
					Checks = 0;
				}
				foreach(string SteamIDCurrentCheck in Checking)
				{
					BasePlayer player = AntiSpeedHacking[SteamIDCurrentCheck].Player;
					if(player)
					{
						if(AntiSpeedHacking[SteamIDCurrentCheck].Check() == true)
						{
							Puts(player.displayName + " was speed hacking");
							SendMsgAdmin(player.displayName + " was detected speed hacking and was banned");
							if(AutoBan)
							{
								ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", player.userID.ToString(), player.displayName, "Banned by Auto Speed.").ToString(),true);
								ConsoleSystem.Run.Server.Quiet("server.writecfg",true);
							}
							Network.Net.sv.Kick(player.net.connection, "Kicked from the server");
						}
					} 
				}
				Checks++;
			}
        }
		void Unload()
		{
			timer.Stop();
		}
        void Loaded()
        {
            AntiSpeedHacking = new Dictionary<string, LastPosData>();
			Checking = new List<string>();
		    timer = new System.Timers.Timer(4000);
            timer.Interval = 4000;
            timer.Elapsed += new System.Timers.ElapsedEventHandler(timer_Elapsed);
			timer.Start();
        }

        void OnServerInitialized()
        {
        }
		
		void OnPlayerInit(BasePlayer ply)
        {
			if(ply != null)
			{           
				if (AntiSpeedHacking.ContainsKey(ply.userID.ToString()) == false)
				{
					AntiSpeedHacking.Add(ply.userID.ToString(), new LastPosData(ply));
				}
			}
		}
		
		void OnPlayerDisconnected(BasePlayer ply, object connection)
		{
			if(ply != null)
			{
				AntiSpeedHacking.Remove(ply.userID.ToString());
			}
		}
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AntiWeaponSpeedHack.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Newtonsoft.Json
// Reference: Oxide.Ext.Rust
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AntiWeaponSpeedHack", "Steven", 0.5)]
    class AntiWeaponSpeedHack : RustPlugin
    {
		/*
		 * Start Of Configurable options
		 */
		private static int BlockAfterDetectionAmount = 10;
		private static bool AutoBan = true;
		/*
		 * End Of Configurable options
		 */
		
		
        private static int[] Limits = new int[10] { 8000, 4000, 18000, 10000, 21000, 13000, 13500, 700, 0, 0 };

        private static long GetTimestamp()
        {
            return long.Parse(System.DateTime.Now.ToString("yyyyMMddHHmmssffff"));
        }

        private struct LastWepData
        {
            public long[] time;
			public long[] LastTimeDiff;
            public int[] Warnings;
            public LastWepData(int k)
            {
                time = new long[10];
                LastTimeDiff = new long[10];
                Warnings = new int[10];
                for (int i = 0; i < 10; i++)
                {
					LastTimeDiff[i] = 0;
                    time[i] = 0;
                    Warnings[i] = 0;
                }
            }
            public bool Check(int ID)
            {
                long nowTime = GetTimestamp();
				LastTimeDiff[ID] = (nowTime - time[ID]);
                if (LastTimeDiff[ID] <= Limits[ID])
                {
                    Warnings[ID]++;                   
                } 
				else if(Warnings[ID] >= 1)
				{
					Warnings[ID] = 0;
				}
				time[ID] = nowTime;
                if (Warnings[ID] >= BlockAfterDetectionAmount)
                    return true;
                return false;
            }
        };
        private Dictionary<BaseEntity, LastWepData> AntiWeaponSpeedHacking;

        void Loaded()
        {
            AntiWeaponSpeedHacking = new Dictionary<BaseEntity, LastWepData>();
        }

        void OnServerInitialized()
        {
		}
		
        void SendMsgAdmin(string msg)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.GetComponent<BaseNetworkable>().net.connection.authLevel > 0)
                {
                    player.SendConsoleCommand("chat.add \"AntiCheat\" " + msg.QuoteSafe() + " 1.0");
                }
            }
        }
		
        void OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (player != null && player.svActiveItem != null && info != null && info.HitEntity != null)
            {
                int Type = -1;
                switch (player.svActiveItem.info.shortname.ToString())
                {
					case "torch":
					case "hammer_salvaged":
                    case "rock":
                        Type = 0;
                        break;
					case "knife_bone":
					case "stonehatchet":
                    case "hatchet":
                        Type = 1;
                        break;
                    case "pickaxe":
                        Type = 2;
                        break;
					case "spear_stone":
					case "spear_wooden":
					case "ice_salvaged":
					case "axe_salvaged":
					case "pistol_revolver":
						Type = 3;
						break;
					case "bow_hunting":
						Type = 4;
						break;
					case "pistol_eoka":
						Type = 5;
						break;
					case "rifle_bolt":
						Type = 6;
						break;
					case "smg_thompson":
					case "rifle_ak":
						Type = 7;
						break;
                }

                if (Type != -1)
                {
                    if (AntiWeaponSpeedHacking.ContainsKey(player) == false)
                    { 
                        AntiWeaponSpeedHacking.Add(player, new LastWepData(0)); 
                    }
					
                    if(AntiWeaponSpeedHacking[player].Check(Type) == true)
                    {
                        Puts(player.displayName + " was weapon speed hacking");
                        SendMsgAdmin(player.displayName + " was detected weapon speed hacking and was banned");
                        if(AutoBan)
						{
							ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", player.userID.ToString(), player.displayName, "Auto Weapon Speed (" + player.svActiveItem.info.shortname.ToString() + ") hit in " + AntiWeaponSpeedHacking[player].LastTimeDiff[Type] + "/" +Limits[Type]+ " " + BlockAfterDetectionAmount +" Times.").ToString(),true);
							ConsoleSystem.Run.Server.Quiet("server.writecfg",true);
						}
						Network.Net.sv.Kick(player.net.connection, "Kicked from the server");
                    }
                }
            }
        }
		
		void OnPlayerDisconnected(BasePlayer ply, object connection)
		{
			if(ply != null)
			{
				AntiWeaponSpeedHacking.Remove(ply);
			}
		}
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AutoGrades.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

/*
	Created By AlexALX (c) 2015
*/
using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Automatic Build Grades", "AlexALX", "0.0.1")]
    public class AutoGrades : RustPlugin
    {
	
		private Dictionary<string,int> playerGrades;
	
		public AutoGrades() {
			//HasConfig = true;
		}
		
        void Loaded() {
            playerGrades = new Dictionary<string, int>();
        }
		/* Not sure if this needed, maybe someone reconnect or so...
        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player)
        {
			var steamId = player.userID.ToString();
            if (playerGrades.ContainsKey(steamId)) {
				playerGrades.Remove(steamId);
			}
        }*/
	
		private int PlayerGrade(string steamId, bool cache = true) {
            if (playerGrades.ContainsKey(steamId)) return playerGrades[steamId];
			if (!cache) return 0;
            playerGrades[steamId] = 0;
            return playerGrades[steamId];
		}
		
		[HookMethod("OnEntityBuilt")]
        void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
        {	
			var player = planner.ownerPlayer;
            if (!player.IsAdmin()) return;
			BuildingBlock buildingBlock = gameObject.GetComponent<BuildingBlock>();
			if (buildingBlock==null) return;
			var steamId = player.userID.ToString();
			var pgrade = PlayerGrade(steamId,false);
			if (pgrade>0) {
				var grd = (BuildingGrade.Enum) pgrade;
				buildingBlock.SetGrade(grd);
				buildingBlock.SetHealthToMax();
			}
		}
		
        [ChatCommand("bgrade")]
        void ChatBuildGrade(BasePlayer player, string command, string[] args) {
            if (!player.IsAdmin()) { 
				SendReply(player, "<color='#DD0000'>You have no access to this command.</color>"); return; 
			}
			var chatmsg = new List<string>();
			var steamId = player.userID.ToString();
            if (args.Length>0) {
				switch (args[0])
				{
					case "1":
					case "2":
					case "3":
					case "4":
						var pgrade = PlayerGrade(steamId);
						playerGrades[steamId] = Convert.ToInt32(args[0]);
						chatmsg.Add("<color='#00DD00'>You successfully set auto update to <color='#DD0000'>" + ((BuildingGrade.Enum) playerGrades[steamId]).ToString() + "</color>.</color>");
					break;
					case "0":
						playerGrades.Remove(steamId);
						chatmsg.Add("<color='#00DD00'>You successfully <color='#DD0000'>disabled</color> auto update.</color>");
					break;
					default:
						chatmsg.Add("<color='#DD0000'>Invalid building grade.</color>");
					break;
				}
			} else {
				var pgrade = PlayerGrade(steamId,false);
				chatmsg.Add("Automatic Build Grade command usage:\n");
				chatmsg.Add("<color='#00DD00'>/bgrade 1</color> - auto update to wood");
				chatmsg.Add("<color='#00DD00'>/bgrade 2</color> - auto update to stone");
				chatmsg.Add("<color='#00DD00'>/bgrade 3</color> - auto update to metal");
				chatmsg.Add("<color='#00DD00'>/bgrade 4</color> - auto update to armored");
				chatmsg.Add("<color='#00DD00'>/bgrade 0</color> - disable auto update");
				var curtxt = ((BuildingGrade.Enum) pgrade).ToString();
				if (pgrade==0) curtxt = "Disabled";
				chatmsg.Add("\nCurrent mode: <color='#DD0000'>" + curtxt + "</color>");
			}
			player.ChatMessage(string.Join("\n", chatmsg.ToArray()));
        }
	
	}
	
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\AutoReply.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;


namespace Oxide.Plugins
{
    [Info("AutoReply", "4seti [Lunatiq] for Rust Planet", "1.3.5", ResourceId = 908)]
    public class AutoReply : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion

		#region Default and private params
		private Dictionary<string, Dictionary<string, DateTime>> antiSpam;
		private int replyInterval = 5;		
		private int minPriveledge = 0;
		
		private Dictionary<string, string> messages;		
		private Dictionary<string, string> defMsg = new Dictionary<string, string>()
		{
			{"attribSet", "Attribute {0} set to {1}"},  
			{"newWord", "New word was added to check: <color=#81F23F>{0}</color> for group: <color=#81F23F>{1}</color>"}, 
			{"newGroup", "New word group was added to check: <color=#81F23F>{0}</color> baseword: {1} with reply: <color=#81F23F>{2}</color>"}, 
			{"removedGroup", "No more words in group! Word group \"<color=#81F23F>{0}</color>\" was removed!"}, 			
			{"newChar", "New char replacement was added to check: <color=#F23F3F>{0}</color>-><color=#81F23F>{1}</color>"}, 
			{"charRemoved", "Char replacement was removed from check: <color=#F23F3F>{0}</color>"},	
			{"charNotFound", "Char replacement not found in check: <color=#F23F3F>{0}</color>"},			
			{"baseWordExist", "This baseword or part of it (<color=#F23F3F>{0}</color>) already exists in group <color=#81F23F>{1}</color>"},
			{"newCharExists", "Char already persist in the check: <color=#81F23F>{0}</color>"}, 
			{"replyChanged", "Reply changed for word group: <color=#81F23F>{0}</color>"}, 			
			{"replyAdded", "Reply added for word group: <color=#81F23F>{0}</color> with number: <color=#81F23F>{1}</color>"}, 	
			{"replyRemoved", "Reply removed for word group: <color=#81F23F>{0}</color> with number: <color=#81F23F>{1}</color>"}, 
			{"replyNotFound", "Reply â<color=#81F23F>{0}</color> not found for word group: <color=#81F23F>{1}</color>"}, 			
			{"Error", "Something went wrong"},
			{"matchChanged", "Match for group: <color=#81F23F>{0}</color>, changed to <color=#81F23F>{1}</color>"},
			{"matchNotFound", "Group: <color=#81F23F>{0}</color> not found"},			
			{"newWordExists", "Word already persist in the check: <color=#F23F3F>{0}</color>"},
			{"wordGroupExist", "Word group with that name exist: <color=#F23F3F>{0}</color>"},
			{"wordGroupDontExist", "Word group with that name don't exist: <color=#F23F3F>{0}</color> use <color=#F23F3F>/ar_new</color> first"},			
			{"newAttr", "New attribute added! Name: {0}, Text: {1}"},
			{"attrRemoved", "Attribute removed! Name: {0}"},	
			{"attrEdited", "Attribute edited! Name: {0}, New value: {1}"},				
			{"attrNoFound", "Attribute not found! Name: {0}"},	
			{"attrExist", "Attribute \"{0}\" already exist"},
			{"newGroupError", "Error! Should be: <color=#F23F3F>/ar_new groupname baseword replymsg params(optional)</color>"},
			{"changeReplyError", "Error! Should be: <color=#F23F3F>/ar_reply add/del/set (set or del is by nums (check /ar_list)) groupname replymsg attribs</color>"},
			{"attrAdded", "Attrib: <color=#F23F3F>{0}</color> added for word group <color=#F23F3F>{1}</color>"},
			{"attrDeleted", "Attrib: <color=#F23F3F>{0}</color> deleted for word group <color=#F23F3F>{1}</color>"},
			{"attrWordExist", "Attrib: <color=#F23F3F>{0}</color> exists in word group <color=#F23F3F>{1}</color>"},
			{"attrNotExist", "Attrib: <color=#F23F3F>{0}</color> do not exists in word group <color=#F23F3F>{1}</color>"},			
			{"attrUnknown", "UNKNOWN Attrib: <color=#F23F3F>{0}</color>"},		
			{"attrCritError", "Error! Should be like that: <color=#81F23F>/ar_wa add/del groupname ReplyNum attrib</color>"},
			{"wordAdded", "Word: <color=#F23F3F>{0}</color> added for word group <color=#F23F3F>{1}</color>"},
			{"wordDeleted", "Word: <color=#F23F3F>{0}</color> deleted for word group <color=#F23F3F>{1}</color>"},
			{"wordWordExist", "Word: <color=#F23F3F>{0}</color> exists in word group <color=#F23F3F>{1}</color>"},
			{"wordNotExist", "Word: <color=#F23F3F>{0}</color> do not exists in word group <color=#F23F3F>{1}</color>"},				
			{"wordCritError", "Error! Should be like that: <color=#81F23F>/ar_word add/del groupname word</color>"},
			{"listGroupReply", "Group Name: <color=#81F23F>{0}</color> with next params:"},
			{"listWords", "Words to lookup: <color=#81F23F>{0}</color>"},
			{"listAttribs", "Attributes for reply: <color=#81F23F>{0}</color>"},
			{"usageOfExc", "Usage of \"!\" at word start is forbidden use \"?\" instead"}
		};
		
		private Dictionary<string, Dictionary<int, string>> replies;
		private Dictionary<string, Dictionary<int, string>> defReply = new Dictionary<string, Dictionary<int, string>>()
		{
			{"wipe", new Dictionary<int, string>()
				{
					{0, "Last wipe: <color=#81F23F>{0}</color>, Next wipe: <color=#F23F3F>{1}</color>"}
				}
			}
		};
		
		private Dictionary<string, bool> fullMatch;
		private Dictionary<string, bool> defMatch = new Dictionary<string, bool>()
		{
			{"wipe", false}			
		};
		
		private Dictionary<string, List<string>> wordList;
		private Dictionary<string, List<string>> defWords = new Dictionary<string, List<string>>()
		{
			{"wipe", new List<string> {"wipe", "baÐ¹Ð¿"}}		
		};
		
		private Dictionary<string, string> attributes;
		private Dictionary<string, string> defAttr = new Dictionary<string, string>()
		{
			{"time", "by_plugin"},
			{"player", "by_plugin"},
			{"online", "by_plugin"},
			{"sleepers", "by_plugin"},
			{"lastwipe", "???"},
			{"nextwipe", "???"}
		};
		
		private Dictionary<string, Dictionary<int, List<string>>> attrForWord;
		private Dictionary<string, Dictionary<int, List<string>>> defAtrForWord = new Dictionary<string, Dictionary<int, List<string>>>()
		{
			{"wipe", new Dictionary<int, List<string>>()
				{
					{0, new List<string> {"lastwipe", "nextwipe"}}
				}		
			}
		};
		
		private Dictionary<char, char> replaceChars;
		private Dictionary<char, char> defChar = new Dictionary<char, char>()
		{
			{'Ñ', 'c'},
			{'Ð°', 'a'},
			{'Ð¾', 'o'},    
			{'Ðµ', 'e'}, 
			{'Ñ', 'p'}, 					
			{'Ð²', 'b'}			
		};		
		#endregion
		#region Default inits
        void Loaded()
        {
            Log("Loaded");
        }
	
		protected override void LoadDefaultConfig()
        {
            Warn("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
		
		// Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
    
		#endregion
		
		[HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            try
            {
                LoadConfig();
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
				
				//Get message dictionary for plugin commands (for Admins) from config
				messages = new Dictionary<string, string>();
                var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (cfgMessages != null)
                    foreach (var pair in cfgMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
				
							
				//Get replies list from config
				replies = new Dictionary<string, Dictionary<int, string>>();
				var cfgReply = GetConfig<Dictionary<string, object>>("replies", null);
				if (cfgReply != null)
					foreach (var pair in cfgReply)
					{
						//silly workaround, ToList and IEnum tries of usage failed :P
						var d = new Dictionary<int, string>();						
						foreach (var v in pair.Value as Dictionary<string, object>)
						{
							d[Convert.ToInt32(v.Key)] = (string)v.Value;
						}
						replies[pair.Key] = d;
					}    
				//Get char replace list from config
				replaceChars = new Dictionary<char, char>();
				var cfgChar = GetConfig<Dictionary<string, object>>("replaceChars", null);
                if (cfgChar != null)
                    foreach (var pair in cfgChar)
                        replaceChars[Convert.ToChar(pair.Key)] = Convert.ToChar(pair.Value);
				
				//Get char replace list from config
				fullMatch = new Dictionary<string, bool>();
				var cfgMatch = GetConfig<Dictionary<string, object>>("fullMatch", null);
                if (cfgMatch != null)
                    foreach (var pair in cfgMatch)
                        fullMatch[pair.Key] = Convert.ToBoolean(pair.Value);
						
				//Get wordlist from config
				wordList = new Dictionary<string, List<string>>();
				antiSpam = new Dictionary<string, Dictionary<string, DateTime>>();
				var cfgWords = GetConfig<Dictionary<string, object>>("wordList", null);
				if (cfgWords != null)
                    foreach (var pair in cfgWords)
					{
						//silly workaround, ToList and IEnum tries of usage failed :P
						var c = new List<string>();
						foreach (var v in pair.Value as List<object>)
                            c.Add((string)v);
						wordList[pair.Key] = c;
						antiSpam[pair.Key] = new Dictionary<string, DateTime>();
					}
				
				//Get attribs for words
				attrForWord = new Dictionary<string, Dictionary<int, List<string>>>();
				var cfgAFW = GetConfig<Dictionary<string, object>>("attrForWord", null);
				if (cfgAFW != null)
                    foreach (var pair in cfgAFW)
					{
						//silly workaround, ToList and IEnum tries of usage failed :P						
						var d = new Dictionary<int, List<string>>();
						foreach (var v in pair.Value as Dictionary<string, object>)
						{
							var c = new List<string>();
							foreach(var k in v.Value as List<object>)
								c.Add((string)k);
							d[Convert.ToInt32(v.Key)] = c;
						}
						attrForWord[pair.Key] = d;
					}   
				//Get attributes list from config
				attributes = new Dictionary<string, string>();
				var cfgAttr = GetConfig<Dictionary<string, object>>("attributes", null);
				if (cfgAttr != null)
                    foreach (var pair in cfgAttr)
                        attributes[pair.Key] = Convert.ToString(pair.Value);
						
				#region version checker
				if (verNum < Version)
                {
                    //placeholder for future version updates
					foreach (var pair in defMsg)
                        if (!messages.ContainsKey(pair.Key))
                            messages[pair.Key] = pair.Value;
							
					foreach (var pair in defAttr)
                        if (!attributes.ContainsKey(pair.Key))
                            attributes[pair.Key] = pair.Value;
					Config["attributes"] = attributes;
                    Config["messages"] = messages;
					Config["version"] = Version;
                    SaveConfig();
                    Warn("Config version updated to: " + Version.ToString() + " please check it");
                }		
				#endregion				
				
				replyInterval = GetConfig<int>("replyInterval", 30);	
				minPriveledge = GetConfig<int>("minPriveledge", 0);	
            }
            catch (Exception ex)
            {
                Error("OnServerInitialized failed: " + ex.Message);
            }
            
        }
		
		private void LoadVariables()
        {
            Config["messages"] = defMsg;
			Config["replies"] = defReply;
			Config["replaceChars"] = defChar;
			Config["wordList"] = defWords;
			Config["attributes"] = defAttr;
			Config["attrForWord"] = defAtrForWord;
			Config["fullMatch"] = defMatch;
			Config["replyInterval"] = 30;
			Config["minPriveledge"] = 0;
            Config["version"] = Version;
        }
        [HookMethod("OnRunCommand")]
        private object OnRunCommand(ConsoleSystem.Arg arg)
        {
			BasePlayer player = null;
			string msg = "";
			try
			{
				if (arg == null) return null;
				if (arg.connection.player == null) return null;
				if (arg.cmd.namefull.ToString() != "chat.say") return null;
				
				if (arg.connection.player is BasePlayer)
				{
					player = arg.connection.player as BasePlayer;
					if (player.net.connection.authLevel > minPriveledge) return null;
				}
				else return null;
				
				msg = arg.GetString(0, "text").ToLower();		
				
				if (msg == null) return null;
				else if (msg == "") return null;
				else if (msg.Substring(0, 1).Equals("/") || msg.Substring(0, 1).Equals("!")) return null;
				
				if (player == null) return null;
			}
			catch
			{
				return null;
			}

			//Fixing alphabets abuse			
			foreach(var pair in replaceChars)
			{
				msg = msg.Replace(pair.Key, pair.Value);				
			}				
			bool found = false;
			string foundGroup = "";
			foreach(var pair in wordList)
			{	
				foreach(var item in pair.Value)
				{
					if(!fullMatch[pair.Key])
					{
						if (msg.Contains(item))
						{
							found = true;
							foundGroup = pair.Key;
							break;
						}
					}
					else
					{
						if (msg == item)
						{
							found = true;
							foundGroup = pair.Key;
							break;
						}					
					}
				}
			}
			
			if (found)
			{
				string userID = player.userID.ToString();	
				if (antiSpam[foundGroup].ContainsKey(userID))
				{							
					if ((DateTime.Now - antiSpam[foundGroup][userID]).Seconds > replyInterval)
					{						
						
						replyToPlayer(player, foundGroup);
						antiSpam[foundGroup][userID] = DateTime.Now;
					}
				}
				else
				{		
					antiSpam[foundGroup].Add(userID, DateTime.Now);
					replyToPlayer(player, foundGroup);
				}
				return false;
			}			
			return null;
		}
		
		private void replyToPlayer(BasePlayer player, string group)
		{		
			foreach(var v in replies[group])
			{
				player.ChatMessage(replyBuilder(v.Value, attrForWord[group][v.Key], player.displayName));
			}								
		}
		
		private string replyBuilder(string text, List<string> attr, string playerName)
		{
			for(int i = 0; i < attr.Count; i++)
			{	
				string attrText;
				//meh, don't blame me for that :'(
				//Sky.Cycle.DateTime:ToString("HH:mm:ss")
				if (attributes[attr[i]] == "by_plugin")
				{
					switch(attr[i])
					{
						case "time":
							attrText = DateTime.Now.ToString("HH:mm:ss");
							break;
						case "player":
							attrText = playerName;
							break;
						case "online":
							attrText = BasePlayer.activePlayerList.Count.ToString();
							break;
						case "sleepers":
							attrText = BasePlayer.sleepingPlayerList.Count.ToString();
							break;
						default:
							attrText = "";
							break;
					}			
				}
				else
					attrText = attributes[attr[i]];
				text = text.Replace("{"+i+"}", attrText);
			}	
			return text;			
		}
		
		[ChatCommand("ar")]
		void cmdAr(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (args[0] == "c") //adding/deleting new char to replace
				{
					try
					{
						if(args[1] == "add") 
						{
							if (!replaceChars.ContainsKey(Convert.ToChar(args[2])))
							{
								replaceChars.Add(Convert.ToChar(args[2].ToLower()), Convert.ToChar(args[3].ToLower()));
								Config["replaceChars"] = replaceChars;
								player.ChatMessage(string.Format(messages["newChar"], args[2], args[3]));	
							}	
							else	
							{
								player.ChatMessage(string.Format(messages["newCharExists"], args[2]));	
							}
						}	
						else if(args[1] == "del")
						{	
							if (replaceChars.ContainsKey(Convert.ToChar(args[2])))
							{
								replaceChars.Remove(Convert.ToChar(args[2].ToLower()));								
								Config["replaceChars"] = replaceChars;		
								player.ChatMessage(string.Format(messages["charRemoved"], args[2]));
							}
							else
							{
								player.ChatMessage(string.Format(messages["charNotFound"], args[2]));
							}							
						}
					}		
					catch		
					{
						player.ChatMessage(messages["Error"]);	
					}					
				}
				else if(args[0] == "a") //adding/deleting new attribute for word list
				{
					try
					{
						if(args[1] == "add") 
						{
							if (!attributes.ContainsKey(args[2]))
							{
								attributes.Add(args[2].ToLower(), args[3]);
								Config["attributes"] = attributes;
								player.ChatMessage(string.Format(messages["newAttr"], args[2], args[3]));	
							}	
							else	
							{
								player.ChatMessage(string.Format(messages["attrExist"], args[2]));	
							}	
						}
						else if(args[1] == "del") 
						{
							if (attributes.ContainsKey(args[2]))
							{
								if (attributes[args[2]] == "by_plugin")
								{
									player.ChatMessage(string.Format(messages["Error"]));
									return;
								}
								removeAttr(args[2].ToLower());
								attributes.Remove(args[2].ToLower());
								Config["attributes"] = attributes;
								player.ChatMessage(string.Format(messages["attrRemoved"], args[2]));	
							}	
							else	
							{
								player.ChatMessage(string.Format(messages["attrNotFound"], args[2]));	
							}	
						}
						else if(args[1] == "set") 
						{
							if (attributes.ContainsKey(args[2]))
							{
								if (attributes[args[2]] == "by_plugin")
								{
									player.ChatMessage(string.Format(messages["Error"]));
									return;
								}
								attributes[args[2].ToLower()] = args[3];
								Config["attributes"] = attributes;
								player.ChatMessage(string.Format(messages["attrEdited"], args[2], args[3]));	
							}	
							else	
							{
								player.ChatMessage(string.Format(messages["attrNotFound"], args[2]));	
							}	
						}
					}		
					catch		
					{
						player.ChatMessage(messages["Error"]);	
					}				
				}
				SaveConfig();
			}
		}
		
		private bool checkWord(BasePlayer player, string baseWord)
		{
			bool found = true;
			string foundGroup = "";
			foreach(var pair in wordList)
			{	
				foreach(var item in pair.Value)
				{					
					if(!fullMatch[pair.Key])
					{
						if (baseWord.Contains(item))
						{
							found = false;
							foundGroup = pair.Key;					
							break;
						}
					}
					else
					{
						if (baseWord == item)
						{
							found = false;
							foundGroup = pair.Key;			
							break;
						}					
					}					
				}
			}
			if (!found)
			{
				player.ChatMessage(string.Format(messages["baseWordExist"], baseWord, foundGroup));				
			}
			return found;
		}
		
		//Adding new word group
		[ChatCommand("ar_new")]
		void cmdArNew(BasePlayer player, string cmd, string[] args)
		{
			//replies, wordList, attrForWord should be innitially filled
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (!replies.ContainsKey(args[0]))
				{
					string groupName = args[0].ToLower();
					string baseWord = args[1].ToLower();
					if (baseWord.Substring(0, 1).Equals("!"))
					{
						player.ChatMessage(messages["usageOfExc"]);	
						return;
					}
					string reply = args[2];					
					
					if (!checkWord(player, baseWord))
						return;
					replies[groupName] = new Dictionary<int, string>();
					replies[groupName][0] = reply;
					wordList[groupName] = new List<string>(){baseWord};
					attrForWord[groupName] = new Dictionary<int, List<string>>();
					attrForWord[groupName][0] = new List<string>();		
					fullMatch[groupName] = false;					
					if (args.Length > 3){						
						for (int i = 3; i < args.Length; i++)
						{
							if (!attributes.ContainsKey(args[i]))
							{
								player.ChatMessage(string.Format(messages["attrUnknown"], args[i]));
								return;
							}
							attrForWord[groupName][0].Add(args[i]);
						}
					}
					player.ChatMessage(string.Format(messages["newGroup"], groupName, baseWord, reply));
					Config["replies"] = replies;
					Config["wordList"] = wordList;
					Config["attrForWord"] = attrForWord;
					Config["fullMatch"] = fullMatch;
					antiSpam[groupName] = new Dictionary<string, DateTime>();
					SaveConfig();					
				}
				else
				{
					player.ChatMessage(string.Format(messages["wordGroupExist"], args[0]));
					return;
				}
			
			}
			else
				player.ChatMessage(messages["newGroupError"]);	
		}
		
		//Change reply
		[ChatCommand("ar_reply")]
		void cmdArReply(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				string groupName = args[1];
				if (replies.ContainsKey(groupName))
				{
					string mode = args[0];					
					if (mode == "add")
					{
						string reply = args[2];
						int newReply = replies[groupName].Count;
						replies[groupName][newReply] = reply;
						player.ChatMessage(string.Format(messages["replyAdded"], groupName, newReply));
						Config["replies"] = replies;						
						attrForWord[groupName][newReply] = new List<string>();
						if (args.Length > 3){						
						for (int i = 3; i < args.Length; i++)
						{
							if (!attributes.ContainsKey(args[i]))
							{
								player.ChatMessage(string.Format(messages["attrUnknown"], args[i]));
								return;
							}
							attrForWord[groupName][newReply].Add(args[i]);
						}
						}
						Config["attrForWord"] = attrForWord;
						SaveConfig();
						
					}	
					else if(mode == "del")
					{
						int removeKey = Convert.ToInt32(args[2]);
						if(replies[groupName].ContainsKey(removeKey))
						{
							replies[groupName].Remove(removeKey);
							player.ChatMessage(string.Format(messages["replyRemoved"], groupName, removeKey));					
							Config["replies"] = replies;
							attrForWord[groupName].Remove(removeKey);
							Config["attrForWord"] = attrForWord;
							SaveConfig();
						}
						else
							player.ChatMessage(string.Format(messages["replyNotFound"], removeKey, groupName));				
					}
					else if(mode == "set")
					{
						int setKey = Convert.ToInt32(args[2]);
						string reply = args[3];
						if(replies[groupName].ContainsKey(setKey))
						{
							replies[groupName][setKey] = reply;
							player.ChatMessage(string.Format(messages["replyChanged"], groupName, setKey));						
							Config["replies"] = replies;
							SaveConfig();
						}
						else
							player.ChatMessage(string.Format(messages["replyNotFound"], setKey, groupName));		
					}
					else
						player.ChatMessage(messages["Error"]);
				}
				else
				{
					player.ChatMessage(string.Format(messages["wordGroupDontExist"], args[0]));
					return;
				}
			
			}
			else
				player.ChatMessage(messages["changeReplyError"]);	
		}
		
		//Add attrib for word group
		[ChatCommand("ar_wa")]
		void cmdArWA(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (attrForWord.ContainsKey(args[1]))
				{
					string groupName = args[1].ToLower();
					string mode = args[0].ToLower();
					try
					{
						int key = Convert.ToInt32(args[2]);
						string attr = args[3].ToLower();
						if (!attributes.ContainsKey(attr))
						{
							player.ChatMessage(string.Format(messages["attrUnknown"], attr));
							return;
						}
						if (mode == "add")
						{
							if (!attrForWord[groupName][key].Contains(attr))
							{
								attrForWord[groupName][key].Add(attr);
								player.ChatMessage(string.Format(messages["attrAdded"], attr, groupName));
								Config["attrForWord"] = attrForWord;
								SaveConfig();
								return;							
							}
							else
								player.ChatMessage(string.Format(messages["attrWordExist"], attr, groupName));	
							return;
						}
						else if (mode == "del")
						{
							if (attrForWord[groupName][key].Contains(attr))
							{
								attrForWord[groupName][key].Remove(attr);
								player.ChatMessage(string.Format(messages["attrDeleted"], attr, groupName));
								Config["attrForWord"] = attrForWord;
								SaveConfig();
								return;							
							}
							else
								player.ChatMessage(string.Format(messages["attrNotExist"], attr, groupName));	
							return;			
						}
						else
						{
							player.ChatMessage(messages["attrCritError"]);	
						}
					}
					catch
					{
						player.ChatMessage(messages["attrCritError"]);
					}
				}
				else
				{
					player.ChatMessage(string.Format(messages["wordGroupDontExist"], args[0]));
					return;
				}
			
			}
			else
				player.ChatMessage(messages["attrCritError"]);	
		}
		
		//Change matching
		[ChatCommand("ar_match")]
		void cmdArMatch(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;		
			if (args.Length > 1)
			{
				string group = args[0];
				bool match = Convert.ToBoolean(args[1]);
				if (fullMatch.ContainsKey(group))
				{
					fullMatch[group] = match;
					Config["fullMatch"] = fullMatch;
					player.ChatMessage(string.Format(messages["matchChanged"], group, match.ToString()));							
					SaveConfig();
				}
				else
					player.ChatMessage(string.Format(messages["matchNotFound"], group));							
			}
			else
				player.ChatMessage(messages["Error"]);	
		}
		//Add attrib for word group
		[ChatCommand("ar_word")]
		void cmdArWord(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (attrForWord.ContainsKey(args[1]))
				{
					string groupName = args[1].ToLower();
					string mode = args[0].ToLower();
					string word = args[2].ToLower();

					if (mode == "add")
					{
						if (!checkWord(player, word))
							return;
						if (!wordList[groupName].Contains(word))
						{
							if (word.Substring(0, 1).Equals("!"))
							{
								player.ChatMessage(messages["usageOfExc"]);	
								return;
							}
							wordList[groupName].Add(word);
							player.ChatMessage(string.Format(messages["wordAdded"], word, groupName));
							Config["wordList"] = wordList;
							SaveConfig();
							return;							
						}
						else
							player.ChatMessage(string.Format(messages["wordWordExist"], word, groupName));	
						return;
					}
					else if (mode == "del")
					{
						if (wordList[groupName].Contains(word))
						{
							wordList[groupName].Remove(word);
							player.ChatMessage(string.Format(messages["wordDeleted"], word, groupName));
							if (wordList[groupName].Count > 0)
							{
								Config["wordList"] = wordList;
								SaveConfig();
							}
							else
								removeGroup(player, groupName);
							return;							
						}
						else
							player.ChatMessage(string.Format(messages["wordNotExist"], word, groupName));	
						return;			
					}
					else
					{
						player.ChatMessage(messages["wordCritError"]);	
					}
				}
				else
				{
					player.ChatMessage(string.Format(messages["wordGroupDontExist"], args[0]));
					return;
				}
			
			}
			else
				player.ChatMessage(messages["wordCritError"]);	
		}	
		
		[ChatCommand("ar_list")]
		void cmdArList(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			
			if (args.Length == 0)				
				foreach(var pair in replies)
				{					
					string groupName = pair.Key;					
					player.ChatMessage(string.Format(messages["listGroupReply"], pair.Key));
					player.ChatMessage(string.Format(messages["listWords"], string.Join(", ", wordList[groupName].ToArray())));						
					foreach(var v in pair.Value)
					{
						player.ChatMessage(string.Format("[{0}] - {1}", v.Key, v.Value.QuoteSafe()));
						player.ChatMessage(string.Format("A:{0}", string.Join(", ", attrForWord[groupName][v.Key].ToArray())));
					}						
					player.ChatMessage("--------------------------------------------------");	
				}	
			else
				if (args[0] == "attr")				
					foreach(var pair in attributes)
					{
						player.ChatMessage(string.Format("{0} -> {1}", pair.Key, pair.Value.QuoteSafe()));					
					}
				else if (args[0] == "match")				
					foreach(var pair in fullMatch)
					{
						player.ChatMessage(string.Format("{0} -> {1}", pair.Key, pair.Value.ToString()));					
					}
		}
		
		private void removeGroup(BasePlayer player, string groupname)
		{
			if (replies.ContainsKey(groupname))
			{
				replies.Remove(groupname);
				wordList.Remove(groupname);
				attrForWord.Remove(groupname);
				fullMatch.Remove(groupname);
				antiSpam.Remove(groupname);
				
				Config["replies"] = replies;
				Config["wordList"] = wordList;
				Config["attrForWord"] = attrForWord;
				Config["fullMatch"] = fullMatch;
				SaveConfig();
				
				player.ChatMessage(string.Format(messages["removedGroup"], groupname));
					
			}		
		}
		
		private void removeAttr(string attr)
		{
			foreach(var pair in attrForWord)
			{	
				foreach(var v in pair.Value)
					attrForWord[pair.Key][v.Key].Remove(attr);		
			}
			Config["attrForWord"] = attrForWord;
			SaveConfig();
		}
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BeginnerProtection.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Rust.Libraries;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Beginner Protection", "Kation", "0.1.2", ResourceId = 910)]
    public class BeginnerProtection : RustPlugin
    {
        private Dictionary<string, string> message = new Dictionary<string, string>()
        {
            {"DoNotAttack", "He is a beginner, he has no guns, don't attack the beginner."},
            {"CanNotAttack", "You are a beginner, you can not attack anyone until you have a gun."},
            {"DoNotAttackSleeped", "Do not attack someone when he was slept."},
            {"DoNotLoot", "You can not loot anything from a sleeping player."},
            {"Enabled", "Beginner Protection is enabled."},
            {"Disabled", "Beginner Protection is disabled."},
            {"ConfigMissing", "Config missing."},
            {"Reloaded", "Beginner gift reloaded."},
            {"Usage", "Usage:"},
            {"ItemName", "item name"},
            {"Amount", "amount"},
            {"ItemNotExist", "Item does not exist."},
            {"AmountInvalid", "Amount value invalid."},
            {"GiftSetSuccess", "Set gift success."}
        };
        private Dictionary<string, object> setting = new Dictionary<string, object>()
        {
            {"IsEnabled", true},
            {"SleepAttack", false},
            {"SleepLoot", false}
        };
        private Dictionary<string, int> gift = new Dictionary<string, int>()
        {
            {"camp fire", 1},
            {"cooked wolf meat", 2},
            {"small water bottle", 1},
            {"stone hatchet", 1},
            {"wood", 200}
        };
        private Dictionary<string, string> nameTable;

        [ChatCommand("bp")]
        private void bpCommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                if ((bool)setting["IsEnabled"])
                    player.ChatMessage(message["Enabled"]);
                else
                    player.ChatMessage(message["Disabled"]);
            }
            else
            {
                if (player.net.connection.authLevel == 0)
                    return;
                if (args[0].ToLower() == "true")
                {
                    setting["IsEnabled"] = true;
                    Config["Settings"] = setting;
                    SaveConfig();
                    player.ChatMessage(message["Enabled"]);
                }
                else if (args[0].ToLower() == "false")
                {
                    setting["IsEnabled"] = false;
                    Config["Settings"] = setting;
                    SaveConfig();
                    player.ChatMessage(message["Disabled"]);
                }
            }
        }

        [ChatCommand("bp.gift.reload")]
        private void giftReloadCommand(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0)
                return;
            LoadConfig();
            Dictionary<string, object> gc = Config["Gifts"] as Dictionary<string, object>;
            if (gc != null)
            {
                gift = gc.Where(t => t.Value is int &&
                    (int)t.Value > 0 &&
                    nameTable.ContainsKey(t.Key.ToLower()) &&
                    ItemManager.FindItemDefinition(nameTable[t.Key.ToLower()]) != null).ToDictionary(t => t.Key.ToLower(), t => (int)t.Value);
            }
            else
            {
                player.ChatMessage(message["ConfigMissing"]);
                return;
            }
            player.ChatMessage(message["Reloaded"]);
        }

        [ChatCommand("bp.gift.set")]
        private void giftAddCommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.ChatMessage(message["Usage"]);
                player.ChatMessage("/bp.gift.set \"[" + message["ItemName"] + "]\" [" + message["Amount"] + "]");
                return;
            }
            var itemname = args[0].ToLower();
            if (!nameTable.ContainsKey(itemname))
            {
                player.ChatMessage(message["ItemNotExist"]);
                return;
            }
            int amount;
            if (!int.TryParse(args[1], out amount))
            {
                player.ChatMessage(message["AmountInvalid"]);
                return;
            }
            if (amount < 0)
            {
                if (gift.ContainsKey(itemname))
                    gift.Remove(itemname);
            }
            else
            {
                if (gift.ContainsKey(itemname))
                    gift[itemname] = amount;
                else
                    gift.Add(itemname, amount);
            }
            Config["Gifts"] = gift;
            SaveConfig();
            player.ChatMessage(message["GiftSetSuccess"]);
        }

        [HookMethod("OnServerInitialized")]
        private void OnServerInitialized()
        {
            LoadConfig();

            Dictionary<string, object> mc = Config["Messages"] as Dictionary<string, object>;
            if (mc != null)
                foreach (var key in message.Keys.ToArray())
                {
                    if (mc.ContainsKey(key))
                        message[key] = mc[key].ToString();
                }
            Dictionary<string, object> sc = Config["Settings"] as Dictionary<string, object>;
            if (sc != null)
                foreach (var key in setting.Keys.ToArray())
                {
                    if (sc.ContainsKey(key))
                    {
                        object value = sc[key];
                        value = Convert.ChangeType(value, setting[key].GetType());
                        setting[key] = value;
                    }
                }
            nameTable = ItemManager.GetItemDefinitions().ToDictionary(t => t.displayName.english.ToLower(), t => t.shortname.ToLower());

            Dictionary<string, object> gc = Config["Gifts"] as Dictionary<string, object>;
            if (gc != null)
                gift = gc.Where(t => t.Value is int &&
                    (int)t.Value > 0 &&
                    nameTable.ContainsKey(t.Key.ToLower()) &&
                    ItemManager.FindItemDefinition(nameTable[t.Key.ToLower()]) != null).ToDictionary(t => t.Key.ToLower(), t => (int)t.Value);

            Config.Clear();
            Config["Settings"] = setting;
            Config["Messages"] = message;
            Config["Gifts"] = gift;
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config["Settings"] = setting;
            Config["Messages"] = message;
            Config["Gifts"] = gift;
            SaveConfig();
        }

        [HookMethod("OnPlayerAttack")]
        private object OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if ((bool)setting["IsEnabled"])
            {
                if (hitInfo.HitEntity != null && hitInfo.HitEntity is BasePlayer)
                {
                    BasePlayer target = (BasePlayer)hitInfo.HitEntity;
                    if (!(bool)setting["SleepAttack"] && target.HasFlag(BaseEntity.Flags.Locked))
                    {
                        SendReply(attacker, message["DoNotAttackSleeped"]);
                        return true;
                    }
                    if (!target.inventory.AllItems().Any(t => t.GetHeldEntity() is BaseProjectile))
                    {
                        SendReply(attacker, message["DoNotAttack"]);
                        return true;
                    }
                    target = attacker;
                    if (!target.inventory.AllItems().Any(t => t.GetHeldEntity() is BaseProjectile))
                    {
                        SendReply(attacker, message["CanNotAttack"]);
                        return true;
                    }
                }
            }
            return null;
        }

        [HookMethod("OnPlayerRespawned")]
        private void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var item in gift)
            {
                var definition = ItemManager.FindItemDefinition(nameTable[item.Key]);
                player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, item.Value, false), player.inventory.containerMain);
            }
        }

        [HookMethod("OnPlayerDisconnected")]
        private void OnPlayerDisconnected(BasePlayer player)
        {
            PluginTimers timer = new PluginTimers(this);
            timer.Once(10, () =>
            {
                player.SetFlag(BaseEntity.Flags.Locked, true);
            });
        }

        [HookMethod("OnPlayerSleepEnded")]
        private void OnPlayerSleepEnded(BasePlayer player)
        {
            player.SetFlag(BaseEntity.Flags.Locked, false);
        }

        [HookMethod("OnPlayerLoot")]
        private void OnPlayerLoot(PlayerLoot lootInventory, BaseEntity targetEntity)
        {
            if ((bool)setting["IsEnabled"])
            {
                if (targetEntity is BasePlayer)
                {
                    BasePlayer targetPlayer = (BasePlayer)targetEntity;
                    if (!(bool)setting["SleepLoot"] && targetPlayer.HasFlag(BaseEntity.Flags.Locked))
                    {
                        BasePlayer player = lootInventory.GetComponent<BasePlayer>();
                        player.ChatMessage(message["DoNotLoot"]);
                        NextTick(() =>
                        {
                            player.EndLooting();
                        });
                    }
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BetterLoot.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("BetterLoot", "playrust.io / dcode", "1.8.4", ResourceId = 828)]
    public class BetterLoot : RustPlugin
    {

        // To configure, use config/BetterLoot.json instead
        #region Configuration

        private double        defaultBlueprintProbability = 0.11;
        private int           defaultMinItemsPerBarrel    = 1;
        private int           defaultMaxItemsPerBarrel    = 3;
        private int           defaultMinItemsPerCrate     = 3;
        private int           defaultMaxItemsPerCrate     = 6;
        private double        defaultBaseItemRarity       = 2;
        private double        defaultBaseBlueprintRarity  = 2;
        private int           defaultRefreshMinutes       = 15;
        private bool          defaultEnforceBlacklist     = false;
        private bool          defaultDropWeaponsWithAmmo  = true;
        private Dictionary<string, int> defaultDropLimits = new Dictionary<string, int>() {
            // C4
            { "explosives", 50 },
            { "explosive.timed", 2 },
            // Ammunition
            { "arrow_wooden", 16 },
            { "ammo_handmade_shell", 32 },
            { "ammo_shotgun", 32 },
            { "ammo_pistol", 32 },
            { "ammo_rifle", 32 },
            { "gunpowder", 200 },
            // From animals
            { "fat_animal", 200 },
            { "cloth", 200 },
            { "lowgradefuel", 200 },
            { "bone_fragments", 200 },
            // Medical
            { "antiradpills", 5 },
            { "bandage", 5 },
            { "largemedkit", 2 },
            { "blood", 200 },
            // Resources
            { "wood", 1000 },
            { "stones", 1000 },
            { "metal_ore", 1000 },
            { "sulfur_ore", 1000 },
            { "metal_fragments", 1000 },
            { "sulfur", 1000 },
            // Food
            { "apple", 10 },
            { "blueberries", 10 },
            { "black raspberries", 10 },
            { "wolfmeat_cooked", 5 },
            { "chicken_cooked", 5 },
            { "can_beans", 5 },
            { "can_tuna", 5 },
            { "granolabar", 5 },
            { "chocholate", 5 },
            { "smallwaterbottle", 5}
        };

        private double       blueprintProbability;
        private int          minItemsPerBarrel;
        private int          maxItemsPerBarrel;
        private int          minItemsPerCrate;
        private int          maxItemsPerCrate;
        private double       baseItemRarity;
        private double       baseBlueprintRarity;
        private int          refreshMinutes;
        private List<string> itemBlacklist;
        private List<string> blueprintBlacklist;
        private bool         enforceBlacklist;
        private bool         dropWeaponsWithAmmo;
        private Dictionary<string, int> dropLimits;

        #endregion

        // Stuff that will never drop as a blueprint (default craftable)
        private List<string> defaultBlueprints = new List<string>() {
            // Building
            "lock.key", "cupboard.tool", "building_planner", "door_key", "sign.wooden.small",
            // Items
            "campfire", "box_wooden", "sleepingbag", "furnace",
            // Resources
            "paper", "lowgradefuel", "gunpowder",
            // Attire
            "burlap_shirt", "burlap_shoes", "burlap_trousers",
            "attire.hide.boots", "attire.hide.pants", "attire.hide.poncho", "attire.hide.vest",
            "urban_pants", "urban_boots",
            // Tools
            "hammer", "torch", "stonehatchet", "stone_pickaxe", "box_repair_bench",
            // Weapons
            "spear_wooden", "knife_bone", "bow_hunting", "pistol_eoka",
            // Ammunition
            "arrow_wooden", "ammo_handmade_shell"
            // Traps
        };

        // Stuff that will simply never drop
        private List<string> doesNotDrop = new List<string>() {
            // Food
            "apple_spoiled", "bearmeat", "chicken_burned", "chicken_spoiled", "wolfmeat_burned", "wolfmeat_spoiled",
            // Resources
            "blood", "battery_small", "paper", "skull_human", "skull_wolf"
        };

        // Ammunition used by the differnt kinds of weapons
        private Dictionary<string, string> weaponAmmunition = new Dictionary<string, string>() {
            { "bow_hunting", "arrow_wooden" },
            { "pistol_eoka", "ammo_handmade_shell" },
            { "pistol_revolver", "ammo_pistol" },
            { "shotgun_waterpipe", "ammo_shotgun" },
            { "shotgun_pump", "ammo_shotgun" },
            { "smg_thompson", "ammo_pistol" },
            { "rifle_bolt", "ammo_rifle" },
            { "rifle_ak", "ammo_rifle" }
        };

        // Translations
        private List<string> texts = new List<string>() {
            "A barrel drops up to %N% items, a chest up to %M% items.",
            "Base item rarity is %N% and base blueprint rarity is %M%.",
            "There is a <color=#aef45b>%N%%</color> chance that any drop is a blueprint.",
            "There is a <color=#f4e75b>%P%%</color> chance to get one of %N% %RARITY% items.",
            "There is a <color=#5bbcf4>%P%%</color> chance to get one of %N% %RARITY% blueprints.",

            "Usage: /droplimit \"ITEMNAME\" [LIMIT]",
            "You are not authorized to modify drop limits",
            "No such item:",
            "Drop limit of '%NAME%' is %LIMIT%",
            "Drop limit of '%NAME%' has been changed from %LIMIT% to %NEWLIMIT%",

            "Usage: /blacklist [additem|deleteitem|addbp|deletebp] \"ITEMNAME\"",
            "There are no blacklisted items",
            "Blacklisted items:",
            "There are no blacklisted blueprints",
            "Blacklisted blueprints:",
            "You are not authorized to modify the blacklist",
            "Not a valid item:",
            "The item '%NAME%' is now blacklisted",
            "The item '%NAME%' is already blacklisted",
            "Not a valid blueprint:",
            "The blueprint '%NAME%' is now blacklisted",
            "The blueprint '{0}' is already blacklisted",
            "The item '%NAME%' is now no longer blacklisted",
            "The item '%NAME%' is not blacklisted",
            "The blueprint '%NAME%' is now no longer blacklisted",
            "The blueprint '%NAME' is not blacklisted",

            "<color=\"#ffd479\">/loot</color> - Displays the details on loot tables",
            "<color=\"#ffd479\">/blacklist</color> - Displays which items are blacklisted",

            "common",
            "uncommon",
            "rare",
            "very rare"
        };
        private Dictionary<string, string> messages = new Dictionary<string, string>();

        // Regular expressions defining what to override
        private Regex barrelEx = new Regex("loot_barrel|loot_trash");
        private Regex crateEx = new Regex("crate");
        private Regex overrideLootOf = new Regex("(loot_barrel|loot_trash|crate)");

        // Items and blueprints data
        private List<string>[] items = new List<string>[4];
        private int totalItems;
        private List<string>[] blueprints = new List<string>[4];
        private int totalBlueprints;
        private int[] itemWeights = new int[4];
        private int[] blueprintWeights = new int[4];
        private int totalItemWeight;
        private int totalBlueprintWeight;

        // What the game says
        private List<ItemDefinition> originalItems;
        private List<ItemBlueprint> originalBlueprints;

        // Underlying random number generator
        private Random rng = new Random();

        // Whether the plugin has been correctly initialized
        private bool initialized = false;

        // Number of ticks until an internals update is scheduled
        private int updateScheduled = -1;

        // List of containers to refresh periodically
        private List<ContainerToRefresh> refreshList = new List<ContainerToRefresh>();

        // Last time containers have been refreshed
        private DateTime lastRefresh = DateTime.MinValue;

        // Loads the default configuration parameters into the config object
        protected override void LoadDefaultConfig() {
            Config["blueprintProbability"] = defaultBlueprintProbability;
            Config["minItemsPerBarrel"]    = defaultMinItemsPerBarrel;
            Config["maxItemsPerBarrel"]    = defaultMaxItemsPerBarrel;
            Config["minItemsPerCrate"]     = defaultMinItemsPerCrate;
            Config["maxItemsPerCrate"]     = defaultMaxItemsPerCrate;
            Config["baseItemRarity"]       = defaultBaseItemRarity;
            Config["baseBlueprintRarity"]  = defaultBaseBlueprintRarity;
            Config["refreshMinutes"]       = defaultRefreshMinutes;
            Config["itemBlacklist"]        = new List<string>();
            Config["blueprintBlacklist"]   = new List<string>();
            Config["enforceBlacklist"]     = defaultEnforceBlacklist;
            Config["dropWeaponsWithAmmo"]  = defaultDropWeaponsWithAmmo;
            Config["dropLimits"]           = defaultDropLimits;

            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        // Gets a configuration value of a specific type
        T GetConfig<T>(string key, T defaultValue) {
            try {
                var val = Config[key];
                if (val == null)
                    return defaultValue;
                if (val is List<object>) {
                    var t = typeof(T).GetGenericArguments()[0];
                    if (t == typeof(String)) {
                        var cval = new List<string>();
                        foreach (var v in val as List<object>)
                            cval.Add((string)v);
                        val = cval;
                    } else if (t == typeof(int)) {
                        var cval = new List<int>();
                        foreach (var v in val as List<object>)
                            cval.Add(Convert.ToInt32(v));
                        val = cval;
                    }
                } else if (val is Dictionary<string, object>) {
                    var t = typeof(T).GetGenericArguments()[1];
                    if (t == typeof(int)) {
                        var cval = new Dictionary<string,int>();
                        foreach (var v in val as Dictionary<string, object>)
                            cval.Add(Convert.ToString(v.Key), Convert.ToInt32(v.Value));
                        val = cval;
                    }
                }
                return (T)Convert.ChangeType(val, typeof(T));
            } catch (Exception ex) {
                Warn("Invalid config value: " + key+" ("+ex.Message+")");
                return defaultValue;
            }
        }

        // Updates the internal probability matrix and optionally logs the result
        private void UpdateInternals(bool doLog) {
            Log("Updating internals ...");
            originalItems = UnityEngine.Resources.LoadAll<ItemDefinition>("items/").ToList<ItemDefinition>();
            originalBlueprints = UnityEngine.Resources.LoadAll<ItemBlueprint>("items/").ToList<ItemBlueprint>();
            if (originalItems.Count < 20 || originalBlueprints.Count < 10) {
                Error("Resources did not contain a sane amount of items and/or blueprints. Is the game broken?");
                return;
            }
            if (doLog)
                Log("There are " + originalItems.Count + " items and " + originalBlueprints.Count + " blueprints in the game.");

            for (var i = 0; i < 4; ++i) {
                items[i] = new List<string>();
                blueprints[i] = new List<string>();
            }
            totalItems = 0;
            totalBlueprints = 0;
            var allItems = ItemManager.GetItemDefinitions();
            if (allItems == null || allItems.Count < 20) {
                Error("ItemManager did not return a sane amount of items. Is the game broken?");
                return;
            }
            var notExistingItems = 0;
            var notExistingBlueprints = 0;
            var itemsWithNoRarity = 0;
            foreach (var item in allItems) {
                if (doesNotDrop.Contains(item.shortname))
                    continue;
                int index = RarityIndex(item.rarity);
                if (index >= 0) {
                    if (ItemExists(item.shortname)) {
                        if (!itemBlacklist.Contains(item.shortname)) {
                            items[index].Add(item.shortname);
                            ++totalItems;
                        }
                    } else ++notExistingItems;
                    if (BlueprintExists(item.shortname)) {
                        if (!blueprintBlacklist.Contains(item.shortname)) {
                            blueprints[index].Add(item.shortname);
                            ++totalBlueprints;
                        }
                    } else ++notExistingBlueprints;
                } else ++itemsWithNoRarity;
            }
            if (totalItems < 20 || totalBlueprints < 10) {
                Error("Failed to categorize items: "+notExistingItems+" items and "+notExistingBlueprints+" blueprints did not exist and "+itemsWithNoRarity+" items had no rarity");
                if (itemsWithNoRarity > 10)
                    Error("THIS IS MOST LIKELY CAUSED BY A MISCONFIGURED (OR BROKEN) PLUGIN THAT MODIFIES ITEMS!");
                else
                    Error("PLEASE REPORT THIS ON THE DEDICATED DISCUSSION THREAD! http://oxidemod.org/threads/betterloot.7063");
                return;
            }
            if (doLog)
                Log("We are going to use " + totalItems + " items and " + totalBlueprints + " blueprints of them.");

            totalItemWeight = 0;
            totalBlueprintWeight = 0;
            for (var i = 0; i < 4; ++i) {
                totalItemWeight += (itemWeights[i] = ItemWeight(baseItemRarity, i) * items[i].Count);
                totalBlueprintWeight += (blueprintWeights[i] = ItemWeight(baseBlueprintRarity, i) * blueprints[i].Count);
            }

            if (doLog) {
                Log(string.Format("Base item rarity is {0} and base blueprint rarity is {1}.", baseItemRarity, baseBlueprintRarity));
                Log(string.Format("With a {0:0.0}% chance that any drop is a blueprint we get:", 100 * blueprintProbability));
                double total = 0;
                for (var i = 0; i < 4; ++i) {
                    double prob = (1 - blueprintProbability) * 100d * itemWeights[i] / totalItemWeight;
                    Log(string.Format("There is a {0:0.000}% chance to get one of {1} " + RarityName(i) + " items (w={2}, {3}/{4}).", prob, items[i].Count, ItemWeight(baseItemRarity, i), itemWeights[i], totalItemWeight));
                    total += prob;
                }
                for (var i = 0; i < 4; ++i) {
                    double prob = blueprintProbability * 100d * blueprintWeights[i] / totalBlueprintWeight;
                    Log(string.Format("There is a {0:0.000}% chance to get one of {1} " + RarityName(i) + " blueprints (w={2}, {3}/{4}).", prob, blueprints[i].Count, ItemWeight(baseBlueprintRarity, i), blueprintWeights[i], totalBlueprintWeight));
                    total += prob;
                }
                // Log("Total chance: " + total + "% == 100%");
            }
            // Update containers accordingly
            var containers = UnityEngine.Object.FindObjectsOfType<LootContainer>();
            foreach (var container in containers) {
                try {
                    PopulateContainer(container);
                } catch (Exception ex) {
                    Warn("Failed to populate container " + ContainerName(container) + ": " + ex.Message + "\n" + ex.StackTrace);
                }
            }
            initialized = true;
            Log("Internals have been updated");
        }

        // Initializes our custom loot tables
        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            if (initialized)
                return;
            try {
                LoadConfig();

                blueprintProbability = GetConfig<double>("blueprintProbability", defaultBlueprintProbability);
                minItemsPerBarrel = GetConfig<int>("minItemsPerBarrel", defaultMinItemsPerBarrel);
                maxItemsPerBarrel = GetConfig<int>("maxItemsPerBarrel", defaultMaxItemsPerBarrel);
                minItemsPerCrate = GetConfig<int>("minItemsPerCrate", defaultMinItemsPerCrate);
                maxItemsPerCrate = GetConfig<int>("maxItemsPerCrate", defaultMaxItemsPerCrate);
                baseItemRarity = GetConfig<double>("baseItemRarity", defaultBaseItemRarity);
                baseBlueprintRarity = GetConfig<double>("baseBlueprintRarity", defaultBaseBlueprintRarity);
                refreshMinutes = GetConfig<int>("refreshMinutes", defaultRefreshMinutes);
                itemBlacklist = GetConfig<List<string>>("itemBlacklist", new List<string>()); /* ref */ Config["itemBlacklist"] = itemBlacklist;
                blueprintBlacklist = GetConfig<List<string>>("blueprintBlacklist", new List<string>()); /* ref */ Config["blueprintBlacklist"] = blueprintBlacklist;
                enforceBlacklist = GetConfig<bool>("enforceBlacklist", defaultEnforceBlacklist);
                dropWeaponsWithAmmo = GetConfig<bool>("dropWeaponsWithAmmo", defaultDropWeaponsWithAmmo);
                dropLimits = GetConfig<Dictionary<string, int>>("dropLimits", defaultDropLimits); /* ref */ Config["dropLimits"] = dropLimits;

                updateScheduled = 3;
                Log("Updating in T-" + updateScheduled + " ...");
                // ^ Wait a couple of ticks to give plugins that modify items a chance to do their thing prior to calculating loot tables.
            } catch (Exception ex) {
                Error("OnServerInitialized failed: " + ex.Message);
            }
        }

        // Asks the mighty RNG for an item
        private Item MightyRNG() {
            bool blueprint = rng.NextDouble() < blueprintProbability;
            List<string> selectFrom;
            int limit = 0;
            string itemName;
            Item item;
            int maxRetry = 20;
            do {
                selectFrom = null;
                item = null;
                if (blueprint) {
                    var r = rng.Next(totalBlueprintWeight);
                    for (var i=0; i<4; ++i) {
                        limit += blueprintWeights[i];
                        if (r < limit) {
                            selectFrom = blueprints[i];
                            break;
                        }
                    }
                } else {
                    var r = rng.Next(totalItemWeight);
                    for (var i=0; i<4; ++i) {
                        limit += itemWeights[i];
                        if (r < limit) {
                            selectFrom = items[i];
                            break;
                        }
                    }
                }
                if (selectFrom == null) {
                    if (--maxRetry <= 0) {
                        Error("Endless loop detected: ABORTING");
                        break;
                    }
                    Warn("Item list to select from is empty (trying another one)");
                    continue;
                }
                itemName = selectFrom[rng.Next(0, selectFrom.Count)];
                item = ItemManager.CreateByName(itemName, 1);
                if (item == null) {
                    Warn("Failed to create item: " + itemName + " (trying another one)");
                    continue;
                }
                if (item.info == null) {
                    Warn("Item has no definition: " + itemName+" (trying another one)");
                    continue;
                }
                break;
            } while (true);
            if (item == null)
                return null;
            if (blueprint) {
                item.isBlueprint = true;
            } else if (item.info.stackable > 1 && dropLimits.TryGetValue(item.info.shortname, out limit)) {
                item.amount = rng.Next(1, Math.Min(limit, item.info.stackable) + 1);
            }
            return item;
        }

        // Clears a loot container's contents
        private void ClearContainer(LootContainer container) {
            while (container.inventory.itemList.Count > 0) {
                var item = container.inventory.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }
        }

        // Suppresses automatic refreshes of a container
        private void SuppressRefresh(LootContainer container) {
            container.minSecondsBetweenRefresh = -1;
            container.maxSecondsBetweenRefresh = 0;
            container.CancelInvoke("SpawnLoot");
        }

        // Populates a container with loot
        private void PopulateContainer(LootContainer container) {
            if (container.inventory == null) {
                Warn("Container " + ContainerName(container) + " has no inventory (skipping)");
                return;
            }
            int min = 1;
            int max = 0;
            bool refresh = false;
            if (container is SupplyDrop) {
                SuppressRefresh(container);
                var inv = container.inventory.itemList.ToArray();
                foreach (var item in inv) {
                    if (itemBlacklist.Contains(item.info.shortname)) {
                        item.RemoveFromContainer();
                        item.Remove(0f);
                        ++max;
                    }
                }
                if (max == 0)
                    return;
            } else if (barrelEx.IsMatch(container.gameObject.name)) {
                SuppressRefresh(container);
                ClearContainer(container);
                min = minItemsPerBarrel;
                max = maxItemsPerBarrel;
            } else if (crateEx.IsMatch(container.gameObject.name)) {
                SuppressRefresh(container);
                ClearContainer(container);
                min = minItemsPerCrate;
                max = maxItemsPerCrate;
                refresh = true; // In case someone puts trash in it
            } else
                return;

            var n = min + rng.Next(0, max - min + 1);
            var sb = new StringBuilder();
            var items = new List<Item>();
            bool hasAmmo = false;
            for (int i = 0; i < n; ++i) {
                var item = MightyRNG();
                if (item == null) {
                    Error("Failed to obtain item: Is the plugin initialized yet?");
                    return;
                }
                items.Add(item);
                if (sb.Length > 0)
                    sb.Append(", ");
                if (item.amount > 1)
                    sb.Append(item.amount).Append("x ");
                sb.Append(item.info.shortname);
                if (item.isBlueprint)
                    sb.Append(" (BP)");
                else if (dropWeaponsWithAmmo && !hasAmmo && items.Count < container.inventorySlots) { // Drop some ammunition with first weapon
                    string ammo;
                    int limit;
                    if (weaponAmmunition.TryGetValue(item.info.shortname, out ammo) && dropLimits.TryGetValue(ammo, out limit)) {
                        try {
                            item = ItemManager.CreateByName(ammo, rng.Next(2, limit + 1));
                            items.Add(item);
                            sb.Append(" + ");
                            if (item.amount > 1)
                                sb.Append(item.amount).Append("x ");
                            sb.Append(item.info.shortname);
                            hasAmmo = true;
                        } catch (Exception) {
                            Warn("Failed to obtain ammo item: "+ammo);
                        }
                    }
                }
            }
            // Log("Populating " + ContainerName(container) + " with " + sb.ToString());
            foreach (var item in items)
                item.MoveToContainer(container.inventory, -1, false);
            container.inventory.MarkDirty();
            if (refresh)
                refreshList.Add(new ContainerToRefresh() { container = container, time = DateTime.UtcNow.AddMinutes(refreshMinutes) });
        }

        [HookMethod("OnEntitySpawned")]
        private void OnEntitySpawned(BaseNetworkable entity) {
            if (!initialized)
                return;
            try {
                var container = entity as LootContainer;
                if (container == null || container.inventory == null || container.inventory.itemList == null)
                    return;
                PopulateContainer(container);
            } catch (Exception ex) {
                Error("OnEntitySpawned failed: " + ex.Message);
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>BetterLoot</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/loot</color> - Displays the details on loot tables")).Append("\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/blacklist</color> - Displays which items are blacklisted"));
            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("loot")]
        private void cmdChatLoot(BasePlayer player, string command, string[] args) {
            if (!initialized)
                return;
            var sb = new StringBuilder();
            sb.Append("<size=22>BetterLoot</size> "+Version+" by <color=#ce422b>http://playrust.io</color>\n");
            sb.Append(_("A barrel drops up to %N% items, a chest up to %M% items.", new Dictionary<string,string>() {
                { "N", maxItemsPerBarrel.ToString() },
                { "M", maxItemsPerCrate.ToString() }
            })).Append("\n");
            sb.Append(_("Base item rarity is %N% and base blueprint rarity is %M%.", new Dictionary<string, string>() {
                { "N", string.Format("{0:0.00}", baseItemRarity) },
                { "M", string.Format("{0:0.00}", baseBlueprintRarity) }
            })).Append("\n");
            sb.Append(_("There is a <color=#aef45b>%P%%</color> chance that any drop is a blueprint.", new Dictionary<string, string>() {
                { "P", string.Format("{0:0.0}", 100 * blueprintProbability) }
            })).Append("\n");
            for (var i = 0; i < 4; ++i) {
                double prob = (1 - blueprintProbability) * 100d * itemWeights[i] / totalItemWeight;
                sb.Append(_("There is a <color=#f4e75b>%P%%</color> chance to get one of %N% %RARITY% items.", new Dictionary<string, string>() {
                    { "P", string.Format("{0:0.000}", prob) },
                    { "N", items[i].Count.ToString() },
                    { "RARITY", _(RarityName(i)) }
                })).Append("\n");
            }
            for (var i = 0; i < 4; ++i) {
                double prob = blueprintProbability * 100d * blueprintWeights[i] / totalBlueprintWeight;
                sb.Append(_("There is a <color=#5bbcf4>%P%%</color> chance to get one of %N% %RARITY% blueprints.", new Dictionary<string, string>() {
                    { "P", string.Format("{0:0.000}", prob) },
                    { "N", blueprints[i].Count.ToString() },
                    { "RARITY", _(RarityName(i)) }
                })).Append("\n");
            }
            SendReply(player, sb.ToString().TrimEnd());
        }

        [ChatCommand("droplimit")]
        private void cmdChatDroplimit(BasePlayer player, string command, string[] args) {
            var usage = _("Usage: /droplimit \"ITEMNAME\" [LIMIT]");
            if (!initialized)
                return;
            if (!ServerUsers.Is(player.userID, ServerUsers.UserGroup.Owner)) {
                SendReply(player, _("You are not authorized to modify drop limits"));
                return;
            }
            if (args.Length < 1) {
                SendReply(player, usage);
                return;
            }
            string name = args[0];
            int currentLimit;
            if (!dropLimits.TryGetValue(name, out currentLimit)) {
                SendReply(player, _("No such item:")+" "+name);
                return;
            }
            if (args.Length == 1) {
                SendReply(player, _("Drop limit of '%NAME%' is %LIMIT%", new Dictionary<string, string>() {
                    { "ITEM", name },
                    { "LIMIT", currentLimit.ToString() }
                }));
                return;
            }
            int limit = Convert.ToInt32(args[1]);
            dropLimits[name] = limit;
            SaveConfig();
            SendReply(player, "Drop limit of '%NAME%' has been changed from %LIMIT% to %NEWLIMIT%", new Dictionary<string, string>() {
                { "NAME", name },
                { "LIMIT", currentLimit.ToString() },
                { "NEWLIMIT", limit.ToString() }
            });
        }

        [ChatCommand("blacklist")]
        private void cmdChatBlacklist(BasePlayer player, string command, string[] args) {
            var usage = _("Usage: /blacklist [additem|deleteitem|addbp|deletebp] \"ITEMNAME\"");
            if (!initialized)
                return;
            if (args.Length == 0) {
                if (itemBlacklist.Count == 0) {
                    SendReply(player, _("There are no blacklisted items"));
                } else {
                    var sb = new StringBuilder();
                    foreach (var item in itemBlacklist) {
                        if (sb.Length > 0)
                            sb.Append(", ");
                        sb.Append(item);
                    }
                    SendReply(player, _("Blacklisted items:")+" "+sb.ToString());
                }
                if (blueprintBlacklist.Count == 0) {
                    SendReply(player, _("There are no blacklisted blueprints"));
                } else {
                    var sb = new StringBuilder();
                    foreach (var item in blueprintBlacklist) {
                        if (sb.Length > 0)
                            sb.Append(", ");
                        sb.Append(item);
                    }
                    SendReply(player, _("Blacklisted blueprints:")+" "+sb.ToString());
                }
                return;
            }
            if (!ServerUsers.Is(player.userID, ServerUsers.UserGroup.Owner)) {
                SendReply(player, _("You are not authorized to modify the blacklist"));
                return;
            }
            if (args.Length != 2) {
                SendReply(player, usage);
                return;
            }
            if (args[0] == "additem") {
                if (!ItemExists(args[1])) {
                    SendReply(player, _("Not a valid item:")+" "+args[1]);
                    return;
                }
                if (!itemBlacklist.Contains(args[1])) {
                    itemBlacklist.Add(args[1]);
                    UpdateInternals(false);
                    SendReply(player, _("The item '%NAME%' is now blacklisted", new Dictionary<string,string>() {
                        { "NAME", args[1] }
                    }));
                    SaveConfig();
                    return;
                } else {
                    SendReply(player, _("The item '%NAME%' is already blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    return;
                }
            } else if (args[0] == "addbp") {
                if (!BlueprintExists(args[1])) {
                    SendReply(player, _("Not a valid blueprint:") + " " + args[1]);
                    return;
                }
                if (!blueprintBlacklist.Contains(args[1])) {
                    blueprintBlacklist.Add(args[1]);
                    UpdateInternals(false);
                    SendReply(player, _("The blueprint '%NAME%' is now blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    SaveConfig();
                    return;
                } else {
                    SendReply(player, _("The blueprint '%NAME%' is already blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    return;
                }
            } else if (args[0] == "deleteitem") {
                if (!ItemExists(args[1])) {
                    SendReply(player, _("Not a valid item:")+" "+args[1]);
                    return;
                }
                if (itemBlacklist.Contains(args[1])) {
                    itemBlacklist.Remove(args[1]);
                    UpdateInternals(false);
                    SendReply(player, _("The item '%NAME%' is now no longer blacklisted", new Dictionary<string,string>() {
                        { "NAME", args[1] }
                    }));
                    SaveConfig();
                    return;
                } else {
                    SendReply(player, _("The item '%NAME%' is not blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    return;
                }
            } else if (args[0] == "deletebp") {
                if (!BlueprintExists(args[1])) {
                    SendReply(player, _("Not a valid blueprint:")+" "+args[1]);
                    return;
                }
                if (blueprintBlacklist.Contains(args[1])) {
                    blueprintBlacklist.Remove(args[1]);
                    UpdateInternals(false);
                    SendReply(player, _("The blueprint '%NAME%' is now no longer blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    SaveConfig();
                    return;
                } else {
                    SendReply(player, _("The blueprint '%NAME' is not blacklisted", new Dictionary<string, string>() {
                        { "NAME", args[1] }
                    }));
                    return;
                }
            } else {
                SendReply(player, usage);
                return;
            }
        }

        /* [HookMethod("OnItemCraft")]
        private void OnItemCraft(ItemCraftTask item) {
        } */

        [HookMethod("OnItemAddedToContainer")]
        private void OnItemAddedToContainer(ItemContainer container, Item item) {
            if (!initialized || !enforceBlacklist)
                return;
            try {
                var owner = item.GetOwnerPlayer();
                if (owner != null && (ServerUsers.Is(owner.userID, ServerUsers.UserGroup.Owner) || ServerUsers.Is(owner.userID, ServerUsers.UserGroup.Moderator)))
                    return;
                if (!item.isBlueprint && itemBlacklist.Contains(item.info.shortname)) {
                    Log(string.Format("Destroying item instance of '{0}'", item.info.shortname));
                    item.RemoveFromContainer();
                    item.Remove(0f);
                } else if (item.isBlueprint && blueprintBlacklist.Contains(item.info.shortname)) {
                    Log(string.Format("Destroying blueprint instance of '{0}'", item.info.shortname));
                    item.RemoveFromContainer();
                    item.Remove(0f);
                }
            } catch (Exception ex) {
                Error("OnItemAddedToContainer failed: " + ex.Message);
            }
        }

        [HookMethod("OnTick")]
        private void OnTick() {
            try {
                if (updateScheduled == 0) {
                    updateScheduled = -1;
                    UpdateInternals(true);
                } else if (updateScheduled > 0) {
                    --updateScheduled;
                }
            } catch (Exception ex) {
                Error("OnTick scheduled update failed: " + ex.Message);
            }
            try {
                var now = DateTime.UtcNow;
                if (lastRefresh < now.AddMinutes(-1)) {
                    lastRefresh = now;
                    int n = 0;
                    int m = 0;
                    var all = refreshList.ToArray();
                    refreshList.Clear();
                    foreach (var ctr in all) {
                        if (ctr.time < now) {
                            if (ctr.container.isDestroyed) { // Discard destroyed containers
                                ++m;
                                continue;
                            }
                            if (ctr.container.IsOpen()) {
                                refreshList.Add(ctr); // Re-add for later if occupied
                                continue;
                            }
                            try {
                                PopulateContainer(ctr.container); // Will re-add
                                ++n;
                            } catch (Exception ex) {
                                Error("Failed to refresh container: " + ContainerName(ctr.container) + ": " + ex.Message + "\n" + ex.StackTrace);
                            }
                        } else
                            refreshList.Add(ctr); // Re-add for later
                    }
                    if (n > 0 || m > 0)
                        Log("Refreshed " + n + " containers (" + m + " destroyed)");
                }
            } catch (Exception ex) {
                Error("OnTick scheduled refresh failed: " + ex.Message);
            }
        }

        [HookMethod("BuildServerTags")]
        private void BuildServerTags(IList<string> taglist) {
            try {
                taglist.Add("betterloot");
            } catch (Exception ex) {
                Error("BuildServerTags failed: " + ex.Message);
            }
        }

        #region Utility Methods

        private void Log(string message) {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message) {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message) {
            PrintError("{0}: {1}", Title, message);
        }

        private static string ContainerName(LootContainer container) {
            var name = container.gameObject.name;
            name = name.Substring(name.LastIndexOf("/") + 1);
            name += "#" + container.gameObject.GetInstanceID();
            return name;
        }


        private static int RarityIndex(Rarity rarity) {
            switch (rarity) {
                case Rarity.Common: return 0;
                case Rarity.Uncommon: return 1;
                case Rarity.Rare: return 2;
                case Rarity.VeryRare: return 3;
            }
            return -1;
        }

        private static string RarityName(int index) {
            switch (index) {
                case 0: return "common";
                case 1: return "uncommon";
                case 2: return "rare";
                case 3: return "very rare";
            }
            return null;
        }

        private bool BlueprintExists(string name) {
            if (defaultBlueprints.Contains(name))
                return false;
            foreach (var def in originalBlueprints) {
                if (def.targetItem.shortname != name)
                    continue;
                var testItem = ItemManager.CreateByName(name, 1);
                if (testItem != null) {
                    testItem.Remove(0f);
                    return true;
                }
            }
            return false;
        }

        private bool ItemExists(string name) {
            foreach (var def in originalItems) {
                if (def.shortname != name)
                    continue;
                var testItem = ItemManager.CreateByName(name, 1);
                if (testItem != null) {
                    testItem.Remove(0f);
                    return true;
                }
            }
            return false;
        }

        private bool IsWeapon(string name) {
            return weaponAmmunition.ContainsKey(name);
        }

        private int ItemWeight(double baseRarity, int index) {
            return (int)(Math.Pow(baseRarity, 3 - index) * 1000); // Round to 3 decimals
        }

        // Translates a string
        private string _(string text, Dictionary<string, string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }

        #endregion

        private class ContainerToRefresh {
            public LootContainer container;
            public DateTime time;
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BetterStability.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

// #define DEBUG

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("BetterStability", "playrust.io/ dcode", "0.7.6", ResourceId = 862)]
    public class BetterStability : RustPlugin
    {
        // Singleton instance
        public static BetterStability Instance { get; private set; }

        // Update queues
        private List<BuildingBlock> stabilityQueueDelayed = new List<BuildingBlock>();
        private List<BuildingBlock> stabilityQueue = new List<BuildingBlock>();

        // Stats
        private Stats currentStats = new Stats();
        private Stats lastStats = new Stats();
        private static int statsInterval = 60 * 1000;
        private DateTime nextStatsTime = DateTime.MinValue;

        // Messages / Translations
        private string[] buildingFailedMessages = new string[] {
            "Man, that looks unstable as shit. Here's your refund!",
            "Even Bob couldn't build that. Refunded!",
            "That wouldn't be stable even with Lego. Have a refund!",
            "That would require a shitload of Duck TapeÂ®. Apparently, you have none.",
            "Well, that looks interesting. Isn't stable, though. Here's your refund!"
        };
        private List<string> texts = new List<string>() {
            "Buildings are either 100% or 0% stable.",
            "All building parts must be supported by pillars."
        };
        private Dictionary<string, string> messages = new Dictionary<string, string>();
        private System.Random rng = new System.Random();

        // Translates a string
        private string _(string text, Dictionary<string, string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }

        // Logs a message to console
        public void Log(string message) {
            Puts("{0}: {1}", Title, message);
        }

        // Logs an error to console
        public void Error(string message, Exception ex = null) {
            if (ex == null)
                PrintError("{0}: {1}", Title, message);
            else
                PrintError("{0}: {1}: {2}\n{3}", Title, message, ex.Message, ex.StackTrace);
        }

        protected override void LoadDefaultConfig() {
            var messages = new Dictionary<string, object>();
            foreach (var msg in buildingFailedMessages)
                texts.Add(msg);
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        #region Hooks

        [HookMethod("Init")]
        private void Init() {
            Instance = this;
            if (server.stability) {
                server.stability = false;
                Log("Default stability has been disabled");
            }
        }

        [HookMethod("OnServerInitialized")]
        private void OnServerInitialized() {
            LoadConfig();
            var customMessages = (Dictionary<string,object>)Config["messages"];
            if (customMessages != null) {
                foreach (var pair in customMessages)
                    messages[pair.Key] = Convert.ToString(pair.Value);
                Log("Loaded " + customMessages.Count + " translation strings");
            }

            // Initialize helpers
            BuildingBlockHelpers.Initialize();

            // Force an update on all blocks when first started
            var fs = Interface.GetMod().DataFileSystem;
            var data = fs.GetDatafile("BetterStability");
            bool firstStart = false;
            if (data["firststart"] == null) {
                Log("Starting the first time, forcing update on ALL blocks");
                firstStart = true;
                data["firststart"] = false;
                fs.SaveDatafile("BetterStability");
            }

            // Schedule stability updates for all blocks that support anything
            var allBlocks = UnityEngine.Object.FindObjectsOfType<BuildingBlock>();
            int n = 0;
            foreach (var block in allBlocks) {
                if (firstStart || (!BuildingBlockHelpers.IsFoundation(block) && BuildingBlockHelpers.IsSupportForAnything(block))) {
                    EnqueueUpdate(block);
                    ++n;
                }
            }
            Log("Queued " + n + " blocks for stability updates");
        }

        [HookMethod("OnEntityBuilt")]
        private void OnEntityBuilt(Planner planner, GameObject obj) {
            if (obj == null)
                return;
            var block = obj.GetComponent<BuildingBlock>();
            if (block == null || block.isDestroyed || block.blockDefinition == null /* ? */)
                return;
            ++currentStats.blocksBuilt;
            try {
                if (!UpdateStability(block, false)) {
                    ++currentStats.blocksFailedBuilding;
                    // If this isn't stable, refund.
                    var player = planner.ownerPlayer;
                    foreach (var cost in block.blockDefinition.defaultGrade.costToBuild) {
                        var item = ItemManager.CreateByItemID(cost.itemid, (int)cost.amount, false);
                        player.GiveItem(item);
                    }
                    player.ChatMessage(_(buildingFailedMessages[rng.Next(0, buildingFailedMessages.Length)]));
                    return;
                }
            } catch (Exception ex) {
                Error("OnEntityBuilt failed", ex);
            }
        }

        /* [HookMethod("OnBuildingBlockDoRotation")]
        private void OnBuildingBlockRotate(BuildingBlock block, object whatev) {
        } */

        [HookMethod("OnBuildingBlockDemolish")]
        private void OnBuildingBlockDemolish(BuildingBlock block, BasePlayer player) {
            if (block == null)
                return;
            OnDemolish(block);
        }

        [HookMethod("OnEntityDeath")]
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info) {
            var block = entity as BuildingBlock;
            if (block == null)
                return;
            OnDemolish(block);
        }

        [HookMethod("OnTick")]
        private void OnTick() {
            var now = DateTime.Now;
            if (nextStatsTime < now) {
                nextStatsTime = now.AddMilliseconds(statsInterval);
                lastStats = currentStats;
                currentStats = new Stats();
            }
            // Never use more than half the available tick time
            // but always process at least one queued block.
            var maxTime = (1000 / server.tickrate) / 2;
            var n = 0;
            while (stabilityQueue.Count > 0 && (n == 0 || (DateTime.Now - now).TotalMilliseconds < maxTime)) {
                var block = stabilityQueue[0];
                stabilityQueue.RemoveAt(0);
                UpdateStability(block);
                ++n;
            }
            // Always delay queued updates until the next tick.
            // This also gives us a nice bottom up effect.
            while (stabilityQueueDelayed.Count > 0) {
                stabilityQueue.Add(stabilityQueueDelayed[0]);
                stabilityQueueDelayed.RemoveAt(0);
            }
        }

        [HookMethod("BuildServerTags")]
        private void BuildServerTags(IList<string> taglist) {
            taglist.Add("betterstability");
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>BetterStability</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("Buildings are either 100% or 0% stable.")).Append("\n")
               .Append("  ").Append(_("All building parts must be supported by pillars."));
            player.ChatMessage(sb.ToString());
        }

        #endregion

        #region Interface

        // Updates supported blocks once a block has been demolished
        private void OnDemolish(BuildingBlock block) {
            ++currentStats.blocksDemolished;
            List<BuildingBlock> supports;
            List<BuildingBlock> supported;
            BuildingBlockHelpers.GetAdjacentBlocks(block, out supports, out supported);
#if DEBUG
            Log("OnDemolish called for " + BuildingBlockHelpers.Name(block) + " (support for " + supported.Count + " blocks)");
#endif
            foreach (var supportedBlock in supported)
                EnqueueUpdate(supportedBlock); // Must be queued as this block is still alive
            var deployables = BuildingBlockHelpers.GetOrphanedDeployables(block);
            foreach (var entity in deployables)
                DemolishDeployable(entity);
        }

        // Enqueues a stability update for the next tick
        private void EnqueueUpdate(BuildingBlock block) {
            ++currentStats.blocksEnqueued;
            if (!stabilityQueueDelayed.Contains(block)) {
                ++currentStats.blocksEnqueuedUnique;
#if DEBUG
                Log("Enqueued " + BuildingBlockHelpers.Name(block));
#endif
                stabilityQueueDelayed.Add(block);
            }
        }

        // Demolishes a block
        private void DemolishBlock(BuildingBlock block) {
            block.Kill(BaseNetworkable.DestroyMode.Gib);
            ++currentStats.blocksDestroyed;
        }

        // Demolishes a deployable and drops its contents
        private void DemolishDeployable(BaseEntity entity) {
            if (entity is BaseCombatEntity) {
                (entity as BaseCombatEntity).DieInstantly();
            } else {
                entity.Kill(BaseNetworkable.DestroyMode.Gib);
            }
            ++currentStats.deployablesDestroyed;
            /* if (entity is StorageContainer) {
                (entity as StorageContainer).OnKilled(null); // Drops
                // var container = entity as StorageContainer;
                // DropUtil.DropItems(container.inventory, container.transform.position, container.dropChance);
            } */
        }

        // Updates the stability of a block and returns false if the block has just been destroyed
        private bool UpdateStability(BuildingBlock block, bool propagate = true) {
            ++currentStats.blocksUpdated;
            if (block.isDestroyed) {
#if DEBUG
                Log("Skipped " + BuildingBlockHelpers.Name(block) + ": Already destroyed");
#endif
                return true;
            }
            // Log("Updating stability on " + block.Name());
            // Exclude foundations from stability updates.
            if (BuildingBlockHelpers.IsFoundation(block)) {
#if DEBUG
                Log("Skipped " + BuildingBlockHelpers.Name(block) + ": Is foundation");
#endif
                return true;
            }
            List<BuildingBlock> supports;
            List<BuildingBlock> supported;
            BuildingBlockHelpers.GetAdjacentBlocks(block, out supports, out supported);
            if (supports.Count > 0) {
#if DEBUG
                Log("Skipped " + BuildingBlockHelpers.Name(block) + ": Still has " + supports.Count + " supports");
#endif
                return true;
            }
            // If this block has no more supports, destroy it.
#if DEBUG
            Log(BuildingBlockHelpers.Name(block) + " has no (more) supports, killing (supported " + supported.Count + ")" + (propagate ? " - propagating" : " - not propagating"));
#endif
            DemolishBlock(block);
            var deployables = BuildingBlockHelpers.GetOrphanedDeployables(block);
            foreach (var deployable in deployables)
                if (!deployable.isDestroyed)
                    DemolishDeployable(deployable);
            if (propagate)
                foreach (var supportedBlock in supported)
                    EnqueueUpdate(supportedBlock);
            return false;
        }

        #endregion

        #region Console Commands

        [ConsoleCommand("stability.status")]
        void cmdConsoleStatus(ConsoleSystem.Arg arg) {
            if (arg.connection != null && arg.connection.authLevel < 2) {
                return;
            }
            var sb = new StringBuilder();
            sb.Append("Current queue: ").Append(stabilityQueueDelayed.Count).Append(" -> ").Append(stabilityQueue.Count).Append("\n")
              .Append("\n-- Current stats ----------\n")
              .Append(currentStats.ToString())
              .Append("\n-- Last stats ----------\n")
              .Append(lastStats.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("stability.updateall")]
        void cmdConsoleUpdateAll(ConsoleSystem.Arg arg) {
            if (arg.connection != null && arg.connection.authLevel < 2) {
                return;
            }
            var allBlocks = UnityEngine.Object.FindObjectsOfType<BuildingBlock>();
            foreach (var block in allBlocks) {
                UpdateStability(block, true);
            }
            SendReply(arg, "Updating stability on ALL " + allBlocks.Length + " blocks in the background now, this will take a while.");
        }

        #endregion

        public static class BuildingBlockHelpers
        {
            #region Methods

            // Tests if the block is a foundation
            public static bool IsFoundation(BuildingBlock self) {
                return foundationList.Contains(self.blockDefinition.fullName);
            }

            // Tests if the block is a wall
            public static bool IsWall(BuildingBlock self) {
                return wallsList.Contains(self.blockDefinition.fullName);
            }

            // Tests if the block is a pillar
            public static bool IsPillar(BuildingBlock self) {
                return self.blockDefinition.fullName == "build/pillar";
            }

            // Tests if the block is a support for anything
            public static bool IsSupportForAnything(BuildingBlock self) {
                return supportNames.Contains(self.blockDefinition.fullName);
            }

            // Tests if the block is a generally supported by the specified
            public static bool IsSupportedBy(BuildingBlock self, BuildingBlock by) {
                string[] supportFor;
                if (!supportMap.TryGetValue(self.blockDefinition.fullName, out supportFor))
                    return false;
                try {
                    return supportFor.Contains(by.blockDefinition.fullName);
                } catch (Exception) {
                    if (supportFor == null)
                        throw new Exception("supportFor is null");
                    if (by == null)
                        throw new Exception("by is null");
                    if (by.blockDefinition == null)
                        throw new Exception("by.blockDefinition is null");
                    if (by.blockDefinition.fullName == null)
                        throw new Exception("by.blockDefinition.fullName is null");
                    throw;
                }
            }


            // Gets adjacent supports and supported blocks
            public static void GetAdjacentBlocks(BuildingBlock self, out List<BuildingBlock> supports, out List<BuildingBlock> supported) {
                supports = new List<BuildingBlock>();
                supported = new List<BuildingBlock>();
                List<StabilityPinPoint> pinPoints = GetPrefabPinPoints(self);
                // Find all blocks supporting this block
                foreach (var pinPoint in pinPoints) {
                    var worldPosition = LocalToWorld(self, pinPoint.worldPosition);
                    Collider[] colliders = Physics.OverlapSphere(worldPosition, 0.1f, constructionLayerMask);
                    foreach (var collider in colliders) {
                        BuildingBlock other = collider.gameObject.ToBaseEntity() as BuildingBlock;
                        if (other == null || other.isDestroyed || other == self) // Bogus or self
                            continue;
                        if (IsSupportedBy(self, other))
                            supports.Add(other);
                    }
                }
                // Find all blocks supported by this block
                if (!IsSupportForAnything(self))
                    return;
                List<Socket_Base> sockets = GetPrefabSockets(self);
                foreach (var socket in sockets) {
                    var worldPosition = LocalToWorld(self, socket.worldPosition);
                    Collider[] colliders = Physics.OverlapSphere(worldPosition, 0.2f, constructionLayerMask);
                    foreach (var collider in colliders) {
                        BuildingBlock other = collider.gameObject.ToBaseEntity() as BuildingBlock;
                        if (other == null || other.isDestroyed || other == self) // Bogus or self
                            continue;
                        if (IsSupportedBy(other, self))
                            supported.Add(other);
                    }
                }
            }

            public static List<BaseEntity> GetOrphanedDeployables(BuildingBlock self) {
                List<BaseEntity> deployables = new List<BaseEntity>();
                Collider[] colliders = Physics.OverlapSphere(self.transform.position, 4f, deployedLayerMask);
                foreach (var collider in colliders) {
                    var entity = collider.gameObject.ToBaseEntity();
                    if (entity == null)
                        continue;
                    var subColliders = Physics.OverlapSphere(entity.transform.position, 0.1f, placementLayerMask);
                    var isOrphaned = true;
                    foreach (var subCollider in subColliders) {
                        if (subCollider is TerrainCollider) {
                            isOrphaned = false;
                            break;
                        }
                        var block = subCollider.gameObject.ToBaseEntity() as BuildingBlock;
                        if (block != null && block != self) {
                            isOrphaned = false;
                            break;
                        }
                    }
                    if (isOrphaned)
                        deployables.Add(entity);
                }
                return deployables;
            }

            public static string Name(BuildingBlock self) {
                return self.blockDefinition.fullName + "#" + self.GetInstanceID() + "[" + GetPrefabPinPoints(self).Count + "/" + GetPrefabSockets(self).Count + "]";
            }

            #endregion

            #region Definitions

            // Blocks considered a foundation, by name
            private static string[] foundationList = new string[] {
                "build/foundation",
                "build/foundation.steps",
                "build/foundation.triangle"
            };

            // Blocks considered a wall, by name
            private static string[] wallsList = new string[] {
                "build/wall",
                "build/wall.doorway",
                "build/wall.window"
            };

            // A map specifying which blocks are considered a support
            private static Dictionary<string, string[]> supportMap = new Dictionary<string, string[]>() {
                { "build/block.halfheight", new string[] {
                    "build/block.halfheight",
                    "build/floor",
                    "build/floor.triangle",
                    "build/foundation",
                    "build/foundation.triangle"
                }},
                { "build/block.halfheight.slanted", new string[] {
                    "build/block.halfheight",
                    "build/floor",
                    "build/foundation"
                }},
                { "build/floor", new string[] {
                    "build/foundation",
                    "build/foundation.triangle",
                    "build/pillar"
                }},
                { "build/floor.triangle", new string[] {
                    "build/foundation",
                    "build/foundation.triangle",
                    "build/pillar"
                }},
                { "build/pillar", new string[] {
                    "build/foundation",
                    "build/foundation.triangle",
                    "build/pillar"
                }},
                { "build/roof", new string[] {
                    "build/pillar"
                }},
                { "build/wall", new string[] {
                    "build/pillar"
                }},
                { "build/wall.doorway", new string[] {
                    "build/pillar"
                }},
                { "build/door.hinged", new string[] {
                    "build/wall.doorway"
                }},
                { "build/wall.low", new string[] {
                    "build/floor",
                    "build/floor.triangle",
                    "build/foundation",
                    "build/foundation.triangle"
                }},
                { "build/wall.window", new string[] {
                    "build/pillar"
                }},
                { "build/wall.window.bars", new string[] {
                    "build/wall.window"
                }}
            };

            private static string[] supportNames;

            // Layer masks used
            private static LayerMask constructionLayerMask;
            private static LayerMask deployedLayerMask;
            private static LayerMask placementLayerMask;

            // Cached prefab pinpoints
            private static Dictionary<uint, List<StabilityPinPoint>> prefabPinPoints = new Dictionary<uint, List<StabilityPinPoint>>();

            // Gets the prefab pinpoints of a block
            public static List<StabilityPinPoint> GetPrefabPinPoints(BuildingBlock self) {
                List<StabilityPinPoint> pinPoints;
                if (!prefabPinPoints.TryGetValue(self.prefabID, out pinPoints))
                    prefabPinPoints.Add(self.prefabID, pinPoints = PrefabAttribute.server.FindAll<StabilityPinPoint>(self.prefabID).ToList());
                return pinPoints;
            }

            // Cached prefab sockets
            private static Dictionary<uint, List<Socket_Base>> prefabSockets = new Dictionary<uint, List<Socket_Base>>();

            // Gets the prefab sockets of a block
            public static List<Socket_Base> GetPrefabSockets(BuildingBlock self) {
                List<Socket_Base> sockets;
                if (!prefabSockets.TryGetValue(self.prefabID, out sockets))
                    prefabSockets.Add(self.prefabID, sockets = PrefabAttribute.server.FindAll<Socket_Base>(self.prefabID).ToList());
                return sockets;
            }

            // Translates a local prefab coordinate to world coordinates
            private static Vector3 LocalToWorld(BuildingBlock block, Vector3 local) {
                return block.transform.localToWorldMatrix.MultiplyPoint3x4(local);
            }

            // Logs a message to console
            private static void Log(string message) {
                BetterStability.Instance.Log(message);
            }

            #endregion

            #region Initialization

            public static void Initialize() {
                constructionLayerMask = LayerMask.GetMask("Construction", "Construction Trigger");
                deployedLayerMask = LayerMask.GetMask("Deployed");
                placementLayerMask = LayerMask.GetMask("Construction", "Terrain");
                var supports = new List<string>();
                foreach (var pair in supportMap) {
                    foreach (var name in pair.Value) {
                        if (!supports.Contains(name))
                            supports.Add(name);
                    }
                }
                supportNames = supports.ToArray();
            }

            #endregion
        }

        public class Stats
        {
            public int blocksBuilt = 0;
            public int blocksFailedBuilding = 0;
            public int blocksDemolished = 0;
            public int blocksEnqueued = 0;
            public int blocksEnqueuedUnique = 0;
            public int blocksUpdated = 0;
            public int blocksDestroyed = 0;
            public int deployablesDestroyed = 0;

            public override string ToString() {
                var sb = new StringBuilder();
                sb.Append("Blocks built: ").Append(blocksBuilt).Append("\n")
                  .Append("Blocks failed building: ").Append(blocksFailedBuilding).Append("\n")
                  .Append("Blocks demolished: ").Append(blocksDemolished).Append("\n")
                  .Append("Blocks enqueued: ").Append(blocksEnqueued).Append("\n")
                  .Append("Unique blocks enqueued: ").Append(blocksEnqueued).Append("\n")
                  .Append("Blocks updated: ").Append(blocksUpdated).Append("\n")
                  .Append("Blocks destroyed: ").Append(blocksDestroyed).Append("\n")
                  .Append("Deployables destroyed: ").Append(deployablesDestroyed).Append("\n");
                return sb.ToString();
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BetterStart.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Looking For Gamers, Inc. <support@lfgame.rs>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// Rust Unity Namespaces
using Rust;
using UnityEngine;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Oxide.Plugins
{
    [Info("Better Start", "Looking For Gamers <support@lfgame.rs>", "1.1.3", ResourceId = 811)]
    public class BetterStart : RustPlugin
    {
        #region Other Classes
        public class configObj
        {
            public int startingHealth { set; get; }
            public int startingCalories { set; get; }
            public int startingHydration { set; get; }
            public List<itemsContainer> startingItems { set; get; }
            public List<string> startingBlueprints { set; get; }
            public configObj()
            {
                this.startingItems = new List<itemsContainer>();
                this.startingBlueprints = new List<string>();
            }
        }

        public class itemsContainer
        {
            public string name { set; get; }
            public List<itemMeta> items { set; get; }
            public itemsContainer()
            {
                this.items = new List<itemMeta>();
            }
        }

        public class itemMeta
        {
            public string name { set; get; }
            public int amount { set; get; }
            public itemMeta()
            {
                this.amount = 1;
            }
        }
        #endregion

        public configObj config;
        private string configPath;
        private bool loaded = false;

        #region hook methods
        void SetupConfig()
        {
            if (this.loaded)
            {
                return;
            }

            LoadConfig();
            this.configPath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
            this.config = JsonConvert.DeserializeObject<configObj>((string)JsonConvert.SerializeObject(Config["Config"]).ToString());
            this.loaded = true;
        }

        void Loaded()
        {
            //Puts("\n\n---------------------------------------------------------------------------------------------------------------------\n\n");
            this.Print("Better Start by Looking For Gamers, has been started");
            this.SetupConfig();
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            this.SetupConfig();
        }

        [HookMethod("LoadDefaultConfig")]
        void CreateDefaultConfig()
        {
            configObj localConfig = new configObj();

            localConfig.startingHealth = 100;
            localConfig.startingCalories = 400;
            localConfig.startingHydration = 1000;

            localConfig.startingItems = JsonConvert.DeserializeObject<List<itemsContainer>>(
                "[{\"name\": \"wear\", \"items\": [{\"name\": \"burlap_trousers\"}, {\"name\": \"burlap_shoes\"}, {\"name\": \"burlap_shirt\"}, {\"name\": \"burlap_gloves\"}, {\"name\": \"coffeecan_helmet\"}]}" +
                ",{\"name\": \"belt\", \"items\": [{\"name\": \"stonehatchet\"}, {\"name\": \"torch\"}]}" +
                ",{\"name\": \"main\", \"items\": [{\"name\": \"bandage\",\"amount\": 3}]}]"
            );
            localConfig.startingBlueprints = JsonConvert.DeserializeObject<List<string>>(
                "['lantern', 'pickaxe', 'stonehatchet', 'arrow_wooden', 'spear_wooden', 'bow_hunting', 'lantern']"
            );

            this.config = localConfig;
            Config["Config"] = this.config;
            Config.Save(this.configPath);
            this.SetupConfig();
        }

        [HookMethod("OnPlayerSpawn")]
        void OnPlayerSpawn(BasePlayer player, Network.Connection connection)
        {
            player.health = config.startingHealth;
            player.metabolism.calories.value = config.startingCalories;
            player.metabolism.hydration.value = config.startingHydration;

            this.givePlayerStartingItems(player);
            this.teachPlayerBlueprints(player);
        }
        #endregion

        #region private helpers
        private void teachPlayerBlueprints(BasePlayer player)
        {
            PlayerBlueprints blueprints = player.blueprints;
            foreach (string name in config.startingBlueprints)
            {
                Item item = ItemManager.CreateByName(name, 1);
                item.isBlueprint = true;
                blueprints.Learn(item.info);
            }
        }

        private void givePlayerStartingItems(BasePlayer player)
        {
            player.inventory.Strip();
            foreach (itemsContainer element in config.startingItems)
            {
                foreach (itemMeta item in element.items)
                {
                    this.giveItem(player, element.name, item);
                }
            }
        }

        private void giveItem(BasePlayer player, string inventoryName, itemMeta meta)
        {
            var manager = SingletonComponent<ItemManager>.Instance;
            PlayerInventory inventory = player.inventory;
            ItemContainer container;
            if (inventoryName == "wear")
            {
                container = inventory.containerWear;
            }
            else if (inventoryName == "belt")
            {
                container = inventory.containerBelt;
            }
            else if (inventoryName == "main")
            {
                container = inventory.containerMain;
            }
            else
            {
                throw new Exception(inventoryName);
            }

            bool blueprint = false;
            if (meta.name.IndexOf("_bp") != -1)
            {
                blueprint = true;
                meta.name = meta.name.Substring(0, meta.name.Length - 3);
            }

            Item item = ItemManager.CreateByName(meta.name, (int)meta.amount);
            item.isBlueprint = blueprint;
            inventory.GiveItem(item, container);
        }

        private void Print(object msg)
        {
            Puts("{0}: {1}", Title, (string)msg);
        }
        #endregion

        #region console commands
        [ConsoleCommand("betterstart.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            this.SetupConfig();
            this.Print("Better Start Config reloaded.");
        }

        [ConsoleCommand("betterstart.version")]
        void cmdConsoleVersion(ConsoleSystem.Arg arg)
        {
            this.Print(Version.ToString());
        }
        #endregion
    }


}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BlockBlockElevators.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("BlockBlockElevators", "Reneb", "1.0.1")]
    class BlockBlockElevators : RustPlugin
    {

        BuildingBlock cachedBlock;
        TriggerBase cachedTrigger;
        BasePlayer cachedPlayer;
        int playerMask;
        int blockLayer;
        int triggerLayer;

        bool hasStarted = false;

        void OnServerInitialized()
        {
            hasStarted = true;
            playerMask = LayerMask.GetMask(new string[] { "Player (Server)" });
            triggerLayer = UnityEngine.LayerMask.NameToLayer("Trigger");
            blockLayer = UnityEngine.LayerMask.NameToLayer("Construction");
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            cachedBlock = gameObject.GetComponent<BuildingBlock>();
            if (cachedBlock == null) return;
            if (cachedBlock.blockDefinition == null) return;
            if (cachedBlock.blockDefinition.fullName != "build/block.halfheight") return;
            cachedBlock.GetComponentInChildren<MeshCollider>().gameObject.AddComponent<TriggerBase>();
            cachedBlock.GetComponentInChildren<TriggerBase>().gameObject.layer = triggerLayer;
            cachedBlock.GetComponentInChildren<TriggerBase>().interestLayers = playerMask;
            timer.Once(0.1f, () => ResetBlock(cachedBlock) );

        }
        void ResetBlock(BuildingBlock block)
        {
            if (block == null) return;
            block.constructionCollision.UpdateLayer(false);
            GameObject.Destroy(block.GetComponentInChildren<TriggerBase>());
        }
        void OnEntityEnter(TriggerBase triggerbase, BaseEntity entity)
        {
            if (!hasStarted) return;
            cachedBlock = triggerbase.GetComponentInParent<BuildingBlock>();
            if (cachedBlock == null) return;
            if (cachedBlock.blockDefinition.fullName != "build/block.halfheight") return;
            cachedPlayer = entity.GetComponent<BasePlayer>();
            if (cachedPlayer == null) return;
            cachedBlock.Kill(BaseNetworkable.DestroyMode.Gib);
            cachedPlayer.SendConsoleCommand("chat.add", new object[] { "0", string.Format("<color=orange>{0}:</color> {1}", "Warning", "You are not allowed to build blocks over you"), 1.0 });
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BlueprintManager.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("BlueprintManager", "Nogrod", "1.0.4", ResourceId = 833)]
    class BlueprintManager : RustPlugin
    {
        private readonly Dictionary<string, string> _itemShortname = new Dictionary<string, string>();
        private int _authLevel = 2;
        private int _authLevelOther = 2;
        private bool _giveAllOnConnect;
        private bool _configChanged;

        void OnServerInitialized()
        {
            _authLevel = Convert.ToInt32(GetConfig("authLevel", 2));
            _authLevelOther = Convert.ToInt32(GetConfig("authLevelOther", 2));
            _giveAllOnConnect = Convert.ToBoolean(GetConfig("giveAllOnConnect", false));
            if (_configChanged) {
                SaveConfig();
                _configChanged = false;
            }
            InitializeShortname();
        }

        void LoadDefaultConfig()
        {
            GetConfig("authLevel", 2);
            GetConfig("authLevelOther", 2);
            GetConfig("giveAllOnConnect", false);
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (_giveAllOnConnect)
            {
                var definitions = ItemManager.GetItemDefinitions();
                foreach (var definition in definitions)
                {
                    player.blueprints.Learn(definition);
                }
                SendReply(player, "You learned all blueprints");
            }
        }

        private void InitializeShortname()
        {
            _itemShortname.Clear();
            var definitions = ItemManager.GetItemDefinitions();
            foreach (var definition in definitions)
            {
                _itemShortname.Add(definition.displayName.english.ToLower(), definition.shortname);
            }
        }

        bool CheckAccess(BasePlayer player, int authLevel)
        {
            if (player.net.connection.authLevel >= authLevel)
            {
                return true;
            }
            SendReply(player, "You are not allowed to use this command");
            return false;
        }

        private object GetConfig(string key, object defaultValue)
        {
            if (Config[key] != null) return Config[key];
            Config[key] = defaultValue;
            _configChanged = true;
            return Config[key];
        }

        [ChatCommand("bpadd")]
        void cmdChatBpAdd(BasePlayer player, string command, string[] args)
        {
            if (!CheckAccess(player, _authLevel)) return;
            if ((args == null) || (args.Length == 0))
            {
                SendReply(player, "/bpadd \"Item\" [\"PlayerName\"]");
                return;
            }
            LocalPuts(string.Format("{0} used /bpadd {1}", player.displayName, string.Join(" ", args)));
            var name = args[0];
            name = name.ToLower();
            if (_itemShortname.ContainsKey(name))
                name = _itemShortname[name];
            var definition = ItemManager.FindItemDefinition(name);
            if (definition == null)
            {
                SendReply(player, string.Format("Item does not exist: {0}", name));
                return;
            }
            var targetPlayer = player;
            if (args.Length > 1)
            {
                if (!CheckAccess(player, _authLevelOther)) return;
                targetPlayer = BasePlayer.Find(args[1]);
                if (targetPlayer == null)
                {
                    SendReply(player, string.Format("Player not found: {0}", args[1]));
                    return;
                }
            }
            targetPlayer.blueprints.Learn(definition);
            SendReply(targetPlayer, string.Format("You learned {0}", definition.displayName.translated));
            if (targetPlayer != player)
            {
                SendReply(player, string.Format("{0} learned {1}", targetPlayer.displayName, definition.displayName.translated));
            }
        }

        [ChatCommand("bpall")]
        void cmdChatBpAll(BasePlayer player, string command, string[] args)
        {
            if (!CheckAccess(player, _authLevel)) return;
            LocalPuts(string.Format("{0} used /bpall {1}", player.displayName, string.Join(" ", args)));
            var targetPlayer = player;
            if (args != null && args.Length > 0)
            {
                if (!CheckAccess(player, _authLevelOther)) return;
                targetPlayer = BasePlayer.Find(args[0]);
                if (targetPlayer == null)
                {
                    SendReply(player, string.Format("Player not found: {0}", args[0]));
                    return;
                }
            }
            var definitions = ItemManager.GetItemDefinitions();
            foreach (var definition in definitions)
            {
                targetPlayer.blueprints.Learn(definition);
            }
            SendReply(targetPlayer, "You learned all blueprints");
            if (targetPlayer != player)
            {
                SendReply(player, string.Format("{0} learned all blueprints", targetPlayer.displayName));
            }
        }

        [ChatCommand("bpreset")]
        void cmdChatBpReset(BasePlayer player, string command, string[] args)
        {
            if (!CheckAccess(player, _authLevel)) return;
            LocalPuts(string.Format("{0} used /bpreset {1}", player.displayName, string.Join(" ", args)));
            var targetPlayer = player;
            if (args != null && args.Length > 0)
            {
                if (!CheckAccess(player, _authLevelOther)) return;
                targetPlayer = BasePlayer.Find(args[0]);
                if (targetPlayer == null)
                {
                    SendReply(player, string.Format("Player not found: {0}", args[0]));
                    return;
                }
            }
            var data = Persistence.GetPlayerInfo(targetPlayer.userID);
            data.blueprints = null;
            PlayerBlueprints.InitializePersistance(data);
            targetPlayer.SendFullSnapshot();
            SendReply(targetPlayer, "You forgot all blueprints");
            if (targetPlayer != player)
            {
                SendReply(player, string.Format("{0} forgot all blueprints", targetPlayer.displayName));
            }
        }

        [ChatCommand("bpaddall")]
        void cmdChatBpAddAll(BasePlayer player, string command, string[] args)
        {
            if (!CheckAccess(player, _authLevelOther)) return;
            LocalPuts(string.Format("{0} used /bpaddall {1}", player.displayName, string.Join(" ", args)));
            List<ItemDefinition> definitions;
            if (args != null && args.Length > 0)
            {
                definitions = new List<ItemDefinition>();
                foreach (var arg in args)
                {
                    foreach (var def in arg.Split(','))
                    {
                        var name = def.ToLower();
                        if (_itemShortname.ContainsKey(name))
                            name = _itemShortname[name];
                        var itemDef = ItemManager.FindItemDefinition(name);
                        if (itemDef == null)
                        {
                            SendReply(player, string.Format("Item not found: {0}", def));
                            return;
                        }
                        definitions.Add(itemDef);
                    }
                }
            }
            else
            {
                definitions = ItemManager.GetItemDefinitions();
            }
            var players = BasePlayer.activePlayerList;
            foreach (var basePlayer in players)
            {
                foreach (var definition in definitions)
                {
                    basePlayer.blueprints.Learn(definition);
                }
                SendReply(basePlayer, "You learned all blueprints");
                if (basePlayer != player)
                {
                    SendReply(player, string.Format("{0} learned all blueprints", basePlayer.displayName));
                }
            }
        }

        [ChatCommand("bpremoveall")]
        void cmdChatBpRemoveAll(BasePlayer player, string command, string[] args)
        {
            if (!CheckAccess(player, _authLevelOther)) return;
            LocalPuts(string.Format("{0} used /bpremoveall {1}", player.displayName, string.Join(" ", args)));
            List<int> definitions;
            if (args != null && args.Length > 0)
            {
                definitions = new List<int>();
                foreach (var arg in args)
                {
                    foreach (var def in arg.Split(','))
                    {
                        var name = def.ToLower();
                        if (_itemShortname.ContainsKey(name))
                            name = _itemShortname[name];
                        var itemDef = ItemManager.FindItemDefinition(name);
                        if (itemDef == null)
                        {
                            SendReply(player, string.Format("Item not found: {0}", def));
                            return;
                        }
                        definitions.Add(itemDef.itemid);
                    }
                }
            }
            else
            {
                definitions = ItemManager.GetItemDefinitions().ConvertAll(i => i.itemid);
            }
            var defaultBlueprints = new List<int>(SingletonComponent<ItemManager>.Instance.defaultBlueprints);
            definitions.RemoveAll(d => defaultBlueprints.Contains(d));
            var players = BasePlayer.activePlayerList;
            foreach (var basePlayer in players)
            {
                var data = Persistence.GetPlayerInfo(basePlayer.userID);
                if (data.blueprints.complete.RemoveAll(a => definitions.Contains(a)) > 0)
                    basePlayer.SendFullSnapshot();
            }
            SendReply(player, "Removed learned blueprints");
        }

        private void LocalPuts(string msg)
        {
            Puts("{0}: {1}", Title, msg);
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Build.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Build", "Reneb", "1.0.9")]
    class Build : RustPlugin
    { 
        class BuildPlayer : MonoBehaviour
        {
            
            public BasePlayer player;
            public InputState input;
            public string currentPrefab;
            public string currentType;
            public float currentHealth;
            public Quaternion currentRotate;
            public BuildingGrade.Enum currentGrade;
            public bool ispressed;
            public float lastTickPress;
            public float currentHeightAdjustment;
            public string selection;
            void Awake()
            {
                input = serverinput.GetValue(GetComponent<BasePlayer>()) as InputState;
                player = GetComponent<BasePlayer>();
                enabled = true;
                ispressed = false;

            }
            void Update()
            {
                if (input.WasJustPressed(BUTTON.FIRE_SECONDARY) && !ispressed)
                {
                    
                    lastTickPress = Time.realtimeSinceStartup;
                    ispressed = true;
                    DoAction(this);
                }
                else if (input.IsDown(BUTTON.FIRE_SECONDARY))
                {
                    if((Time.realtimeSinceStartup - lastTickPress) > 1)
                    {
                        DoAction(this);
                    }
                }
                else
                {
                    ispressed = false;
                }
            }
        }
        enum SocketType
        {
            Wall,
            Floor,
            Block,
            FloorTriangle,
            Support
        }


        private MethodInfo CreateEntity;
        private MethodInfo FindPrefab;
        private static FieldInfo serverinput;
        private static Dictionary<string, string> deployedToItem;
        private Dictionary<string, string> nameToBlockPrefab;
        private static Dictionary<string, SocketType> nameToSockets;
        private static Dictionary<SocketType, object> TypeToType;
        private static List<string> resourcesList;
        private static Dictionary<string, string> animalList;
        /// CACHED VARIABLES
        /// 

        private static Quaternion currentRot;
        private static Vector3 closestHitpoint;
        private static object closestEnt;
        private static Quaternion newRot;
        private string buildType;
        private string prefabName;
        private static int defaultGrade;
        private static float defaultHealth;
        private static Vector3 newPos;
        private static float distance;
        private static Dictionary<SocketType, object> sourceSockets;
        private static SocketType targetsocket;
        private static SocketType sourcesocket;
        private static Dictionary<Vector3, Quaternion>  newsockets;
        private static Vector3 VectorUP;
        private static float heightAdjustment;
        private static BasePlayer currentplayer;
        private static Collider currentCollider;
        private static BaseNetworkable currentBaseNet;
        private static List<object> houseList;
        private static List<Vector3> checkFrom;
        private static BuildingBlock fbuildingblock;
        private static BuildingBlock buildingblock;
        private static Item newItem;

        private static Quaternion defaultQuaternion = new Quaternion(0f, 0f, 0f, 1f);
        /////////////////////////////////////////////////////
        ///  OXIDE HOOKS
        /////////////////////////////////////////////////////

        /////////////////////////////////////////////////////
        ///  Loaded()
        ///  When the plugin is loaded by Oxide
        /////////////////////////////////////////////////////

        void Loaded()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            deployedToItem = new Dictionary<string, string>();
            
            nameToBlockPrefab = new Dictionary<string, string>();
            VectorUP = new Vector3(0f, 1f, 0f);
        }

        /////////////////////////////////////////////////////
        ///  Unload()
        ///  When the plugin is unloaded by Oxide
        /////////////////////////////////////////////////////
        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(BuildPlayer));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        /////////////////////////////////////////////////////
        ///  Loaded()
        ///  When the server has been initialized and all plugins loaded
        /////////////////////////////////////////////////////
        void OnServerInitialized()
        {
            InitializeBlocks();
            InitializeSockets();
            InitializeDeployables();
            InitializeResources();
            InitializeAnimals();
        }

        /////////////////////////////////////////////////////
        /// Get all animals in an easy list to convert from shortname to full prefabname
        /////////////////////////////////////////////////////
        void InitializeAnimals()
        {
            animalList = new Dictionary<string, string>();
            string[] resourcefiles = GameManifest.Get().resourceFiles;
            foreach (string resourcefile in resourcefiles)
            {
                if (resourcefile.Contains("autospawn/animals"))
                {
                    animalList.Add(resourcefile.Substring(26),resourcefile.Substring(8));
                }
            }
        }

        /////////////////////////////////////////////////////
        /// Get all resources in an easy list to convert from ID to full prefabname
        /////////////////////////////////////////////////////
        void InitializeResources()
        {
            resourcesList = new List<string>();
            string[] resourcefiles = GameManifest.Get().resourceFiles;
            foreach (string resourcefile in resourcefiles)
            {
                if (resourcefile.Contains("autospawn/resource"))
                {
                    resourcesList.Add(resourcefile.Substring(8));
                }
            }
        }

        /////////////////////////////////////////////////////
        /// Get all deployables in an easy list to convert from shortname to fullname
        /////////////////////////////////////////////////////
        void InitializeDeployables()
        {
            var allItemsDef = UnityEngine.Resources.FindObjectsOfTypeAll<ItemDefinition>();
            foreach (ItemDefinition itemDef in allItemsDef)
            {
                if (itemDef.GetComponent<ItemModDeployable>() != null)
                {
                    deployedToItem.Add(itemDef.displayName.english.ToString().ToLower(), itemDef.shortname.ToString());
                }
            }

        }

        /////////////////////////////////////////////////////
        /// Create New sockets that wont match Rusts, this is exaustive
        /// But at least we can add new sockets later on
        /////////////////////////////////////////////////////
        void InitializeSockets()
        {
            // PrefabName to SocketType 
            nameToSockets = new Dictionary<string, SocketType>();

            // Get all possible sockets from the SocketType
            TypeToType = new Dictionary<SocketType, object>();

            // Sockets that can connect on a Floor / Foundation type
            var FloorType = new Dictionary<SocketType, object>();

            // Floor to Floor sockets
            var FloortoFloor = new Dictionary<Vector3, Quaternion>();
            FloortoFloor.Add(new Vector3(0f, 0f, -3f), new Quaternion(0f, 1f, 0f, 0f));

            //FloortoFloor.Add(new Vector3(-3f, 0f, 0f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            FloortoFloor.Add(new Vector3(-3f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));
            FloortoFloor.Add(new Vector3(0f, 0f, 3f), new Quaternion(0f, 0f, 0f, 1f));
            //FloortoFloor.Add(new Vector3(3f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            FloortoFloor.Add(new Vector3(3f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            // Floor to FloorTriangle sockets
            var FloortoFT = new Dictionary<Vector3, Quaternion>();
            FloortoFT.Add(new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 1f, 0f, 0f));
            FloortoFT.Add(new Vector3(-1.5f, 0f, 0f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            FloortoFT.Add(new Vector3(0f, 0f, 1.5f), new Quaternion(0f, 0f, 0f, 1f));
            FloortoFT.Add(new Vector3(1.5f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            // Floor to Wall sockets
            var FloortoWall = new Dictionary<Vector3, Quaternion>();
            FloortoWall.Add(new Vector3(0f, 0f, 1.5f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            FloortoWall.Add(new Vector3(-1.5f, 0f, 0f), new Quaternion(0f,1f, 0f, 0f));
            FloortoWall.Add(new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            FloortoWall.Add(new Vector3(1.5f, 0f, 0f), new Quaternion(0f, 0f, 0f,1f));

            // Floor to Support (Pillar) sockets
            var FloortoSupport = new Dictionary<Vector3, Quaternion>();
            FloortoSupport.Add(new Vector3(1.5f, 0f, 1.5f), new Quaternion(0f, 0f,0f, 1f));
            FloortoSupport.Add(new Vector3(-1.5f, 0f, 1.5f), new Quaternion(0f, 0f, 0f, 1f));
            FloortoSupport.Add(new Vector3(1.5f, 0f, -1.5f), new Quaternion(0f, 0.0f, 0f, 1f));
            FloortoSupport.Add(new Vector3(-1.5f, 0f, -1.5f), new Quaternion(0f, 0f, 0f, 1f));

            // Floor to Blocks sockets
            var FloorToBlock = new Dictionary<Vector3, Quaternion>();
            FloorToBlock.Add(new Vector3(0f, 0.1f, 0f), new Quaternion(0f, 1f, 0f, 0f));

            // Adding all informations from the Floor type into the main table
            FloorType.Add(SocketType.Block, FloorToBlock);
            FloorType.Add(SocketType.Support, FloortoSupport);
            FloorType.Add(SocketType.Wall, FloortoWall);
            FloorType.Add(SocketType.Floor, FloortoFloor);
            FloorType.Add(SocketType.FloorTriangle, FloortoFT);
            TypeToType.Add(SocketType.Floor, FloorType);

            // Sockets that can connect on a Wall type
            var WallType = new Dictionary<SocketType, object>();

            // Wall to Wall sockets
            var WallToWall = new Dictionary<Vector3, Quaternion>();
            WallToWall.Add(new Vector3(0f, 0f, -3f), new Quaternion(0f, 1f, 0f, 0f));
            WallToWall.Add(new Vector3(0f, 0f, 3f), new Quaternion(0f, 0f, 0f, 1f));

            // Wall to Wall Floor sockets
            var WallToFloor = new Dictionary<Vector3, Quaternion>();
            WallToFloor.Add(new Vector3(1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, -0.7071068f));
            WallToFloor.Add(new Vector3(-1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
             
            // Adding all informations from the Wall type into the main table
            // Note that you can't add blocks or supports on a wall
            WallType.Add(SocketType.Floor, WallToFloor);
            WallType.Add(SocketType.Wall, WallToWall);
            TypeToType.Add(SocketType.Wall, WallType);

            // Sockets that can connect on a Block type
            var BlockType = new Dictionary<SocketType, object>();

            // Block to Block sockets
            var BlockToBlock = new Dictionary<Vector3, Quaternion>();
            BlockToBlock.Add(new Vector3(0f, 1.5f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            // For safety reasons i didn't put pillars or walls here
            // If needed it could easily be added
            BlockType.Add(SocketType.Block, BlockToBlock);
            TypeToType.Add(SocketType.Block, BlockType);

            // Sockets that can connect on a Floor/Foundation Triangles  type
            var FloorTriangleType = new Dictionary<SocketType, object>();

            // Floor Triangles to Floor Triangles type
            var FTtoFT = new Dictionary<Vector3, Quaternion>();
            FTtoFT.Add(new Vector3(0f, 0f, 0f), new Quaternion(0f,1f, 0f, 0.0000001629207f));
            FTtoFT.Add(new Vector3(-0.75f, 0f, 1.299038f), new Quaternion(0f, 0.4999998f, 0f, -0.8660255f));
            FTtoFT.Add(new Vector3(0.75f, 0f, 1.299038f), new Quaternion(0f, 0.5000001f, 0f, 0.8660254f));
            FloorTriangleType.Add(SocketType.FloorTriangle, FTtoFT);

            // Floor Triangles to Wall type
            var FTtoWall = new Dictionary<Vector3, Quaternion>();
            FTtoWall.Add(new Vector3(0f, 0f, 0f), new Quaternion(0f, 0.7f, 0f, 0.7000001629207f)); 
            FTtoWall.Add(new Vector3(-0.75f, 0f, 1.299038f), new Quaternion(0f, 0.96593f, 0f, -0.25882f));
            FTtoWall.Add(new Vector3(0.75f, 0f, 1.299038f), new Quaternion(0f, -0.25882f, 0f, 0.96593f));
            FloorTriangleType.Add(SocketType.Wall, FTtoWall);

            // Floor Triangles to Floor type is a big fail, need to work on that still
           /* var FTtoFloor = new Dictionary<Vector3, Quaternion>();
            FTtoFloor.Add(new Vector3(0f, 0f, 0f), new Quaternion(0f, 0.7f, 0f, 0.7000001629207f)); 
            FTtoFloor.Add(new Vector3(-0.75f, 0f, 1.299038f), new Quaternion(0f, 0.96593f, 0f, -0.25882f));
            FTtoFloor.Add(new Vector3(0.75f, 0f, 1.299038f), new Quaternion(0f, -0.25882f, 0f, 0.96593f));
            FloorTriangleType.Add(SocketType.Floor, FTtoFloor);
            */

            // So at the moment only Floor and Foundation triangles can connect to easy other.
            TypeToType.Add(SocketType.FloorTriangle, FloorTriangleType);

            nameToSockets.Add("build/foundation", SocketType.Floor);
            nameToSockets.Add("build/foundation.triangle", SocketType.FloorTriangle);
            nameToSockets.Add("build/floor.triangle", SocketType.FloorTriangle);
            nameToSockets.Add("build/roof", SocketType.Floor);
            nameToSockets.Add("build/floor", SocketType.Floor);
            nameToSockets.Add("build/wall", SocketType.Wall);
            nameToSockets.Add("build/wall.doorway", SocketType.Wall);
            nameToSockets.Add("build/wall.window", SocketType.Wall);
            nameToSockets.Add("build/wall.low", SocketType.Wall);
            nameToSockets.Add("build/pillar", SocketType.Support);
            nameToSockets.Add("build/block.halfheight", SocketType.Block);
            nameToSockets.Add("build/block.halfheight.slanted", SocketType.Block);

            // Foundation steps are fucked up, i need to look how this works more
            //nameToSockets.Add("build/foundation.steps", SocketType.Floor);
            
        }
        /////////////////////////////////////////////////////
        /// Get all blocknames from shortname to full prefabname
        /////////////////////////////////////////////////////
        void InitializeBlocks()
        {
            foreach (Construction construction in PrefabAttribute.server.GetAll<Construction>())
            {
                    /*if (construction.name == "foundation.triangle")
                    {
                        Construction.Socket[] socketArray = item.sockets;

                        foreach (Construction.Socket socket in socketArray) 
                        {
                            //Puts(string.Format("{0} {1} {2} {3}", socket.name, socket.type.ToString(), socket.position.ToString(), socket.rotation.w.ToString()));
                            Puts(string.Format("{0} {1} {2} {3} {4}", socket.name, socket.type.ToString(), socket.position.x.ToString(), socket.position.y.ToString(), socket.position.z.ToString()));
                        }
                        Puts("================");
                    }*/
                nameToBlockPrefab.Add(construction.hierachyName, construction.fullName);
            } 
        }

        /////////////////////////////////////////////////////
        ///  GENERAL FUNCTIONS
        /////////////////////////////////////////////////////
        /////////////////////////////////////////////////////
        ///  hasAccess( BasePlayer player )
        ///  Checks if the player has access to this command
        /////////////////////////////////////////////////////
        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return false;
            }
            return true;
        }

        /////////////////////////////////////////////////////
        ///  TryGetPlayerView( BasePlayer player, out Quaternion viewAngle )
        ///  Get the angle on which the player is looking at
        ///  Notice that this is very usefull for spectating modes as the default player.transform.rotation doesn't work in this case.
        /////////////////////////////////////////////////////
        static bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null)
                return false;
            if (input.current == null)
                return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        /////////////////////////////////////////////////////
        ///  TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        ///  Get the closest entity that the player is looking at
        /////////////////////////////////////////////////////
        static bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            UnityEngine.Ray ray = new UnityEngine.Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = UnityEngine.Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                {
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.collider;
                        closestHitpoint = hit.point;
                    }
                }
            }
            if (closestEnt is bool)
                return false;
            return true;
        }

        /////////////////////////////////////////////////////
        ///  SpawnDeployable()
        ///  Function to spawn a deployable
        /////////////////////////////////////////////////////
        private static void SpawnDeployable(string prefab, Vector3 pos, Quaternion angles, BasePlayer player)
        {
            newItem = ItemManager.CreateByName(prefab, 1);
            if (newItem == null)
            {
                return;
            }
            if (newItem.info.GetComponent<ItemModDeployable>() == null)
            {
                return;
            }
            var deployable = newItem.info.GetComponent<ItemModDeployable>().entityPrefab.targetObject.GetComponent<Deployable>();
            if (deployable == null)
            {
                return;
            }
            var newBaseEntity = GameManager.server.CreateEntity(deployable.gameObject, pos, angles);
            if (newBaseEntity == null)
            {
                return;
            }
            newBaseEntity.SendMessage("SetDeployedBy", player, UnityEngine.SendMessageOptions.DontRequireReceiver);
            newBaseEntity.SendMessage("InitializeItem", newItem, UnityEngine.SendMessageOptions.DontRequireReceiver);
            newBaseEntity.Spawn(true);
        }

        /////////////////////////////////////////////////////
        ///  SpawnStructure()
        ///  Function to spawn a block structure
        /////////////////////////////////////////////////////
        private static void SpawnStructure(string prefabname, Vector3 pos, Quaternion angles, BuildingGrade.Enum grade, float health)
        {
            UnityEngine.GameObject prefab = GameManager.server.FindPrefab(prefabname);
            if (prefab == null)
            {
                return;
            }
            UnityEngine.GameObject build = UnityEngine.Object.Instantiate(prefab);
            if (build == null) return;
            BuildingBlock block = build.GetComponent<BuildingBlock>();
            if (block == null) return;
            block.transform.position = pos;
            block.transform.rotation = angles;
            block.gameObject.SetActive(true);
            block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);
            block.Spawn(true);
            block.SetGrade(grade);
            if(health <= 0f)
                block.health = block.MaxHealth();
            else
                block.health = health;
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            
        }

        /////////////////////////////////////////////////////
        ///  SpawnDeployable()
        ///  Function to spawn a resource (tree, barrel, ores)
        /////////////////////////////////////////////////////
        private static void SpawnResource(string prefab, Vector3 pos, Quaternion angles) 
        {
            UnityEngine.GameObject newPrefab = GameManager.server.FindPrefab(prefab);
            if (newPrefab == null)
            {
                return;
            }
            BaseEntity entity = GameManager.server.CreateEntity(newPrefab, pos, angles);
            if (entity == null) return;
            entity.Spawn(true);
        }

        /////////////////////////////////////////////////////
        ///  isColliding()
        ///  Check if you already placed the structure
        /////////////////////////////////////////////////////
        private static bool isColliding(string name, Vector3 position, float radius)
        {
            UnityEngine.Collider[] colliders = UnityEngine.Physics.OverlapSphere(position, radius);
            foreach (UnityEngine.Collider collider in colliders)
            {
                if (collider.GetComponentInParent<BuildingBlock>())
                {
                    if (collider.GetComponentInParent<BuildingBlock>().blockDefinition.fullName == name)
                            if (Vector3.Distance(collider.transform.position, position) < 0.6f)
                                return true;
                }
            }
            return false;
        }
        /////////////////////////////////////////////////////
        ///  SetGrade(BuildingBlock block, BuildingGrade.Enum level)
        ///  Change grade level of a block
        /////////////////////////////////////////////////////
        private static void SetGrade(BuildingBlock block, BuildingGrade.Enum level)
        {
            block.SetGrade(level);
            block.health = block.MaxHealth();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        /////////////////////////////////////////////////////
        ///  SetHealth(BuildingBlock block)
        ///  Set max health for a block
        /////////////////////////////////////////////////////
        private static void SetHealth(BuildingBlock block)
        {
            block.health = block.MaxHealth();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        /////////////////////////////////////////////////////
        ///  DoAction(BuildPlayer buildplayer)
        ///  Called from the BuildPlayer, will handle all different building types
        /////////////////////////////////////////////////////
        private static void DoAction(BuildPlayer buildplayer)
        {
            currentplayer = buildplayer.player;
            if (!TryGetPlayerView(currentplayer, out currentRot))
            {
                return;
            }
            if (!TryGetClosestRayPoint(currentplayer.transform.position, currentRot, out closestEnt, out closestHitpoint))
            {
                return;
            }
            currentCollider = closestEnt as Collider;
            if (currentCollider == null)
            {
                return;
            }
            switch (buildplayer.currentType)
            {
                case "building":
                    DoBuild(buildplayer, currentplayer, currentCollider);
                break;
                case "buildup":
                DoBuildUp(buildplayer, currentplayer, currentCollider);
                break;
                case "deploy":
                DoDeploy(buildplayer, currentplayer, currentCollider);
                break;
                case "plant":
                case "animal":
                DoPlant(buildplayer, currentplayer, currentCollider);
                break;
                case "grade":
                DoGrade(buildplayer, currentplayer, currentCollider);
                break;
                case "heal":
                DoHeal(buildplayer, currentplayer, currentCollider);
                break;
                case "erase":
                DoErase(buildplayer, currentplayer, currentCollider);
                break;
                case "rotate":
                    DoRotation(buildplayer, currentplayer, currentCollider);
                break;
                case "spawning":
                DoSpawn(buildplayer, currentplayer, currentCollider);
                break;
                default:
                return;
            }
        }
        /////////////////////////////////////////////////////
        ///  DoErase(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Erase function
        /////////////////////////////////////////////////////
        private static void DoErase(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            currentBaseNet = baseentity.GetComponentInParent<BaseNetworkable>();
            if (currentBaseNet == null)
                return;
            currentBaseNet.Kill(BaseNetworkable.DestroyMode.Gib);
        }
        /////////////////////////////////////////////////////
        ///  DoPlant(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Spawn Trees, Barrels, Animals, Resources
        /////////////////////////////////////////////////////
        private static void DoPlant(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            newPos = closestHitpoint + (VectorUP * buildplayer.currentHeightAdjustment);
            newRot = currentRot;
            newRot.x = 0f;
            newRot.z = 0f;
            SpawnResource(buildplayer.currentPrefab, newPos, newRot);
        }
        /////////////////////////////////////////////////////
        ///  DoDeploy(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Deploy Deployables
        /////////////////////////////////////////////////////
        private static void DoDeploy(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            newPos = closestHitpoint + (VectorUP * buildplayer.currentHeightAdjustment);
            newRot = currentRot;
            newRot.x = 0f;
            newRot.z = 0f;
            SpawnDeployable(buildplayer.currentPrefab, newPos, newRot, currentplayer);
        }

        /////////////////////////////////////////////////////
        ///  DoGrade(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Set building grade
        /////////////////////////////////////////////////////
        private static void DoGrade(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            fbuildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (fbuildingblock == null)
            {
                return;
            }
            SetGrade(fbuildingblock, buildplayer.currentGrade);
            if (buildplayer.selection == "select")
            {
                return;
            }

            houseList = new List<object>();
            checkFrom = new List<Vector3>();
            houseList.Add(fbuildingblock);
            checkFrom.Add(fbuildingblock.transform.position);

            int current = 0;
            while (true)
            {
                current++;
                if (current > checkFrom.Count)
                    break;
                var hits = UnityEngine.Physics.OverlapSphere(checkFrom[current - 1], 3.1f);
                foreach (var hit in hits)
                {
                    if (hit.GetComponentInParent<BuildingBlock>() != null)
                    {
                        fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                        if (!(houseList.Contains(fbuildingblock)))
                        {
                            houseList.Add(fbuildingblock);
                            checkFrom.Add(fbuildingblock.transform.position);
                            SetGrade(fbuildingblock, buildplayer.currentGrade);
                        }
                    }
                }
            }
        }
        static void DoRotation(BuildingBlock block, Quaternion defaultRotation)
        {
            if (block.blockDefinition == null) return;
            UnityEngine.Transform transform = block.transform;
            if (defaultRotation == defaultQuaternion)
                transform.localRotation *= Quaternion.Euler(block.blockDefinition.rotationAmount);
            else
                transform.localRotation *= defaultRotation;
            block.ClientRPC(null, "UpdateConditionalModels", new object[0]);
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }
        private static void DoRotation(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            var buildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (buildingblock == null)
            {
                return;
            }
            DoRotation(buildingblock, buildplayer.currentRotate);
            if (buildplayer.selection == "select")
            {
                return;
            }

            houseList = new List<object>();
            checkFrom = new List<Vector3>();
            houseList.Add(buildingblock);
            checkFrom.Add(buildingblock.transform.position);

            int current = 0;
            while (true)
            {
                current++;
                if (current > checkFrom.Count)
                    break;
                var hits = UnityEngine.Physics.OverlapSphere(checkFrom[current - 1], 3.1f);
                foreach (var hit in hits)
                {
                    if (hit.GetComponentInParent<BuildingBlock>() != null)
                    {
                        fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                        if (!(houseList.Contains(fbuildingblock)))
                        {
                            houseList.Add(fbuildingblock);
                            checkFrom.Add(fbuildingblock.transform.position);
                            DoRotation(fbuildingblock, buildplayer.currentRotate);
                        }
                    }
                }
            }
        }

        /////////////////////////////////////////////////////
        ///  DoHeal(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Set max health to building
        /////////////////////////////////////////////////////
        private static void DoHeal(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            var buildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (buildingblock == null)
            {
                return;
            }
            SetHealth(buildingblock);
            if (buildplayer.selection == "select")
            {
                return;
            }

            houseList = new List<object>();
            checkFrom = new List<Vector3>();
            houseList.Add(buildingblock);
            checkFrom.Add(buildingblock.transform.position);

            int current = 0;
            while (true)
            {
                current++;
                if (current > checkFrom.Count)
                    break;
                var hits = UnityEngine.Physics.OverlapSphere(checkFrom[current - 1], 3.1f);
                foreach (var hit in hits)
                {
                    if (hit.GetComponentInParent<BuildingBlock>() != null)
                    {
                        fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                        if (!(houseList.Contains(fbuildingblock)))
                        {
                            houseList.Add(fbuildingblock);
                            checkFrom.Add(fbuildingblock.transform.position);
                            SetHealth(fbuildingblock);
                        }
                    }
                }
            }
        }

        /////////////////////////////////////////////////////
        ///  DoSpawn(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Raw spawning building elements, no AI here
        /////////////////////////////////////////////////////
        private static void DoSpawn(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            newPos = closestHitpoint + (VectorUP * buildplayer.currentHeightAdjustment);
            newRot = currentRot;
            newRot.x = 0f;
            newRot.z = 0f;
            SpawnStructure(buildplayer.currentPrefab, newPos, newRot, buildplayer.currentGrade, buildplayer.currentHealth);
        }

        /////////////////////////////////////////////////////
        ///  DoBuildUp(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Raw buildup, you can build anything on top of each other, exept the position, there is no AI
        /////////////////////////////////////////////////////
        private static void DoBuildUp(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            fbuildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (fbuildingblock == null)
            {
                return;
            }
            newPos = fbuildingblock.transform.position + (VectorUP * buildplayer.currentHeightAdjustment);
            newRot = fbuildingblock.transform.rotation;
            if (isColliding(buildplayer.currentPrefab, newPos, 1f))
            {
                return;
            }
            SpawnStructure(buildplayer.currentPrefab, newPos, newRot, buildplayer.currentGrade, buildplayer.currentHealth);
        }

        /////////////////////////////////////////////////////
        ///  DoBuild(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Fully AIed Build :) see the InitializeSockets for more informations
        /////////////////////////////////////////////////////
        private static void DoBuild(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        {
            fbuildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (fbuildingblock == null)
            {
                return;
            }
            distance = 999999f;
            Vector3 newPos = new Vector3(0f, 0f, 0f);
            newRot = new Quaternion(0f, 0f, 0f, 0f);
            ///  Checks if this building has a socket hooked to it self
            ///  If not ... well it won't be able to be built via AI
            if (nameToSockets.ContainsKey(fbuildingblock.blockDefinition.fullName))
            {
                sourcesocket = (SocketType)nameToSockets[fbuildingblock.blockDefinition.fullName];
                // Gets all Sockets that can be connected to the source building
                if (TypeToType.ContainsKey(sourcesocket))
                {
                    sourceSockets = TypeToType[sourcesocket] as Dictionary<SocketType, object>;
                    targetsocket = (SocketType)nameToSockets[buildplayer.currentPrefab];
                    // Checks if the newly built structure can be connected to the source building
                    if (sourceSockets.ContainsKey(targetsocket))
                    {
                        newsockets = sourceSockets[targetsocket] as Dictionary<Vector3, Quaternion>;
                        // Get all the sockets that can be hooked to the source building via the new structure element
                        foreach (KeyValuePair<Vector3, Quaternion> pair in newsockets)
                        {
                            var currentrelativepos = (fbuildingblock.transform.rotation * pair.Key) + fbuildingblock.transform.position;
                            if (Vector3.Distance(currentrelativepos, closestHitpoint) < distance)
                            {
                                // Get the socket that is the closest to where the player is aiming at
                                distance = Vector3.Distance(currentrelativepos, closestHitpoint);
                                newPos = currentrelativepos + (VectorUP * buildplayer.currentHeightAdjustment);
                                newRot = (fbuildingblock.transform.rotation * pair.Value);
                            }
                        }
                    }
                }
            }
            if (newPos.x == 0f)
                return;
            // Checks if the element has already been built to prevent multiple structure elements on one spot
            if (isColliding(buildplayer.currentPrefab,newPos, 1f))
                return;

            SpawnStructure(buildplayer.currentPrefab, newPos, newRot, buildplayer.currentGrade, buildplayer.currentHealth);
        }

        /////////////////////////////////////////////////////
        ///  TryGetBuildingPlans(string arg, out string buildType, out string prefabName)
        ///  Checks if the argument of every commands are valid or not
        /////////////////////////////////////////////////////
        bool TryGetBuildingPlans(string arg, out string buildType, out string prefabName)
        {
            prefabName = "";
            buildType = "";
            int intbuilding = 0;
            if (nameToBlockPrefab.ContainsKey(arg))
            {
                prefabName = nameToBlockPrefab[arg];
                buildType = "building";
                return true;
            }
            else if (deployedToItem.ContainsKey(arg.ToLower()))
            {
                prefabName = deployedToItem[arg.ToLower()];
                buildType = "deploy";
                return true;
            }
            else if (deployedToItem.ContainsValue(arg.ToLower()))
            {
                prefabName = arg.ToLower();
                buildType = "deploy";
                return true;
            }
            else if (animalList.ContainsKey(arg.ToLower()))
            {
                prefabName = animalList[arg.ToLower()];
                buildType = "animal";
                return true;
            }
            else if (int.TryParse(arg, out intbuilding))
            {
                if (intbuilding <= resourcesList.Count )
                {
                    prefabName = resourcesList[intbuilding];
                    buildType = "plant";
                    return true;
                }
            }
            return false;
        }

        /////////////////////////////////////////////////////
        ///  GetGrade(int lvl)
        ///  Convert grade number written by the players into the BuildingGrade.Enum used by rust
        /////////////////////////////////////////////////////
        BuildingGrade.Enum GetGrade(int lvl)
        {
            if (lvl == 0)
                return BuildingGrade.Enum.Twigs;
            else if (lvl == 1)
                return BuildingGrade.Enum.Wood;
            else if (lvl == 2)
                return BuildingGrade.Enum.Stone;
            else if (lvl == 3)
                return BuildingGrade.Enum.Metal;
            return BuildingGrade.Enum.TopTier;
        }

        /////////////////////////////////////////////////////
        ///  hasNoArguments(BasePlayer player, string[] args)
        ///  Action when no arguments were written in the commands
        /////////////////////////////////////////////////////
        bool hasNoArguments(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                if (player.GetComponent<BuildPlayer>())
                {
                    UnityEngine.GameObject.Destroy(player.GetComponent<BuildPlayer>());
                    SendReply(player, "Build Tool Deactivated");
                }
                else
                    SendReply(player, "For more informations say: /buildhelp");
                return true;
            }
            return false;
        } 

        /////////////////////////////////////////////////////
        ///  GetBuildPlayer(BasePlayer player)
        ///  Create or Get the BuildPlayer from a player, where all informations of current action is stored
        /////////////////////////////////////////////////////
        BuildPlayer GetBuildPlayer(BasePlayer player)
        {
            if (player.GetComponent<BuildPlayer>() == null)
                return player.gameObject.AddComponent<BuildPlayer>();
            else
                return player.GetComponent<BuildPlayer>();
        }
        /////////////////////////////////////////////////////
        ///  CHAT COMMANDS
        /////////////////////////////////////////////////////
        [ChatCommand("build")]
        void cmdChatBuild(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;
            
            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            if (buildType != "building")
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);
            
            defaultGrade = 0;
            defaultHealth = -1f;
            heightAdjustment = 0f;

            if (args.Length > 1) float.TryParse(args[1], out heightAdjustment);
            if (args.Length > 2) int.TryParse(args[2], out defaultGrade);
            if (args.Length > 3) float.TryParse(args[3], out defaultHealth);

            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            buildplayer.currentHealth = defaultHealth;
            buildplayer.currentGrade = GetGrade(defaultGrade);
            buildplayer.currentHeightAdjustment = heightAdjustment;
            SendReply(player, string.Format("Building Tool AIBuild: {0} - HeightAdjustment: {1} - Grade: {2} - Health: {3}", args[0], heightAdjustment.ToString(), buildplayer.currentGrade.ToString(), buildplayer.currentHealth.ToString()));
        }
        [ChatCommand("spawn")]
        void cmdChatSpawn(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;

            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            if (buildType == "building") buildType = "spawning";
            else
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);

            defaultGrade = 0;
            defaultHealth = -1f;
            heightAdjustment = 0f;

            if (args.Length > 1) float.TryParse(args[1], out heightAdjustment);
            if (args.Length > 2) int.TryParse(args[2], out defaultGrade);
            if (args.Length > 3) float.TryParse(args[3], out defaultHealth);

            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            buildplayer.currentHealth = defaultHealth;
            buildplayer.currentGrade = GetGrade(defaultGrade);
            buildplayer.currentHeightAdjustment = heightAdjustment;
            SendReply(player, string.Format("Building Tool RawSpawning: {0} - HeightAdjustment: {1} - Grade: {2} - Health: {3}", args[0], heightAdjustment.ToString(), buildplayer.currentGrade.ToString(), buildplayer.currentHealth.ToString()));
        }
        [ChatCommand("deploy")]
        void cmdChatDeploy(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;

            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp deployables");
                return;
            }
            if (buildType != "deploy")
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp deployables");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);

            heightAdjustment = 0f;
            if (args.Length > 1) float.TryParse(args[1], out heightAdjustment);

            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            buildplayer.currentHeightAdjustment = heightAdjustment;

            SendReply(player, string.Format("Building Tool Deploying: {0} - Height Adjustment: {1}", buildplayer.currentPrefab, buildplayer.currentHeightAdjustment.ToString()));
        }
        [ChatCommand("erase")]
        void cmdChatErase(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            BuildPlayer buildplayer = GetBuildPlayer(player);
            if (buildplayer.currentType != null && buildplayer.currentType == "erase")
            {
                UnityEngine.GameObject.Destroy(player.GetComponent<BuildPlayer>());
                SendReply(player, "Building Tool: Remove Deactivated");
            }
            else
            {
                buildplayer.currentType = "erase";
                SendReply(player, "Building Tool: Remove Activated");
            }
        }
        [ChatCommand("plant")]
        void cmdChatPlant(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;

            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp resources");
                return;
            }
            if (buildType != "plant")
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp resources");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);

            heightAdjustment = 0f;
            if (args.Length > 1) float.TryParse(args[1], out heightAdjustment);

            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            buildplayer.currentHeightAdjustment = heightAdjustment;

            SendReply(player, string.Format("Building Tool Planting: {0} - HeightAdjustment: {1}", prefabName, buildplayer.currentHeightAdjustment.ToString()));
        }
        [ChatCommand("animal")]
        void cmdChatAnimal(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;

            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp animals");
                return;
            }
            if (buildType != "animal")
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp animals");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);

            heightAdjustment = 0f;
            if (args.Length > 1) float.TryParse(args[1], out heightAdjustment);

            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            buildplayer.currentHeightAdjustment = heightAdjustment;

            SendReply(player, string.Format("Building Tool Spawning Animals: {0} - HeightAdjustment: {1}", prefabName, heightAdjustment.ToString()));
        }
        [ChatCommand("buildup")]
        void cmdChatBuildup(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;

            if (!TryGetBuildingPlans(args[0], out buildType, out prefabName))
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            if (buildType != "building")
            {
                SendReply(player, "Invalid Argument 1: For more informations say: /buildhelp buildings");
                return;
            }
            BuildPlayer buildplayer = GetBuildPlayer(player);

            buildType = "buildup";
            buildplayer.currentPrefab = prefabName;
            buildplayer.currentType = buildType;
            defaultGrade = 0;
            defaultHealth = -1f;
            heightAdjustment = 3f;

            if(args.Length > 1) float.TryParse(args[1], out heightAdjustment);
            if(args.Length > 2) int.TryParse(args[2],out defaultGrade);
            if(args.Length > 3) float.TryParse(args[3], out defaultHealth);


            buildplayer.currentHealth = defaultHealth;
            buildplayer.currentGrade = GetGrade(defaultGrade);
            buildplayer.currentHeightAdjustment = heightAdjustment;
            SendReply(player, string.Format("Building Tool BuildUP: {0} - Height: {1} - Grade: {2} - Health: {3}", args[0], buildplayer.currentHeightAdjustment.ToString(), buildplayer.currentGrade.ToString(), buildplayer.currentHealth.ToString()));
        }
        [ChatCommand("buildgrade")]
        void cmdChatBuilGrade(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;
            BuildPlayer buildplayer = GetBuildPlayer(player);
            defaultGrade = 0;
            buildplayer.selection = "select";
            buildplayer.currentType = "grade";
            int.TryParse(args[0], out defaultGrade);
            if (args.Length > 1)
                if (args[1] == "all")
                    buildplayer.selection = "all";
            buildplayer.currentGrade = GetGrade(defaultGrade);

            SendReply(player, string.Format("Building Tool SetGrade: {0} - for {1}", buildplayer.currentGrade.ToString(), buildplayer.selection));
        }
        [ChatCommand("buildheal")]
        void cmdChatBuilHeal(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (hasNoArguments(player, args)) return;
            BuildPlayer buildplayer = GetBuildPlayer(player);
            
            buildplayer.currentType = "heal";
            buildplayer.selection = "select";
            if (args.Length > 0)
                if (args[0] == "all")
                    buildplayer.selection = "all";

            SendReply(player, string.Format("Building Tool Heal for: {0}", buildplayer.selection));
        }
        [ChatCommand("buildrotate")]
        void cmdChatBuilRotate(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            BuildPlayer buildplayer = GetBuildPlayer(player);

            buildplayer.currentType = "rotate";
            buildplayer.selection = "select";
            float rotate = 0f;
            
            if (args.Length > 0) float.TryParse(args[0], out rotate);
            if (args.Length > 1)
                if (args[1] == "all")
                    buildplayer.selection = "all";
            buildplayer.currentRotate = Quaternion.Euler(0f, rotate, 0f);
            SendReply(player, string.Format("Building Tool Rotation for: {0}", buildplayer.selection));
        }
        [ChatCommand("buildhelp")]
        void cmdChatBuildhelp(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, "======== Buildings ========");
                SendReply(player, "/buildhelp buildings");
                SendReply(player, "/buildhelp grades");
                SendReply(player, "/buildhelp heal");
                SendReply(player, "======== Deployables ========");
                SendReply(player, "/buildhelp deployables");
                SendReply(player, "======== Resources (Trees, Ores, Barrels) ========");
                SendReply(player, "/buildhelp resources");
                SendReply(player, "======== Animals ========");
                SendReply(player, "/buildhelp animals");
                SendReply(player, "======== Erase ========");
                SendReply(player, "/buildhelp erase");
                return;
            }
            if (args[0].ToLower() == "buildings")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/build StructureName Optional:HeightAdjust(can be negative, 0 default) Optional:Grade Optional:Health");
                SendReply(player, "/buildup StructureName Optional:HeightAdjust(can be negative, 3 default) Optional:Grave Optional:Health");
                SendReply(player, "/buildrotate");
                SendReply(player, "======== Usage ========");
                SendReply(player, "/build foundation => build a Twigs Foundation");
                SendReply(player, "/build foundation 0 2 => build a Stone Foundation");
                SendReply(player, "/build wall 0 3 1 => build a Metal Wall with 1 health");
                SendReply(player, "======== List ========");
                SendReply(player, "/build foundation - /build foundation.triangle - /build foundation.steps(not avaible)");
                SendReply(player, "/build block.halfheight - /build block.halfheight.slanted (stairs)");
                SendReply(player, "/build wall - /build wall.low - /build wall.doorway - /build wall.window");
                SendReply(player, "/build floor - /build floor.triangle - /build roof");
            }
            else if (args[0].ToLower() == "grades")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/buildgrade GradeLevel Optional:all => default is only the selected block");
                SendReply(player, "======== Usage ========");
                SendReply(player, "/buildgrade 0 => set grade 0 for the select block");
                SendReply(player, "/buildgrade 2 all => set grade 2 (Stone) for the entire building");
            }
            else if (args[0].ToLower() == "heal")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/buildheal Optional:all => default is only the selected block");
                SendReply(player, "======== Usage ========");
                SendReply(player, "/buildheal all => will heal your entire structure");
            }
            else if (args[0].ToLower() == "deployables")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/deploy \"Deployable Name\" Optional:HeightAdjust(can be negative, 0 default)");
                SendReply(player, "======== Usage ========");
                SendReply(player, "/deploy \"Tool Cupboard\" => build a Tool Cupboard");
            }
            else if (args[0].ToLower() == "resources")
            {
                int i = 0;
                SendReply(player, "======== Commands ========");
                SendReply(player, "/plant \"Resource ID\"");
                SendReply(player, "======== List ========");
                foreach (string resource in resourcesList)
                {
                    SendReply(player, string.Format("{0} - {1}", i.ToString(), resource.Substring(19)));
                    i++;
                }
            }
            else if (args[0].ToLower() == "animals")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/animal \"Name\"");
                SendReply(player, "======== List ========");
                foreach (KeyValuePair<string, string> pair in animalList)
                {
                    SendReply(player, string.Format("{0}", pair.Key));
                }
            }
            else if (args[0].ToLower() == "erase")
            {
                SendReply(player, "======== Commands ========");
                SendReply(player, "/erase => Erase where you are looking at, there is NO all option here to prevent fails :p");
            }
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BuildBlocker.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("BuildBlocker", "Bombardir", "1.2.5" )]
    class BuildBlocker : RustPlugin
    {
        #region Config

        private static bool OnRock = false;
        private static bool InRock = true;
        private static bool InCave = false;
        private static bool InWarehouse = true;
        private static bool InMetalBuilding = true;
        private static bool InHangar = true;
        private static bool InTank = true;
        private static bool InBase = true;
        private static bool UnTerrain = true;
        private static bool UnBridge = false;
        private static bool UnRadio = false;
        private static bool BlockHorizontalSigns = true;
        private static bool BlockStructuresHeight = false;
        private static bool BlockDeployablesHeight = false;
        private static int MaxHeight = 100;
        private static bool BlockStructuresWater = false;
        private static bool BlockDeployablesWater = false;
        private static int MaxWater = -2;
        private static int AuthLVL = 2;
        private static string Msg = "Hey! You can't build here!";
        private static string MsgHeight = "You can't build here! (Height limit 100m)";
        private static string MsgSign = "You can't build horizontal sign on other sign!";
        private static string MsgWater = "You can't build here! (Water limit -2m)";

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
				Config[Key] = var;
        }

        void Init() 
        {
            CheckCfg<bool>("Block On Rock", ref OnRock);
            CheckCfg<bool>("Block In Rock", ref InRock);
            CheckCfg<bool>("Block In Rock Cave", ref InCave);
            CheckCfg<bool>("Block In Base", ref InBase);
            CheckCfg<bool>("Block In Warehouse", ref InWarehouse);
            CheckCfg<bool>("Block In Metal Building", ref InMetalBuilding);
            CheckCfg<bool>("Block In Hangar", ref InHangar);
            CheckCfg<bool>("Block Under Terrain", ref UnTerrain);
            CheckCfg<bool>("Block Under|On Metal Sphere", ref InTank);
            CheckCfg<bool>("Block Under|On Bridge", ref UnBridge);
            CheckCfg<bool>("Block Under|On Radar", ref UnRadio);
            CheckCfg<bool>("Block Horizontal Signs on other Signs", ref BlockHorizontalSigns);
            CheckCfg<int>("Max Height Limit", ref MaxHeight);
            CheckCfg<bool>("Block Structures above the max height", ref BlockStructuresHeight);
            CheckCfg<bool>("Block Deployables above the max height", ref BlockDeployablesHeight);
            CheckCfg<int>("Max Under Water Height Limit", ref MaxWater);
            CheckCfg<bool>("Block Structures under water", ref BlockStructuresWater);
            CheckCfg<bool>("Block Deployables under water", ref BlockDeployablesWater);
            CheckCfg<string>("Block Water Message", ref MsgWater);
            CheckCfg<string>("Block Height Message", ref MsgHeight);
            CheckCfg<string>("Block Sign Message", ref MsgSign);
            CheckCfg<string>("Block Message", ref Msg); 
            CheckCfg<int>("Ignore Auth Lvl", ref AuthLVL);
            SaveConfig(); 
        }  
        #endregion 
         
        private void CheckBlock(BaseNetworkable StartBlock, BasePlayer sender, bool CheckHeight, bool CheckWater)
        {
            if (StartBlock && sender.net.connection.authLevel < AuthLVL && !StartBlock.isDestroyed)
            {
                Vector3 Pos = StartBlock.transform.position;
                if (StartBlock.name == "foundation.steps(Clone)")
                    Pos.y += 1.3f;

                if (CheckHeight || CheckWater)
                {
                   float height = TerrainMeta.HeightMap.GetHeight(Pos);
                    if (CheckHeight && Pos.y - height > MaxHeight)
                    {
                        SendReply(sender, MsgHeight);
                        StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                    else if (CheckWater && height < 0 && height < MaxWater && Pos.y < 2.8 )
                    {
                        SendReply(sender, MsgWater);
                        StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                }

                if (BlockHorizontalSigns && StartBlock.GetComponent<Signage>())
                {
                    Vector3 euler = StartBlock.transform.rotation.eulerAngles;
                    if (euler.z == 0)
                    {
                        SendReply(sender, MsgSign);
                        StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                }

                Pos.y = Pos.y + 100;
                RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 102.8f);
                Pos.y = Pos.y - 100;
                for (int i = 0; i < hits.Length; i++)
                {
                    RaycastHit hit = hits[i];
                    if (hit.collider)
                    {
                        string ColName = hit.collider.name;
                        if (UnTerrain && ColName == "Terrain" && hit.point.y > Pos.y || 
                            InBase && ColName.StartsWith("base", StringComparison.CurrentCultureIgnoreCase) || 
                            InMetalBuilding && ColName == "Metal_building_COL" || 
                            UnBridge && ColName == "Bridge_top" || 
                            UnRadio && ColName.StartsWith("dish") || 
                            InWarehouse && ColName.StartsWith("Warehouse") || 
                            InHangar && ColName.StartsWith("Hangar") ||
                            InTank && ColName == "howie_spheretank_blockin" ||
                            ColName == "COL" && (hit.point.y < Pos.y ? OnRock : hit.collider.bounds.Contains(Pos) ? InRock : InCave))
                        {
                            SendReply(sender, Msg);
                            StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                            break;
                        }
                        if (ColName == "Terrain")
                            break;
                    }
                }
            }
        }

        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            CheckBlock(obj.GetComponent<BaseNetworkable>(), plan.ownerPlayer, BlockStructuresHeight, BlockStructuresWater);
        }

        void OnItemDeployed(Deployer deployer, BaseEntity deployedentity)
        {
            if (!(deployedentity is BaseLock))
                CheckBlock((BaseNetworkable) deployedentity, deployer.ownerPlayer, BlockDeployablesHeight, BlockDeployablesWater);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BuildingGrades.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using System;
using System.Collections.Generic;
using System.Reflection;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Grades", "bawNg", 0.1)]
    class BuildingGrades : RustPlugin
    {
        FieldInfo serverInputField = typeof(BasePlayer).GetField("serverInput", BindingFlags.Instance | BindingFlags.NonPublic);

        [ChatCommand("up")]
        void UpCommand(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, true);
        }

        [ChatCommand("down")]
        void DownCommand(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, false);
        }

        void ChangeBuildingGrade(BasePlayer player, bool increment)
        {
            if (!player.IsAdmin())
            {
                SendReply(player, "<color=red>Only admins may use that command</color>");
                return;
            }

            var initial_block = GetTargetBuildingBlock(player);
            if (!initial_block)
            {
                SendReply(player, "<color=red>You are not looking at a building block!</color>");
                return;
            }
            
            var all_blocks = new HashSet<BuildingBlock>();
            all_blocks.Add(initial_block);

            Action<BuildingBlock> queue_attached_blocks = null;
            queue_attached_blocks = (building_block) =>
            {
                foreach (var collider in Physics.OverlapSphere(building_block.transform.position, 3.5f))
                {
                    var next_block = collider.GetComponentInParent<BuildingBlock>();
                    if (!next_block || !all_blocks.Add(next_block)) continue;
                    queue_attached_blocks(next_block);
                }
            };
            queue_attached_blocks(initial_block);
            
            foreach (var building_block in all_blocks)
            {
                var target_grade = NextBlockGrade(building_block, increment ? 1 : -1);
                if (target_grade == (int)building_block.grade) continue;
                                
                building_block.SetGrade((BuildingGrade.Enum)target_grade);
                building_block.SetHealthToMax();
                building_block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }            
        }

        int NextBlockGrade(BuildingBlock building_block, int offset = 1)
        {
            var current_grade = (int)building_block.grade;

            var grades = building_block.blockDefinition.grades;
            if (grades == null) return current_grade;

            var target_grade = current_grade + offset;
            while (target_grade >= 0 && target_grade < grades.Length)
            {
                if (grades[target_grade] != null) return target_grade;
                target_grade += offset;
            }

            return current_grade;
        }

        BuildingBlock GetTargetBuildingBlock(BasePlayer player)
        {
            var eye_postion = player.transform.position;
            eye_postion.y += 1.51f;
            var input = serverInputField.GetValue(player) as InputState;
            var direction = Quaternion.Euler(input.current.aimAngles);
            RaycastHit initial_hit;
            if (!Physics.Raycast(new Ray(eye_postion, direction * Vector3.forward), out initial_hit, 150f) || initial_hit.collider is TerrainCollider)
                return null;
            var entity = initial_hit.collider.GetComponentInParent<BuildingBlock>();
            if (!entity) return null;
            return entity;
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BuildingOwners.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Building Owners", "Reneb", "2.1.2")]
    class BuildingOwners : RustPlugin
    {
    	private static DateTime epoch;
        private Core.Configuration.DynamicConfigFile ReverseData;
        private Dictionary<float,string> OwnersData;
        private FieldInfo keyvalues;
        private static bool serverInitialized;
        void Loaded() 
        {
            serverInitialized = false;
            OwnersData = new Dictionary<float, string>(); 
        	epoch = new System.DateTime(1970, 1, 1);
            keyvalues = typeof(Oxide.Core.Configuration.DynamicConfigFile).GetField("keyvalues", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        void OnServerInitialized()
        {
            ReverseData = Interface.GetMod().DataFileSystem.GetDatafile("BuildingOwners");
            serverInitialized = true;
            ReverseTable();
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("BuildingOwners");
        }
        void ReverseTable()
        {
            //var Table = keyvalues.GetValue(ReverseData) as Dictionary<string, object>;

            foreach (KeyValuePair<string, object> pair in ReverseData)
            {
                var list = pair.Value as List<object>;
                foreach (object heights in list)
                {
                    if (!(OwnersData.ContainsKey(Convert.ToSingle(heights))))
                    {
                        OwnersData.Add(Convert.ToSingle(heights), pair.Key.ToString());
                    }
                }
            }
        }
        double CurrentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalMilliseconds;
        }
        object FindBuilding(BasePlayer player)
        {
            var hits = UnityEngine.Physics.OverlapSphere(player.transform.position, 3f);
            foreach (var hit in hits)
            {
                if (hit.GetComponentInParent<BuildingBlock>() != null)
                {
                    return hit.GetComponentInParent<BuildingBlock>();
                }
            }
            return false;
        }
        void OnEntityBuilt(HeldEntity heldentity, GameObject gameobject)
        {
            if (serverInitialized)
            {
                var buildingblock = gameobject.GetComponent<BuildingBlock>();
                if (buildingblock == null) return;
                float posy = buildingblock.transform.position.y;
                if (!(OwnersData.ContainsKey(posy)))
                {
                    string userid = heldentity.ownerPlayer.userID.ToString();
                    OwnersData.Add(posy, userid);
                    if (ReverseData[userid] == null)
                        ReverseData[userid] = new List<object>();
                    var list = ReverseData[userid] as List<object>;
                    list.Add(posy);
                    ReverseData[userid] = list;
                }
            }
        }
        object FindBlockData(BuildingBlock block)
        {
            float posy = block.transform.position.y;
            if (OwnersData.ContainsKey(posy))
                return OwnersData[posy];
            return false;
        }
        [ChatCommand("changeowner")]
        void cmdChatchangeowner(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return; 
            }
            if (args == null || args.Length < 1)
            {
                SendReply(player, "You need to give the name of the new owner");
                return;
            }
            var target = BasePlayer.Find(args[0].ToString());
            if (target == null || target.net == null || target.net.connection == null)
            {
                SendReply(player, "Target player not found");
            }
            else
            {
                object block = FindBuilding(player);
                if ( block is bool )
                {
                    SendReply(player, "No Building found.");
                }
                else
                {
                    var userid = target.userID.ToString();
                    BuildingBlock buildingblock = block as BuildingBlock;
                    List<BuildingBlock> houseList = new List<BuildingBlock>();
                    List<Vector3> checkFrom = new List<Vector3>();
                    houseList.Add((BuildingBlock) buildingblock);
                    checkFrom.Add(buildingblock.transform.position);
                    var current = 0;
                    while (true)
                    {
                        current++;
                        if (current > checkFrom.Count)
                            break;
                        var hits = UnityEngine.Physics.OverlapSphere(checkFrom[current-1], 3f);
                        foreach (var hit in hits)
                        {
                            if (hit.GetComponentInParent<BuildingBlock>() != null)
                            {
                                BuildingBlock fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                                if (!(houseList.Contains(fbuildingblock)))
                                {
                                    houseList.Add(fbuildingblock);
                                    checkFrom.Add(fbuildingblock.transform.position);
                                    if (!(OwnersData.ContainsKey(fbuildingblock.transform.position.y)))
                                    {
                                        OwnersData.Add(fbuildingblock.transform.position.y, userid);
                                    }
                                    else
                                    {
                                        OwnersData[fbuildingblock.transform.position.y] = userid;
                                    }
                                    if (ReverseData[userid] == null)
                                        ReverseData[userid] = new List<object>();
                                    var list = ReverseData[userid] as List<object>;
                                    if (!(list.Contains(fbuildingblock.transform.position.y)))
                                    {
                                        list.Add(fbuildingblock.transform.position.y);
                                        ReverseData[userid] = list;
                                    }
                                }
                            }
                        }
                    }
                    SendReply(player, string.Format("New owner of this house is: {0}",target.displayName));
                    SendReply(target, "An admin gave you the ownership of this house");
                }
            }
        }
        void OnServerSave()
        {
            SaveData();
        }
        void OnServerQuit()
        {
            SaveData();
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\BuildingPrivileges.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("BuildingPrivileges", "Reneb", 1.0)]
    class BuildingPrivileges : RustPlugin
    {
        private FieldInfo localbuildingPrivileges;
        void Loaded()
        {
            localbuildingPrivileges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        [ChatCommand("bdp")]
        void cmdChatBuildingPrivileges(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            var bldprivs = localbuildingPrivileges.GetValue(player) as List<BuildingPrivlidge>;
            foreach (BuildingPrivlidge bldpriv in bldprivs)
            {
                SendReply(player, string.Format("Found a Tool Cupboard @ {0} {1} {2}, allowed users:", Math.Round(bldpriv.transform.position.x).ToString(), Math.Round(bldpriv.transform.position.y).ToString(), Math.Round(bldpriv.transform.position.z).ToString()));
                var locAllowed = bldpriv.authorizedPlayers;
                foreach (ProtoBuf.PlayerNameID ply in locAllowed)
                {
                    SendReply(player, ply.username);
                }
            }
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\CashSystem.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust
// Reference: NLua

using System.Collections.Generic;
using System;








namespace Oxide.Plugins
{
    [Info("CashSystem", "igor1150", 1.0)]
    class CashSystem : RustPlugin
    {
        private string menuPreco = "precos";
        private string menuQuantia = "quantia";
        private string menuNome = "nome";
        void OnPlayerInit(BasePlayer player){
            LoadConfig();
            if (Config[menuPreco] == null)
                GerarListaPrecos();
            if(Config[menuQuantia] == null)
                GerarListaQuantia();
            if (Config[menuNome] == null)
                GerarListaNome();
        }
        [ChatCommand("buy")]
        void chatCompra(BasePlayer player, string command, string[] args)
        {
            if (Convert.ToInt32(args[1].ToString()) == 0 || Convert.ToInt32(args[1].ToString()) == null)
            {
                SendReply(player, "To buy the amount must be greater than 0 (zero)");
                SendReply(player, "How to use: /buy \"ITEMNAME\" \"AMOUNT\"");
            }
            else
            {
                if (!VenderItem(player, args[0].ToString(), Convert.ToInt32(args[1].ToString())))
                {
                    SendReply(player, "Make sure you typed the item name correctly");
                    SendReply(player, "How to use: /buy \"ITEMNAME\" \"AMOUNT\"");
                }
            }
        }
        [ChatCommand("cash")]
        void chatCash(BasePlayer player, string command, string[] args)
        {
            SendReply(player, String.Concat("Your current cash and: ", Convert.ToString(ObterCash(player))));
        }
        [ChatCommand("addcash")]
        void chataddcash(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (args[0].ToString() == "" || args[0] == null || args[0].ToString().Length <= 0)
                {
                    SendReply(player, "Enter a nickname");
                }
                if (args[1].ToString() == Convert.ToString(0) || args[1] == null)
                {
                    SendReply(player, "Enter a value");
                }
                else
                {
                    if (!AddCash(player, args[0].ToString(), Convert.ToInt32(args[1].ToString())))
                    {
                        SendReply(player, "How to use: /addcash \"PLAYERNOME\" \"AMOUNT\"");
                    }
                }
            }
            catch (Exception ex)
            {
                SendReply(player, "How to use: /addcash \"PLAYERNOME\" \"AMOUNT\"");
            }
        }
        [ChatCommand("help")]
        void chatajuda(BasePlayer player, string command, string[] args)
        {
            if (Administrador(player))
            {
                SendReply(player, "How to use: /addcash \"PLAYERNAME\" \"AMOUNT\"");
                SendReply(player, "How to use: /cash -show cash");
                SendReply(player, "How to use: /buy \"ITEMNAME\" \"AMOUNT\"");
                SendReply(player, "How to use: /generatepricelists -generates a new price list [CAUTION]");
                SendReply(player, "How to use: /generateamountlist -generates a new list of the amount of items [CAUTION]");
                SendReply(player, "How to use: /generatenamelist -generates a new list of names of items in English");
                SendReply(player, "How to use: /getprice \"ITEMNAME\"");
                SendReply(player, "How to use: /setprice \"ITEMNAME\" \"VALOR\"");
                SendReply(player, "How to use: /delitem \"ITEMNAME\"");                
                SendReply(player, "How to use: /setamount \"ITEMNAME\" \"AMOUNT\"");
                SendReply(player, "How to use: /getamount \"ITEMNAME\"");
            }
            else
            {
                SendReply(player, "How to use: /cash -show cash");
                SendReply(player, "How to use: /getprice \"ITEMNAME\"");
                if (ObterCash(player) > 0)
                {
                    SendReply(player, "How to use: /buy \"ITEMNAME\" \"AMOUNT\"");
                }
            }
        }
        [ChatCommand("generatepricelist")]
        void chatgerarlistaprecos(BasePlayer player, string command, string[] args)
        {
            if (!GerarListaPrecos())
                SendReply(player, "Error generating the list");
            else
                SendReply(player, "Success to generate the list");
        }
        [ChatCommand("getprice")]
        void chatobterpreco(BasePlayer player, string command, string[] args)
        {
            if (args[0].ToString() == "" || args[0] == null)
                SendReply(player, "enter a name of an item");
            else
            {
                int preco = ObterPreco(args[0].ToString());
                if (preco == 0 || preco < 0)
                    SendReply(player, "The item does not exist or is not for sale make sure you typed the name correctly type / help for more information");
                else
                    SendReply(player, String.Concat("The value of the item and: ", preco));

            }

        }
        [ChatCommand("setprice")]
        void chatdefinirpreco(BasePlayer player, string command, string[] args)
        {
            if (!Administrador(player))
            {
                SendReply(player, "The command does not exist");
            }
            else
            {
                if (args[0].ToString() == "" || args[0] == null || Convert.ToInt32(args[1]) == 0 || args[1] == null)
                    SendReply(player, "Enter a name of an item and price");
                else
                {
                    if (ObterPreco(args[0].ToString())>0)
                        SendReply(player, "Error setting the price of the item make sure you typed the name correctly");
                    else
                    {
                        DefinirPreco(args[0].ToString(), Convert.ToInt32(args[1]));
                        SendReply(player, String.Concat("Price change item with new price and success: ", Convert.ToString(args[1])));
                    }
                }
            }
        }
        [ChatCommand("delitem")]
        void chatremoveritem(BasePlayer player, string command, string[] args)
        {
            if (!Administrador(player))
            {
                SendReply(player, "The command does not exist");
            }
            else
            {
                if (args[0].ToString() == "" || args[0] == null)
                    SendReply(player, "Eter a name of an item");
                else
                {
                    if (ObterPreco(args[0].ToString())==0)
                        SendReply(player, "Error deleting the item make sure you typed the name correctly");
                    else
                    {
                        RemoverItem(args[0].ToString());
                        SendReply(player, "Item successfully deleted!");
                    }
                }
            }
        }
        [ChatCommand("generateamountlist")]
        void chatgerarlistaquantia(BasePlayer player, string command, string[] args)
        {
            if (!GerarListaQuantia())
                SendReply(player, "Error generating the list");
            else
                SendReply(player, "Success to generate the list");
        }
        [ChatCommand("getamount")]
        void chatobterquantia(BasePlayer player, string command, string[] args)
        {
            if (args[0].ToString() == "" || args[0] == null)
                SendReply(player, "enter a name of an item");
            else
            {
                int quantia = ObterQuantia(args[0].ToString());
                if (quantia == 0 || quantia < 0)
                    SendReply(player, "The item does not exist or is not for sale make sure you typed the name correctly type / help for more information");
                else
                    SendReply(player, String.Concat("The amount of the item and: ", quantia));

            }
        }
        [ChatCommand("setamount")]
        void chatdefinirquantia(BasePlayer player, string command, string[] args)
        {
            if (!Administrador(player))
            {
                SendReply(player, "The command does not exist");
            }
            else
            {
                if (args[0].ToString() == "" || args[0] == null || Convert.ToInt32(args[1]) == 0 || args[1] == null)
                    SendReply(player, "enter a name of an item e depois a quantia");
                else
                {
                    if (ObterPreco(args[0].ToString()) == 0)
                        SendReply(player, "Error setting the amount of the item make sure you typed the name correctly");
                    else
                    {
                        DefinirQuantia(args[0].ToString(), Convert.ToInt32(args[1]));
                        SendReply(player, String.Concat("Amount successfully changed item new amount and: ", Convert.ToString(args[1])));
                    }
                }
            }
        }

        [ChatCommand("generatenamelist")]
        void chatgerarlistanome(BasePlayer player, string command, string[] args)
        {
            if (!GerarListaNome())
                SendReply(player, "Error generating the list");
            else
                SendReply(player, "Success to generate the list");
        }


        bool VenderItem(BasePlayer player, string nome, int quantia)
        {
            try
            {
                LoadConfig();
                string ID641 = player.userID.ToString();
                object value1;
                var menu = (Config[menuNome]) as Dictionary<string, object>;
                if (menu != null)
                {
                    menu.TryGetValue(nome, out value1);
                    if (value1 != null || value1.ToString() != "")
                        nome = value1.ToString();
                }
                 int cash = ObterCash(player);
                 int preco = ObterPreco(nome);
                 if (cash < preco)
                 {
                     SendReply(player, "Your current cash and not enough to buy");
                     return false;
                 }
                 if (preco == 0)
                 {
                     return false;
                 }
                var item = ItemManager.FindItemDefinition(nome);
                if (item == null)
                    return false;            
                else{
                    string ID64 = player.userID.ToString();
                    cash -= preco * quantia;
                    SendReply(player, String.Concat("Purchased Item successfully! price: ", Convert.ToString(preco * quantia)));
                    Dictionary<string, object> subMenu = new Dictionary<string, object>();
                    subMenu.Add("cash", Convert.ToString(cash));
                    Config[ID64] = subMenu;
                    SaveConfig();
                    quantia = quantia * ObterQuantia(nome);
                    player.inventory.GiveItem(ItemManager.CreateByItemID((int)item.itemid, quantia, false), (ItemContainer)((BasePlayer)player).inventory.containerMain);              
                    return true;
                }
            }
            catch (Exception ex)
            {
                return false;
            }
            return false;
        }
        int ObterCash(BasePlayer player)
        {
            LoadConfig();
            string ID64 = player.userID.ToString();
            var menu = (Config[ID64]) as Dictionary<string, object>;
            if (menu != null)
            {
                object value;
                menu.TryGetValue("cash", out value);
                int cash = Convert.ToInt32(value);
                if (cash > 0)
                {
                    return cash;
                }
                else
                {
                    RemoveCash((BasePlayer)player);
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        bool RemoveCash(BasePlayer player)
        {
            LoadConfig();
            string ID64 = player.userID.ToString();
            var newMenu = new Dictionary<string, object>();
            foreach (KeyValuePair<string, object> str in Config)
            {
                if (str.Key.ToString() != ID64.ToString() && str.Value != null)//testar com o str.Value eu nao testei ainda
                {
                    newMenu.Add(str.Key.ToString(), str.Value);
                }
            }
            Config.Clear();
            foreach (KeyValuePair<string, object> str in newMenu)
            {
                Config[str.Key] = str.Value;
            }
            SaveConfig();
            return true;
        }
        bool AddCash(BasePlayer player, string nick, int cash)
        {
            if (!Administrador(player))
            {
                SendReply(player, "The command does not exist");
            }
            else
            {
                var add = BasePlayer.Find(nick);
                if (add == null)
                {
                    SendReply(player, "Player not found");
                    return false;
                }
                LoadConfig();
                string ID64 = add.userID.ToString();
                if (ID64 == "" || ID64 == null)
                {
                    SendReply(player, "Error looking the ID64Steam");
                    return false;
                }
                Dictionary<string, object> subMenu = new Dictionary<string, object>();
                cash += ObterCash(add);
                subMenu.Add("cash", Convert.ToString(cash));
                Config[ID64] = subMenu;
                SaveConfig();
                SendReply(player, String.Concat("Cash added value with new success: ", Convert.ToString(cash)));
            }
            return true;
        }
        bool Administrador(BasePlayer player)
        {
            if (player.net.connection.authLevel >= 2)
                return true;
            return false;
        }
        bool GerarListaPrecos()
        {
            LoadConfig();
            var items = ItemManager.GetItemDefinitions();
            if (items == null)
                return false;
            var newMenu = new Dictionary<string, int>();
            foreach (var item in items)
            {
                newMenu.Add(Convert.ToString(item.shortname), 2);
            }
            if (newMenu == null)
                return false;
            Config[menuPreco] = newMenu;
            SaveConfig();
            return true;
        }
        int ObterPreco(string nomeItem)
        {
            LoadConfig();
            Dictionary<string, object> menu = new Dictionary<string, object>();
            menu = Config[menuPreco] as Dictionary<string, object>;    
            if (menu != null)
            {
                object value;
                menu.TryGetValue(nomeItem, out value);
                if (Convert.ToInt32(value) > 0)
                {
                    return Convert.ToInt32(value);
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        void DefinirPreco(string nomeItem, int Preco)
        {
            LoadConfig();
            var newMenu = Config[menuPreco] as Dictionary<string, object>;
            newMenu[nomeItem] = Preco;
            Config[menuPreco] = newMenu;
            SaveConfig();
        }
        void RemoverItem(string nomeItem)
        {
            LoadConfig();
            var Menu = Config[menuPreco] as Dictionary<string, object>;
            var newMenu = new Dictionary<string, object>();
            foreach (KeyValuePair<string, object> str in Menu)
            {
                if (str.Key.ToString() != nomeItem)
                {
                    newMenu.Add(str.Key.ToString(), str.Value);
                } 
            }
            Config[menuPreco] = newMenu;
            Menu = new Dictionary<string, object>();
            Menu = Config[menuQuantia] as Dictionary<string, object>;
            newMenu = new Dictionary<string, object>();
            foreach (KeyValuePair<string, object> str in Menu)
            {
                if (str.Key.ToString() != nomeItem)
                {
                    newMenu.Add(str.Key.ToString(), str.Value);
                }
            }
            Config[menuQuantia] = newMenu;
            SaveConfig();
        }
        bool GerarListaQuantia()
        {
            LoadConfig();
            var items = ItemManager.GetItemDefinitions();
            if (items == null)
                return false;
            var newMenu = new Dictionary<string, int>();
            foreach (var item in items)
            {
                newMenu.Add(Convert.ToString(item.shortname), 1);
            }
            if (newMenu == null)
                return false;
            Config[menuQuantia] = newMenu;
            SaveConfig();
            return true;
        }        
        int ObterQuantia(string nomeItem)
        {
            LoadConfig();
            Dictionary<string, object> menu = new Dictionary<string, object>();
            menu = Config[menuQuantia] as Dictionary<string, object>;
            if (menu != null)
            {
                object value;
                menu.TryGetValue(nomeItem, out value);
                if (Convert.ToInt32(value) > 0)
                {
                    return Convert.ToInt32(value);
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        void DefinirQuantia(string nomeItem, int quantia)
        {
            LoadConfig();
            var newMenu = Config[menuQuantia] as Dictionary<string, object>;
            newMenu[nomeItem] = quantia;
            Config[menuQuantia] = newMenu;
            SaveConfig();
        }

        bool GerarListaNome()
        {
            LoadConfig();
            var items = ItemManager.GetItemDefinitions();
            if (items == null)
                return false;
            var newMenu = new Dictionary<string, string>();
            foreach (var item in items)
            {
                newMenu.Add(Convert.ToString(item.displayName.english), Convert.ToString(item.shortname));
            }
            if (newMenu == null)
                return false;
            Config[menuNome] = newMenu;
            SaveConfig();
            return true;
        }        
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Clans.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Clans", "playrust.io / dcode", "1.4.2", ResourceId = 842)]
    public class Clans : RustPlugin
    {

        #region Rust:IO Bindings

        private Library lib;
        private MethodInfo isInstalled;
        private MethodInfo hasFriend;
        private MethodInfo addFriend;
        private MethodInfo deleteFriend;

        private void InitializeRustIO() {
            lib = Interface.GetMod().GetLibrary<Library>("RustIO");
            if (lib == null || (isInstalled = lib.GetFunction("IsInstalled")) == null || (hasFriend = lib.GetFunction("HasFriend")) == null || (addFriend = lib.GetFunction("AddFriend")) == null || (deleteFriend = lib.GetFunction("DeleteFriend")) == null) {
                lib = null;
                Puts("{0}: {1}", Title, "Rust:IO is not present. You need to install Rust:IO first in order to use this plugin!");
            }
        }

        private bool IsInstalled() {
            if (lib == null) return false;
            return (bool)isInstalled.Invoke(lib, new object[] { });
        }

        private bool HasFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)hasFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool AddFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)addFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool DeleteFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)deleteFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        #endregion

        private Dictionary<string,Clan> clans = new Dictionary<string,Clan>();
        private Dictionary<string, string> originalNames = new Dictionary<string, string>();
        private Regex tagRe = new Regex("^[a-zA-Z0-9]{2,6}$");
        private Dictionary<string, string> messages = new Dictionary<string, string>();

        // Loads the data file
        private void LoadData() {
            clans.Clear();
            var data = Interface.GetMod().DataFileSystem.GetDatafile("rustio_clans");
            if (data["clans"] != null) {
                var clansData = (Dictionary<string,object>) Convert.ChangeType(data["clans"], typeof(Dictionary<string, object>));
                foreach (var iclan in clansData) {
                    string tag = iclan.Key;
                    var clanData = iclan.Value as Dictionary<string,object>;
                    string description = (string) clanData["description"];
                    string owner = (string)clanData["owner"];
                    List<string> moderators = new List<string>();
                    foreach (var imoderator in clanData["moderators"] as List<object>) {
                        moderators.Add((string)imoderator);
                    }
                    List<string> members = new List<string>();
                    foreach (var imember in clanData["members"] as List<object>) {
                        members.Add((string)imember);
                    }
                    List<string> invited = new List<string>();
                    foreach (var iinvited in clanData["invited"] as List<object>) {
                        invited.Add((string)iinvited);
                    }
                    clans.Add(tag, new Clan() {
                        tag = tag,
                        description = description,
                        owner = owner,
                        moderators = moderators,
                        members = members,
                        invited = invited
                    });
                }
            }
        }

        // Saves the data file
        private void SaveData() {
            var data = Interface.GetMod().DataFileSystem.GetDatafile("rustio_clans");
            var clansData = new Dictionary<string, object>();
            foreach (var clan in clans) {
                var clanData = new Dictionary<string, object>();
                clanData.Add("tag", clan.Value.tag);
                clanData.Add("description", clan.Value.description);
                clanData.Add("owner", clan.Value.owner);
                var moderators = new List<object>();
                foreach (var imoderator in clan.Value.moderators)
                    moderators.Add(imoderator);
                var members = new List<object>();
                foreach (var imember in clan.Value.members)
                    members.Add(imember);
                var invited = new List<object>();
                foreach (var iinvited in clan.Value.invited)
                    invited.Add(iinvited);
                clanData.Add("moderators", moderators);
                clanData.Add("members", members);
                clanData.Add("invited", invited);
                clansData.Add(clan.Value.tag, clanData);
            }
            data["clans"] = clansData;
            Interface.GetMod().DataFileSystem.SaveDatafile("rustio_clans");
        }

        // A list of all translateable texts
        private List<string> texts = new List<string>() {
            "%NAME% has come online!",
            "%NAME% has gone offline.",

            "You are currently not a member of a clan.",
            "You are the owner of:",
            "You are a moderator of:",
            "You are a member of:",
            "Members online:",
            "Pending invites:",
            "To learn more about clans, type: <color=\"#ffd479\">/clan help</color>",

            "Usage: <color=\"#ffd479\">/clan create \"TAG\" \"Description\"</color>",
            "You are already a member of a clan.",
            "Clan tags must be 2 to 6 characters long and may contain standard letters and numbers only",
            "Please provide a short description of your clan.",
            "There is already a clan with this tag.",
            "You are now the owner of your new clan:",
            "To invite new members, type: <color=\"#ffd479\">/clan invite \"Player name\"</color>",

            "Usage: <color=\"#ffd479\">/clan invite \"Player name\"</color>",
            "You need to be a moderator of your clan to use this command.",
            "No such player or player name not unique:",
            "This player is already a member of your clan:",
            "This player is not a member of your clan:",
            "This player has already been invited to your clan:",
            "This player is already a moderator of your clan:",
            "This player is not a moderator of your clan:",
            "%MEMBER% invited %PLAYER% to the clan.",
            "Usage: <color=\"#ffd479\">/clan join \"TAG\"</color>",
            "You have not been invited to join this clan.",
            "%NAME% has joined the clan!",
            "You have been invited to join the clan:",
            "To join, type: <color=#ffd479>/clan join \"%TAG%\"</color>",

            "Usage: <color=\"#ffd479\">/clan promote \"Player name\"</color>",
            "You need to be the owner of your clan to use this command.",
            "%OWNER% promoted %MEMBER% to moderator.",

            "Usage: <color=\"#ffd479\">/clan demote \"Player name\"</color>",

            "Usage: <color=\"#ffd479\">/clan leave</color>",
            "You have left your current clan.",
            "%NAME% has left the clan.",

            "Usage: <color=\"#ffd479\">/clan kick \"Player name\"</color>",
            "This player is an owner or moderator and cannot be kicked:",
            "%NAME% kicked %MEMBER% from the clan.",

            "Usage: <color=\"#ffd479\">/clan disband forever</color>",
            "Your current clan has been disbanded forever.",

            "Usage: <color=\"#ffd479\">/clan delete \"TAG\"</color>",
            "You need to be a server owner to delete clans.",
            "There is no clan with that tag:",
            "Your clan has been deleted by the server owner.",
            "You have deleted the clan:",

            "Available commands:",
            "<color=#ffd479>/clan</color> - Displays relevant information about your current clan",
            "<color=#ffd479>/c Message...</color> - Sends a message to all online clan members",
            "<color=#ffd479>/clan create \"TAG\" \"Description\"</color> - Creates a new clan you own",
            "<color=#ffd479>/clan join \"TAG\"</color> - Joins a clan you have been invited to",
            "<color=#ffd479>/clan leave</color> - Leaves your current clan",
            "<color=#74c6ff>Moderator</color> commands:",
            "<color=#ffd479>/clan invite \"Player name\"</color> - Invites a player to your clan",
            "<color=#ffd479>/clan kick \"Player name\"</color> - Kicks a member from your clan",
            "<color=#a1ff46>Owner</color> commands:",
            "<color=#ffd479>/clan promote \"Name\"</color> - Promotes a member to moderator",
            "<color=#ffd479>/clan demote \"Name\"</color> - Demotes a moderator to member",
            "<color=#ffd479>/clan disband forever</color> - Disbands your clan (no undo)",
            "<color=#cd422b>Server owner</color> commands:",
            "<color=#ffd479>/clan delete \"TAG\"</color> - Deletes a clan (no undo)",

            "<color=\"#ffd479\">/clan</color> - Displays your current clan status",
            "<color=\"#ffd479\">/clan help</color> - Learn how to create or join a clan"
        };

        // Loads the default configuration
        protected override void LoadDefaultConfig() {
            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue) {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        // Translates a string
        private string _(string text, Dictionary<string,string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }

        // Finds a clan by tag
        private Clan FindClan(string tag) {
            if (clans.ContainsKey(tag))
                return clans[tag];
            return null;
        }

        // Finds a user's clan
        private Clan FindClanByUser(string userId) {
            foreach (var clan in clans)
                if (clan.Value.IsMember(userId))
                    return clan.Value;
            return null;
        }

        // Finds a player by partial name
        private BasePlayer FindPlayerByPartialName(string name) {
            if (string.IsNullOrEmpty(name))
                return null;
            BasePlayer player = null;
            name = name.ToLower();
            var allPlayers = BasePlayer.activePlayerList.ToArray();
            // Try to find an exact match first
            foreach (var p in allPlayers) {
                if (p.displayName == name) {
                    if (player != null)
                        return null; // Not unique
                    player = p;
                }
            }
            if (player != null)
                return player;
            // Otherwise try to find a partial match
            foreach (var p in allPlayers) {
                if (p.displayName.ToLower().IndexOf(name) >= 0) {
                    if (player != null)
                        return null; // Not unique
                    player = p;
                }
            }
            return player;
        }

        private string StripTag(string name, Clan clan) {
            if (clan == null)
                return name;
            var re = new Regex(@"^\["+clan.tag+@"\]\s");
            while (re.IsMatch(name))
                name = name.Substring(clan.tag.Length+3);
            return name;
        }

        // Sets up a player to use the correct clan tag
        private void SetupPlayer(BasePlayer player) {
            var prevName = player.displayName;
            var playerId = player.userID.ToString();
            var clan = FindClanByUser(playerId);
            player.displayName = StripTag(player.displayName, clan);
            string originalName = null;
            if (!originalNames.ContainsKey(playerId)) {
                originalNames.Add(playerId, originalName = player.displayName);
            } else {
                originalName = originalNames[playerId];
            }
            if (clan == null) {
                player.displayName = originalName;
            } else {
                var tag = "[" + clan.tag + "]"+" ";
                if (!player.displayName.StartsWith(tag))
                    player.displayName = tag + originalName;
            }
            if (player.displayName != prevName)
                player.SendNetworkUpdate();
        }

        // Sets up all players contained in playerIds
        private void SetupPlayers(List<string> playerIds) {
            foreach (var playerId in playerIds) {
                var uid = Convert.ToUInt64(playerId);
                var player = BasePlayer.FindByID(uid);
                if (player != null)
                    SetupPlayer(player);
                else {
                    player = BasePlayer.FindSleeping(uid);
                    if (player != null)
                        SetupPlayer(player);
                }
            }
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            try {
                InitializeRustIO();
                LoadConfig();
                var customMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (customMessages != null)
                    foreach (var pair in customMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
                LoadData();
                foreach (var player in BasePlayer.activePlayerList)
                    SetupPlayer(player);
                foreach (var player in BasePlayer.sleepingPlayerList)
                    SetupPlayer(player);
            } catch (Exception ex) {
                Error("OnServerInitialized failed: " + ex.Message);
            }
        }

        [HookMethod("OnUserApprove")]
        void OnUserApprove(Network.Connection connection) {
            // Override whatever there is
            originalNames[connection.userid.ToString()] = connection.username;
        }

        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player) {
            string originalName;
            if (originalNames.TryGetValue(player.userID.ToString(), out originalName))
                player.displayName = originalName;
            try {
                SetupPlayer(player);
                var clan = FindClanByUser(player.userID.ToString());
                if (clan != null)
                    clan.Broadcast(_("%NAME% has come online!", new Dictionary<string, string>() { { "NAME", StripTag(player.displayName, clan) } }));
            } catch (Exception ex) {
                Error("OnPlayerInit failed: " + ex.Message);
            }
        }

        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player) {
            try {
                var clan = FindClanByUser(player.userID.ToString());
                if (clan != null)
                    clan.Broadcast(_("%NAME% has gone offline.", new Dictionary<string, string>() { { "NAME", StripTag(player.displayName, clan) } }));
            } catch (Exception ex) {
                Error("OnPlayerDisconnected failed: " + ex.Message);
            }
        }

        [HookMethod("Unload")]
        void OnUnload() {
            try {
                // Reset player names to originals
                foreach (var pair in originalNames) {
                    var playerId = Convert.ToUInt64(pair.Key);
                    var player = BasePlayer.FindByID(playerId);
                    if (player != null)
                        player.displayName = pair.Value;
                    else {
                        player = BasePlayer.FindSleeping(playerId);
                        if (player != null)
                            player.displayName = pair.Value;
                    }
                }
            } catch (Exception ex) {
                Error("Unload failed: " + ex.Message);
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>Clans</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/clan</color> - Displays your current clan status")).Append("\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/clan help</color> - Learn how to create or join a clan"));
            player.ChatMessage(sb.ToString());
        }

        [HookMethod("BuildServerTags")]
        private void BuildServerTags(IList<string> taglist) {
            taglist.Add("clans");
        }

        [ChatCommand("clan")]
        private void cmdChatClan(BasePlayer player, string command, string[] args) {
            var userId = player.userID.ToString();
            var myClan = FindClanByUser(userId);
            var sb = new StringBuilder();
            // No arguments: List clans and get help how to create one
            if (args.Length == 0) {
                sb.Append("<size=22>Clans</size> "+Version+" by <color=#ce422b>http://playrust.io</color>\n");
                if (myClan == null) {
                    sb.Append(_("You are currently not a member of a clan.")).Append("\n");
                } else {
                    if (myClan.IsOwner(userId)) {
                        sb.Append(_("You are the owner of:"));
                    } else if (myClan.IsModerator(userId))
                        sb.Append(_("You are a moderator of:"));
                    else
                        sb.Append(_("You are a member of:"));
                    sb.Append(" [").Append(myClan.tag).Append("] ").Append(myClan.description).Append("\n");
                    sb.Append(_("Members online:")).Append(" ");
                    List<string> onlineMembers = new List<string>();
                    int n = 0;
                    foreach (var memberId in myClan.members) {
                        var p = BasePlayer.FindByID(Convert.ToUInt64(memberId));
                        if (p != null) {
                            if (n > 0) sb.Append(", ");
                            if (myClan.IsOwner(memberId)) {
                                sb.Append("<color=#a1ff46>").Append(StripTag(p.displayName, myClan)).Append("</color>");
                            } else if (myClan.IsModerator(memberId)) {
                                sb.Append("<color=#74c6ff>").Append(StripTag(p.displayName, myClan)).Append("</color>");
                            } else {
                                sb.Append(p.displayName);
                            }
                            ++n;
                        }
                    }
                    sb.Append("\n");
                    if ((myClan.IsOwner(userId) || myClan.IsModerator(userId)) && myClan.invited.Count > 0) {
                        sb.Append(_("Pending invites:")).Append(" ");
                        int m = 0;
                        foreach (var inviteId in myClan.invited) {
                            var p = BasePlayer.FindByID(Convert.ToUInt64(inviteId));
                            if (p != null) {
                                if (m > 0) sb.Append(", ");
                                sb.Append(p.displayName);
                                ++m;
                            }
                        }
                        sb.Append("\n");
                    }
                }
                sb.Append(_("To learn more about clans, type: <color=\"#ffd479\">/clan help</color>"));
                SendReply(player, sb.ToString());
                return;
            }
            switch (args[0]) {
                case "create":
                    if (args.Length != 3) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan create \"TAG\" \"Description\"</color>"));
                        break;
                    }
                    if (myClan != null) {
                        sb.Append(_("You are already a member of a clan."));
                        break;
                    }
                    if (!tagRe.IsMatch(args[1])) {
                        sb.Append(_("Clan tags must be 2 to 6 characters long and may contain standard letters and numbers only"));
                        break;
                    }
                    args[2] = args[2].Trim();
                    if (args[2].Length < 2 || args[2].Length > 30) {
                        sb.Append(_("Please provide a short description of your clan."));
                        break;
                    }
                    if (clans.ContainsKey(args[1])) {
                        sb.Append(_("There is already a clan with this tag."));
                        break;
                    }
                    myClan = Clan.Create(args[1], args[2], userId);
                    clans.Add(myClan.tag, myClan);
                    SaveData();
                    SetupPlayer(player); // Add clan tag
                    sb.Append(_("You are now the owner of your new clan:")).Append(" ");
                    sb.Append("[").Append(myClan.tag).Append("] ").Append(myClan.description).Append("\n");
                    sb.Append(_("To invite new members, type: <color=\"#ffd479\">/clan invite \"Player name\"</color>"));
                    break;
                case "invite":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan invite \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId) && !myClan.IsModerator(userId)) {
                        sb.Append(_("You need to be a moderator of your clan to use this command."));
                        break;
                    }
                    var invPlayer = FindPlayerByPartialName(args[1]);
                    if (invPlayer == null) {
                        sb.Append(_("No such player or player name not unique:")).Append(" ").Append(args[1]);
                        break;
                    }
                    var invUserId = invPlayer.userID.ToString();
                    if (myClan.members.Contains(invUserId)) {
                        sb.Append(_("This player is already a member of your clan:")).Append(" ").Append(invPlayer.displayName);
                        break;
                    }
                    if (myClan.invited.Contains(invUserId)) {
                        sb.Append(_("This player has already been invited to your clan:")).Append(" ").Append(invPlayer.displayName);
                        break;
                    }
                    myClan.invited.Add(invUserId);
                    SaveData();
                    myClan.Broadcast(_("%MEMBER% invited %PLAYER% to the clan.", new Dictionary<string,string>() { {"MEMBER",StripTag(player.displayName, myClan)}, {"PLAYER",invPlayer.displayName}}));
                    invPlayer.SendConsoleCommand("chat.add", "", 
                        _("You have been invited to join the clan:") + " [" + myClan.tag + "] " + myClan.description + "\n"+
                        _("To join, type: <color=#ffd479>/clan join \"%TAG%\"</color>", new Dictionary<string,string>() {{"TAG",myClan.tag}}));
                    break;
                case "join":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan join \"TAG\"</color>"));
                        break;
                    }
                    if (myClan != null) {
                        sb.Append(_("You are already a member of a clan."));
                        break;
                    }
                    myClan = FindClan(args[1]);
                    if (myClan == null || !myClan.IsInvited(userId)) {
                        sb.Append(_("You have not been invited to join this clan."));
                        break;
                    }
                    myClan.invited.Remove(userId);
                    myClan.members.Add(userId);
                    SaveData();
                    SetupPlayer(player);
                    myClan.Broadcast(_("%NAME% has joined the clan!", new Dictionary<string,string>() {{"NAME",StripTag(player.displayName,myClan)}}));
                    foreach (var memberId in myClan.members) {
                        if (memberId != userId && IsInstalled()) {
                            AddFriend(memberId, userId);
                            AddFriend(userId, memberId);
                        }
                    }
                    break;
                case "promote":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan promote \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    var promotePlayer = FindPlayerByPartialName(args[1]);
                    if (promotePlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var promotePlayerUserId = promotePlayer.userID.ToString();
                    if (!myClan.IsMember(promotePlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + promotePlayer.displayName);
                        break;
                    }
                    if (myClan.IsModerator(promotePlayerUserId)) {
                        sb.Append(_("This player is already a moderator of your clan:") + " " + promotePlayer.displayName);
                        break;
                    }
                    myClan.moderators.Add(promotePlayerUserId);
                    SaveData();
                    myClan.Broadcast(_("%OWNER% promoted %MEMBER% to moderator.", new Dictionary<string,string>() {{"OWNER",StripTag(player.displayName,myClan)}, {"MEMBER",StripTag(promotePlayer.displayName,myClan)}}));
                    break;
                case "demote":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan demote \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    var demotePlayer = FindPlayerByPartialName(args[1]);
                    if (demotePlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var demotePlayerUserId = demotePlayer.userID.ToString();
                    if (!myClan.IsMember(demotePlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + demotePlayer.displayName);
                        break;
                    }
                    if (!myClan.IsModerator(demotePlayerUserId)) {
                        sb.Append(_("This player is not a moderator of your clan:") + " " + demotePlayer.displayName);
                        break;
                    }
                    myClan.moderators.Remove(demotePlayerUserId);
                    SaveData();
                    myClan.Broadcast(player.displayName + " demoted " + demotePlayer.displayName + " to a member");
                    break;
                case "leave":
                    if (args.Length != 1) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan leave</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (myClan.members.Count == 1) { // Remove the clan once the last member leaves
                        clans.Remove(myClan.tag);
                    } else {
                        myClan.moderators.Remove(userId);
                        myClan.members.Remove(userId);
                        myClan.invited.Remove(userId);
                        if (myClan.IsOwner(userId) && myClan.members.Count > 0) { // Make the first member the new owner
                            myClan.owner = myClan.members[0];
                        }
                    }
                    SaveData();
                    SetupPlayer(player); // Remove clan tag
                    sb.Append(_("You have left your current clan."));
                    myClan.Broadcast(_("%NAME% has left the clan.", new Dictionary<string,string>() {{"NAME", player.displayName}}));
                    break;
                case "kick":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan kick \"Player name\"</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId) && !myClan.IsModerator(userId)) {
                        sb.Append(_("You need to be a moderator of your clan to use this command."));
                        break;
                    }
                    var kickPlayer = FindPlayerByPartialName(args[1]);
                    if (kickPlayer == null) {
                        sb.Append(_("No such player or player name not unique:") + " " + args[1]);
                        break;
                    }
                    var kickPlayerUserId = kickPlayer.userID.ToString();
                    if (!myClan.IsMember(kickPlayerUserId) && !myClan.IsInvited(kickPlayerUserId)) {
                        sb.Append(_("This player is not a member of your clan:") + " " + kickPlayer.displayName);
                        break;
                    }
                    if (myClan.IsOwner(kickPlayerUserId) || myClan.IsModerator(kickPlayerUserId)) {
                        sb.Append(_("This player is an owner or moderator and cannot be kicked:") + " " + kickPlayer.displayName);
                        break;
                    }
                    myClan.members.Remove(kickPlayerUserId);
                    myClan.invited.Remove(kickPlayerUserId);
                    SaveData();
                    SetupPlayer(kickPlayer); // Remove clan tag
                    myClan.Broadcast(_("%NAME% kicked %MEMBER% from the clan.", new Dictionary<string,string>() {{"NAME",StripTag(player.displayName,myClan)},{"MEMBER",kickPlayer.displayName}}));
                    break;
                case "disband":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan disband forever</color>"));
                        break;
                    }
                    if (myClan == null) {
                        sb.Append(_("You are currently not a member of a clan."));
                        break;
                    }
                    if (!myClan.IsOwner(userId)) {
                        sb.Append(_("You need to be the owner of your clan to use this command."));
                        break;
                    }
                    clans.Remove(myClan.tag);
                    SaveData();
                    myClan.Broadcast(_("Your current clan has been disbanded forever."));
                    SetupPlayers(myClan.members); // Remove clan tags
                    break;
                case "delete":
                    if (args.Length != 2) {
                        sb.Append(_("Usage: <color=\"#ffd479\">/clan delete \"TAG\"</color>"));
                        break;
                    }
                    if (player.net.connection.authLevel < 2) {
                        sb.Append(_("You need to be a server owner to delete clans."));
                        break;
                    }
                    Clan clan;
                    if (!clans.TryGetValue(args[1], out clan)) {
                        sb.Append(_("There is no clan with that tag:")).Append(" ").Append(args[1]);
                        break;
                    }
                    clan.Broadcast(_("Your clan has been deleted by the server owner."));
                    clans.Remove(args[1]);
                    SaveData();
                    SetupPlayers(clan.members);
                    sb.Append(_("You have deleted the clan:")).Append(" [").Append(clan.tag).Append("] ").Append(clan.description);
                    break;
                default:
                    sb.Append(_("Available commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan</color> - Displays relevant information about your current clan")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/c Message...</color> - Sends a message to all online clan members")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan create \"TAG\" \"Description\"</color> - Creates a new clan you own")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan join \"TAG\"</color> - Joins a clan you have been invited to")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan leave</color> - Leaves your current clan")).Append("\n");
                    sb.Append(_("<color=#74c6ff>Moderator</color> commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan invite \"Player name\"</color> - Invites a player to your clan")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan kick \"Player name\"</color> - Kicks a member from your clan")).Append("\n");
                    sb.Append(_("<color=#a1ff46>Owner</color> commands:")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan promote \"Name\"</color> - Promotes a member to moderator")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan demote \"Name\"</color> - Demotes a moderator to member")).Append("\n");
                    sb.Append("  ").Append(_("<color=#ffd479>/clan disband forever</color> - Disbands your clan (no undo)")).Append("\n");
                    if (player.net.connection.authLevel >= 2) {
                        sb.Append(_("<color=#cd422b>Server owner</color> commands:")).Append("\n");
                        sb.Append("  ").Append(_("<color=#ffd479>/clan delete \"TAG\"</color> - Deletes a clan (no undo)")).Append("\n");
                    }
                    break;
            }
            SendReply(player, sb.ToString().TrimEnd());
        }

        [ChatCommand("c")]
        private void cmdChatClanchat(BasePlayer player, string command, string[] args) {
            var myClan = FindClanByUser(player.userID.ToString());
            if (myClan == null) {
                SendReply(player, _("You are currently not a member of a clan."));
                return;
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message))
                return;
            myClan.Broadcast(StripTag(player.displayName, myClan) + ": " + message);
        }

        // Represents a clan
        public class Clan
        {
            public string tag;
            public string description;
            public string owner;
            public List<string> moderators = new List<string>();
            public List<string> members = new List<string>();
            public List<string> invited = new List<string>();

            public static Clan Create(string tag, string description, string ownerId) {
                var clan = new Clan() { tag = tag, description = description, owner = ownerId };
                clan.members.Add(ownerId);
                return clan;
            }

            public bool IsOwner(string userId) {
                return userId == owner;
            }

            public bool IsModerator(string userId) {
                return moderators.Contains(userId);
            }

            public bool IsMember(string userId) {
                return members.Contains(userId);
            }

            public bool IsInvited(string userId) {
                return invited.Contains(userId);
            }

            public void Broadcast(string message) {
                foreach (var memberId in members) {
                    var player = BasePlayer.FindByID(Convert.ToUInt64(memberId));
                    if (player == null)
                        continue;
                    player.SendConsoleCommand("chat.add", "", "<color=#a1ff46>(CLAN)</color> " + message);
                }
            }
        }

        #region Utility Methods

        private void Log(string message) {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message) {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message) {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\ConstructionConfig.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

using System.Collections.Generic;
using System.Linq;

using Rust;

using System;
using System.IO;

using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

using JSONObject = JSON.Object;
using JSONArray = JSON.Array;
using JSONValue = JSON.Value;
using JSONValueType = JSON.ValueType;

namespace Oxide.Plugins
{
    [Info("ConstructionConfig", "Nogrod", "1.0.1", ResourceId = 859)]
    class ConstructionConfig : RustPlugin
    {
        private string _configpath = "";

        void Loaded()
        {
            _configpath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
        }

        void LoadDefaultConfig()
        {

        }

        private static JSONObject ToJsonObject(object obj)
        {
            return JSONObject.Parse(ToJsonString(obj));
        }

        private static JSONArray ToJsonArray(object obj)
        {
            return JSONArray.Parse(ToJsonString(obj));
        }

        private static string ToJsonString(object obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings
            {
                ContractResolver = new DynamicContractResolver(),
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                Converters = new List<JsonConverter> { new Newtonsoft.Json.Converters.StringEnumConverter() }
            });
        }

        private static void StripObject(JSONObject obj)
        {
            if (obj == null) return;
            var keys = obj.Select(entry => entry.Key).ToList();
            foreach (var key in keys)
            {
                if (!key.Equals("shortname") && !key.Equals("itemid"))
                    obj.Remove(key);
            }
        }

        private static void StripArray(JSONArray arr, string key)
        {
            if (arr == null) return;
            foreach (var obj in arr)
            {
                StripObject(obj.Obj[key].Obj);
            }
        }

        private bool CreateDefaultConfig()
        {
            Config.Clear();
            Config["Version"] = Protocol.network;
            var constructions = new Dictionary<string, object>();
            Config["Constructions"] = constructions;
            var protectionProperties = new HashSet<ProtectionProperties>();
            var constructionPrefabs = PrefabAttribute.server.GetAll<Construction>();
            foreach (var construct in constructionPrefabs)
            {
                var construction = new Dictionary<string, object>();
                var grades = new Dictionary<string, object>();
                construction["costMultiplier"] = construct.costMultiplier;
                construction["healthMultiplier"] = construct.healthMultiplier;
                for (var g = 0; g < construct.grades.Length; g++)
                {
                    var grade = construct.grades[g];
                    if (grade == null) continue;
                    var dict = new Dictionary<string, object>();
                    dict["baseHealth"] = grade.gradeBase.baseHealth;
                    var costToBuild = ToJsonArray(grade.gradeBase.baseCost);
                    foreach (var cost in costToBuild)
                    {
                        cost.Obj["itemDef"] = cost.Obj.GetObject("itemDef").GetString("shortname", "unnamed");
                    }
                    dict["baseCost"] = JsonObjectToObject(costToBuild);
                    if (grade.gradeBase.damageProtecton != null)
                    {
                        protectionProperties.Add(grade.gradeBase.damageProtecton);
                    }
                    grades[((BuildingGrade.Enum)g).ToString()] = dict;
                }
                construction["grades"] = grades;
                constructions[construct.hierachyName] = construction;
            }
            var protections = new Dictionary<string, object>();
            Config["DamageProtections"] = protections;
            foreach (var protectionProperty in protectionProperties)
            {
                var damageProtection = new Dictionary<string, object>();
                for (var i = 0; i < protectionProperty.amounts.Length; i++)
                {
                    damageProtection[Enum.GetName(typeof(DamageType), i)] = protectionProperty.amounts[i];
                }
                protections[protectionProperty.name] = damageProtection;
            }
            try
            {
                Config.Save(_configpath);
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            LocalPuts("Created new config");
            return LoadConfig();
        }

        private bool LoadConfig()
        {
            try
            {
                Config.Load(_configpath);
            }
            catch (FileNotFoundException)
            {
                return CreateDefaultConfig();
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            return true;
        }

        private void CheckConfig()
        {
            if (Config["Version"] != null && (int)Config["Version"] == Protocol.network) return;
            LocalPuts("Incorrect config version(" + Config["Version"] + ") move to .old");
            Config.Save(string.Format("{0}.old", _configpath));
            CreateDefaultConfig();
        }

        void OnServerInitialized()
        {
            if (!LoadConfig())
                return;
            CheckConfig();
            UpdateConstructions();
        }

        private void UpdateConstructions()
        {
            var constructions = Config["Constructions"] as Dictionary<string, object>;
            if (constructions == null)
            {
                LocalPuts("No constructions in config");
                return;
            }
            var oldGrades = new HashSet<BuildingGrade>();
            var protectionProperties = new HashSet<ProtectionProperties>();
            var constructionPrefabs = PrefabAttribute.server.GetAll<Construction>();
            var manager = SingletonComponent<ItemManager>.Instance;
            foreach (var common in constructionPrefabs)
            {
                if (constructions[common.hierachyName] == null)
                {
                    LocalPuts(common.hierachyName + " doesn't exist in config");
                    continue;
                }
                var construction = ObjectToJsonObject(constructions[common.hierachyName]);
                common.costMultiplier = construction.Obj.GetFloat("costMultiplier", 0);
                var healthChanged = common.healthMultiplier != construction.Obj.GetFloat("healthMultiplier", 0);
                common.healthMultiplier = construction.Obj.GetFloat("healthMultiplier", 0);
                var grades = construction.Obj.GetObject("grades");
                for (var g = 0; g < common.grades.Length; g++)
                {
                    var gradeType = (BuildingGrade.Enum) g;
                    if (!grades.ContainsKey(gradeType.ToString()))
                    {
                        common.grades[g] = null;
                        continue;
                    }
                    if (common.grades[g] == null)
                    {
                        LocalPuts("Can't create grade: " + gradeType + " for: " + common.hierachyName);
                        continue;
                    }
                    var grade = UnityEngine.Object.Instantiate(common.grades[g].gradeBase);
                    grade.name = grade.name.Replace("(Clone)", "");
                    oldGrades.Add(common.grades[g].gradeBase);
                    common.grades[g].gradeBase = grade;
                    var newGrade = grades.GetObject(gradeType.ToString());
                    UpdateConstructionHealth(grade, newGrade.GetFloat("baseHealth", 0), healthChanged);
                    grade.baseCost.Clear();
                    var costToBuild = newGrade.GetArray("baseCost");
                    foreach (var cost in costToBuild)
                    {
                        var itemid = cost.Obj.GetInt("itemid", 0);
                        var definition = manager.itemList.Find(x => x.itemid == itemid);
                        grade.baseCost.Add(new ItemAmount(definition, cost.Obj.GetFloat("amount", 0)));
                    }
                    if (grade.damageProtecton != null)
                    {
                        protectionProperties.Add(grade.damageProtecton);
                    }
                }
            }
            foreach (var oldGrade in oldGrades)
            {
                UnityEngine.Object.Destroy(oldGrade);
            }
            var protections = Config["DamageProtections"] as Dictionary<string, object>;
            if (protections == null)
                return;
            foreach (var protectionProperty in protectionProperties)
            {
                protectionProperty.Clear();
                var damageProtection = protections[protectionProperty.name] as Dictionary<string, object>;
                if (damageProtection == null) continue;
                foreach (var o in damageProtection)
                {
                    protectionProperty.Add((DamageType) Enum.Parse(typeof (DamageType), o.Key), (float)Convert.ToDouble(o.Value));
                }
            }
        }

        private void UpdateConstructionHealth(BuildingGrade grade, float newHealth, bool healthChanged)
        {
            if (!healthChanged && grade.baseHealth == newHealth) return;
            grade.baseHealth = newHealth;
            var bb = UnityEngine.Object.FindObjectsOfType<BuildingBlock>().Where(b => b.currentGrade.gradeBase == grade);
            foreach (var buildingBlock in bb)
            {
                buildingBlock.SetHealthToMax();
            }
        }

        private JSONValue ObjectToJsonObject(object obj)
        {
            if (obj == null)
            {
                return new JSONValue(JSONValueType.Null);
            }
            if (obj is string)
            {
                return new JSONValue((string)obj);
            }
            if (obj is double)
            {
                return new JSONValue((double)obj);
            }
            if (obj is int)
            {
                return new JSONValue((int)obj);
            }
            if (obj is bool)
            {
                return new JSONValue((bool)obj);
            }
            var dict = obj as Dictionary<string, object>;
            if (dict != null)
            {
                var newObj = new JSONObject();
                foreach (var prop in dict)
                {
                    newObj.Add(prop.Key, ObjectToJsonObject(prop.Value));
                }
                return newObj;
            }
            var list = obj as List<object>;
            if (list != null)
            {
                var arr = new JSONArray();
                foreach (var o in list)
                {
                    arr.Add(ObjectToJsonObject(o));
                }
                return arr;
            }
            LocalPuts("Unknown: " + obj.GetType().FullName + " Value: " + obj);
            return new JSONValue(JSONValueType.Null);
        }

        private object JsonObjectToObject(JSONValue obj)
        {
            switch (obj.Type)
            {
                case JSONValueType.String:
                    return obj.Str;
                case JSONValueType.Number:
                    return obj.Number;
                case JSONValueType.Boolean:
                    return obj.Boolean;
                case JSONValueType.Null:
                    return null;
                case JSONValueType.Array:
                    return obj.Array.Select(v => JsonObjectToObject(v.Obj)).ToList();
                case JSONValueType.Object:
                    var dict = new Dictionary<string, object>();
                    foreach (var prop in obj.Obj)
                    {
                        dict[prop.Key] = JsonObjectToObject(prop.Value);
                    }
                    return dict;
                default:
                    LocalPuts("Missing type: " + obj.Type);
                    break;
            }
            return null;
        }

        private void LocalPuts(string msg)
        {
            Puts("{0}: {1}", Title, msg);
        }

        [ConsoleCommand("construction.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            if (!LoadConfig())
                return;
            CheckConfig();
            UpdateConstructions();
            LocalPuts("Config reloaded.");
        }

        [ConsoleCommand("construction.reset")]
        void cmdConsoleReset(ConsoleSystem.Arg arg)
        {
            if (!CreateDefaultConfig())
                return;
            UpdateConstructions();
        }

        class DynamicContractResolver : DefaultContractResolver
        {
            private static bool IsAllowed(JsonProperty property)
            {
                return property.PropertyType.IsPrimitive ||
                        property.PropertyType == typeof(List<ItemAmount>) ||
                        property.PropertyType == typeof(ItemDefinition) ||
                        property.PropertyType == typeof(BuildingGrade) ||
                        property.PropertyType == typeof(ConstructionGrade) ||
                        property.PropertyType == typeof(String);
            }

            protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
            {
                var properties = base.CreateProperties(type, memberSerialization);
                return properties.Where(p => p.DeclaringType == type && IsAllowed(p)).ToList();
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\CopyPaste.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Copy Paste", "Reneb", "2.2.3")]
    class CopyPaste : RustPlugin
    {
        private MethodInfo inventoryClear = typeof(ItemContainer).GetMethod("Clear", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo serverinput = typeof(BasePlayer).GetField("serverInput", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo keycode = typeof(KeyLock).GetField("keyCode", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo codelock = typeof(CodeLock).GetField("code", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo firstKeyCreated = typeof(KeyLock).GetField("firstKeyCreated", BindingFlags.NonPublic | BindingFlags.Instance);
        private Dictionary<string, string> deployedToItem = new Dictionary<string, string>();
        private int layerMasks = LayerMask.GetMask("Construction", "Construction Trigger", "Trigger", "Deployed", "Tree", "AI");

        /// CACHED VARIABLES

        private Vector3 transformedPos;
        private Vector3 normedPos;
        private Quaternion currentRot;
        private float normedYRot;
        private float newX;
        private float newZ;
        private Dictionary<string, object> posCleanData;
        private Dictionary<string, object> rotCleanData;
        private List<object> rawStructure;
        private List<object> rawDeployables;
        private List<object> rawSpawnables;
        private float heightAdjustment;
        private string filename;
        private object closestEnt;
        private Vector3 closestHitpoint;
        private string cleanDeployedName;

        void OnServerInitialized()
        {
            var allItemsDef = Resources.FindObjectsOfTypeAll<ItemDefinition>();
            foreach (ItemDefinition itemDef in allItemsDef)
            {
                if (itemDef.GetComponent<ItemModDeployable>() != null)
                {
                    deployedToItem.Add(itemDef.GetComponent<ItemModDeployable>().entityPrefab.targetObject.gameObject.name.ToString(), itemDef.shortname.ToString());
                }
            }
        }

        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
            {
                if (hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }
            if (closestEnt is bool)
                return false;
            return true;
        }

        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return false;
            }
            return true;
        }

        bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null || input.current == null || input.current.aimAngles == Vector3.zero)
                return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        Vector3 GenerateGoodPos(Vector3 InitialPos, Vector3 CurrentPos, float diffRot)
        {
            transformedPos = CurrentPos - InitialPos;
            newX = (transformedPos.x * (float)Math.Cos(-diffRot)) + (transformedPos.z * (float)Math.Sin(-diffRot));
            newZ = (transformedPos.z * (float)Math.Cos(-diffRot)) - (transformedPos.x * (float)Math.Sin(-diffRot));
            transformedPos.x = newX;
            transformedPos.z = newZ;
            return transformedPos;
        }

        bool GetStructureClean(BuildingBlock initialBlock, float playerRot, BuildingBlock currentBlock, out Dictionary<string, object> data)
        {
            data = new Dictionary<string, object>();
            posCleanData = new Dictionary<string, object>();
            rotCleanData = new Dictionary<string, object>();

            normedPos = GenerateGoodPos(initialBlock.transform.position, currentBlock.transform.position, playerRot);
            normedYRot = currentBlock.transform.rotation.ToEulerAngles().y - playerRot;

            data.Add("prefabname", currentBlock.blockDefinition.fullName);
            data.Add("grade", currentBlock.grade);

            posCleanData.Add("x", normedPos.x);
            posCleanData.Add("y", normedPos.y);
            posCleanData.Add("z", normedPos.z);
            data.Add("pos", posCleanData);

            rotCleanData.Add("x", currentBlock.transform.rotation.ToEulerAngles().x);
            rotCleanData.Add("y", normedYRot);
            rotCleanData.Add("z", currentBlock.transform.rotation.ToEulerAngles().z);
            data.Add("rot", rotCleanData);
            return true;
        }

        bool GetDeployableClean(BuildingBlock initialBlock, float playerRot, Deployable currentBlock, out Dictionary<string, object> data)
        {
            data = new Dictionary<string, object>();
            posCleanData = new Dictionary<string, object>();
            rotCleanData = new Dictionary<string, object>();

            normedPos = GenerateGoodPos(initialBlock.transform.position, currentBlock.transform.position, playerRot);
            normedYRot = currentBlock.transform.rotation.ToEulerAngles().y - playerRot;
            data.Add("prefabname", StringPool.Get(currentBlock.prefabID).ToString());

            posCleanData.Add("x", normedPos.x);
            posCleanData.Add("y", normedPos.y);
            posCleanData.Add("z", normedPos.z);
            data.Add("pos", posCleanData);

            rotCleanData.Add("x", currentBlock.transform.rotation.ToEulerAngles().x);
            rotCleanData.Add("y", normedYRot);
            rotCleanData.Add("z", currentBlock.transform.rotation.ToEulerAngles().z);
            data.Add("rot", rotCleanData);
            return true;
        }

        bool GetSpawnableClean(BuildingBlock initialBlock, float playerRot, Spawnable currentSpawn, out Dictionary<string, object> data)
        {
            data = new Dictionary<string, object>();
            posCleanData = new Dictionary<string, object>();
            rotCleanData = new Dictionary<string, object>();

            normedPos = GenerateGoodPos(initialBlock.transform.position, currentSpawn.transform.position, playerRot);
            normedYRot = currentSpawn.transform.rotation.ToEulerAngles().y - playerRot;
            data.Add("prefabname", currentSpawn.GetComponent<BaseNetworkable>().LookupPrefabName().ToString());

            posCleanData.Add("x", normedPos.x);
            posCleanData.Add("y", normedPos.y);
            posCleanData.Add("z", normedPos.z);
            data.Add("pos", posCleanData);

            rotCleanData.Add("x", currentSpawn.transform.rotation.ToEulerAngles().x);
            rotCleanData.Add("y", normedYRot);
            rotCleanData.Add("z", currentSpawn.transform.rotation.ToEulerAngles().z);
            data.Add("rot", rotCleanData);
            return true;
        }

        object CopyBuilding(Vector3 playerPos, float playerRot, BuildingBlock initialBlock, out List<object> rawStructure, out List<object> rawDeployables, out List<object> rawSpawnables)
        {
            rawStructure = new List<object>();
            rawDeployables = new List<object>();
            rawSpawnables = new List<object>();
            List<object> houseList = new List<object>();
            List<Vector3> checkFrom = new List<Vector3>();
            BuildingBlock fbuildingblock;
            Deployable fdeployable;
            Spawnable fspawnable;

            houseList.Add(initialBlock);
            checkFrom.Add(initialBlock.transform.position);

            Dictionary<string, object> housedata;
            if (!GetStructureClean(initialBlock, playerRot, initialBlock, out housedata))
            {
                return "Couldn't get a clean initial block";
            }
            if (initialBlock.HasSlot(BaseEntity.Slot.Lock)) // initial block could be a door.
                TryCopyLock(initialBlock, housedata);
            rawStructure.Add(housedata);

            int current = 0;
            while (true)
            {
                current++;
                if (current > checkFrom.Count)
                    break;
                var hits = Physics.OverlapSphere(checkFrom[current - 1], 3f, layerMasks);
                foreach (var hit in hits)
                {
                    if (hit.GetComponentInParent<BuildingBlock>() != null)
                    {
                        fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                        if (!(houseList.Contains(fbuildingblock)))
                        {
                            houseList.Add(fbuildingblock);
                            checkFrom.Add(fbuildingblock.transform.position);
                            if (GetStructureClean(initialBlock, playerRot, fbuildingblock, out housedata))
                            {

                                if (fbuildingblock.HasSlot(BaseEntity.Slot.Lock))
                                    TryCopyLock(fbuildingblock, housedata);
                                rawStructure.Add(housedata);
                            }
                        }
                    }
                    else if (hit.GetComponentInParent<Deployable>() != null)
                    {
                        fdeployable = hit.GetComponentInParent<Deployable>();
                        if (!(houseList.Contains(fdeployable)))
                        {
                            houseList.Add(fdeployable);
                            checkFrom.Add(fdeployable.transform.position);
                            if (GetDeployableClean(initialBlock, playerRot, fdeployable, out housedata))
                            {
                                if (fdeployable.GetComponent<StorageContainer>())
                                {
                                    var box = fdeployable.GetComponent<StorageContainer>();
                                    var itemlist = new List<object>();
                                    foreach (Item item in box.inventory.itemList)
                                    {
                                        var newitem = new Dictionary<string, object>();
                                        newitem.Add("blueprint", item.isBlueprint.ToString());
                                        newitem.Add("id", item.info.itemid.ToString());
                                        newitem.Add("amount", item.amount.ToString());
                                        itemlist.Add(newitem);
                                    }
                                    housedata.Add("items", itemlist);

                                    if (box.HasSlot(BaseEntity.Slot.Lock))
                                        TryCopyLock(box, housedata);
                                }
                                else if (fdeployable.GetComponent<Signage>())
                                {
                                    var signage = fdeployable.GetComponent<Signage>();
                                    var sign = new Dictionary<string, object>();
                                    sign.Add("text", signage.text);
                                    sign.Add("locked", signage.IsLocked());
                                    housedata.Add("sign", sign);
                                }
                                rawDeployables.Add(housedata);
                            }
                        }
                    }
                    else if (hit.GetComponentInParent<Spawnable>() != null)
                    {
                        fspawnable = hit.GetComponentInParent<Spawnable>();
                        if (!(houseList.Contains(fspawnable)))
                        {
                            houseList.Add(fspawnable);
                            checkFrom.Add(fspawnable.transform.position);
                            if (GetSpawnableClean(initialBlock, playerRot, fspawnable, out housedata))
                            {
                                rawSpawnables.Add(housedata);
                            }
                        }
                    }
                }
            }
            return true;
        }
        
        [ChatCommand("copy")]
        void cmdChatCopy(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;

            if (args == null || args.Length == 0)
            {
                SendReply(player, "You need to set the name of the copy file: /copy NAME");
                return;
            }

            // Get player camera view directly from the player
            if (!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't find your eyes");
                return;
            }

            // Get what the player is looking at
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint))
            {
                SendReply(player, "Couldn't find any Entity");
                return;
            }

            // Check if what the player is looking at is a collider
            var baseentity = closestEnt as Collider;
            if (baseentity == null)
            {
                SendReply(player, "You are not looking at a Structure, or something is blocking the view.");
                return;
            }

            // Check if what the player is looking at is a BuildingBlock (like a wall or something like that)
            var buildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            if (buildingblock == null)
            {
                SendReply(player, "You are not looking at a Structure, or something is blocking the view.");
                return;
            }

            var returncopy = CopyBuilding(player.transform.position, currentRot.ToEulerAngles().y, buildingblock, out rawStructure, out rawDeployables, out rawSpawnables);
            if (returncopy is string)
            {
                SendReply(player, (string)returncopy);
                return;
            }

            if (rawStructure.Count == 0)
            {
                SendReply(player, "Something went wrong, house is empty?");
                return;
            }

            Dictionary<string, object> defaultValues = new Dictionary<string, object>();

            Dictionary<string, object> defaultPos = new Dictionary<string, object>();
            defaultPos.Add("x", buildingblock.transform.position.x);
            defaultPos.Add("y", buildingblock.transform.position.y);
            defaultPos.Add("z", buildingblock.transform.position.z);
            defaultValues.Add("position", defaultPos);
            defaultValues.Add("yrotation", buildingblock.transform.rotation.ToEulerAngles().y);

            filename = string.Format("copypaste-{0}", args[0].ToString());
            Core.Configuration.DynamicConfigFile CopyData = Interface.GetMod().DataFileSystem.GetDatafile(filename);
            CopyData.Clear();
            CopyData["structure"] = rawStructure;
            CopyData["deployables"] = rawDeployables;
            CopyData["spawnables"] = rawSpawnables;
            CopyData["default"] = defaultValues;


            Interface.GetMod().DataFileSystem.SaveDatafile(filename);

            SendReply(player, string.Format("The house {0} was successfully saved", args[0].ToString()));
            SendReply(player, string.Format("{0} building parts detected", rawStructure.Count.ToString()));
            SendReply(player, string.Format("{0} deployables detected", rawDeployables.Count.ToString()));
            SendReply(player, string.Format("{0} spawnables detected", rawSpawnables.Count.ToString()));
        }

        [ChatCommand("paste")]
        void cmdChatPaste(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, "You need to set the name of the copy file: /paste NAME optional:HeightAdjustment");
                return;
            }

            // Adjust height so you don't automatically paste in the ground
            heightAdjustment = 0.5f;
            if (args.Length > 1)
            {
                float.TryParse(args[1].ToString(), out heightAdjustment);
            }

            // Get player camera view directly from the player
            if (!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't find your eyes");
                return;
            }

            // Get what the player is looking at
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint))
            {
                SendReply(player, "Couldn't find any Entity");
                return;
            }

            // Check if what the player is looking at is a collider
            var baseentity = closestEnt as Collider;
            if (baseentity == null)
            {
                SendReply(player, "You are not looking at a Structure, or something is blocking the view.");
                return;
            }
            closestHitpoint.y = closestHitpoint.y + heightAdjustment;

            filename = string.Format("copypaste-{0}", args[0].ToString());
            Core.Configuration.DynamicConfigFile PasteData = Interface.GetMod().DataFileSystem.GetDatafile(filename);
            if (PasteData["structure"] == null || PasteData["default"] == null)
            {
                SendReply(player, "This is not a correct copypaste file, or it's empty.");
                return;
            }
            List<object> structureData = PasteData["structure"] as List<object>;
            List<object> deployablesData = PasteData["deployables"] as List<object>;
            List<object> spawnablesData = PasteData["spawnables"] as List<object>;

            PasteBuilding(structureData, closestHitpoint, currentRot.ToEulerAngles().y, heightAdjustment);
            PasteDeployables(deployablesData, closestHitpoint, currentRot.ToEulerAngles().y, heightAdjustment, player);
            PasteSpawnables(spawnablesData, closestHitpoint, currentRot.ToEulerAngles().y, heightAdjustment, player);
        }

        [ChatCommand("placeback")]
        void cmdChatPlaceback(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            if (args == null || args.Length == 0)
            {
                SendReply(player, "You need to set the name of the copy file: /placeback NAME");
                return;
            }
            heightAdjustment = 0;
            filename = string.Format("copypaste-{0}", args[0].ToString());

            Core.Configuration.DynamicConfigFile PasteData = Interface.GetMod().DataFileSystem.GetDatafile(filename);
            if (PasteData["structure"] == null || PasteData["default"] == null)
            {
                SendReply(player, "This is not a correct copypaste file, or it's empty.");
                return;
            }
            Dictionary<string, object> defaultData = PasteData["default"] as Dictionary<string, object>;
            Dictionary<string, object> defaultPos = defaultData["position"] as Dictionary<string, object>;
            Vector3 defaultposition = new Vector3(Convert.ToSingle(defaultPos["x"]), Convert.ToSingle(defaultPos["y"]), Convert.ToSingle(defaultPos["z"]));
            List<object> structureData = PasteData["structure"] as List<object>;
            List<object> deployablesData = PasteData["deployables"] as List<object>;

            PasteBuilding(structureData, defaultposition, Convert.ToSingle(defaultData["yrotation"]), heightAdjustment);
            PasteDeployables(deployablesData, defaultposition, Convert.ToSingle(defaultData["yrotation"]), heightAdjustment, player);
        }

        BuildingBlock SpawnStructure(GameObject prefab, Vector3 pos, Quaternion angles, BuildingGrade.Enum grade)
        {
            GameObject build = UnityEngine.Object.Instantiate(prefab);
            if (build == null) return null;
            BuildingBlock block = build.GetComponent<BuildingBlock>();
            if (block == null) return null;
            block.transform.position = pos;
            block.transform.rotation = angles;
            block.gameObject.SetActive(true);
            block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);
            block.Spawn(true);
            block.SetGrade(grade);
            block.health = block.MaxHealth();
            return block;

        }

        void SpawnDeployable(Item newitem, Vector3 pos, Quaternion angles, BasePlayer player)
        {
            if (newitem.info.GetComponent<ItemModDeployable>() == null)
            {
                return;
            }
            var deployable = newitem.info.GetComponent<ItemModDeployable>().entityPrefab.targetObject.GetComponent<Deployable>();
            if (deployable == null)
            {
                return;
            }
            var newBaseEntity = GameManager.server.CreateEntity(deployable.gameObject, pos, angles);
            if (newBaseEntity == null)
            {
                return;
            }
            newBaseEntity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
            newBaseEntity.SendMessage("InitializeItem", newitem, SendMessageOptions.DontRequireReceiver);
            newBaseEntity.Spawn(true);
        }

        void PasteBuilding(List<object> structureData, Vector3 targetPoint, float targetRot, float heightAdjustment)
        {
            Vector3 OriginRotation = new Vector3(0f, targetRot, 0f);
            Quaternion OriginRot = Quaternion.EulerRotation(OriginRotation);
            foreach (Dictionary<string, object> structure in structureData)
            {

                Dictionary<string, object> structPos = structure["pos"] as Dictionary<string, object>;
                Dictionary<string, object> structRot = structure["rot"] as Dictionary<string, object>;
                string prefabname = (string)structure["prefabname"];
                BuildingGrade.Enum grade = (BuildingGrade.Enum)structure["grade"];
                Quaternion newAngles = Quaternion.EulerRotation((new Vector3(Convert.ToSingle(structRot["x"]), Convert.ToSingle(structRot["y"]), Convert.ToSingle(structRot["z"]))) + OriginRotation);
                Vector3 TempPos = OriginRot * (new Vector3(Convert.ToSingle(structPos["x"]), Convert.ToSingle(structPos["y"]), Convert.ToSingle(structPos["z"])));
                Vector3 NewPos = TempPos + targetPoint;
                GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
                if (newPrefab != null)
                {
                    var block = SpawnStructure(newPrefab, NewPos, newAngles, grade);
                    if (block && block.HasSlot(BaseEntity.Slot.Lock))
                    {
                        TryPasteLock(block, structure);
                    }
                }
            }
        }

        void TryCopyLock(BaseCombatEntity lockableEntity, IDictionary<string, object> housedata)
        {
            var slotentity = lockableEntity.GetSlot(BaseEntity.Slot.Lock);
            if (slotentity != null)
            {
                if (slotentity.GetComponent<CodeLock>())
                {
                    housedata.Add("codelock", codelock.GetValue(slotentity.GetComponent<CodeLock>()).ToString());
                }
                else if (slotentity.GetComponent<KeyLock>())
                {
                    var code = (int)keycode.GetValue(slotentity.GetComponent<KeyLock>());
                    if ((bool)firstKeyCreated.GetValue(slotentity.GetComponent<KeyLock>()))
                        code |= 0x80;
                    housedata.Add("keycode", code.ToString());
                }
            }
        }

        void TryPasteLock(BaseCombatEntity lockableEntity, IDictionary<string, object> structure)
        {
            BaseEntity lockentity = null;
            if (structure.ContainsKey("codelock"))
            {
                lockentity = GameManager.server.CreateEntity("build/locks/lock.code", Vector3.zero, new Quaternion());
                lockentity.OnDeployed(lockableEntity);
                var code = (string)structure["codelock"];
                if (!string.IsNullOrEmpty(code))
                {
                    var @lock = lockentity.GetComponent<CodeLock>();
                    codelock.SetValue(@lock, (string)structure["codelock"]);
                    @lock.SetFlag(BaseEntity.Flags.Locked, true);
                }
            }
            else if (structure.ContainsKey("keycode"))
            {
                lockentity = GameManager.server.CreateEntity("build/locks/lock.key", Vector3.zero, new Quaternion());
                lockentity.OnDeployed(lockableEntity);
                var code = Convert.ToInt32(structure["keycode"]);
                var @lock = lockentity.GetComponent<KeyLock>();
                if ((code & 0x80) != 0)
                {
                    // Set the keycode only if that lock had keys before. Otherwise let it be random.
                    keycode.SetValue(@lock, (code & 0x7F));
                    firstKeyCreated.SetValue(@lock, true);
                    @lock.SetFlag(BaseEntity.Flags.Locked, true);
                }

            }

            if (lockentity)
            {
                lockentity.gameObject.Identity();
                lockentity.SetParent(lockableEntity, "lock");
                lockentity.Spawn(true);
                lockableEntity.SetSlot(BaseEntity.Slot.Lock, lockentity);
            }
        }

        void PasteDeployables(List<object> deployablesData, Vector3 targetPoint, float targetRot, float heightAdjustment, BasePlayer player)
        {
            Vector3 OriginRotation = new Vector3(0f, targetRot, 0f);
            Quaternion OriginRot = Quaternion.EulerRotation(OriginRotation);
            foreach (Dictionary<string, object> deployable in deployablesData)
            {

                Dictionary<string, object> structPos = deployable["pos"] as Dictionary<string, object>;
                Dictionary<string, object> structRot = deployable["rot"] as Dictionary<string, object>;
                string prefabname = (string)deployable["prefabname"];

                Quaternion newAngles = Quaternion.EulerRotation((new Vector3(Convert.ToSingle(structRot["x"]), Convert.ToSingle(structRot["y"]), Convert.ToSingle(structRot["z"]))) + OriginRotation);
                Vector3 TempPos = OriginRot * (new Vector3(Convert.ToSingle(structPos["x"]), Convert.ToSingle(structPos["y"]), Convert.ToSingle(structPos["z"])));
                Vector3 NewPos = TempPos + targetPoint;

                GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
                if (newPrefab != null)
                {
                    BaseEntity entity = GameManager.server.CreateEntity(newPrefab, NewPos, newAngles);
                    if (entity == null) return;
                    entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
                    entity.Spawn(true);
                    if (entity.GetComponent<StorageContainer>())
                    {
                        var box = entity.GetComponent<StorageContainer>();
                        inventoryClear.Invoke(box.inventory, null);
                        var items = deployable["items"] as List<object>;
                        foreach (var itemDef in items)
                        {
                            var item = itemDef as Dictionary<string, object>;
                            var i = ItemManager.CreateByItemID(Convert.ToInt32(item["id"]), Convert.ToInt32(item["amount"]), Convert.ToBoolean(item["blueprint"]));
                            i?.MoveToContainer(box.inventory);
                        }

                        if (box.HasSlot(BaseEntity.Slot.Lock))
                            TryPasteLock(box, deployable);
                    }
                    else if (entity.GetComponent<Signage>())
                    {
                        var sign = entity.GetComponent<Signage>();
                        var signData = deployable["sign"] as Dictionary<string, object>;
                        sign.text = (string)signData["text"];
                        if (Convert.ToBoolean(signData["locked"]))
                            sign.SetFlag(BaseEntity.Flags.Locked, true);
                        sign.SendNetworkUpdate();
                    }
                }
                else
                {
                    SendReply(player, prefabname);
                }

            }
        }

        void PasteSpawnables(List<object> spawnablesData, Vector3 targetPoint, float targetRot, float heightAdjustment, BasePlayer player)
        {
            if (spawnablesData == null) return;

            Vector3 OriginRotation = new Vector3(0f, targetRot, 0f);
            Quaternion OriginRot = Quaternion.EulerRotation(OriginRotation);
            foreach (Dictionary<string, object> spawnable in spawnablesData)
            {
                Dictionary<string, object> structPos = spawnable["pos"] as Dictionary<string, object>;
                Dictionary<string, object> structRot = spawnable["rot"] as Dictionary<string, object>;
                string prefabname = (string)spawnable["prefabname"];
                Quaternion newAngles = Quaternion.EulerRotation((new Vector3(Convert.ToSingle(structRot["x"]), Convert.ToSingle(structRot["y"]), Convert.ToSingle(structRot["z"]))) + OriginRotation);
                Vector3 TempPos = OriginRot * (new Vector3(Convert.ToSingle(structPos["x"]), Convert.ToSingle(structPos["y"]), Convert.ToSingle(structPos["z"])));
                Vector3 NewPos = TempPos + targetPoint;
                GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
                if (newPrefab == null) return;
                BaseEntity entity = GameManager.server.CreateEntity(newPrefab, NewPos, newAngles);
                if (entity == null) return;
                entity.Spawn(true);
            }

        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\CraftingController.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Crafting Controller", "Mughisi", "2.2.1", ResourceId = 695)]
    class CraftingController : RustPlugin
    {

        #region Configuration Data
        // Do not modify these values, to configure this plugin edit
        // 'CraftingController.json' in your server's config folder.
        // <drive>:\...\server\<server identity>\oxide\config\

        private bool configChanged = false;

        // Plugin settings
        string defaultChatPrefix = "Crafting Controller";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        float defaultCraftingRate = 1;
        bool defaultAdminInstantCraft = true;
        bool defaultModeratorInstantCraft = false;
        bool defaultCompleteCurrentCraftingOnShutdown = false;
        int defaultKeyLShift = 5;
        int defaultKeyLCtrl = 10;

        float craftingRate;
        bool adminInstantCraft;
        bool moderatorInstantCraft;
        bool completeCurrentCrafting;
        bool cancelAllCrafting;
        int keyLShift;
        int keyLCtrl;

        // Plugin options - blocked items
        List<object> defaultBlockedItems = new List<object>();

        List<string> blockedItems = new List<string>();

        // Plugin messages
        string defaultCurrentCraftingRate = "The crafting rate is set to {0}.";
        string defaultModifyCraftingRate = "The crafting rate is now set to {0}.";
        string defaultModifyError = "The new crafting rate must be a number between 0 and 2 where 0 is instant craft, 1 is normal and 2 is double!";
        string defaultCraftBlockedItem = "{0} is blocked and can not be crafted!";
        string defaultNoItemSpecified = "You need to specify an item to block/unblock.";
        string defaultInvalidItem = "{0} is not a valid item. Please use the name of the item as it appears in the item list. Ex: Camp Fire";
        string defaultBlockedItem = "{0} has already been blocked!";
        string defaultBlockSucces = "{0} has been blocked from crafting.";
        string defaultUnblockItem = "{0} is not blocked!";
        string defaultUnblockSucces = "{0} is no longer blocked from crafting.";
        string defaultNoPermission = "You don't have permission to use this command.";
        string defaultShowBlockedItems = "The following items are blocked: ";
        string defaultNoBlockedItems = "No items have been blocked.";

        string currentCraftingRate;
        string modifyCraftingRate;
        string modifyError;
        string craftBlockedItem;
        string noItemSpecified;
        string invalidItem;
        string blockedItem;
        string blockSucces;
        string unblockItem;
        string unblockSucces;
        string noPermission;
        string possibleItems;
        string showBlockedItems;
        string noBlockedItems;

        #endregion

        List<ItemBlueprint> blueprintDefinitions = new List<ItemBlueprint>();
        Dictionary<string, float> blueprints = new Dictionary<string, float>();

        List<ItemDefinition> itemDefinitions = new List<ItemDefinition>();
        List<string> items = new List<string>();

        private MethodInfo FinishCraftingTask = typeof(ItemCrafter).GetMethod("FinishCrafting", BindingFlags.NonPublic | BindingFlags.Instance);

        private readonly MethodInfo CollectIngredients = typeof(ItemCrafter).GetMethod("CollectIngredients", BindingFlags.NonPublic | BindingFlags.Instance);

        private readonly FieldInfo serverInputField = typeof(BasePlayer).GetField("serverInput", BindingFlags.NonPublic | BindingFlags.Instance);

        void Loaded() => LoadConfigValues();

        void OnServerInitialized()
        {
            blueprintDefinitions.Clear();
            itemDefinitions.Clear();
            blueprintDefinitions = Resources.LoadAll<ItemBlueprint>("items/").ToList();
            itemDefinitions = Resources.LoadAll<ItemDefinition>("items/").ToList();
            foreach (ItemBlueprint bp in blueprintDefinitions)
                blueprints.Add(bp.targetItem.shortname, bp.time);
            foreach (ItemDefinition itemdef in itemDefinitions)
                items.Add(itemdef.displayName.english);
            UpdateCraftingRate();
        }

        void Unloaded()
        {
            foreach (ItemBlueprint bp in blueprintDefinitions)
                bp.time = blueprints[bp.targetItem.shortname];
        }

        protected override void LoadDefaultConfig() => Log("New configuration file created.");

        void LoadConfigValues()
        {
            // Plugin settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Plugin options
            adminInstantCraft = Convert.ToBoolean(GetConfigValue("Options", "InstantCraftForAdmins", defaultAdminInstantCraft));
            moderatorInstantCraft = Convert.ToBoolean(GetConfigValue("Options", "InstantCraftForModerators", defaultModeratorInstantCraft));
            craftingRate = float.Parse(Convert.ToString(GetConfigValue("Options", "CraftingRate", defaultCraftingRate)), System.Globalization.CultureInfo.InvariantCulture);
            completeCurrentCrafting = Convert.ToBoolean(GetConfigValue("Options", "CompleteCurrentCraftingOnShutdown", defaultCompleteCurrentCraftingOnShutdown));
            keyLShift = int.Parse(Convert.ToString(GetConfigValue("Options", "LShiftAmount", defaultKeyLShift)));
            keyLCtrl = int.Parse(Convert.ToString(GetConfigValue("Options", "LCtrlAmount", defaultKeyLCtrl)));

            // Plugin options - blocked items
            var list = GetConfigValue("Options", "BlockedItems", defaultBlockedItems);

            blockedItems.Clear();
            foreach (object item in list as List<object>)
                blockedItems.Add(item.ToString());

            // Plugin messages
            currentCraftingRate = Convert.ToString(GetConfigValue("Messages", "CurrentCraftingRate", defaultCurrentCraftingRate));
            modifyCraftingRate = Convert.ToString(GetConfigValue("Messages", "ModifyCraftingRate", defaultModifyCraftingRate));
            modifyError = Convert.ToString(GetConfigValue("Messages", "ModifyError", defaultModifyError));
            craftBlockedItem = Convert.ToString(GetConfigValue("Messages", "CraftBlockedItem", defaultCraftBlockedItem));
            noItemSpecified = Convert.ToString(GetConfigValue("Messages", "NoItemSpecified", defaultNoItemSpecified));
            invalidItem = Convert.ToString(GetConfigValue("Messages", "InvalidItem", defaultInvalidItem));
            blockedItem = Convert.ToString(GetConfigValue("Messages", "BlockedItem", defaultBlockedItem));
            blockSucces = Convert.ToString(GetConfigValue("Messages", "BlockSucces", defaultBlockSucces));
            unblockItem = Convert.ToString(GetConfigValue("Messages", "UnblockItem", defaultUnblockItem));
            unblockSucces = Convert.ToString(GetConfigValue("Messages", "UnblockSucces", defaultUnblockSucces));
            noPermission = Convert.ToString(GetConfigValue("Messages", "NoPermission", defaultNoPermission));
            showBlockedItems = Convert.ToString(GetConfigValue("Messages", "ShowBlockedItems", defaultShowBlockedItems));
            noBlockedItems = Convert.ToString(GetConfigValue("Messages", "NoBlockedItems", defaultNoBlockedItems));

            if (configChanged)
            {
                Log("Configuration file updated.");
                SaveConfig();
            }
        }

        [ChatCommand("craft")]
        void ChangeCraftingRate(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 2 && args.Length == 1)
            {
                try
                {
                    craftingRate = float.Parse(args[0], System.Globalization.CultureInfo.InvariantCulture);
                }
                catch
                {
                    SendChatMessage(player, modifyError);
                    return;
                }
                if (craftingRate >= 0f && craftingRate <= 2f)
                {
                    SetConfigValue("Options", "CraftingRate", craftingRate);
                    SendChatMessage(player, modifyCraftingRate, craftingRate.ToString());
                    UpdateCraftingRate();
                    return;
                }
                SendChatMessage(player, modifyError);
                return;
            }
            SendChatMessage(player, currentCraftingRate, craftingRate.ToString());
        }

        [ChatCommand("block")]
        void BlockItemCraft(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 2)
            {
                if (args.Length == 0)
                {
                    SendChatMessage(player, noItemSpecified);
                    return;
                }
                string item = string.Join(" ", args);
                if (!items.Contains(item))
                {
                    SendChatMessage(player, invalidItem, item);
                    return;
                }
                if (blockedItems.Contains(item))
                {
                    SendChatMessage(player, blockedItem, item);
                    return;
                }
                blockedItems.Add(item);
                SetConfigValue("Options", "BlockedItems", blockedItems);
                SendChatMessage(player, blockSucces, item);
                return;
            }
            SendChatMessage(player, noPermission);
        }

        [ChatCommand("unblock")]
        void UnblockItemCraft(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 2)
            {
                if (args.Length == 0)
                {
                    SendChatMessage(player, noItemSpecified);
                    return;
                }
                string item = string.Join(" ", args);
                if (!items.Contains(item))
                {
                    SendChatMessage(player, invalidItem, item);
                    return;
                }
                if (!blockedItems.Contains(item))
                {
                    SendChatMessage(player, unblockItem, item);
                    return;
                }
                blockedItems.Remove(item);
                SetConfigValue("Options", "BlockedItems", blockedItems);
                SendChatMessage(player, unblockSucces, item);
                return;
            }
            SendChatMessage(player, noPermission);
        }
        [ChatCommand("blocked")]
        void BlockedItems(BasePlayer player, string command, string[] args)
        {
            if (blockedItems.Count == 0)
                SendChatMessage(player, noBlockedItems);
            else
            {
                SendChatMessage(player, showBlockedItems);
                foreach (string item in blockedItems)
                    SendChatMessage(player, item);
            }
        }

        void OnServerQuit()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (completeCurrentCrafting)
                    CompleteCrafting(player);

                CancelAllCrafting(player);
            }
        }

        void CompleteCrafting(BasePlayer player)
        {
            ItemCrafter crafter = player.inventory.crafting;
            if (crafter.queue.Count == 0) return;
            ItemCraftTask task = crafter.queue.First<ItemCraftTask>();
            FinishCraftingTask.Invoke(crafter, new object[] { task });
            crafter.queue.Dequeue();
        }

        void CancelAllCrafting(BasePlayer player)
        {
            ItemCrafter crafter = player.inventory.crafting;
            foreach (ItemCraftTask task in crafter.queue)
                crafter.CancelTask(task.taskUID, true);
        }

        void UpdateCraftingRate()
        {
            foreach (ItemBlueprint bp in blueprintDefinitions)
                bp.time = blueprints[bp.targetItem.shortname] * craftingRate;
        }

        void OnItemCraft(ItemCraftTask item)
        {
            BasePlayer crafter = item.owner;
            string itemname = item.blueprint.targetItem.displayName.english;
            if (adminInstantCraft && item.owner.net.connection.authLevel == 2) item.endTime = 1f;
            if (moderatorInstantCraft && item.owner.net.connection.authLevel == 1) item.endTime = 1f;
            if (blockedItems.Contains(itemname))
            {
                item.cancelled = true;
                SendChatMessage(crafter, craftBlockedItem, itemname);
                foreach (ItemAmount amount in item.blueprint.ingredients)
                    crafter.inventory.GiveItem(amount.itemid, (int)amount.amount, false);
            }

            if (craftingRate == 0f) item.endTime = 1f;
            var input = (InputState)serverInputField.GetValue(crafter);
            if (input.IsDown(BUTTON.SPRINT))
                BulkCraft(crafter, item, keyLShift);
            if (input.IsDown(BUTTON.DUCK))
                BulkCraft(crafter, item, keyLCtrl);
        }

        void BulkCraft(BasePlayer player, ItemCraftTask task, int amount)
        {
            ItemCrafter crafter = player.inventory.crafting;
            if (crafter.queue.ToArray()[0] == task)
                amount--;

            for (int i = 1; i <= amount; i++)
            {
                if (!crafter.CanCraft(task.blueprint, 1))
                    break;

                crafter.taskUID++;
                ItemCraftTask item = new ItemCraftTask {
                    blueprint = task.blueprint
                };

                CollectIngredients.Invoke(crafter, new object[] { item.blueprint, item.ingredients });
                if (craftingRate == 0) item.endTime = 1f;
                else item.endTime = 0f;
                item.taskUID = crafter.taskUID;
                item.owner = player;
                item.instanceData = null;
                crafter.queue.Enqueue(item);

                if (item.owner != null)
                {
                    object[] args = new object[] { item.taskUID, item.blueprint.targetItem.itemid };
                    item.owner.Command("note.craft_add", args);
                }
            }
        }

        #region Helper methods
        void Log(string message) => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, string arguments = null)
        {
            string chatMessage = $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}";
            player?.SendConsoleCommand("chat.add", -1, string.Format(chatMessage, arguments), 1.0);
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }
            return value;
        }

        void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }
            SaveConfig();
        }
        #endregion
    }

}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\DeadPlayersList.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Dead Players List", "Mughisi", "2.0.4", ResourceId = 696)]
    class DeadPlayersList : RustPlugin
    {

        class LocationInfo
        {
            public string x;
            public string y;
            public string z;
            Vector3 position;

            public LocationInfo(Vector3 position)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();
                this.position = position;
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
        }

        class DeadPlayerInfo
        {
            public string UserId;
            public string Name;
            public string Reason;
            public LocationInfo Position;

            public DeadPlayerInfo()
            {
            }

            public DeadPlayerInfo(BasePlayer victim, HitInfo info)
            {
                UserId = victim.userID.ToString();
                Name = victim.displayName;
                Reason = victim.lastDamage.ToString();
                if (info != null)
                {
                    var attacker = info.Initiator as BasePlayer;
                    if (info.Initiator)
                    {
                        Reason = info.Initiator.LookupPrefabName();
                        if (attacker && attacker != victim) Reason = attacker.displayName;
                    }
                }
                Position = new LocationInfo(victim.transform.position);
            }

            public ulong GetUserId()
            {
                ulong user_id;
                if (!ulong.TryParse(UserId, out user_id)) return 0;
                return user_id;
            }
        }

        class StoredData
        {
            public HashSet<DeadPlayerInfo> DeadPlayers = new HashSet<DeadPlayerInfo>();

            public StoredData()
            {
            }
        }

        StoredData storedData;
        Hash<ulong, DeadPlayerInfo> deadPlayers = new Hash<ulong, DeadPlayerInfo>();
        bool dataChanged = false;

        void Loaded()
        {
            LoadData();
        }

        void Unloaded()
        {
            SaveData();
        }

        void LoadData()
        {
            deadPlayers.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("DeadPlayersList");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var dead_player in storedData.DeadPlayers)
                deadPlayers[dead_player.GetUserId()] = dead_player;
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("DeadPlayersList", storedData);
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (deadPlayers.Remove(player.userID) && storedData.DeadPlayers.RemoveWhere(info => info.GetUserId() == player.userID) > 0)
                dataChanged = true;
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (deadPlayers.Remove(player.userID) && storedData.DeadPlayers.RemoveWhere(info => info.GetUserId() == player.userID) > 0)
                dataChanged = true;
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;
            if (!player) return;

            var dead_player = deadPlayers[player.userID];
            if (dead_player != null) storedData.DeadPlayers.Remove(dead_player);
            dead_player = new DeadPlayerInfo(player, info);
            deadPlayers[player.userID] = dead_player;
            storedData.DeadPlayers.Add(dead_player);

            dataChanged = true;
        }

        void OnServerSave()
        {
            if (!dataChanged) return;
            SaveData();
            dataChanged = false;
        }

        Dictionary<string, string> GetPlayerList()
        {
            Dictionary<string, string> deadPlayerList = new Dictionary<string, string>();
            foreach (var deadPlayer in deadPlayers)
                deadPlayerList.Add(deadPlayer.Key.ToString(), deadPlayer.Value.Name);

            return deadPlayerList;
        }

        string GetPlayerName(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Name;

        string GetPlayerDeathReason(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Reason;

        Vector3 GetPlayerDeathPosition(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Position.GetPosition() ?? Vector3.zero;
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\DemolishLimiter.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Demolish Limiter", "Mughisi", "1.0.1")]
    class DemolishLimiter : RustPlugin
    {

        #region Configuration Data

        private bool configChanged = false;

        // Plugin settings
        string defaultChatPrefix = "Demolisher";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultAdminCanDemolish = true;
        bool defaultModeratorCanDemolish = false;
        bool defaultLogDemolishToConsole = true;

        bool adminCanDemolish;
        bool moderatorCanDemolish;
        bool logToConsole;
        
        // Plugin messages
        string defaultNotAllowed = "You are not allowed to demolish anything.";
        
        string notAllowed;

        #endregion

        void Loaded()
        {
            LoadConfigValues();
        }

        protected override void LoadDefaultConfig()
        {
            Log("New configuration file created.");
        }

        void LoadConfigValues()
        {
            // Plugin settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Plugin options
            adminCanDemolish = Convert.ToBoolean(GetConfigValue("Options", "AdminsCanDemolish", defaultAdminCanDemolish));
            moderatorCanDemolish = Convert.ToBoolean(GetConfigValue("Options", "ModeratorsCanDemolish", defaultModeratorCanDemolish));
            logToConsole = Convert.ToBoolean(GetConfigValue("Options", "LogToConsole", defaultLogDemolishToConsole));

            // Plugin messages
            notAllowed = Convert.ToString(GetConfigValue("Messages", "NotAllowed", defaultNotAllowed));

            if (configChanged)
            {
                Log("Configuration file updated.");
                SaveConfig();
            }
        }
        
        object OnBuildingBlockDemolish(BuildingBlock block, BasePlayer player)
        {
            int demolisherAuthLevel = player.net.connection.authLevel;

            if ((demolisherAuthLevel == 1 && !moderatorCanDemolish) || (demolisherAuthLevel == 2 && !adminCanDemolish))
            {
                SendChatMessage(player, notAllowed);
                return true;
            }

            if (logToConsole)
                Log($"{player.displayName} has demolished a {block.blockDefinition.hierachyName} at location {block.transform.position.ToString()}.");

            return null;
        }

        #region Helper methods
        void Log(string message)
        {
            Puts("{0} : {1}", Title, message);
        }

        void SendChatMessage(BasePlayer player, string message, string arguments = null)
        {
            string chatMessage = $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}";
            player?.SendConsoleCommand("chat.add", -1, string.Format(chatMessage, arguments), 1.0);
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }
            return value;
        }

        void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }
            SaveConfig();
        }
        #endregion
    }

}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Draw.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using Oxide.Core.Libraries;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Draw", "playrust.io / dcode", "1.0.1", ResourceId = 968)]
    public class Draw : RustPlugin
    {
        [LibraryFunction("Line")]
        public void Line(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration) {
            player.SendConsoleCommand("ddraw.line", duration, color, from, to);
        }

        [LibraryFunction("Arrow")]
        public void Arrow(BasePlayer player, Vector3 from, Vector3 to, float headSize, Color color, float duration) {
            player.SendConsoleCommand("ddraw.arrow", duration, color, from, to, headSize);
        }

        [LibraryFunction("Sphere")]
        public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration) {
            player.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius);
        }

        [LibraryFunction("Text")]
        public void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration) {
            player.SendConsoleCommand("ddraw.text", duration, color, pos, text);
        }

        [LibraryFunction("Box")]
        public void Box(BasePlayer player, Vector3 pos, float size, Color color, float duration) {
            player.SendConsoleCommand("ddraw.box", duration, color, pos, size);
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\ExplosivesModifier.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{

    [Info("Explosives Modifier", "Mughisi", "1.1.1")]
    class ExplosivesModifier : RustPlugin
    {

        #region Configuration Data

        bool configChanged;

        // Explosive damage values.
        string defaultChatPrefix = "Bomb Squad";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Timed Explosive settings
        float defaultTimedExplosiveDamageModifier = 100;
        float defaultTimedExplosiveRadiusModifier = 100;

        float timedExplosiveDamageModifier;
        float timedExplosiveRadiusModifier;

        // F1 Grenade settings
        float defaultF1GrenadeDamageModifier = 100;
        float defaultF1GrenadeRadiusModifier = 100;
        bool defaultStickyGrenades = false;

        float f1GrenadeDamageModifier;
        float f1GrenadeRadiusModifier;
        bool stickyGrenades;

        // Messages
        string defaultHelpTextPlayerTimedExplosives = "Timed Explosives deal {0}% of their normal damage and their radius is set to {1}%.";
        string defaultHelpTextPlayerF1Grenades = "F1 Grenades deal {0}% of their normal damage and their radius is set to {1}%.\r\nSticky grenades are {2}.";
        string defaultHelpTextAdmin = "Modify explosive and grenade damage by using one of the following commands: \r\n" +
                                      " /explosivedamage <type:timed|grenade> <value:percentage> \r\n" +
                                      "  examples: '/explosivedamage timed 50' - For 50% of normal explosives damage \r\n" +
                                      "            '/explosivedamage grenade 200' - For 200% of normal grenade damage \r\n" +
                                      "\r\n" +
                                      "Modify explosive and grenade damage radius by using one of the following commands: \r\n" +
                                      " /explosiveradius <type:timed|grenade> <value:percentage> \r\n" +
                                      "  examples: '/explosiveradius timed 200' - For 200% of normal explosive explosion radius \r\n" +
                                      "            '/explosivedamage grenade 50' - For 50% of normal grenade explosion radius" +
                                      "\r\n" +
                                      "Toggle sticky grenades by using the following command: \r\n" +
                                      " /stickygrenades";

        string defaultTimedExplosivesDamageModified = "Timed Explosives {1} changed to {0}% of the normal {1}.";
        string defaultF1GrenadesDamageModified = "F1 Grenades {1} changed to {0}% of the normal {1}.";
        string defaultF1GrenadesSticky = "You have {0} sticky grenades.";
        string defaultNotAllowed = "You are not allowed to use this command.";
        string defaultInvalidArgument = "Invalid arguments supplied!\r\nUse '/{0}  <type:timed|grenade> <value:percentage> ' where value is the % of the original value.";

        string helpTextPlayerTimedExplosives;
        string helpTextPlayerF1Grenades;
        string helpTextAdmin;
        string timedExplosivesDamageModified;
        string f1GrenadesDamageModified;
        string f1GrenadesSticky;
        string modified;
        string notAllowed;
        string invalidArgument;

        #endregion

        protected override void LoadDefaultConfig()
        {
            Log("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void Loaded()
        {
            LoadVariables();

            // Save config changes when required
            if (configChanged)
            {
                Log("Config file was updated.");
                SaveConfig();
            }

        }

        void LoadVariables()
        {
            // Settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Timed Explosive Settings
            timedExplosiveDamageModifier = float.Parse(Convert.ToString(GetConfigValue("TimedExplosives", "DamageModifier", defaultTimedExplosiveDamageModifier)), System.Globalization.CultureInfo.InvariantCulture);
            timedExplosiveRadiusModifier = float.Parse(Convert.ToString(GetConfigValue("TimedExplosives", "RadiusModifier", defaultTimedExplosiveRadiusModifier)), System.Globalization.CultureInfo.InvariantCulture);

            // F1 Grenades Settings
            f1GrenadeDamageModifier = float.Parse(Convert.ToString(GetConfigValue("F1Grenades", "DamageModifier", defaultF1GrenadeDamageModifier)), System.Globalization.CultureInfo.InvariantCulture);
            f1GrenadeRadiusModifier = float.Parse(Convert.ToString(GetConfigValue("F1Grenades", "RadiusModifier", defaultF1GrenadeRadiusModifier)), System.Globalization.CultureInfo.InvariantCulture);
            stickyGrenades = bool.Parse(Convert.ToString(GetConfigValue("F1Grenades", "StickyGrenades", defaultStickyGrenades)));

            // Messages
            helpTextPlayerTimedExplosives = Convert.ToString(GetConfigValue("Messages", "HelpTextPlayerTimedExplosives", defaultHelpTextPlayerTimedExplosives));
            helpTextPlayerF1Grenades = Convert.ToString(GetConfigValue("Messages", "HelpTextPlayerF1Grenades", defaultHelpTextPlayerF1Grenades));
            helpTextAdmin = Convert.ToString(GetConfigValue("Messages", "HelpTextAdmin", defaultHelpTextAdmin));
            timedExplosivesDamageModified = Convert.ToString(GetConfigValue("Messages", "TimedExplosivesModified", defaultTimedExplosivesDamageModified));
            f1GrenadesDamageModified = Convert.ToString(GetConfigValue("Messages", "GrenadesModified", defaultF1GrenadesDamageModified));
            f1GrenadesSticky = Convert.ToString(GetConfigValue("Messages", "StickyGrenades", defaultF1GrenadesSticky));
            notAllowed = Convert.ToString(GetConfigValue("Messages", "NotAllowed", defaultNotAllowed));
            invalidArgument = Convert.ToString(GetConfigValue("Messages", "InvalidArgument", defaultInvalidArgument));
        }

        [ChatCommand("explosivedamage")]
        void ExplosiveDamage(BasePlayer player, string command, string[] args)
        {
            ChangeExplosive(player, command, args, "DamageModifier");
        }

        [ChatCommand("explosiveradius")]
        void ExplosiveRadius(BasePlayer player, string command, string[] args)
        {
            ChangeExplosive(player, command, args, "RadiusModifier");
        }

        [ChatCommand("stickygrenades")]
        void StickyGrenades(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player)) return;

            stickyGrenades = !stickyGrenades;
            SetConfigValue("F1Grenades", "StickyGrenades", stickyGrenades);
            SendChatMessage(player, f1GrenadesSticky, (stickyGrenades ? "enabled" : "disabled"));
        }

        void ChangeExplosive(BasePlayer player, string command, string[] args, string type)
        {
            if (!IsAllowed(player)) return;

            if (args.Length != 2)
            {
                SendChatMessage(player, invalidArgument, command);
                return;
            }

            float newModifier = 0f;
            if ((args[0] != "timed" || args[0] != "grenade") && !float.TryParse(args[1], out newModifier))
            {
                SendChatMessage(player, invalidArgument, command);
                return;
            }

            string configCategory = "";
            if (args[0] == "timed")
            {
                configCategory = "TimedExplosives";
                if (type == "DamageModifier")
                    timedExplosiveDamageModifier = newModifier;
                if (type == "RadiusModifier")
                    timedExplosiveRadiusModifier = newModifier;
                SendChatMessage(player, timedExplosivesDamageModified, newModifier, type.Replace("Modifier", "").ToLower());
            }
            if (args[0] == "grenade")
            {
                configCategory = "F1Grenades";
                if (type == "DamageModifier")
                    f1GrenadeDamageModifier = newModifier;
                if (type == "RadiusModifier")
                    f1GrenadeRadiusModifier = newModifier;
                SendChatMessage(player, f1GrenadesDamageModified, newModifier, type.Replace("Modifier", "").ToLower());
            }

            SetConfigValue(configCategory, type, newModifier);
            return;
        }

        #region Hooks

        void OnEntitySpawned(BaseEntity entity)
        {
            var explosive = entity as TimedExplosive;
            if (explosive)
            {
                if (entity.name == "timed.explosive.deployed(Clone)")
                {
                    if (timedExplosiveDamageModifier != 100)
                    {
                        foreach (global::Rust.DamageTypeEntry entry in explosive.damageTypes)
                            entry.amount *= timedExplosiveDamageModifier / 100;
                    }

                    if (timedExplosiveRadiusModifier != 100)
                        explosive.explosionRadius *= timedExplosiveRadiusModifier / 100;
                }

                if (entity.name == "grenade.f1.deployed(Clone)")
                {
                    foreach (global::Rust.DamageTypeEntry entry in explosive.damageTypes)
                        entry.amount *= f1GrenadeDamageModifier / 100;

                    if (f1GrenadeRadiusModifier != 100)
                        explosive.explosionRadius *= f1GrenadeRadiusModifier / 100;

                    explosive.canStick = stickyGrenades;
                }
            }
        }

        void SendHelpText(BasePlayer player)
        {
            SendChatMessage(player, helpTextPlayerTimedExplosives, timedExplosiveDamageModifier, timedExplosiveRadiusModifier);
            SendChatMessage(player, helpTextPlayerF1Grenades, f1GrenadeDamageModifier, f1GrenadeRadiusModifier, (stickyGrenades ? "enabled" : "disabled"));

            if (player.net.connection.authLevel == 2)
                SendChatMessage(player, helpTextAdmin);
        }

        #endregion

        #region Helper Methods

        void Log(string message) => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, params object[] arguments) =>
            PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}", arguments);

        bool IsAllowed(BasePlayer player)
        {
            if (player.net.connection.authLevel == 2) return true;
            SendChatMessage(player, notAllowed);
            return false;
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }

        void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }

            SaveConfig();
        }

        #endregion

    }

}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Factions.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: LFG

/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Looking For Gamers, Inc. <support@lfgame.rs>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// Rust Unity Namespaces
using Rust;
using UnityEngine;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

using LFG;

namespace Oxide.Plugins
{
    [Info("Factions", "Looking For Gamers <support@lfgame.rs>", "0.1.1")]
    public class Factions : RustPlugin
    {
        #region Other Classes
        public class ConfigObj
        {
            public Dictionary<string, List<string>> messages { set; get; }
            public string chatPrefix { set; get; }
            public string chatPrefixColor { set; get; }

            public ConfigObj()
            {
                this.messages = new Dictionary<string, List<string>>();
                this.chatPrefix = "Factions";
                this.chatPrefixColor = "green";
            }

            public void addMessage(string key, List<string> message)
            {
                this.messages.Add(key, message);
            }

            public List<string> getMessage(string key, string[] args)
            {
                List<string> strings = new List<string>();
                List<string> messageList;

                if (this.messages.ContainsKey(key))
                {
                    messageList = (List<string>) this.messages[key];
                    foreach (string message in messageList)
                    {
                        strings.Add(string.Format(message, args));
                    }
                }

                return strings;
            }
        }
        #endregion


        public ConfigObj config;
        private string configPath;
        private bool loaded = false;
        private List<Faction> factions;
        private string factionDatafile = "Factions_Data-factions";

        #region hook methods
        void SetupConfig()
        {
            if (this.loaded)
            {
                return;
            }

            LoadConfig();
            this.configPath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
            this.config = JsonConvert.DeserializeObject<ConfigObj>((string)JsonConvert.SerializeObject(Config["Config"]).ToString());
            
            // This all seems 
            try
            {
                this.factions = Interface.GetMod().DataFileSystem.ReadObject<List<Faction>>(this.factionDatafile);
            }
            catch (Exception e)
            {
                this.factions = new List<Faction>();
                this.SaveData();
            }

            if (this.factions == null)
            {
                this.factions = new List<Faction>();
            }

            this.loaded = true;
        }

        void Loaded()
        {
            this.SetupConfig();
            Print("Factions by Looking For Gamers, has been started");
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject(this.factionDatafile, this.factions);
        }

        [HookMethod("LoadDefaultConfig")]
        void CreateDefaultConfig()
        {
            ConfigObj localConfig = new ConfigObj();

            localConfig.addMessage(
                "help", 
                new List<string>()
                { 
                    "To create a faction, type \"/faction create <name>\".",
                    "To request to join a faction, type \"/faction join <name>\".",
                    "To invite, type \"/faction invite <player>\".",
                    "To get faction info, type \"/faction info <name>\".",
                    "You can also use \"/f\"."
                }
            );
            localConfig.addMessage("created", new List<string>() { "You have created the \"{0}\" faction." });
            localConfig.addMessage("notCreated", new List<string>() { "The \"{0}\" faction doesn't exists." });
            localConfig.addMessage("alreadyCreated", new List<string>() { "The \"{0}\" faction already exists." });
            localConfig.addMessage("alreadyInFaction", new List<string>() { "You are already a member of a faction." });
            localConfig.addMessage("invalidCommand", new List<string>() { "You ran the \"{0}\" command incorrectly. Type \"/faction help\" to get help" });
            localConfig.addMessage("invitationSent", new List<string>() { "You have invited \"{0}\" to your faction." });
            localConfig.addMessage(
                "invitationReceived", 
                new List<string>() 
                { 
                    "You have been invited to the \"{0}\" faction.",
                    "To accept, type \"/faction join {0}\".",
                    "To reject, type \"/faction reject {0}\".",
                }
            );
            localConfig.addMessage("invitationRejected", new List<string>() { "You have rejected the invitiation from the \"{0}\" faction." });
            localConfig.addMessage("requestSent", new List<string>() { "You have requested to join the \"{0}\" faction." });
            localConfig.addMessage(
                "requestReceived",
                new List<string>()
                {
                    "\"{0}\" is requesting to join your faction.",
                    "Accept with \"/faction accept {0}\".",
                    "Deny with \"/faction deny {0}\"."
                }
            );
            localConfig.addMessage("notInFaction", new List<string>() { "You are not a member of a faction." });
            localConfig.addMessage("notOnline", new List<string>() { "\"{0}\" is either not online, or not a real user." });
            localConfig.addMessage("notAcceptee", new List<string>() { "\"{0}\" has not requested to join your group." });
            localConfig.addMessage("membershipGranted", new List<string>() { "You have been accepted into the \"{0}\" faction." });
            localConfig.addMessage("membershipDenied", new List<string>() { "You have been denied from the \"{0}\" faction." });
            localConfig.addMessage("playerAccepted", new List<string>() { "\"{0}\" has been added to your faction." });
            localConfig.addMessage("playerDenied", new List<string>() { "\"{0}\" has NOT been added to your faction." });
            localConfig.addMessage("playerKicked", new List<string>() { "You have kicked \"{0}\" from your faction." });
            localConfig.addMessage("playerKickReceived", new List<string>() { "You have been kicked from the \"{0}\" faction." });
            localConfig.addMessage(
                "factionInfo",
                new List<string>()
                {
                    "The \"{0}\" faction:",
                    "Owner: {1}",
                    "Members: {2}"
                }
            );

            this.config = localConfig;
            Config["Config"] = this.config;
            SaveConfig();

            this.SetupConfig();
        }

        void OnPlayerInit(BasePlayer player)
        {
            Faction faction = this.getPlayerOwnedFaction(player);
            if (faction != null)
            {
                foreach (string request in faction.requests)
                {
                    BasePlayer requestee = this.getActivePlayer(request);
                    if (requestee != null)
                    {
                        this.chatMessage(player, config.getMessage("requestReceived", new string[] { requestee.displayName.ToString() }));
                    }
                }
            }


            foreach (Faction f in this.factions)
            {
                if (f.hasInvite(player))
                {
                    this.chatMessage(player, config.getMessage("invitationReceived", new string[] { f.name }));
                }
            }
        }


        [HookMethod("OnEntityAttacked")]
        object OnEntityAttacked(MonoBehaviour entity, HitInfo hitinfo)
        {
            //**
            if (hitinfo == null)
            {
                Print("No hit info at all");
                return null;
            }
            if (hitinfo.Initiator == null)
            {
                Print("Attacker is null");
                return null;
            }

            BasePlayer attacker = hitinfo.Initiator as BasePlayer;
            BasePlayer defender = entity as BasePlayer;

            if (attacker == null || defender == null)
            {
                //Print("Attacker Type: " + hitinfo.Initiator.GetType().ToString());
                //Print("Defender Type: " + entity.GetType().ToString());
                return null;
            }

            Faction attackerFaction = this.getPlayerFaction(attacker);
            Faction defenderFaction = this.getPlayerFaction(defender);
            if (attackerFaction == null)
            {
                Print("Attacker doesn't have a faction");
                return null;
            }
            if (defenderFaction == null)
            {
                Print("Defender doesn't have a faction");
                return null;
            }

            if (attackerFaction.Equals(defenderFaction))
            {
                return false;
            }
            //*/
            return null;
        }
        #endregion

        #region chat commands

        [ChatCommand("f")]
        void cmdChatFactionShortcut(BasePlayer player, string command, string[] args)
        {
            this.cmdChatFaction(player, command, args);
        }

        [ChatCommand("faction")]
        void cmdChatFaction(BasePlayer player, string command, string[] args)
        {
            #region help
            if (args.Length == 0 || (args.Length == 1 && args[0].ToLower() == "help"))
            {
                this.chatMessage(player, config.getMessage("help", new string[] { }));
                return;
            }
            #endregion

            string name;
            Faction faction;
            BasePlayer acceptee;
            BasePlayer invitee;
            Print("Running the " + args[0].ToLower() + " command");
            switch (args[0].ToLower())
            {
                #region default
                default:
                    this.cmdChatFaction(player, command, new string[] { });
                    return;
                #endregion

                 #region create
                case "create":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "create" }));
                        return;
                    }

                    if (this.playerHasFaction(player))
                    {
                        this.chatMessage(player, config.getMessage("alreadyInFaction", new string[] { }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("create ", "");
                    faction = this.getFactionByName(name);
                    if (faction != null)
                    {
                        this.chatMessage(player, config.getMessage("alreadyCreated", new string[] { faction.name }));
                        return;
                    }

                    this.createFaction(name, player);
                    this.chatMessage(player, config.getMessage("created", new string[] { name }));

                    return;
                #endregion

                #region join
                case "join":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] {"join"}));
                        return;
                    }

                    if (this.playerHasFaction(player))
                    {
                        this.chatMessage(player, config.getMessage("alreadyInFaction", new string[] { }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("join ", "");
                    Print("Does the " + name + " faction exist");
                    faction = this.getFactionByName(name);
                    if (faction == null)
                    {
                        this.chatMessage(player, config.getMessage("notCreated", new string[] { name }));
                        return;
                    }

                    this.sendRequestToFaction(faction, player);

                    return;
                #endregion

                #region invite
                case "invite":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "invite" }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("invite ", "");
                    invitee = this.getPlayerByName(name);
                    if (invitee == null)
                    {
                        this.chatMessage(player, config.getMessage("notOnline", new string[] { name }));
                        return;
                    }

                    faction = this.getPlayerOwnedFaction(player);
                    if (faction == null)
                    {
                        this.chatMessage(player, config.getMessage("notInFaction", new string[] { invitee.displayName }));
                        return;
                    }
                    if (faction.hasInvite(invitee))
                    {
                        return;
                    }

                    Print("Inviting " + invitee.displayName + " to " + faction.name);

                    this.inviteMember(faction, invitee);
                    this.chatMessage(player, config.getMessage("invitationSent", new string[] { invitee.displayName }));
                    this.chatMessage(invitee, config.getMessage("invitationReceived", new string[] { faction.name }));

                    return;
                #endregion

                #region reject
                case "reject":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "reject" }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("reject ", "");
                    faction = this.getFactionByName(name);
                    if (faction == null)
                    {
                        this.chatMessage(player, config.getMessage("notCreated", new string[] { name }));
                        return;
                    }

                    this.rejectInvitation(player, faction);
                    this.chatMessage(player, config.getMessage("invitationRejected", new string[] { faction.name }));

                    return;
                #endregion

                #region accept
                case "accept":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "accept" }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("accept ", "");
                    acceptee = this.getPlayerByName(name);
                    if (acceptee == null)
                    {
                        this.chatMessage(player, config.getMessage("notOnline", new string[] { name }));
                        return;
                    }

                    faction = this.getPlayerOwnedFaction(player);
                    if (!faction.hasRequest(acceptee))
                    {
                        this.chatMessage(player, config.getMessage("notAcceptee", new string[] { acceptee.displayName }));
                        return;
                    }

                    this.promoteToMember(faction, player);
                    this.chatMessage(player, config.getMessage("playerAccepted", new string[] { acceptee.displayName }));

                    return;
                #endregion

                #region deny
                case "deny":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "deny" }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("deny ", "");
                    acceptee = this.getPlayerByName(name);
                    if (acceptee == null)
                    {
                        this.chatMessage(player, config.getMessage("notOnline", new string[] { name }));
                        return;
                    }

                    faction = this.getPlayerOwnedFaction(player);
                    if (!faction.hasRequest(acceptee))
                    {
                        this.chatMessage(player, config.getMessage("notAcceptee", new string[] { acceptee.displayName }));
                        return;
                    }

                    this.rejectFromMember(faction, player);
                    this.chatMessage(player, config.getMessage("playerDenied", new string[] { acceptee.displayName }));

                    return;
                #endregion

                #region kick
                case "kick":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "kick" }));
                        return;
                    }

                    name = string.Join(" ", args).Replace("kick ", "");
                    BasePlayer kickee = this.getPlayerByName(name);
                    if (kickee == null)
                    {
                        this.chatMessage(player, config.getMessage("notOnline", new string[] { name }));
                        return;
                    }

                    faction = this.getPlayerOwnedFaction(player);
                    if (!faction.hasMember(kickee))
                    {
                        this.chatMessage(player, config.getMessage("notAcceptee", new string[] { kickee.displayName }));
                        return;
                    }

                    this.kickMember(faction, player);
                    this.chatMessage(player, config.getMessage("playerKicked", new string[] { kickee.displayName }));
                    this.chatMessage(kickee, config.getMessage("playerKickReceived", new string[] { faction.name }));

                    return;
                #endregion

                #region info
                case "info":
                    if (args.Length < 2)
                    {
                        this.chatMessage(player, config.getMessage("invalidCommand", new string[] { "info" }));
                        return;
                    }
                    
                    name = string.Join(" ", args).Replace("info ", "");
                    faction = this.getFactionByName(name);
                    if (faction == null)
                    {
                        this.chatMessage(player, config.getMessage("notCreated", new string[] { name }));
                        return;
                    }

                    this.chatMessage(
                        player,
                        config.getMessage(
                            "factionInfo",
                            new string[]
                            {
                                faction.name,
                                this.getFactionOwner(faction),
                                faction.members.Count().ToString()
                            }
                        )
                    );

                    return;
                #endregion
            }
        }
        #endregion

        #region console commands
        [ConsoleCommand("factions.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            this.loaded = false;
            this.SetupConfig();
            this.Print("Factions Reloaded");
        }

        [ConsoleCommand("factions.version")]
        void cmdConsoleVersion(ConsoleSystem.Arg arg)
        {
            this.Print(Version.ToString());
        }
        #endregion



        #region private helpers
        private void Print(object msg)
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("{0}: {1}", Title, msg);
        }

        private BasePlayer getActivePlayer(string userId)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string id = player.userID.ToString();
                if (id.Equals(userId))
                {
                    return player;
                }
            }

            return null;
        }

        private void chatMessage(BasePlayer player, List<string> messages)
        {
            foreach (string message in messages)
            {
                player.ChatMessage(string.Format("<color={0}>{1}</color>: " + message, config.chatPrefixColor, config.chatPrefix));
            }
        }

        public Faction getFactionByName(string name)
        {
            foreach (Faction faction in this.factions)
            {
                if (faction.name.ToLower().Equals(name.ToLower()))
                {
                    return faction;
                }
            }

            return null;
        }

        private bool playerHasFaction(BasePlayer player)
        {
            foreach (Faction faction in this.factions)
            {
                if (faction.hasMember(player))
                {
                    return true;
                }
            }

            return false;
        }

        private string getFactionOwner(Faction faction)
        {
            BasePlayer player = this.getActivePlayer(faction.owner);

            return player == null ? "offline" : player.displayName;
        }

        private Faction getPlayerOwnedFaction(BasePlayer player)
        {
            foreach (Faction faction in this.factions)
            {
                if (faction.isOwnedBy(player))
                {
                    return faction;
                }
            }

            return null;
        }

        private Faction getPlayerFaction(BasePlayer player)
        {
            foreach (Faction faction in this.factions)
            {
                if (faction.hasMember(player))
                {
                    return faction;
                }
            }

            return null;
        }

        /**
         * Has to Save Data
         */
        private void createFaction(string name, BasePlayer player)
        {
            Faction faction = new Faction();
            faction.initialize(name, player);
            this.saveFaction(faction);
        }

        /**
         * Has to Save Data
         */
        private void sendRequestToFaction(Faction faction, BasePlayer player)
        {
            if (faction.hasMember(player) || faction.hasRequest(player))
            {
                return;
            }

            if (faction.hasInvite(player))
            {
                faction.addMember(player);
                this.chatMessage(player, config.getMessage("membershipGranted", new string[] { faction.name }));
            }
            else
            {
                faction.addRequest(player);
                this.chatMessage(player, config.getMessage("requestSent", new string[] { faction.name }));
                this.sendFactionMessage(faction, player);
            }

            this.saveFaction(faction);
        }

        private void sendFactionMessage(Faction faction, BasePlayer requestee)
        {
            BasePlayer owner = this.getActivePlayer(faction.owner);
            if (owner != null)
            {
                this.chatMessage(owner, config.getMessage("requestReceived", new string[] { requestee.displayName.ToString() }));
            }
        }

        /**
         * Has to Save Data
         */
        private void inviteMember(Faction faction, BasePlayer player)
        {
            faction.addInvite(player);
            this.saveFaction(faction);
        }

        private void rejectInvitation(BasePlayer player, Faction faction)
        {
            faction.removePlayer(player);
            this.saveFaction(faction);
        }

        /**
         * Has to Save Data
         */
        private void kickMember(Faction faction, BasePlayer player)
        {
            faction.removePlayer(player);
            this.saveFaction(faction);
        }

        /**
         * Has to Save Data
         */
        private void promoteToMember(Faction faction, BasePlayer player)
        {
            faction.removePlayer(player);
            faction.addMember(player);

            this.saveFaction(faction);

            this.chatMessage(player, config.getMessage("membershipGranted", new string[] { faction.name }));
        }

        /**
         * Has to Save Data
         */
        private void rejectFromMember(Faction faction, BasePlayer player)
        {
            faction.removePlayer(player);

            this.saveFaction(faction);

            this.chatMessage(player, config.getMessage("membershipDenied", new string[] { faction.name }));
        }

        private BasePlayer getPlayerByName(string name)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.displayName.Equals(name))
                {
                    return player;
                }
            }

            return null;
        }

        private void saveFaction(Faction faction)
        {
            this.Print("Saving the " + faction.name + " faction");
            if (!this.factions.Contains(faction))
            {
                this.factions.Add(faction);
            }
            SaveData();
        }
        #endregion
    }
}


namespace LFG
{
    public class Faction
    {
        public string name { set; get; }
        public string owner { set; get; }
        public List<string> members { set; get; }
        public List<string> requests { set; get; }
        public List<string> invites { set; get; }
        public Faction()
        {
            this.members = new List<string>();
            this.requests = new List<string>();
            this.invites = new List<string>();
        }

        public void initialize(string name, BasePlayer owner)
        {
            this.name = name;
            this.owner = owner.userID.ToString();
            this.addMember(owner);
        }

        public bool isOwnedBy(BasePlayer player)
        {
            string id = player.userID.ToString();
            return id.Equals(this.owner);
        }

        public bool hasMember(BasePlayer player)
        {
            return this.members.Contains(player.userID.ToString());
        }

        public bool hasRequest(BasePlayer player)
        {
            return this.requests.Contains(player.userID.ToString());
        }

        public bool hasInvite(BasePlayer player)
        {
            return this.invites.Contains(player.userID.ToString());
        }

        public void addMember(BasePlayer player)
        {
            string id = player.userID.ToString();
            // Don't do anything if the user is already a member. This should happen here.
            if (this.members.Contains(id))
            {
                return;
            }

            // Remove user requests and invites
            if (this.requests.Contains(id))
            {
                this.requests.Remove(id);
            }
            if (this.invites.Contains(id))
            {
                this.invites.Remove(id);
            }

            this.members.Add(id);
        }

        public void addInvite(BasePlayer player)
        {
            string id = player.userID.ToString();
            //If the user is already a member, or is already invited, don't do anything
            if (this.members.Contains(id) || this.invites.Contains(id))
            {
                return;
            }

            // If the user has already requested, just make them a member
            if (this.requests.Contains(id))
            {
                this.addMember(player);
                return;
            }

            this.invites.Add(id);
        }

        public void addRequest(BasePlayer player)
        {
            string id = player.userID.ToString();
            //If the user is already a member, or has already requested, don't do anything
            if (this.members.Contains(id) || this.requests.Contains(id))
            {
                return;
            }

            // If the user has already been invited, just make them a member
            if (this.invites.Contains(id))
            {
                this.addMember(player);
                return;
            }

            this.requests.Add(id);
        }

        public void removePlayer(BasePlayer player)
        {
            string id = player.userID.ToString();
            if (this.members.Contains(id))
            {
                this.members.Remove(id);
            }
            if (this.requests.Contains(id))
            {
                this.requests.Remove(id);
            }
            if (this.invites.Contains(id))
            {
                this.invites.Remove(id);
            }
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\FamilyShareBlocker.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

namespace Oxide.Plugins
{

    [Info("FamilyShareBlocker", "Mughisi", "1.0.0")]
    class FamilyShareBlocker : RustPlugin
    {

        #region Configuration Data
        // Do not modify these values, to configure this plugin edit
        // 'RemoverTool.json' in your server's config folder.
        // <drive>:\...\server\<server identity>\oxide\config\

        private bool configChanged = false;

        // Plugin settings
        string defaultChatPrefix = "Family Share Blocker";
        string defaultChatPrefixColor = "008000ff";
        string defaultAPIKey = "STEAM_API_KEY";

        string chatPrefix;
        string chatPrefixColor;
        string APIKey;

        // Plugin options
        bool defaultLogToConsole = true;
        List<object> defaultWhitelist = new List<object>();

        bool logToConsole;
        List<string> whitelist = new List<string>();

        #endregion

        public class WebResponse
        {

            [JsonProperty("response")]
            public Content Response { get; set; }

            public class Content
            {

                [JsonProperty("lender_steamid")]
                public string LenderSteamid { get; set; }
            }
        }

        void Loaded()
        {
            LoadConfigValues();
        }

        protected override void LoadDefaultConfig()
        {
            Log("New configuration file created.");
        }

        void LoadConfigValues()
        {
            APIKey = Convert.ToString(GetConfigValue("Settings", "SteamAPIKey", defaultAPIKey));
            logToConsole = Convert.ToBoolean(GetConfigValue("Options", "LogToConsole", defaultLogToConsole));
            var list = GetConfigValue("Options", "Whitelist", defaultWhitelist);

            whitelist.Clear();
            foreach (object steamID in list as List<object>)
                whitelist.Add(steamID.ToString());

            if (configChanged)
            {
                SaveConfig();
                Log("Configuration file updated.");
            }
        }

        void CanClientLogin(Network.Connection connection)
        {
            if (APIKey == defaultAPIKey || APIKey == "")
            {
                Log("Error! No Steam API key found.");
                Log("You need to set your API key in the configuration file for this plugin to work!");
                Log("To obtain an API key browse to http://steamcommunity.com/dev/apikey");
                return;
            }

            string playerName = connection.username;
            string steamID = Convert.ToString(connection.userid);

            if (whitelist.Contains(steamID))
            {
                if (logToConsole)
                    Log($"{playerName} ({steamID}) is whitelisted, allowing the player to join.");
                return;
            }

            string url = $"http://api.steampowered.com/IPlayerService/IsPlayingSharedGame/v0001/?key={APIKey}&steamid={steamID}&appid_playing=252490";
            Interface.GetMod().GetLibrary<WebRequests>("WebRequests").EnqueueGet(url, (code, response) => IsFamilySharing(code, response, connection), this);
        }

        void IsFamilySharing(int code, string response, Network.Connection connection)
        {
            string playerName = connection.username;
            string steamID = Convert.ToString(connection.userid);

            switch (code)
            {
                case 200:
                    var json = JsonConvert.DeserializeObject<WebResponse>(response);
                    if (json.Response.LenderSteamid != "0")
                    {
                        if (logToConsole)
                            Log($"{playerName} ({steamID}) is using a family shared account, kicking player...");
                        Network.Net.sv.Kick(connection, "Family shared accounts are not allowed.");
                    }
                    break;
                case 401:
                    Log("Webrequest failed, invalid Steam API key.");
                    break;
                case 404:
                case 503:
                    Log("Webrequest failed. Steam API unavailable.");
                    break;
                default:
                    Log($"Webrequest failed. Error code {code}.");
                    break;
            }
        }

        #region Helper methods

        void Log(string message)
        {
            Puts("{0} : {1}", Title, message);
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }

        #endregion
    }

}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Fly.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System;
using System.Reflection;
using UnityEngine;
 
namespace Oxide.Plugins
{

    [Info("Fly", "Bombardir", "0.5.0", ResourceId = 822)]
	class Fly : RustPlugin
	{
        private static FieldInfo serverinput;
        private static byte authLevel = 2;

		class FlyMode : MonoBehaviour 
		{
			private float speed;
            private Vector3 direction;
            private InputState input;
			private BasePlayer player;
		
			private void CheckParent()
			{
				BaseEntity parentEntity = player.GetParentEntity();
				if (parentEntity != null)
				{
					parentEntity.RemoveChild(player);
					Vector3 CurrPos = parentEntity.transform.position;
					player.parentEntity.Set(null);
					player.parentBone = 0U;
					transform.position = CurrPos;
					player.UpdateNetworkGroup();
					player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
				}
			}

            private void Move(Vector3 newpos)
            {
                transform.position = newpos;
                player.ClientRPC(null, player, "ForcePositionTo", new object[] { newpos });
            }
		
			void Awake () 
			{
                speed = 10;
                player = GetComponent<BasePlayer>();
				input = serverinput.GetValue(player) as InputState;
				enabled = false;
			}

            void FixedUpdate()
            {
                if (input.IsDown(BUTTON.CHAT))
                    enabled = false;
                else
                {
                    if (!player.IsSpectating())
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        TransformEx.SetLayerRecursive(gameObject, "Invisible");
                        CancelInvoke("MetabolismUpdate");
                        CancelInvoke("InventoryUpdate");
                    }

                    direction = Vector3.zero;
                    if (input.IsDown(BUTTON.FORWARD))
                        direction.z++;
                    if (input.IsDown(BUTTON.RIGHT))
                        direction.x++;
                    if (input.IsDown(BUTTON.LEFT))
                        direction.x--;
                    if (input.IsDown(BUTTON.BACKWARD))
                        direction.z--;

                    if (input.IsDown(BUTTON.FIRE_PRIMARY))
                        if (input.IsDown(BUTTON.PREVIOUS))
                            speed++;
                        else if (input.IsDown(BUTTON.NEXT))
                            speed--;

                    if (direction != Vector3.zero)
                    {
                        CheckParent();
                        Move(transform.position + Quaternion.Euler(input.current.aimAngles) * direction * Time.deltaTime * speed);
                    }
                }
            }

            void OnDisable()
            {
				CheckParent();
                RaycastHit hit;
                if (Physics.Raycast(new Ray(transform.position, Vector3.down), out hit, 25000) || Physics.Raycast(new Ray(transform.position, Vector3.up), out hit, 25000))
                    Move(hit.point);
                player.metabolism.Reset();
                InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                TransformEx.SetLayerRecursive(gameObject, "Player (Server)");
                player.ChatMessage("Fly deactivated!");
            }
		}
		
        void OnPlayerDisconnected(BasePlayer player)
        {
            FlyMode fly = player.GetComponent<FlyMode>();
            if (fly)
                fly.enabled = false;
        }

		void LoadDefaultConfig()
		{
			Config["AuthLevel"] = 2;
			SaveConfig();
		}
    
        void Init()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Instance | BindingFlags.NonPublic));
			if (Config["AuthLevel"] != null)
				authLevel = Convert.ToByte(Config["AuthLevel"]);
        }
		
		void Unload()
		{	
			var objects = GameObject.FindObjectsOfType(typeof(FlyMode));
			if (objects != null)
				foreach (var gameObj in objects)
					GameObject.Destroy(gameObj);
		} 

        [ChatCommand("fly")]
        void FlyCMD(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel >= authLevel)
			{
				FlyMode fly = player.GetComponent<FlyMode>();
				if (!fly)
					fly = player.gameObject.AddComponent<FlyMode>();
				fly.enabled = true;
				SendReply(player, "Fly activated!");
			}
			else
				SendReply(player, "No Permission!");
        }
	}
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\FriendlyFire.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("FriendlyFire", "playrust.io / dcode", "1.3.4", ResourceId = 840)]
    public class FriendlyFire : RustPlugin
    {

        #region Rust:IO Bindings

        private Library lib;
        private MethodInfo isInstalled;
        private MethodInfo hasFriend;
        private MethodInfo addFriend;
        private MethodInfo deleteFriend;

        private void InitializeRustIO() {
            lib = Interface.GetMod().GetLibrary<Library>("RustIO");
            if (lib == null || (isInstalled = lib.GetFunction("IsInstalled")) == null || (hasFriend = lib.GetFunction("HasFriend")) == null || (addFriend = lib.GetFunction("AddFriend")) == null || (deleteFriend = lib.GetFunction("DeleteFriend")) == null) {
                lib = null;
                Puts("{0}: {1}", Title, "Rust:IO is not present. You need to install Rust:IO first in order to use this plugin!");
            }
        }

        private bool IsInstalled() {
            if (lib == null) return false;
            return (bool)isInstalled.Invoke(lib, new object[] {});
        }

        private bool HasFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)hasFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool AddFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)addFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool DeleteFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)deleteFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        #endregion

        private List<ulong> manuallyEnabledBy = new List<ulong>();
        private List<string> texts = new List<string>() {
            "%NAME% is your friend and cannot be hurt. To disable this, unshare your location with %NAME% on the live map or type: <color=\"#ffd479\">/ff on</color>",

            "Usage: <color=\"#ffd479\">/ff [on|off]</color>",
            "Friendly fire is <color=#cd422b>enabled</color> for your friends:",
            "Friendly fire is <color=#8acd2b>disabled</color> for your friends:",
            "You do not have any friends currently.",
            "You may add or delete friends using the live map.",
            "To toggle friendly fire on or off, type: <color=\"#ffd479\">/ff on|off</color>",
            "Friendly fire for your friends is already <color=#cd422b>enabled</color>. Take care!",
            "You have <color=#cd422b>enabled</color> friendly fire for your friends. Take care!",
            "Friendly fire for your friends is already <color=#8acd2b>disabled</color>. They are safe!",
            "You have <color=#8acd2b>disabled</color> friendly fire for your friends. They are safe!",

            "<color=\"#ffd479\">/ff</color> - Displays your friendly fire status",
            "<color=\"#ffd479\">/ff on|off</color> - Toggles friendly fire <color=#cd422b>on</color> or <color=#8acd2b>off</color>"
        };
        private Dictionary<string, string> messages = new Dictionary<string, string>();
        private Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();

        // Translates a string
        private string _(string text, Dictionary<string, string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }


        // Loads the default configuration
        protected override void LoadDefaultConfig() {
            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue) {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            try {
                InitializeRustIO();
                LoadConfig();
                var customMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (customMessages != null)
                    foreach (var pair in customMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
            } catch (Exception ex) {
                Error("OnServerInitialized failed: " + ex.Message);
            }
        }

        private void RestoreDefaults(BasePlayer player) {
            manuallyEnabledBy.Remove(player.userID);
        }

        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player) {
            RestoreDefaults(player);
        }

        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player) {
            RestoreDefaults(player);
        }

        [HookMethod("OnEntityTakeDamage")]
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit) {
            try {
                if (lib == null || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer) || (entity == hit.Initiator))
                    return null;
                var victim = entity as BasePlayer;
                var victimId = victim.userID.ToString();
                var attacker = hit.Initiator as BasePlayer;
                var attackerId = attacker.userID.ToString();
                var key = attackerId + "-" + victimId;
                if (!manuallyEnabledBy.Contains(attacker.userID) && HasFriend(attackerId, victimId)) {
                    DateTime now = DateTime.UtcNow;
                    DateTime time;
                    if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-10)) {
                        attacker.SendConsoleCommand("chat.add", "", _("%NAME% is your friend and cannot be hurt. To disable this, unshare your location with %NAME% on the live map or type: <color=\"#ffd479\">/ff on</color>", new Dictionary<string, string>() { { "NAME", victim.displayName } }));
                        notificationTimes[key] = now;
                    }
                    hit.damageTypes = new DamageTypeList(); // clear damage
                    return false;
                }
            } catch (Exception ex) {
                Error("OnEntityAttacked failed: " + ex.Message);
            }
            return null;
        }

        [ChatCommand("ff")]
        private void cmdChatFF(BasePlayer player, string command, string[] args) {
            if (!IsInstalled())
                return;
            if (args.Length > 1) {
                SendReply(player, _("Usage: <color=\"#ffd479\">/ff [on|off]</color>"));
                return;
            }
            if (args.Length == 0) {
                var sb = new StringBuilder();
                int n = 0;
                sb.Append("<size=22>FriendlyFire</size> "+Version+" by <color=#ce422b>http://playrust.io</color>\n");
                if (manuallyEnabledBy.Contains(player.userID))
                    sb.Append(_("Friendly fire is <color=#cd422b>enabled</color> for your friends:")).Append("\n");
                else
                    sb.Append(_("Friendly fire is <color=#8acd2b>disabled</color> for your friends:")).Append("\n");
                var playerId = player.userID.ToString();
                foreach (var p in BasePlayer.activePlayerList) {
                    var pId = p.userID.ToString();
                    if (HasFriend(playerId, pId)) {
                        if (n > 0)
                            sb.Append(", ");
                        sb.Append(p.displayName);
                        ++n;
                    }
                }
                foreach (var p in BasePlayer.sleepingPlayerList) {
                    var pId = p.userID.ToString();
                    if (HasFriend(playerId, pId)) {
                        if (n > 0)
                            sb.Append(", ");
                        sb.Append(p.displayName);
                        ++n;
                    }
                }
                if (n == 0)
                    sb.Append(_("You do not have any friends currently."));
                sb.Append("\n").Append(_("You may add or delete friends using the live map."));
                sb.Append("\n").Append(_("To toggle friendly fire on or off, type: <color=\"#ffd479\">/ff on|off</color>"));
                SendReply(player, sb.ToString());
            } else if (args.Length == 1) {
                switch (args[0]) {
                    case "on":
                        if (manuallyEnabledBy.Contains(player.userID)) {
                            SendReply(player, _("Friendly fire for your friends is already <color=#cd422b>enabled</color>. Take care!"));
                        } else {
                            manuallyEnabledBy.Add(player.userID);
                            SendReply(player, _("You have <color=#cd422b>enabled</color> friendly fire for your friends. Take care!"));
                        }
                        break;
                    case "off":
                        if (!manuallyEnabledBy.Contains(player.userID)) {
                            SendReply(player, _("Friendly fire for your friends is already <color=#8acd2b>disabled</color>. They are safe!"));
                        } else {
                            manuallyEnabledBy.Remove(player.userID);
                            SendReply(player, _("You have <color=#8acd2b>disabled</color> friendly fire for your friends. They are safe!"));
                        }
                        break;
                    default:
                        SendReply(player, _("Usage: <color=\"#ffd479\">/ff [on|off]</color>"));
                        return;
                }
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>FriendlyFire</size> by <color=#ce422b>http://playrust.io</color>\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/ff</color> - Displays your friendly fire status")).Append("\n")
               .Append("  ").Append(_("<color=\"#ffd479\">/ff on|off</color> - Toggles friendly fire <color=#cd422b>on</color> or <color=#8acd2b>off</color>"));
            player.ChatMessage(sb.ToString());
        }

        [HookMethod("BuildServerTags")]
        private void BuildServerTags(IList<string> taglist) {
            taglist.Add("friendlyfire");
        }

        #region Utility Methods

        private void Log(string message) {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message) {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message) {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Give.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;

using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Give", "Reneb", "2.1.2", ResourceId = 666)]
    class Give : RustPlugin
    {
        private bool Changed;

        private int giveBasic;
        private int giveAll;
        private int giveKit;
        private string itemNotFound;
        private string multiplePlayersFound;
        private string noPlayersFound;
        private string noAccess;
        private bool logAdmins;
        private bool Stackable;

        private Dictionary<string,string> displaynameToShortname;

        [PluginReference]
        Plugin Kits;
        
        void Loaded() 
        {
            LoadVariables();
            displaynameToShortname = new Dictionary<string, string>();
        }
        void OnServerInitialized()
        {
            InitializeTable();
        }

        private void InitializeTable () {
            displaynameToShortname.Clear ();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions () ;
            foreach (ItemDefinition itemdef in ItemsDefinition) {
                displaynameToShortname.Add (itemdef.displayName.english.ToString ().ToLower (), itemdef.shortname.ToString ());
            }
        }
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        private void LoadVariables()
        {
            giveBasic = Convert.ToInt32(GetConfig("authLevel", "give", 1));
            giveAll = Convert.ToInt32(GetConfig("authLevel", "giveall", 2));
            giveKit = Convert.ToInt32(GetConfig("authLevel", "givekit", 1));
            logAdmins = Convert.ToBoolean(GetConfig("Give", "logAdmins", true));
            itemNotFound = Convert.ToString(GetConfig("Messages", "itemNotFound", "This item doesn't exist: "));
            multiplePlayersFound = Convert.ToString(GetConfig("Messages", "multiplePlayersFound", "Multiple Players Found"));
            noPlayersFound = Convert.ToString(GetConfig("Messages", "noPlayersFound", "No Players Found"));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You are not allowed to use this command"));
            Stackable = Convert.ToBoolean(GetConfig("Give", "overrightStackable", false));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Give: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        bool hasAccess(BasePlayer player, string ttype)
        {
            if (ttype == "give" && player.net.connection.authLevel >= giveBasic)
                return true;
            if (ttype == "giveall" && player.net.connection.authLevel >= giveAll)
                return true;
            if (ttype == "givekit" && player.net.connection.authLevel >= giveKit)
                return true;
            return false;
        }
        private object FindPlayerByID(ulong steamid) {
            BasePlayer targetplayer = BasePlayer.FindByID(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            targetplayer = BasePlayer.FindSleeping(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            return null;
        }
        private object FindPlayer(string tofind)
        {
            if (tofind.Length == 17)
            {
                ulong steamid;
                if (ulong.TryParse(tofind.ToString(), out steamid))
                {
                    return FindPlayerByID(steamid);
                }
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
            object targetplayer = null;
            foreach (BasePlayer player in onlineplayers.ToArray())
            {

                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return multiplePlayersFound;
                }
            }
            if (targetplayer != null)
                return targetplayer;
            List<BasePlayer> offlineplayers = BasePlayer.sleepingPlayerList as List<BasePlayer>;
            foreach (BasePlayer player in offlineplayers.ToArray())
            {

                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return multiplePlayersFound;
                }
            }
            if (targetplayer == null)
                return noPlayersFound;
            return targetplayer;
        }
        public object GiveItem(BasePlayer player, string itemname, int amount, ItemContainer pref, out string description)
        {
            description = itemname;
            itemname = itemname.ToLower();
            if (amount < 1) amount = 1;
            bool isBP = false;
            if (itemname.EndsWith(" bp"))
            {
                isBP = true;
                itemname = itemname.Substring(0, itemname.Length - 3);
            }
            if (displaynameToShortname.ContainsKey(itemname))
                itemname = displaynameToShortname[itemname];
            var definition = ItemManager.FindItemDefinition(itemname);
            if (definition == null)
                return string.Format("{0} {1}",itemNotFound,itemname);
            description = definition.displayName.english.ToString();
            int giveamount = 0;
            int stack = (int)definition.stackable;
            if (stack < 1) stack = 1;
            if (isBP)
            {
                stack = 1;
                description = description + " BP";
            }
            if (Stackable && !isBP)
            {
                player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, amount, isBP), pref);
                SendReply(player, string.Format("You've received {0} x {1}", description, amount.ToString()));
            }
            else
            {
                for (var i = amount; i > 0; i = i - stack)
                {
                    if (i >= stack)
                        giveamount = stack;
                    else
                        giveamount = i;
                    if (giveamount < 1) return true;
                    player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, giveamount, isBP), pref);
                    SendReply(player, string.Format("You've received {0} x {1}", description, giveamount.ToString()));
                }
            }
            return true;
        }
        bool hasKit(string args)
        {
            if (args.Contains(" kit"))
                return true;
            else if (args == "kit")
                return true;
            else if (args.StartsWith("kit "))
                return true;
            return false;
        }
       
        void GiveKit(object source, string[] Args, string ttype)
        {
            if (source is BasePlayer)
            {
                if (((BasePlayer)source).net.connection.authLevel < giveKit)
                {
                    SendTheReply(source, noAccess);
                    return;
                }
            }
            if(Kits == null)
            {
                SendTheReply(source, "You must have the Kits plugin to use this command");
                return;
            }
            if ((ttype == "all" && Args.Length <= 1) || (ttype == "self" && Args.Length <= 1) || (ttype == "player" && Args.Length <= 2))
            {
                SendTheReply(source, "===== Available kits to give =====");
                Kits?.Call ("SendList", source);
                return;
            }
            object target = false;
            if (ttype == "player")
                target = FindPlayer(Args[0]);
            else if (ttype == "self")
                target = source;
            else if (ttype == "all")
                target = true;

            if (target == null) {
                SendTheReply (source, "Couldn't find a player with the steam id " + Args [0].ToString ());
                return;
            }
            if (target is string)
            {
                SendTheReply(source, (string)target);
                return;
            }

            if (Args [Args.Length - 1].ToLower () == "online") {
                var targetPlayer = target as BasePlayer;
                if (!targetPlayer.IsConnected ()) {
                    SendTheReply (source, "Player needs to be online to receive the item!");
                    return;
                }
            }

            object targetkit;
            if (ttype == "player")
                targetkit = Args[2];
            else
                targetkit = Args[1];
            if (ttype == "all")
            {

                int sentkits = 0;
                List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
                foreach (BasePlayer onlineplayer in onlineplayers.ToArray())
                {
                    object trytogivekit = Kits?.Call("GiveKit", onlineplayer, targetkit);
                    if (trytogivekit == null || (trytogivekit is bool && (!(bool)trytogivekit)))
                    {
                        SendTheReply(source, "Couldn't give the kit, does it really exist?");
                        return;
                    }
                    sentkits++;
                }
                SendTheReply(source, string.Format("Kit {0} was given to {1} players",targetkit,sentkits.ToString()));
                if (logAdmins)
                    Puts(string.Format("GIVE: /giveall {0} was used", string.Join(" ", Args)));
            }
            else
            {
                object trytogivekit = Kits?.Call ("GiveKit", target, targetkit);
                if (trytogivekit == null || (trytogivekit is bool && (!(bool)trytogivekit)))
                {
                    SendTheReply(source, "Couldn't give the kit, does it really exist?");
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: /give {0} was used", string.Join(" ", Args)));
            }
        }
        void SendTheReply(object source, string message)
        {
            if(source is ConsoleSystem.Arg)
                SendReply((ConsoleSystem.Arg)source, message);
            else
                SendReply((BasePlayer)source, message);
        }
        void GivePlayer(object source, string[] Args)
        {
            if (Args.Length == 1)
            {
                SendTheReply(source, "You need to set an item to give");
                return;
            }
            int amount = 1;
            if (Args.Length > 2)
                int.TryParse(Args[2].ToString(), out amount);

            if (amount == 0)
                amount = 1;

            var target = FindPlayer(Args[0].ToString());
            if (target == null) {
                SendTheReply (source, "Couldn't find a player with the steam id " + Args [0].ToString ());
                return;
            }
            if (target is string)
            {
                SendTheReply(source, target.ToString());
                return;
            }

            if (Args [Args.Length - 1].ToLower() == "online") {
                var targetPlayer = target as BasePlayer;
                if (!targetPlayer.IsConnected()) {
                    SendTheReply (source, "Player needs to be online to receive the item!");
                    return;
                }
            }

            string description = Args[1];
            object error = GiveItem((BasePlayer)target, Args[1], amount, (ItemContainer)((BasePlayer)target).inventory.containerMain, out description);
            if (!(error is bool))
            {
                SendTheReply(source, error.ToString());
                return;
            }
            SendTheReply(source, string.Format("Gave {0} x {1} to {2}", description, amount.ToString(), ((BasePlayer)target).displayName.ToString()));
        }
        void GiveSelf(object source, BasePlayer player, string[] Args)
        {
            int amount = 1;
            if (Args.Length > 1)
                int.TryParse(Args[1].ToString(), out amount);

            string description = Args[0];
            object error = GiveItem(player, Args[0], amount, (ItemContainer)player.inventory.containerMain, out description);
            if (!(error is bool))
            {
                SendTheReply(source, error.ToString());
                return;
            }
            SendTheReply(source, string.Format("Gave {0} x {1} to {2}", description, amount.ToString(), player.displayName.ToString()));
        }
        private void GiveToAll(ConsoleSystem.Arg arg)
        {
            int playersSent = 0;
            int amount = 1;
            if (arg.Args.Length > 1)
            {
                int.TryParse(arg.Args[1].ToString(), out amount);
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
            object error = false;
            string description = arg.Args[0].ToString();
            foreach (BasePlayer player in onlineplayers.ToArray())
            {
                playersSent++;
                error = GiveItem(player, arg.Args[0], amount, (ItemContainer)player.inventory.containerMain, out description);
            }
            if (!(error is bool))
            {
                SendTheReply(arg, error.ToString());
                return;
            }
            SendTheReply(arg, string.Format("Gave {0} x {1} to {2} inventories", description, amount.ToString(), playersSent.ToString()));
        }
        [ChatCommand("give")]
        void cmdChatGivePlayer(BasePlayer player, string command, string[] args)
        {
            if (hasKit(string.Join(" ", args)))
            {
                GiveKit(player, args, "player");
                return;
            }
            if (player.net.connection.authLevel < giveBasic)
            {
                SendReply(player, noAccess);
                return;
            }
            if ((args == null) || (args != null && args.Length == 0))
            {
                SendReply(player, "/give \"Name/SteamID\" \"Item/Kit\" \"Amount\" ");
                return;
            }
            if (logAdmins)
                Puts(string.Format("GIVE: {0} used /give {1}", player.displayName.ToString(), string.Join(" ", args)));
            GivePlayer(player, args);
        }
        [ChatCommand("giveme")]
        void cmdChatGiveMe(BasePlayer player, string command, string[] args)
        {
            if (hasKit(string.Join(" ", args)))
            {
                GiveKit(player, args, "self");
                return;
            }
            if (player.net.connection.authLevel < giveBasic)
            {
                SendReply(player, noAccess);
                return;
            }
            if ((args == null) || (args != null && args.Length == 0))
            {
                SendReply(player, "/giveme \"Item/Kit\" \"Amount\" ");
                return;
            }
            if (logAdmins)
                Puts(string.Format("GIVE: {0} used /giveme {1}", player.displayName.ToString(), string.Join(" ", args)));
            GiveSelf(player, player, args);
        }
        [ConsoleCommand("inv.giveplayer")]
        void cmdConsoleGivePlayer(ConsoleSystem.Arg arg)
        {
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.giveplayer \"Name/SteamID\" \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "player");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveBasic)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveplayer {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            else
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveplayer {1}", "CONSOLE", arg.ArgsStr.ToString()));
            GivePlayer(arg, arg.Args);
        }
        [ConsoleCommand("inv.give")]
        void cmdConsoleGive(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                SendReply(arg, "You can't use this command from the console");
                return;
            }
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.give \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "self");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveBasic)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.give {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            GiveSelf(arg, (BasePlayer)arg.connection.player, (string[])arg.Args);
        }
        [ConsoleCommand("inv.giveall")]
        void cmdConsoleGiveAll(ConsoleSystem.Arg arg)
        {
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.giveall \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "all");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveAll)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveall {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            else
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveall {1}", "CONSOLE", arg.ArgsStr.ToString()));
            GiveToAll(arg);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\HappyHour.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Oxide.Ext.Unity
// Reference: Newtonsoft.Json

/*
 * The MIT License (MIT)
 * Copyright (c) 2015 feramor@computer.org
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.Collections.Generic;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;

//External NameSpaces
using Newtonsoft.Json;

namespace Oxide.Plugins
{

    [Info("Happy Hour Plugin", "Feramor", "1.0.4", ResourceId = 807)]
    public class HappyHour : RustPlugin
    {
        public Core.Configuration.DynamicConfigFile mySave;
        Dictionary<string, object> Users = new Dictionary<string, object>();
        static List<Oxide.Core.Libraries.Timer.TimerInstance> Timers = new List<Oxide.Core.Libraries.Timer.TimerInstance>();
        Time MainTime;
        Oxide.Core.Libraries.Timer MainTimer;
        void Init()
        {
            LoadConfig();
            mySave = Interface.GetMod().DataFileSystem.GetDatafile("HappyHour");
            if (mySave["Users"] != null)
                if (((Dictionary<string, object>)mySave["Users"]).Count != 0)
                    Users = (Dictionary<string, object>)mySave["Users"];
            mySaveData();
            MainTimer = Interface.GetMod().GetLibrary<Oxide.Core.Libraries.Timer>("Timer");
            MainTime = Interface.GetMod().GetLibrary<Time>("Time");
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            MainTimer.Once(0, () => WriteConsole(string.Format("Happy Hour : Adding Happy hours.")), this);
            MainTimer.Once(0, () => CalculateTimers(), this);
        }

        void CalculateTimers()
        {
            foreach (KeyValuePair<string, object> pair in (Dictionary<string, object>)Config["HappyHours"])
            {
                string[] Hour = pair.Key.Split(':');
                long CurrentTime = MainTime.GetUnixTimestamp();
                DateTime EventTimeData = new DateTime(DateTime.UtcNow.Year, DateTime.UtcNow.Month, DateTime.UtcNow.Day, Convert.ToInt32(Hour[0]), Convert.ToInt32(Hour[1]), Convert.ToInt32(Hour[2]), DateTimeKind.Utc);
                long EventTime = Convert.ToInt64((EventTimeData - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);

                if (CurrentTime > EventTime)
                {
                    EventTimeData = EventTimeData.AddDays(1);
                    EventTime = Convert.ToInt64((EventTimeData - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                }

                Dictionary<string, object> Event = (Dictionary<string, object>)pair.Value;
                Event["NextEvent"] = EventTime.ToString();

                List<ItemDefinition> AllItems = ItemManager.GetItemDefinitions();
                Dictionary<string, object> Items = (Dictionary<string, object>)Event["Items"];
                foreach (KeyValuePair<string, object> zItem in (Dictionary<string, object>)Items)
                {
                    Dictionary<string, object> CurrentItem = (Dictionary<string, object>)zItem.Value;
                    foreach (ItemDefinition SearchItem in AllItems)
                    {
                        if (SearchItem.displayName.english == zItem.Key.ToString())
                            CurrentItem["ID"] = SearchItem.shortname.ToString();
                    }
                }
                Oxide.Core.Libraries.Timer.TimerInstance newTimer = MainTimer.Once(EventTime - CurrentTime, () => HappyHours(this, pair), this);
                Timers.Add(newTimer);
                WriteConsole(string.Format("Happy Hour : Added happy hour @ UTC {0} : Next occurrence with server timezone {1}.", pair.Key.ToString(), EventTimeData.ToLocalTime().ToString()));
            }
            SaveConfig();
        }
        private void HappyHours(object sender , object PairObj)
        {
            HappyHour myPlugin = (HappyHour)sender;
            KeyValuePair<string, object> pair = (KeyValuePair<string, object>)PairObj;
            long CurrentTime = MainTime.GetUnixTimestamp();
            Dictionary<string, object> Event = (Dictionary<string, object>)pair.Value;
            if (CurrentTime < (Convert.ToInt64(Event["NextEvent"].ToString()) + Convert.ToInt64(myPlugin.Config["Time"].ToString())))
            {
                foreach (BasePlayer Player in BasePlayer.activePlayerList)
                {
                    if (myPlugin.Users.ContainsKey(Player.userID.ToString()) == false)
                    {
                        myPlugin.myPrintToChat(Player, Event["Message"].ToString());
                        Dictionary<string, object> Items = (Dictionary<string, object>)Event["Items"];
                        foreach (KeyValuePair<string, object> zItem in (Dictionary<string, object>)Items)
                        {
                            Dictionary<string, object> ItemVars = (Dictionary<string, object>)zItem.Value;
                            Item newItem = ItemManager.CreateByName(ItemVars["ID"].ToString(), Convert.ToInt32(ItemVars["Amount"].ToString()));
                            ItemContainer Cont = null;
                            switch (ItemVars["Amount"].ToString())
                            {
                                case "Belt":
                                    Cont = Player.inventory.containerBelt;
                                    break;
                                case "Wear":
                                    Cont = Player.inventory.containerWear;
                                    break;
                                default:
                                    Cont = Player.inventory.containerMain;
                                    break;
                            }
                            Player.inventory.GiveItem(newItem, Cont);
                        }
                        myPlugin.Users.Add(Player.userID.ToString(), CurrentTime.ToString());
                    }
                }
                myPlugin.mySaveData();
                Oxide.Core.Libraries.Timer.TimerInstance newTimer = MainTimer.Once(1, () => HappyHours(sender, PairObj), (Plugin)sender);
                Timers.Add(newTimer);
            }
            else
            {
                myPlugin.WriteConsole(string.Format("Happy Hour : Happy Hour ended @ {0}", DateTime.Now.ToString()));
                string[] Hour = pair.Key.Split(':');
                DateTime EventTimeData = new DateTime(DateTime.UtcNow.Year, DateTime.UtcNow.Month, DateTime.UtcNow.Day, Convert.ToInt32(Hour[0]), Convert.ToInt32(Hour[1]), Convert.ToInt32(Hour[2]), DateTimeKind.Utc);
                long EventTime = Convert.ToInt64((EventTimeData - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                if (CurrentTime > EventTime)
                {
                    EventTimeData = EventTimeData.AddDays(1);
                    EventTime = Convert.ToInt64((EventTimeData - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                }
                Event["NextEvent"] = EventTime.ToString();
                myPlugin.WriteConsole(string.Format("Happy Hour : User List cleared @ {0}", DateTime.Now.ToString()));
                myPlugin.WriteConsole(string.Format("Happy Hour : Same event will occur again @ {0}", EventTimeData.ToLocalTime().ToString()));
                myPlugin.Users.Clear();
                myPlugin.mySaveData();
                Oxide.Core.Libraries.Timer.TimerInstance newTimer = MainTimer.Once((EventTime - CurrentTime), () => HappyHours(sender, PairObj), (Plugin)sender);
                Timers.Add(newTimer);
            }
        }

        [HookMethod("Unload")]
        void myUnload()
        {
            EndTimers();
            Users.Clear();
            mySaveData();
        }

        [HookMethod("LoadDefaultConfig")]
        void myLoadDefaultConfig()
        {
            Dictionary<string, object> ConfigFile = new Dictionary<string, object>();
            Dictionary<string, object> NewHappyHour = new Dictionary<string, object>();
            Dictionary<string, object> Items = new Dictionary<string, object>();
            Dictionary<string, object> Item = new Dictionary<string, object>();
            Item.Add("Amount", 1);
            Item.Add("Type", "Belt");
            Items.Add("Stone Hatchet", Item);
            Items.Add("Building Plan", Item);
            NewHappyHour.Add("Message", "Its time to be happy...");
            NewHappyHour.Add("Items", Items);
            ConfigFile.Add("22:00:00", NewHappyHour);
            ConfigFile.Add("23:00:00", NewHappyHour);
            Config.Clear();
            Config["Time"] = "600";
            Config["ChatTag"] = "Happy Hour";
            Config["HappyHours"] = ConfigFile;
            SaveConfig();

        }
        void OnTick()
        {

        }
        void EndTimers()
        {
            foreach (Oxide.Core.Libraries.Timer.TimerInstance CurrentTimer in Timers)
            {
                if (CurrentTimer != null)
                    if (CurrentTimer.Destroyed == false)
                        CurrentTimer.Destroy();
            }
            Timers.Clear();
        }
        public void WriteConsole(string myText)
        {
            this.Puts(myText);
        }
        public void mySaveData()
        {
            mySave["Users"] = Users;
            Interface.GetMod().DataFileSystem.SaveDatafile("HappyHour");
        }
        public void myPrintToChat(BasePlayer Player, string format, params object[] Args)
        {
            Player.SendConsoleCommand("chat.add", 0, string.Format("<color=orange>{0}</color>  {1}", Config["ChatTag"].ToString(), string.Format(format, Args)), 1.0);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\HumanNPC.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust
// Reference: RustBuild

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("HumanNPC", "Reneb", "0.1.7", ResourceId = 856)]
    class HumanNPC : RustPlugin
    {
         
        ////////////////////////////////////////////////////// 
        ///  Fields
        //////////////////////////////////////////////////////
        private static FieldInfo serverinput;
        private static FieldInfo viewangles;
        private static int playerLayer;
        private DamageTypeList emptyDamage;
        private List<Oxide.Plugins.Timer> TimersList;
        private static Vector3 Vector3Down;
        private static Vector3 Vector3Forward;
        private static Vector3 jumpPosition;
        private static int groundLayer;
        private static int blockshootLayer;

        StoredData storedData;
        static Hash<string, Waypoint> waypoints = new Hash<string, Waypoint>();
        Hash<string, HumanNPCInfo> humannpcs = new Hash<string, HumanNPCInfo>();

        [PluginReference]
        Plugin Kits;
        [PluginReference]
        public static Plugin PathFinding;

        ////////////////////////////////////////////////////// 
        ///  Cached Fields
        //////////////////////////////////////////////////////
        private Quaternion currentRot;

        private Vector3 closestHitpoint;
        private static Vector3 eyesPosition;


        private static RaycastHit hitinfo;

        private object closestEnt;

        ////////////////////////////////////////////////////// 
        ///  class WaypointInfo
        ///  Waypoint information, position & speed
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        class WaypointInfo
        {
            public string x;
            public string y;
            public string z;
            public string s;
            Vector3 position;
            float speed;

            public WaypointInfo(Vector3 position, float speed)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();
                s = speed.ToString();

                this.position = position;
                this.speed = speed;
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
            public float GetSpeed()
            {
                speed = Convert.ToSingle(s);
                return speed;
            }
        }

        ////////////////////////////////////////////////////// 
        ///  class SpawnInfo
        ///  Spawn information, position & rotation
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        class SpawnInfo
        {
            public string x;
            public string y;
            public string z;
            public string rx;
            public string ry;
            public string rz;
            public string rw;
            Vector3 position;
            Quaternion rotation;

            public SpawnInfo(Vector3 position, Quaternion rotation)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();

                rx = rotation.x.ToString();
                ry = rotation.y.ToString();
                rz = rotation.z.ToString();
                rw = rotation.w.ToString();

                this.position = position;
                this.rotation = rotation;
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
            public Quaternion GetRotation()
            {
                if (rotation.x == 0f)
                    rotation = new Quaternion(Convert.ToSingle(rx), Convert.ToSingle(ry), Convert.ToSingle(rz), Convert.ToSingle(rw));
                return rotation;
            }
            public string String()
            {
                return string.Format("Pos({0},{1},{2}) - Rot({3},{4},{5},{6})", x, y, z, rx, ry, rz, rw);
            }
            public string ShortString()
            {
                return string.Format("Pos({0},{1},{2})", Math.Ceiling(position.x).ToString(), Math.Ceiling(position.y).ToString(), Math.Ceiling(position.z).ToString());
            }
            public SpawnInfo Clone()
            {
                var clone = (SpawnInfo)MemberwiseClone();
                return clone;
            }
        }

        ////////////////////////////////////////////////////// 
        ///  class Waypoint
        ///  Waypoint List information
        //////////////////////////////////////////////////////
        class Waypoint
        {
            public string Name;
            public List<WaypointInfo> Waypoints;

            public Waypoint()
            {
                Waypoints = new List<WaypointInfo>();
            }
            public void AddWaypoint(Vector3 position, float speed)
            {
                Waypoints.Add(new WaypointInfo(position, speed));
            }
        }

        ////////////////////////////////////////////////////// 
        ///  class HumanTrigger
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all collisions and area management of humanNPCs
        //////////////////////////////////////////////////////
        class HumanTrigger : MonoBehaviour
        {
            HumanPlayer npc;

            Collider[] colliderArray;

            List<BasePlayer> collidePlayers = new List<BasePlayer>();
            List<BasePlayer> triggerPlayers = new List<BasePlayer>();
            List<BasePlayer> removePlayers = new List<BasePlayer>();

            BasePlayer cachedPlayer;
            public float collisionRadius;

            void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                collisionRadius = float.Parse(npc.info.collisionRadius);
                InvokeRepeating("UpdateTriggerArea", 2, 2);

            }
            void UpdateTriggerArea()
            {
                colliderArray = Physics.OverlapSphere(npc.player.transform.position, collisionRadius, playerLayer);
                foreach (Collider collider in colliderArray)
                {
                    cachedPlayer = collider.GetComponentInParent<BasePlayer>();
                    if (cachedPlayer == null) continue;
                    if (cachedPlayer == npc.player) continue;
                    collidePlayers.Add(cachedPlayer);
                    if (!triggerPlayers.Contains(cachedPlayer)) OnEnterCollision(cachedPlayer);
                }

                foreach (BasePlayer player in triggerPlayers) { if (!collidePlayers.Contains(player)) removePlayers.Add(player); }
                foreach (BasePlayer player in removePlayers) { OnLeaveCollision(player); }
               
                collidePlayers.Clear();
                removePlayers.Clear();
            }
            void OnEnterCollision(BasePlayer targetplayer)
            {
                triggerPlayers.Add(targetplayer);
                Interface.CallHook("OnEnterNPC", npc.player, targetplayer);
            }
            void OnLeaveCollision(BasePlayer targetplayer)
            {
                triggerPlayers.Remove(targetplayer);
                Interface.CallHook("OnLeaveNPC", npc.player, targetplayer);
            }
        }

        ////////////////////////////////////////////////////// 
        ///  class HumanLocomotion
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all movements and attacks of HumanNPCs
        //////////////////////////////////////////////////////
        class HumanLocomotion : MonoBehaviour
        {
            public HumanPlayer npc;
            public Vector3 StartPos = new Vector3(0f, 0f, 0f);
            public Vector3 EndPos = new Vector3(0f, 0f, 0f);
            public Vector3 LastPos = new Vector3(0f, 0f, 0f);
            public Vector3 nextPos = new Vector3(0f, 0f, 0f);
            public float waypointDone = 0f;
            public float secondsTaken = 0f;
            public float secondsToTake = 0f;

            public List<WaypointInfo> cachedWaypoints;
            public int currentWaypoint = -1;

            public float c_attackDistance = 0f;
            public float attackDistance = 0f;
            public float maxDistance = 0f;
            public float damageDistance = 0f;
            public float damageInterval = 0f;
            public float damageAmount = 0f;
            public float lastHit = 0f;
            public float speed = 4f;

            public int noPath = 0;
            public bool shouldMove = true;

            public BaseEntity attackEntity = null;

            public List<Vector3> pathFinding;
            public List<Vector3> temppathFinding;

            void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                cachedWaypoints = GetWayPoints(npc.info.waypoint);
                attackDistance = float.Parse(npc.info.attackDistance);
                maxDistance = float.Parse(npc.info.maxDistance);
                damageDistance = float.Parse(npc.info.damageDistance);
                damageInterval = float.Parse(npc.info.damageInterval);
                damageAmount = float.Parse(npc.info.damageAmount);
                speed = float.Parse(npc.info.speed);
            }
            void FixedUpdate()
            {
                TryToMove();
            }
            void TryToMove()
            {
                if (npc.player.IsWounded()) return;
                if(attackEntity != null) MoveOrAttack(attackEntity);
                else if (secondsTaken == 0f) GetNextPath();
                if (StartPos != EndPos) Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }
            void Execute_Move()
            {
                if (!shouldMove) return;
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Vector3.Lerp(StartPos, EndPos, waypointDone);
                npc.player.transform.position = nextPos;
                npc.player.TransformChanged();
            }
            void GetNextPath()
            {
                if (npc == null) npc = GetComponent<HumanPlayer>();
                LastPos = Vector3.zero;
                shouldMove = true;
                if (cachedWaypoints == null) { shouldMove = false; return; }
                Interface.CallHook("OnNPCPosition", npc.player, npc.player.transform.position); 
                if (currentWaypoint +1 >= cachedWaypoints.Count)
                    currentWaypoint = -1;
                currentWaypoint++;
                SetMovementPoint(npc.player.transform.position, cachedWaypoints[currentWaypoint].GetPosition(), cachedWaypoints[currentWaypoint].GetSpeed());
                if (npc.player.transform.position == cachedWaypoints[currentWaypoint].GetPosition()) { npc.DisableMove(); npc.Invoke("AllowMove", cachedWaypoints[currentWaypoint].GetSpeed()); return; }
            } 
            public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s)
            {  
                StartPos = startpos;
                EndPos = endpos;
                if (StartPos != EndPos)
                    secondsToTake = Vector3.Distance(EndPos, StartPos) / s;
                    LookTowards(npc.player, EndPos);
                    secondsTaken = 0f;
                    waypointDone = 0f;
            }
            void MoveOrAttack(BaseEntity entity)
            {
                
                c_attackDistance = Vector3.Distance(entity.transform.position, npc.player.transform.position);
                shouldMove = false;
                if (((BaseCombatEntity)entity).IsAlive() && c_attackDistance < attackDistance && Vector3.Distance(LastPos, npc.player.transform.position) < maxDistance && noPath < 5)
                {
                    if (waypointDone >= 1f) { 
                        if (pathFinding != null && pathFinding.Count > 0) pathFinding.RemoveAt(0);
                        waypointDone = 0f;
                    }
                    if (c_attackDistance < damageDistance && CanSee(npc.player, entity))
                    {
                        if (Time.realtimeSinceStartup > lastHit + damageInterval)
                            DoHit(this, (BaseCombatEntity)entity);
                        return;
                    }
                    if (pathFinding == null || pathFinding.Count < 1) return;
                    shouldMove = true;
                    if (waypointDone == 0f) SetMovementPoint(npc.player.transform.position, pathFinding[0], speed*2);
                }
                else
                    npc.EndAttackingEntity();
            }
            public void PathFinding()
            {
                if (IsInvoking("PathFinding")) { CancelInvoke("PathFinding");}
                
                temppathFinding = (List<Vector3>)Interface.CallHook("FindBestPath", npc.player.transform.position, attackEntity.transform.position);
                
                if (temppathFinding == null)
                {
                    if (pathFinding == null || pathFinding.Count == 0)
                        noPath++;
                    else noPath = 0;
                    Invoke("PathFinding", 2);
                }
                else
                {
                    noPath = 0;
                    pathFinding = temppathFinding;
                    waypointDone = 0f;
                    Invoke("PathFinding", pathFinding.Count/speed);
                }
            }  
            
            public void GetBackToLastPos()
            {
                if (npc.player.transform.position != LastPos)
                {
                    SetMovementPoint(npc.player.transform.position, LastPos, 7f);
                    secondsTaken = 0.01f;
                }
            } 
            public void Enable() { this.enabled = true; }
            public void Disable() { this.enabled = false; }
        }

        ////////////////////////////////////////////////////// 
        ///  class HumanPlayer : MonoBehaviour
        ///  MonoBehaviour: managed by UnityEngine
        /// Takes care of all the sub categories of the HumanNPCs
        //////////////////////////////////////////////////////
        class HumanPlayer : MonoBehaviour
        {
            public HumanNPCInfo info;
            public HumanLocomotion locomotion;
            public HumanTrigger trigger;

            public BasePlayer player;
             
            public bool hostile;
            public bool invulnerability;

            public bool stopandtalk;
            public float stopandtalkSeconds;

            public float lastMessage;


            void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
            public void SetInfo(HumanNPCInfo info)
            {
                this.info = info;
                if (info == null) return;
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.userID = ulong.Parse(info.userid);
                player.displayName = info.displayName;
                invulnerability = bool.Parse(info.invulnerability);
                stopandtalk = bool.Parse(info.stopandtalk);
                hostile = bool.Parse(info.hostile);
                stopandtalkSeconds = float.Parse(info.stopandtalkSeconds);
                player.InitializeHealth(float.Parse(info.health), float.Parse(info.health));
                player.syncPosition = true;
                player.transform.position = info.spawnInfo.GetPosition();
                player.TransformChanged();
                SetViewAngle(player, info.spawnInfo.GetRotation());
                player.EndSleeping();
                player.UpdateNetworkGroup();
                Interface.CallHook("OnNPCRespawn", player);

                locomotion = player.gameObject.AddComponent<HumanLocomotion>();
                trigger = player.gameObject.AddComponent<HumanTrigger>();
                enabled = true;
                lastMessage = Time.realtimeSinceStartup;
            }
            public void AllowMove() { locomotion.Enable(); }
            public void DisableMove() { locomotion.Disable(); } 
            public void TemporaryDisableMove(float thetime = -1f)
            {
                if (thetime == -1f) thetime = stopandtalkSeconds;
                DisableMove();
                if (IsInvoking("AllowMove")) CancelInvoke("AllowMove");
                Invoke("AllowMove", thetime);
            }
            public void EndAttackingEntity()
            {
                if (locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");
                locomotion.noPath = 0;
                locomotion.shouldMove = true;
                Debug.Log("end");
                Interface.CallHook("OnNPCStopTarget", player, locomotion.attackEntity);
                locomotion.attackEntity = null;
                player.health = float.Parse(info.health);
                locomotion.GetBackToLastPos();
            }
            public void StartAttackingEntity(BaseEntity entity)
            {
                
                if (Interface.CallHook("OnNPCStartTarget", player, entity) == null)
                {
                    
                    locomotion.attackEntity = entity;
                    locomotion.pathFinding = null;
                    locomotion.temppathFinding = null;
                    
                    if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                    if(IsInvoking("AllowMove")) { CancelInvoke("AllowMove"); AllowMove(); }
                    locomotion.Invoke("PathFinding", 0);
                    
                }
            }
            void OnDestroy()
            {
                GameObject.Destroy(locomotion);
                GameObject.Destroy(trigger);
            }
        }

        ////////////////////////////////////////////////////// 
        ///  class HumanNPCInfo
        ///  NPC information that will be saved inside the datafile
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        class HumanNPCInfo
        {
            public string userid;
            public string displayName;
            public string invulnerability;
            public string health;
            public string respawn;
            public string respawnSeconds;
            public SpawnInfo spawnInfo;
            public string waypoint;
            public string collisionRadius;
            public string spawnkit;
            public string damageAmount;
            public string damageDistance;
            public string damageInterval;
            public string attackDistance;
            public string maxDistance;
            public string hostile;
            public string speed;
            public string stopandtalk;
            public string stopandtalkSeconds;
            public string enable;
            public string lootable;
            public List<string> message_hello;
            public List<string> message_bye;
            public List<string> message_use;
            public List<string> message_hurt;
            public List<string> message_kill;
               
            public HumanNPCInfo(ulong userid, Vector3 position, Quaternion rotation)
            {
                this.userid = userid.ToString();
                displayName = "NPC";
                invulnerability = "true";
                health = "50";
                hostile = "false";
                respawn = "true";
                respawnSeconds = "60";
                spawnInfo = new SpawnInfo(position, rotation);
                collisionRadius = "10";
                damageDistance = "3";
                damageAmount = "10";
                attackDistance = "100";
                maxDistance = "200";
                speed = "3";
                stopandtalk = "true";
                stopandtalkSeconds = "3";
                enable = "true";
                lootable = "true";
                damageInterval = "2";
            }

            public HumanNPCInfo Clone(ulong userid)
            {
                var clone = new HumanNPCInfo(userid, this.spawnInfo.GetPosition(), this.spawnInfo.GetRotation());
                clone.userid = userid.ToString();
                clone.displayName = this.displayName;
                clone.invulnerability = this.invulnerability;
                clone.health = this.health;
                clone.respawn = this.respawn;
                clone.respawnSeconds = this.respawnSeconds;
                clone.waypoint = this.waypoint;
                clone.collisionRadius = this.collisionRadius;
                clone.spawnkit = this.spawnkit;
                clone.damageAmount = this.damageAmount;
                clone.damageDistance = this.damageDistance;
                clone.attackDistance = this.attackDistance;
                clone.maxDistance = this.maxDistance;
                clone.hostile = this.hostile;
                clone.speed = this.speed;
                clone.stopandtalk = this.stopandtalk;
                clone.stopandtalkSeconds = this.stopandtalkSeconds;
                clone.lootable = this.lootable;
                clone.damageInterval = this.damageInterval;
                clone.message_hello = this.message_hello;
                clone.message_bye = this.message_bye;
                clone.message_use = this.message_use;
                clone.message_hurt = this.message_hurt;
                clone.message_kill = this.message_kill;
                return clone;
            }
        }

        class WaypointEditor : MonoBehaviour
        {
            public Waypoint targetWaypoint;

            void Awake()
            {
            }
        }
        class NPCEditor : MonoBehaviour
        {
            public BasePlayer player;
            public HumanPlayer targetNPC;
            void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
        }

        class StoredData
        {
            public HashSet<Waypoint> WayPoints = new HashSet<Waypoint>();
            public HashSet<HumanNPCInfo> HumanNPCs = new HashSet<HumanNPCInfo>();

            public StoredData()
            {
            }
        }
        static float GetGroundY(Vector3 position)
        {
            position = position + jumpPosition;
            if (Physics.Raycast(position, Vector3Down, out hitinfo, 1.5f, groundLayer))
            {
                return hitinfo.point.y;
            }
            return position.y - 1.5f;
        }

        void Loaded()
        {
            LoadData();
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            viewangles = typeof(BasePlayer).GetField("viewAngles", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            TimersList = new List<Oxide.Plugins.Timer>();
            eyesPosition = new Vector3(0f, 0.5f, 0f);
            jumpPosition = new Vector3(0f, 1f, 0f);
            Vector3Down = new Vector3(0f, -1f, 0f);
            Vector3Forward = new Vector3(0f, 0f, 1f);
        }

        void Unloaded()
        {
            SaveData();
        }
        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(WaypointEditor));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
            objects = GameObject.FindObjectsOfType(typeof(HumanPlayer));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
            objects = GameObject.FindObjectsOfType(typeof(NPCEditor));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
            foreach (Oxide.Plugins.Timer timers in TimersList)
                timers.Destroy();
            TimersList.Clear();
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("HumanNPC", storedData);
        }
        void LoadData()
        {
            waypoints.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("HumanNPC");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var thewaypoint in storedData.WayPoints)
                waypoints[thewaypoint.Name] = thewaypoint;
            foreach (var thenpc in storedData.HumanNPCs)
                humannpcs[thenpc.userid] = thenpc;
        }












        ////////////////////////////////////////////////////// 
        ///  Oxide Hooks
        //////////////////////////////////////////////////////

        ////////////////////////////////////////////////////// 
        ///  OnServerInitialized()
        ///  called when the server is done being initialized
        //////////////////////////////////////////////////////
        void OnServerInitialized()
        {
            playerLayer = LayerMask.GetMask(new string[] { "Player (Server)" });
            groundLayer = LayerMask.GetMask(new string[] { "Construction", "Terrain", "World" });
            blockshootLayer = LayerMask.GetMask(new string[] { "Construction", "Terrain", "World" });
            RefreshAllNPC();
            emptyDamage = new DamageTypeList();
        }

        ////////////////////////////////////////////////////// 
        ///  OnServerSave() 
        ///  called when a server performs a save
        //////////////////////////////////////////////////////
        void OnServerSave()
        {
            SaveData();
        }

        ////////////////////////////////////////////////////// 
        /// OnPlayerInput(BasePlayer player, InputState input)
        /// Called when a plugin presses a button
        //////////////////////////////////////////////////////
        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.USE))
            {
                TryGetPlayerView(player, out currentRot);
                if (Physics.Raycast(new Ray(player.transform.position + eyesPosition, currentRot * Vector3.forward), out hitinfo, 5f, playerLayer))
                    if (hitinfo.collider.GetComponentInParent<HumanPlayer>() != null)
                        Interface.CallHook("OnUseNPC", hitinfo.collider.GetComponentInParent<BasePlayer>(), player);
            }
        }

        ////////////////////////////////////////////////////// 
        /// OnEntityAttacked(BaseCombatEntity entity, HitInfo hitinfo)
        /// Called when an entity gets attacked (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
        void OnEntityAttacked(BaseCombatEntity entity, HitInfo hitinfo)
        {
            
            if (entity.GetComponent<HumanPlayer>() != null)
            {
                
                Interface.CallHook("OnHitNPC", entity.GetComponent<BaseCombatEntity>(), hitinfo);
                if (entity.GetComponent<HumanPlayer>().invulnerability)
                {
                    hitinfo.damageTypes = emptyDamage;
                    hitinfo.HitMaterial = 0;
                }
            }
        }

        ////////////////////////////////////////////////////// 
        /// OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        /// Called when an entity gets killed (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity.GetComponent<HumanPlayer>() != null)
            {
                Interface.CallHook("OnKillNPC", entity.GetComponent<BasePlayer>(), hitinfo);
                if (entity.GetComponent<HumanPlayer>().info.respawn == "true")
                {
                    var userid = entity.GetComponent<HumanPlayer>().info.userid;
                    TimersList.Add(timer.Once(float.Parse(entity.GetComponent<HumanPlayer>().info.respawnSeconds), () => SpawnNPC(userid, false)));
                }
            }
        }


        void OnPlayerLoot(PlayerLoot loot, BaseEntity target)
        {
            var userid = GetIDFromLoot(target);
            if (userid != 0L && humannpcs[userid.ToString()] != null)
            {
                Interface.CallHook("OnLootNPC", loot, target, userid.ToString());
            }
        }
        ////////////////////////////////////////////////////// 
        /// End of Oxide Hooks
        //////////////////////////////////////////////////////
        ulong GetIDFromLoot(BaseEntity target)
        {
            if (target is PlayerCorpse) return (target as PlayerCorpse).playerSteamID;
            if (target is BasePlayer) return (target as BasePlayer).userID;
            return 0L;
        }

        HumanPlayer FindHumanPlayerByID(ulong userid)
        {
            var allBasePlayer = UnityEngine.Resources.FindObjectsOfTypeAll<HumanPlayer>();
            foreach (HumanPlayer humanplayer in allBasePlayer)
            {
                if (humanplayer.player.userID == userid) return humanplayer;
            }
            return null;
        }
        BasePlayer FindPlayerByID(ulong userid)
        {
            var allBasePlayer = UnityEngine.Resources.FindObjectsOfTypeAll<BasePlayer>();
            foreach (BasePlayer player in allBasePlayer)
            {
                if (player.userID == userid) return player;
            }
            return null;
        }
        static void DoHit(HumanLocomotion loc, BaseCombatEntity target)
        {
            loc.lastHit = Time.realtimeSinceStartup;
            HitInfo info = new HitInfo(loc.npc.player, DamageType.Stab, loc.damageAmount, target.transform.position)
            {
                PointStart = loc.npc.player.transform.position,
                PointEnd = target.transform.position
            };
            target.SendMessage("OnAttacked", info, SendMessageOptions.DontRequireReceiver);
            loc.npc.player.SignalBroadcast(BaseEntity.Signal.Attack, null);
        }
        static void SetViewAngle(BasePlayer player, Quaternion ViewAngles)
        {
            viewangles.SetValue(player, ViewAngles);
            player.SendNetworkUpdate(BasePlayer.NetworkQueue.Positional);
        }
        void RefreshAllNPC()
        {
            List<string> npcspawned = new List<string>();
            foreach (KeyValuePair<string, HumanNPCInfo> pair in humannpcs)
            {
                if (pair.Value.enable == "true")
                {
                    BasePlayer findplayer = FindPlayerByID(Convert.ToUInt64(pair.Key));
                    npcspawned.Add(pair.Key);
                    if (findplayer == null) SpawnNPC(pair.Key, false);
                    else RefreshNPC(findplayer, false);
                }
            }
            foreach (BasePlayer player in UnityEngine.Resources.FindObjectsOfTypeAll<BasePlayer>())
            {
                if (player.userID < 76560000000000000L && player.userID > 0L)
                    if (!npcspawned.Contains(player.userID.ToString())) { player.KillMessage(); Puts(string.Format("Detected a HumanNPC with no data or disabled, deleting him: {0} {1}", player.userID.ToString(), player.displayName)); }
            }

        }
        void SpawnNPC(string userid, bool isediting)
        {
            if (humannpcs[userid] == null) return;
            if (!isediting && humannpcs[userid].enable == "false") return;
            var newplayer = GameManager.server.CreateEntity("player/player", humannpcs[userid].spawnInfo.GetPosition(), humannpcs[userid].spawnInfo.GetRotation()).ToPlayer();
            newplayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            newplayer.userID = Convert.ToUInt64(userid);
            var humanplayer = newplayer.gameObject.AddComponent<HumanPlayer>();
            newplayer.displayName = (humannpcs[userid]).displayName;
            newplayer.Spawn(true);
            humanplayer.SetInfo(humannpcs[userid]);
            Puts("Spawned NPC: " + userid);
        }
        void RefreshNPC(BasePlayer player, bool isediting)
        {
            if (player.GetComponent<HumanPlayer>() != null) GameObject.Destroy(player.GetComponent<HumanPlayer>());
            var humanplayer = player.gameObject.AddComponent<HumanPlayer>();
            humanplayer.SetInfo(humannpcs[player.userID.ToString()]);
            if (humannpcs[player.userID.ToString()].enable == "false" && !isediting) { player.KillMessage(); Puts("NPC was refreshed and Killed because he is disabled: " + player.userID.ToString()); return; }
            Puts("Refreshed NPC: " + player.userID.ToString());
        }
        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1) { SendReply(player, "You don't have access to this command"); return false; }
            return true;
        }
        bool isEditingWP(BasePlayer player, int ttype)
        {
            if (player.GetComponent<WaypointEditor>() != null)
            {
                if (ttype == 0) SendReply(player, string.Format("You are already editing {0}", player.GetComponent<WaypointEditor>().targetWaypoint.Name.ToString()));
                return true;
            }
            else
            {
                if (ttype == 1) SendReply(player, string.Format("You are not editing any waypoints, say /waypoints_new or /waypoints_edit NAME"));
                return false;
            }
        }
        bool hasNoArguments(BasePlayer player, string[] args, int Number)
        {
            if (args.Length < Number) { SendReply(player, "Not enough Arguments"); return true; }
            return false;
        }
        bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null) return false;
            if (input.current == null) return false;
            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }
        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            UnityEngine.Ray ray = new UnityEngine.Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = UnityEngine.Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.collider;
                        closestHitpoint = hit.point;
                    }

            if (closestEnt is bool) return false;
            return true;
        }
        static bool CanSee(BasePlayer source, BaseEntity target)
        {
            if (UnityEngine.Physics.Linecast(source.transform.position + jumpPosition, target.transform.position + jumpPosition, blockshootLayer))
                return false;
            return true;
        }
        string GetRandomMessage(List<string> messagelist) { return messagelist[GetRandom(0, messagelist.Count)]; }
        int GetRandom(int min, int max) { return UnityEngine.Random.Range(min, max); }


        static List<WaypointInfo> GetWayPoints(string name) => waypoints[name]?.Waypoints;

        List<string> ListFromArgs(string[] args, int from)
        {
            var newlist = new List<string>();
            for (var i = from; i < args.Length; i++) { newlist.Add(args[i]); }
            return newlist;
        }

        public static void LookTowards(BasePlayer player, Vector3 pos)
        {
            if (pos != player.transform.position)
                SetViewAngle(player, Quaternion.LookRotation(pos - player.transform.position));
        }

        //////////////////////////////////////////////////////////////////////////////
        /// Chat Commands
        //////////////////////////////////////////////////////////////////////////////
        [ChatCommand("npc_add")]
        void cmdChatNPCAdd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null) { SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first"); return; }
            if (!TryGetPlayerView(player, out currentRot)) return;

            var newplayer = GameManager.server.CreateEntity("player/player", player.transform.position, currentRot).ToPlayer();
            newplayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            newplayer.displayName = "NPC";
            newplayer.Spawn(true);
            var humannpcinfo = new HumanNPCInfo(newplayer.userID, player.transform.position, currentRot);
            var humanplayer = newplayer.gameObject.AddComponent<HumanPlayer>();

            if (args.Length > 0)
            {
                if (humannpcs[args[0]] != null)
                {
                    humannpcinfo = humannpcs[args[0]].Clone(newplayer.userID);
                    humannpcinfo.userid = newplayer.userID.ToString();
                    humannpcinfo.spawnInfo = new SpawnInfo(player.transform.position, currentRot);
                    humanplayer.SetInfo(humannpcinfo);
                }
            }
            else
            {
                humanplayer.SetInfo(humannpcinfo);
            }

            var npceditor = player.gameObject.AddComponent<NPCEditor>();
            npceditor.targetNPC = humanplayer;

            if (humannpcs[newplayer.userID.ToString()] != null) storedData.HumanNPCs.Remove(humannpcs[newplayer.userID.ToString()]);

            humannpcs[newplayer.userID.ToString()] = humannpcinfo;
            storedData.HumanNPCs.Add(humannpcs[newplayer.userID.ToString()]);
            SaveData();
        }
        [ChatCommand("npc_edit")]
        void cmdChatNPCEdit(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null) { SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first"); return; }

            HumanPlayer targetnpc;
            ulong userid;
            if (args.Length == 0)
            {
                if (!TryGetPlayerView(player, out currentRot)) return;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                if (((Collider)closestEnt).GetComponentInParent<HumanPlayer>() == null) { SendReply(player, "This is not an NPC"); return; }
                targetnpc = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
            }
            else if (humannpcs[args[0]] != null)
            {
                if (!ulong.TryParse(args[0], out userid)) { SendReply(player, "/npc_edit TARGETID"); return; }
                targetnpc = FindHumanPlayerByID(userid);
                if (targetnpc == null) { SpawnNPC(args[0], true); }
                targetnpc = FindHumanPlayerByID(userid);
                if (targetnpc == null) { SendReply(player, "Couldn't Spawn the NPC"); return; }
            }
            else { SendReply(player, "You are not looking at an NPC or this userid doesn't exist"); return; }

            var npceditor = player.gameObject.AddComponent<NPCEditor>();
            npceditor.targetNPC = targetnpc;
            SendReply(player, string.Format("NPC Editor: Start Editing {0} - {1}", npceditor.targetNPC.player.displayName, npceditor.targetNPC.player.userID.ToString()));
        }
        [ChatCommand("npc_list")]
        void cmdChatNPCList(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (humannpcs.Count == 0) { SendReply(player, "No NPC created yet"); return; }

            SendReply(player, "==== NPCs ====");
            foreach (KeyValuePair<string, HumanNPCInfo> pair in humannpcs) SendReply(player, string.Format("{0} - {1} - {2} {3}", pair.Key, pair.Value.displayName, pair.Value.spawnInfo.ShortString(), pair.Value.enable == "true" ? "" : "- Disabled"));
        }

        [ChatCommand("npc")]
        void cmdChatNPC(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() == null) { SendReply(player, "NPC Editor: You need to be editing an NPC, say /npc_add or /npc_edit"); return; }
            var npceditor = player.GetComponent<NPCEditor>();
            if (args.Length == 0)
            {
                SendReply(player, "<color=#81F781>/npc attackdistance</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>Distance between him and the target needed for the NPC to ignore the target and go back to spawn</color>");
                SendReply(player, "<color=#81F781>/npc bye</color> reset/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=><color=#D8D8D8> Dont forgot the \", this is what NPC with say when a player gets away, multiple texts are possible</color>");
                SendReply(player, "<color=#81F781>/npc damageamount</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Damage done by that NPC when he hits a player</color>");
                SendReply(player, "<color=#81F781>/npc damagedistance</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Min distance for the NPC to hit a player (3 is default, maybe 20-30 needed for snipers?)</color>");
                SendReply(player, "<color=#81F781>/npc damageinterval</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Time to wait before attacking again (2 seconds is default)</color>");
                SendReply(player, "<color=#81F781>/npc enable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color><color=#D8D8D8>Enable/Disable the NPC, maybe save it for later?</color>");
                SendReply(player, "<color=#81F781>/npc health</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>To set the Health of the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hello</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", this what will be said when the player gets close to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hostile</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC is Hostile</color>");
                SendReply(player, "<color=#81F781>/npc hurt</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he hurts the NPC</color>");
                SendReply(player, "<color=#81F781>/npc invulnerable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false </color>=> <color=#D8D8D8>To set the NPC invulnerable or not</color>");
                SendReply(player, "<color=#81F781>/npc kill</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he kills the NPC</color>");
                SendReply(player, "<color=#81F781>/npc kit</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"KitName\" </color>=> <color=#D8D8D8>To set the kit of this NPC, requires the Kit plugin</color>");
                SendReply(player, "<color=#81F781>/npc lootable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC corpse is lootable or not</color>");
                SendReply(player, "<color=#81F781>/npc maxdistance</color> <color=#F2F5A9>XXX </color>=><color=#D8D8D8> Max distance from the spawn point that the NPC can run from (while attacking a player)</color>");
                SendReply(player, "<color=#81F781>/npc name</color> <color=#F2F5A9>\"THE NAME\"</color> =><color=#D8D8D8> To set a name to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc radius</color> <color=#F2F5A9>XXX</color> =><color=#D8D8D8> Radius of which the NPC will detect the player</color>");
                SendReply(player, "<color=#81F781>/npc respawn</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it to respawn on death after XX seconds, default is instant respawn</color>");
                SendReply(player, "<color=#81F781>/npc spawn</color> <color=#F2F5A9>\"new\" </color>=> <color=#D8D8D8>To set the new spawn location</color>");
                SendReply(player, "<color=#81F781>/npc speed</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>To set the NPC running speed (while chasing a player)</color>");
                SendReply(player, "<color=#81F781>/npc stopandtalk</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> XX <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To choose if the NPC should stop & look at the player that is talking to him</color>");
                SendReply(player, "<color=#81F781>/npc use</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", this what will be said when the player presses USE on the NPC</color>");
                SendReply(player, "<color=#81F781>/npc waypoints</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"Waypoint list Name\" </color>=> <color=#D8D8D8>To set waypoints of an NPC, /npc_help for more informations</color>");
                return;
            }
            switch (args[0].ToLower())
            {
                case "name":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC name is: {0}", npceditor.targetNPC.info.displayName)); return; }
                    npceditor.targetNPC.info.displayName = args[1];
                    break;
                case "enable":
                case "enabled":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Respawn enabled: {0}", npceditor.targetNPC.info.enable)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.enable = "true";
                    else
                        npceditor.targetNPC.info.enable = "false";
                    break;
                case "invulnerable":
                case "invulnerability":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC invulnerability is set to: {0}", npceditor.targetNPC.info.invulnerability)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.invulnerability = "true";
                    else
                        npceditor.targetNPC.info.invulnerability = "false";
                    break;
                case "lootable":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC lootable is set to: {0}", npceditor.targetNPC.info.lootable)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.lootable = "true";
                    else
                        npceditor.targetNPC.info.lootable = "false";
                    break;
                case "hostile":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC hostility is set to: {0}", npceditor.targetNPC.info.hostile)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.hostile = "true";
                    else
                        npceditor.targetNPC.info.hostile = "false";
                    break;
                case "health":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Initial health is set to: {0}", npceditor.targetNPC.info.health)); return; }
                    npceditor.targetNPC.info.health = args[1];
                    break;
                case "attackdistance":
                    if (args.Length == 1) { SendReply(player, string.Format("This Max Attack Distance is: {0}", npceditor.targetNPC.info.attackDistance)); return; }
                    npceditor.targetNPC.info.attackDistance = args[1];
                    break;
                case "damageamount":
                    if (args.Length == 1) { SendReply(player, string.Format("This Damage amount is: {0}", npceditor.targetNPC.info.damageAmount)); return; }
                    npceditor.targetNPC.info.damageAmount = args[1];
                    break;
                case "damageinterval":
                    if (args.Length == 1) { SendReply(player, string.Format("This Damage interval is: {0} seconds", npceditor.targetNPC.info.damageInterval)); return; }
                    npceditor.targetNPC.info.damageInterval = args[1];
                    break;
                case "maxdistance":
                    if (args.Length == 1) { SendReply(player, string.Format("The Max Distance from spawn is: {0}", npceditor.targetNPC.info.maxDistance)); return; }
                    npceditor.targetNPC.info.maxDistance = args[1];
                    break;
                case "damagedistance":
                    if (args.Length == 1) { SendReply(player, string.Format("This Damage distance is: {0}", npceditor.targetNPC.info.damageDistance)); return; }
                    npceditor.targetNPC.info.damageDistance = args[1];
                    break;
                case "radius":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Collision radius is set to: {0}", npceditor.targetNPC.info.collisionRadius)); return; }
                    npceditor.targetNPC.info.collisionRadius = args[1];
                    break;
                case "respawn":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Respawn is set to: {0} after {1} seconds", npceditor.targetNPC.info.respawn, npceditor.targetNPC.info.respawnSeconds)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.respawn = "true";
                    else
                        npceditor.targetNPC.info.respawn = "false";

                    npceditor.targetNPC.info.respawnSeconds = "60";
                    if (args.Length > 2)
                        npceditor.targetNPC.info.respawnSeconds = args[2];
                    break;
                case "spawn":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Spawn is set to: {0}", npceditor.targetNPC.info.spawnInfo.String())); return; }
                    TryGetPlayerView(player, out currentRot);
                    var newSpawn = new SpawnInfo(player.transform.position, currentRot);
                    npceditor.targetNPC.info.spawnInfo = newSpawn;
                    SendReply(player, string.Format("This NPC Spawn now is set to: {0}", newSpawn.String()));
                    break;
                case "speed":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC Chasing speed is: {0}", npceditor.targetNPC.info.speed)); return; }
                    npceditor.targetNPC.info.speed = args[1];
                    break;
                case "stopandtalk":
                    if (args.Length == 1) { SendReply(player, string.Format("This NPC stop to talk is set to: {0} for {1} seconds", npceditor.targetNPC.info.stopandtalk, npceditor.targetNPC.info.stopandtalkSeconds)); return; }
                    if (args[1] == "true" || args[1] == "1")
                        npceditor.targetNPC.info.stopandtalk = "true";
                    else
                        npceditor.targetNPC.info.stopandtalk = "false";

                    npceditor.targetNPC.info.stopandtalkSeconds = "3";
                    if (args.Length > 2)
                        npceditor.targetNPC.info.stopandtalkSeconds = args[2];
                    break;
                case "waypoints":
                case "waypoint":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.waypoint == null || npceditor.targetNPC.info.waypoint == "") SendReply(player, "No waypoints set for this NPC yet");
                        else SendReply(player, string.Format("This NPC waypoints are: {0}", npceditor.targetNPC.info.waypoint));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.waypoint = "";
                    else if (waypoints[args[1]] == null) { SendReply(player, "This waypoint doesn't exist"); return; }
                    else npceditor.targetNPC.info.waypoint = args[1];
                    break;
                case "kit":
                case "kits":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.spawnkit == null || npceditor.targetNPC.info.spawnkit == "") SendReply(player, "No spawn kits set for this NPC yet");
                        else SendReply(player, string.Format("This NPC spawn kit is: {0}", npceditor.targetNPC.info.spawnkit));
                        return;
                    }
                    npceditor.targetNPC.info.spawnkit = args[1];
                    break;
                case "hello":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.message_hello == null || (npceditor.targetNPC.info.message_hello.Count == 0)) SendReply(player, "No hello message set yet");
                        else SendReply(player, string.Format("This NPC will say hi: {0} different messages", npceditor.targetNPC.info.message_hello.Count.ToString()));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.message_hello = new List<string>();
                    else npceditor.targetNPC.info.message_hello = ListFromArgs(args, 1);
                    break;
                case "bye":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.message_bye == null || npceditor.targetNPC.info.message_bye.Count == 0) SendReply(player, "No bye message set yet");
                        else SendReply(player, string.Format("This NPC will say bye: {0} difference messages ", npceditor.targetNPC.info.message_bye.Count.ToString()));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.message_bye = new List<string>();
                    else npceditor.targetNPC.info.message_bye = ListFromArgs(args, 1);
                    break;
                case "use":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.message_use == null || npceditor.targetNPC.info.message_use.Count == 0) SendReply(player, "No bye message set yet");
                        else SendReply(player, string.Format("This NPC will say bye: {0} different messages", npceditor.targetNPC.info.message_use.Count.ToString()));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.message_use = new List<string>();
                    else npceditor.targetNPC.info.message_use = ListFromArgs(args, 1);
                    break;
                case "hurt":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.message_hurt == null || npceditor.targetNPC.info.message_hurt.Count == 0) SendReply(player, "No hurt message set yet");
                        else SendReply(player, string.Format("This NPC will say ouch: {0} different messages", npceditor.targetNPC.info.message_hurt.Count.ToString()));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.message_hurt = new List<string>();
                    else npceditor.targetNPC.info.message_hurt = ListFromArgs(args, 1);
                    break;
                case "kill":
                    if (args.Length == 1)
                    {
                        if (npceditor.targetNPC.info.message_kill == null || npceditor.targetNPC.info.message_kill.Count == 0) SendReply(player, "No kill message set yet");
                        else SendReply(player, string.Format("This NPC will say a death message: {0} different messages", npceditor.targetNPC.info.message_kill.Count.ToString()));
                        return;
                    }
                    if (args[1] == "reset") npceditor.targetNPC.info.message_kill = new List<string>();
                    else npceditor.targetNPC.info.message_kill = ListFromArgs(args, 1);
                    break;
                default:
                    SendReply(player, "Wrong Argument, /npc for more informations");
                    return;
                    break;
            }

            if (args.Length > 1)
            {
                SendReply(player, string.Format("NPC Editor: Set {0} to {1}", args[0], args[1]));
                SaveData();
                RefreshNPC(npceditor.targetNPC.player, true);
            }
        }

        [ChatCommand("npc_end")]
        void cmdChatNPCEnd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() == null) { SendReply(player, "NPC Editor: You are not editing any NPC"); return; }
            var npceditor = player.GetComponent<NPCEditor>();
            if (npceditor.targetNPC.info.enable == "false")
            {
                npceditor.targetNPC.player.KillMessage();
                SendReply(player, "NPC Editor: The NPC you edited is disabled, killing him");
            }
            GameObject.Destroy(player.GetComponent<NPCEditor>());
            SendReply(player, "NPC Editor: Ended");
        }
        [ChatCommand("npc_pathtest")]
        void cmdChatNPCPathTest(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() == null) { SendReply(player, "NPC Editor: You are not editing any NPC"); return; }
            if (!TryGetPlayerView(player, out currentRot)) return;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
            var npceditor = player.GetComponent<NPCEditor>();
            var curtime = Time.realtimeSinceStartup;
            List<Vector3> vector3list = (List<Vector3>)Interface.CallHook("FindBestPath", npceditor.targetNPC.player.transform.position, closestHitpoint);
            Debug.Log((Time.realtimeSinceStartup - curtime).ToString());
        }
        [ChatCommand("npc_remove")]
        void cmdChatNPCRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;


            HumanPlayer targetnpc;
            ulong userid;
            if (args.Length == 0)
            {
                if (!TryGetPlayerView(player, out currentRot)) return;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                if (((Collider)closestEnt).GetComponentInParent<HumanPlayer>() == null) { SendReply(player, "This is not an NPC"); return; }

                targetnpc = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
            }
            else if (humannpcs[args[0]] != null)
            {
                if (!ulong.TryParse(args[0], out userid)) { SendReply(player, "/npc_remove TARGETID"); return; }
                targetnpc = FindHumanPlayerByID(userid);
                if (targetnpc == null) { SendReply(player, "This NPC doesn't exist"); return; }
            }
            else { SendReply(player, "You are not looking at an NPC or this userid doesn't exist"); return; }

            var targetid = targetnpc.player.userID.ToString();
            storedData.HumanNPCs.Remove(humannpcs[targetid]);
            humannpcs[targetid] = null;
            RefreshAllNPC();
            SendReply(player, string.Format("NPC {0} Removed", targetid));
        }
        [ChatCommand("npc_reset")]
        void cmdChatNPCReset(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null) GameObject.Destroy(player.GetComponent<NPCEditor>());
            humannpcs.Clear();
            storedData.HumanNPCs.Clear();
            SaveData();
            SendReply(player, "All NPCs were removed");
            OnServerInitialized();
        }

        ////////////////////////////////////////////////////// 
        // Waypoints manager
        ////////////////////////////////////////////////////// 

        [ChatCommand("waypoints_new")]
        void cmdWaypointsNew(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (isEditingWP(player, 0)) return;

            var newWaypoint = new Waypoint();
            if (newWaypoint == null)
            {
                SendReply(player, "Waypoints: Something went wrong while making a new waypoint");
                return;
            }
            var newWaypointEditor = player.gameObject.AddComponent<WaypointEditor>();
            newWaypointEditor.targetWaypoint = newWaypoint;
            SendReply(player, "Waypoints: New WaypointList created, you may now add waypoints.");
        }
        [ChatCommand("waypoints_add")]
        void cmdWaypointsAdd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (!isEditingWP(player, 1)) return;
            var WaypointEditor = player.GetComponent<WaypointEditor>();
            if (WaypointEditor.targetWaypoint == null)
            {
                SendReply(player, "Waypoints: Something went wrong while getting your WaypointList");
                return;
            }
            float speed = 3f;
            if (args.Length > 0) float.TryParse(args[0], out speed);
            WaypointEditor.targetWaypoint.AddWaypoint(player.transform.position, speed);

            SendReply(player, string.Format("Waypoint Added: {0} {1} {2} - Speed: {3}", player.transform.position.x.ToString(), player.transform.position.y.ToString(), player.transform.position.z.ToString(), speed.ToString()));
        }
        [ChatCommand("waypoints_list")]
        void cmdWaypointsList(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (waypoints.Count == 0)
            {
                SendReply(player, "No waypoints created yet");
                return;
            }
            SendReply(player, "==== Waypoints ====");
            foreach (KeyValuePair<string, Waypoint> pair in waypoints)
            {
                SendReply(player, pair.Key);
            }

        }
        [ChatCommand("waypoints_save")]
        void cmdWaypointsSave(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (!isEditingWP(player, 1)) return;
            if (args.Length == 0)
            {
                SendReply(player, "Waypoints: /waypoints_save NAMEOFWAYPOINT");
                return;
            }
            var WaypointEditor = player.GetComponent<WaypointEditor>();
            if (WaypointEditor.targetWaypoint == null)
            {
                SendReply(player, "Waypoints: Something went wrong while getting your WaypointList");
                return;
            }

            WaypointEditor.targetWaypoint.Name = args[0];

            if (waypoints[args[0]] != null) storedData.WayPoints.Remove(waypoints[args[0]]);
            waypoints[args[0]] = WaypointEditor.targetWaypoint;
            storedData.WayPoints.Add(waypoints[args[0]]);
            SendReply(player, string.Format("Waypoints: New waypoint saved with: {0} with {1} waypoints stored", WaypointEditor.targetWaypoint.Name, WaypointEditor.targetWaypoint.Waypoints.Count.ToString()));
            GameObject.Destroy(player.GetComponent<WaypointEditor>());
            SaveData();
        }
        [ChatCommand("waypoints_close")]
        void cmdWaypointsClose(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (!isEditingWP(player, 1)) return;
            SendReply(player, "Waypoints: Closed without saving");
            GameObject.Destroy(player.GetComponent<WaypointEditor>());
        }


        void SendMessage(HumanPlayer npc, BasePlayer target, string message)
        {
            if (Time.realtimeSinceStartup > npc.lastMessage + 0.1f)
            {
                target.SendConsoleCommand("chat.add", new object[] { "0", string.Format("<color=#FA58AC>{0}:</color> {1}", npc.player.displayName, message), 1.0 });
                npc.lastMessage = Time.realtimeSinceStartup;
            }
        }
        ////////////////////////////////////////////////////// 
        // NPC HOOKS:
        // will call ALL plugins
        ////////////////////////////////////////////////////// 

        ////////////////////////////////////////////////////// 
        /// OnHitNPC(BasePlayer npc, HitInfo hinfo)
        /// called when an NPC gets hit
        //////////////////////////////////////////////////////
        void OnHitNPC(BasePlayer npc, HitInfo hinfo)
        {
            
            npc.GetComponent<HumanPlayer>().StartAttackingEntity(hinfo.Initiator);
            if (npc.GetComponent<HumanPlayer>().info.message_hurt != null && npc.GetComponent<HumanPlayer>().info.message_hurt.Count != 0)
                if (hinfo.Initiator != null)
                    if (hinfo.Initiator.ToPlayer() != null)
                        SendMessage(npc.GetComponent<HumanPlayer>(), hinfo.Initiator.ToPlayer(), GetRandomMessage(npc.GetComponent<HumanPlayer>().info.message_hurt));
        }


        ////////////////////////////////////////////////////// 
        ///  OnUseNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player press USE while looking at the NPC (5m max)
        //////////////////////////////////////////////////////
        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            var usenpc = npc.GetComponent<HumanPlayer>();
            if (usenpc.stopandtalk) { LookTowards(npc, player.transform.position); usenpc.TemporaryDisableMove(); }
            if (usenpc.info.message_use != null && usenpc.info.message_use.Count != 0)
                SendMessage(npc.GetComponent<HumanPlayer>(), player, GetRandomMessage(npc.GetComponent<HumanPlayer>().info.message_use));
        }

        ////////////////////////////////////////////////////// 
        ///  OnEnterNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets close to an NPC (default is in 10m radius)
        //////////////////////////////////////////////////////
        void OnEnterNPC(BasePlayer npc, BasePlayer player)
        {
            if(npc.GetComponent<HumanPlayer>().hostile)
                if(npc.GetComponent<HumanPlayer>().locomotion.attackEntity == null)
                    if(player.net.connection != null && player.net.connection.authLevel < 1)
                        npc.GetComponent<HumanPlayer>().StartAttackingEntity(player);
            if (npc.GetComponent<HumanPlayer>().info.message_hello != null && npc.GetComponent<HumanPlayer>().info.message_hello.Count != 0)
                SendMessage(npc.GetComponent<HumanPlayer>(), player, GetRandomMessage(npc.GetComponent<HumanPlayer>().info.message_hello));
        }
        ////////////////////////////////////////////////////// 
        ///  OnLeaveNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets away from an NPC
        //////////////////////////////////////////////////////
        void OnLeaveNPC(BasePlayer npc, BasePlayer player)
        {
            if (npc.GetComponent<HumanPlayer>().info.message_bye != null && npc.GetComponent<HumanPlayer>().info.message_bye.Count != 0)
                SendMessage(npc.GetComponent<HumanPlayer>(), player, GetRandomMessage(npc.GetComponent<HumanPlayer>().info.message_bye));
        }

        ////////////////////////////////////////////////////// 
        ///  OnKillNPC(BasePlayer npc, HitInfo hinfo)
        ///  called when an NPC gets killed
        //////////////////////////////////////////////////////
        void OnKillNPC(BasePlayer npc, HitInfo hinfo)
        {
            if (npc.GetComponent<HumanPlayer>().info.message_kill != null && npc.GetComponent<HumanPlayer>().info.message_kill.Count != 0)
                if (hinfo.Initiator != null)
                    if (hinfo.Initiator.ToPlayer() != null)
                        SendMessage(npc.GetComponent<HumanPlayer>(), hinfo.Initiator.ToPlayer(), GetRandomMessage(npc.GetComponent<HumanPlayer>().info.message_kill));
        }

        ////////////////////////////////////////////////////// 
        ///  OnNPCPosition(BasePlayer npc, Vector3 pos)
        ///  Called when an npc reachs a position
        //////////////////////////////////////////////////////
        void OnNPCPosition(BasePlayer npc, Vector3 pos)
        {
            return;
        }

        ////////////////////////////////////////////////////// 
        ///  OnNPCRespawn(BasePlayer npc)
        ///  Called when an NPC respawns
        ///  here it will give an NPC a kit and set the first tool in the belt as the active weapon
        //////////////////////////////////////////////////////
        void OnNPCRespawn(BasePlayer npc)
        {
            if (npc.GetComponent<HumanPlayer>().info.spawnkit != null && npc.GetComponent<HumanPlayer>().info.spawnkit != "")
            {
                npc.inventory.Strip();
                Kits.Call("GiveKit", npc, npc.GetComponent<HumanPlayer>().info.spawnkit);
                if (npc.inventory.containerBelt.GetSlot(0) != null)
                {
                    npc.svActiveItem = npc.inventory.containerBelt.GetSlot(0);
                    HeldEntity entity2 = npc.svActiveItem.GetHeldEntity() as HeldEntity;
                    entity2.SetHeld(true);
                }
                npc.SV_ClothingChanged();
                npc.inventory.ServerUpdate(0f);
            }
        }
        ////////////////////////////////////////////////////// 
        ///  OnNPCStartAttacking(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC start to target someone to attack
        ///  return anything will block the attack
        //////////////////////////////////////////////////////
        object OnNPCStartTarget(BasePlayer npc, BaseEntity target)
        {
            return null;
        }
        ////////////////////////////////////////////////////// 
        ///  OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC stops targetting
        ///  no return;
        //////////////////////////////////////////////////////
        void OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        {
            return;
        }

        ////////////////////////////////////////////////////// 
        ///  OnLootNPC(PlayerLoot loot, BaseEntity target, string npcuserID)
        ///  Called when an NPC gets looted
        ///  no return;
        //////////////////////////////////////////////////////
        void OnLootNPC(PlayerLoot loot, BaseEntity target, string npcuserID)
        {
            if (humannpcs[npcuserID].lootable == "false")
                timer.Once(0.01f, () => loot.Clear());
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\HuntPlugin.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Hunt.RPG;
using Hunt.RPG.Keys;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Reflection;
using System.Text;
using Oxide.Core.Libraries;
using Oxide.Plugins;
using Rust;
using Random=System.Random;
using Time=UnityEngine.Time;
using System.Collections;

namespace Oxide.Plugins
{

    [Info("Hunt RPG", "PedraozauM / SW", "1.2.10", ResourceId = 841)]
    public class HuntPlugin : RustPlugin
    {
        [PluginReference] private Plugin Pets;
        [PluginReference] private Plugin BuildingOwners;
        private readonly HuntRPG HuntRPGInstance;
        private bool ServerInitialized;
        private bool UpdateConfig;
        private bool UpdatePlayerData;
        private DynamicConfigFile HuntDataFile;
        private VersionNumber DataVersion;

        public HuntPlugin()
        {
            HasConfig = true;
            HuntRPGInstance = new HuntRPG(this);
            DataVersion = new VersionNumber(0,9,0);
        }

        public void GiveTamePermission(string playerid, string perm)
        {
            if (permission.UserHasPermission(playerid, perm)) return;
            permission.GrantUserPermission(playerid, perm, Pets);
        }

        public void RevokeTamePermission(string playerid, string perm)
        {
            if (!permission.UserHasPermission(playerid, perm)) return;
            permission.RevokeUserPermission(playerid, perm);
        }

        protected override void LoadDefaultConfig()
        {
            UpdateConfig = true;
            DefaultConfig();
            UpdateData();
        }

        private void DefaultConfig()
        {
            if (!ServerInitialized && UpdateConfig)
            {
                //this will only be called if there is not a config file, or it needs updating
                Config[HK.ConfigVersion] = Version;
                Config[HK.DataVersion] = DataVersion;
                Config[HK.XPTable] = HuntTablesGenerator.GenerateXPTable(HK.MaxLevel, HK.BaseXP, HK.LevelMultiplier, HK.LevelModule, HK.ModuleReducer);
                Config[HK.MaxStatsTable] = HuntTablesGenerator.GenerateMaxStatsTable();
                Config[HK.SkillTable] = HuntTablesGenerator.GenerateSkillTable();
                Config[HK.ResearchSkillTable] = HuntTablesGenerator.GenerateResearchTable();
                Config[HK.UpgradeBuildTable] = HuntTablesGenerator.GenerateUpgradeBuildingTable();
                Config[HK.MessagesTable] = HuntTablesGenerator.GenerateMessageTable();
                Config[HK.TameTable] = HuntTablesGenerator.GenerateTameTable();
                SaveConfig();
            }
            else
            {
                var itemTable = ReadFromConfig<Dictionary<string, ItemInfo>>(HK.ItemTable);
                if (itemTable == null || UpdatePlayerData)
                {
                    //this will be called only on serverinit if the config needs updating
                    LogToConsole("Generating item table.");
                    Config[HK.ItemTable] = HuntTablesGenerator.GenerateItemTable();
                    SaveConfig();
                }
            }
        }

        private void UpdateData()
        {
            if (!UpdatePlayerData) return;
            // this will only be called if this version requires a data wipe and the config is outdated.
            LogToConsole("This version needs a wipe to data file.");
            LogToConsole("Dont worry levels will be kept! =]");
            LogToConsole("Doing that now...");
            LoadRPG(false);
            var profiles = new Dictionary<string, RPGInfo>(ReadFromData<Dictionary<string, RPGInfo>>(HK.Profile));
            var rpgInfos = new Dictionary<string, RPGInfo>();
            foreach (var profile in profiles)
            {
                var steamId = profile.Key;
                var player = BasePlayer.FindByID(Convert.ToUInt64(steamId)) ??
                             BasePlayer.FindSleeping(Convert.ToUInt64(steamId));
                var rpgInfo = new RPGInfo(player.displayName);
                rpgInfos.Add(steamId, rpgInfo);
                HuntRPGInstance.LevelUpPlayer(rpgInfo, profile.Value.Level);
            }
            LogToConsole("Data file updated!");
            Config[HK.DataVersion] = DataVersion;
            SaveConfig();
            SaveRPG(rpgInfos, new Dictionary<string, string>());
            UpdatePlayerData = false;
        }

        private void LoadRPG(bool showMsgs = true)
        {
            LoadConfig();
            if (showMsgs)
                LogToConsole("Loading plugin data and config...");
            HuntDataFile = Interface.GetMod().DataFileSystem.GetDatafile(HK.DataFileName);
            var rpgConfig = ReadFromData<Dictionary<string, RPGInfo>>(HK.Profile) ?? new Dictionary<string, RPGInfo>();
            if (showMsgs)
                LogToConsole(String.Format("{0} profiles loaded", rpgConfig.Count));
            var playerFurnaces = ReadFromData<Dictionary<string, string>>(HK.Furnaces) ?? new Dictionary<string, string>();
            if (showMsgs)
                LogToConsole(String.Format("{0} furnaces loaded", playerFurnaces.Count));
            var xpTable = ReadFromConfig<Dictionary<int, long>>(HK.XPTable);
            var messagesTable = ReadFromConfig<PluginMessagesConfig>(HK.MessagesTable);
            var skillTable = ReadFromConfig<Dictionary<string, Skill>>(HK.SkillTable);
            var maxStatsTable = ReadFromConfig<Dictionary<string, float>>(HK.MaxStatsTable);
            var itemTable = ReadFromConfig<Dictionary<string, ItemInfo>>(HK.ItemTable);
            var researchSkillTable = ReadFromConfig<Dictionary<string, int>>(HK.ResearchSkillTable);
            var upgradeBuildTable = ReadFromConfig<Dictionary<BuildingGrade.Enum, float>>(HK.UpgradeBuildTable);
            var tameTable = ReadFromConfig<Dictionary<int, string>>(HK.TameTable);
            HuntRPGInstance.ConfigRPG(messagesTable, xpTable, maxStatsTable, upgradeBuildTable, skillTable, researchSkillTable, itemTable,tameTable, rpgConfig, playerFurnaces);
            if (showMsgs)
                LogToConsole("Data and config loaded!");
            
            if (Pets == null)
            {
                LogToConsole("Pets plugin was not found, disabling taming skill");
                skillTable[HRK.Tamer].Enabled = false;
            }
            if (BuildingOwners == null)
            {
                LogToConsole("Building Owners plugin was not found, disabling blink to arrow skill");
                skillTable[HRK.BlinkArrow].Enabled = false;
            }

        }

        public T ReadFromConfig<T>(string configKey)
        {
            string serializeObject = JsonConvert.SerializeObject(Config[configKey]);
            return JsonConvert.DeserializeObject<T>(serializeObject);
        }

        public T ReadFromData<T>(string dataKey)
        {
            string serializeObject = JsonConvert.SerializeObject(HuntDataFile[dataKey]);
            return JsonConvert.DeserializeObject<T>(serializeObject);
        }

        public void SaveRPG(Dictionary<string, RPGInfo> rpgConfig, Dictionary<string, string> playersFurnaces, bool showMsgs = true)
        {
            if (showMsgs)
                LogToConsole("Data being saved...");
            HuntDataFile[HK.Profile] = rpgConfig;
            HuntDataFile[HK.Furnaces] = playersFurnaces;
            Interface.GetMod().DataFileSystem.SaveDatafile(HK.DataFileName);
            if (!showMsgs) return;
            LogToConsole(String.Format("{0} profiles saved", rpgConfig.Count));
            LogToConsole(String.Format("{0} furnaces saved", playersFurnaces.Count));
            LogToConsole("Data was saved successfully!");
        }

        [HookMethod("Init")]
        void Init()
        {
            LogToConsole(HuntRPGInstance == null ? "Problem initializating RPG Instance!" : "Hunt RPG initialized!");
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            ServerInitialized = true;
            DefaultConfig();
            LoadRPG();
        }

        [HookMethod("Unload")]
        void Unload()
        {
            HuntRPGInstance.SaveRPG();
        }

        [HookMethod("Loaded")]
        private void Loaded()
        {
            Interface.GetMod().DataFileSystem.GetDatafile(HK.DataFileName);
            var configVersion = new VersionNumber();
            if (Config[HK.ConfigVersion] != null)
                configVersion = ReadFromConfig<VersionNumber>(HK.ConfigVersion);
            var dataVersion = new VersionNumber();
            if (Config[HK.DataVersion] != null)
                dataVersion = ReadFromConfig<VersionNumber>(HK.DataVersion);
            var needDataUpdate = !DataVersion.Equals(dataVersion);
            var needConfigUpdate = !Version.Equals(configVersion);
            if (!needConfigUpdate && !needDataUpdate)
            {
                PrintToChat("<color=lightblue>Hunt</color>: RPG Loaded!");
                PrintToChat("<color=lightblue>Hunt</color>: To see the Hunt RPG help type \"/hunt\" or \"/h\"");
                return;
            }
            if (needConfigUpdate)
            {
                LogToConsole("Your config needs updating...Doing it now.");
                Config.Clear();
                UpdateConfig = true;
                DefaultConfig();
                LogToConsole("Config updated!");
            }
            UpdatePlayerData = needDataUpdate;
            if (needDataUpdate)
            {
                var wasUpdated = UpdatePlayerData;
                UpdateData();
                foreach (var player in BasePlayer.activePlayerList)
                    HuntRPGInstance.PlayerInit(player, wasUpdated);
            }
        }

        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player)
        {
            HuntRPGInstance.PlayerInit(player, UpdatePlayerData);
        }

        //[HookMethod("OnItemAddedToContainer")]
        //void OnItemAddedToContainer(ItemContainer itemContainer, Item item)
        //{
        //    HuntRPGInstance.OnItemAddedToContainer(itemContainer, item);
        //}

        [HookMethod("OnEntityTakeDamage")]
        object OnEntityTakeDamage(MonoBehaviour entity, HitInfo hitInfo)
        {
            var player = entity as BasePlayer;
            if (player == null) return null;
            if (!HuntRPGInstance.OnAttacked(player, hitInfo)) return null;
            hitInfo = new HitInfo();
            return hitInfo;
        }

        [HookMethod("OnPlayerAttack")]
        object OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            return HuntRPGInstance.OnPlayerAttack(player, hitInfo) ? true as object : null;
        }

        [HookMethod("OnEntityDeath")]
        void OnEntityDeath(MonoBehaviour entity, HitInfo hitinfo)
        {
            var player = entity as BasePlayer;
            if (player == null) return;
            HuntRPGInstance.OnDeath(player);
        }

        [HookMethod("OnItemCraft")]
        ItemCraftTask OnItemCraft(ItemCraftTask item)
        {
            return HuntRPGInstance.OnItemCraft(item);
        }

        [HookMethod("OnGather")]
        void OnGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            HuntRPGInstance.OnGather(dispenser, entity, item);
        }

        [HookMethod("OnItemDeployed")]
        void OnItemDeployed(Deployer deployer, BaseEntity baseEntity)
        {
            HuntRPGInstance.OnDeployItem(deployer, baseEntity);
        }

        [HookMethod("OnConsumeFuel")]
        void OnConsumeFuel(BaseOven oven,Item fuel, ItemModBurnable burnable)
        {
            HuntRPGInstance.OnConsumeFuel(oven, fuel, burnable);
        }

        [HookMethod("OnBuildingBlockDoUpgradeToGrade")]
        object OnBuildingBlockUpgrade(BuildingBlock buildingBlock, BaseEntity.RPCMessage message, BuildingGrade.Enum grade)
        {
            HuntRPGInstance.OnBuildingBlockUpgrade(message.player, buildingBlock, grade);
            return null;
        }


        [ChatCommand("h")]
        void cmdHuntShortcut(BasePlayer player, string command, string[] args)
        {
            cmdHunt(player, command, args);
        }

        [ChatCommand("hunt")]
        void cmdHunt(BasePlayer player, string command, string[] args)
        {
            HuntRPGInstance.HandleChatCommand(player, args);
        }

        [ConsoleCommand("hunt.saverpg")]
        private void cmdSaveRPG(ConsoleSystem.Arg arg)
        {
            if (!arg.CheckPermissions()) return;
            HuntRPGInstance.SaveRPG();
        }

        [ConsoleCommand("hunt.resetrpg")]
        private void cmdResetRPG(ConsoleSystem.Arg arg)
        {
            if (!arg.CheckPermissions()) return;
            HuntRPGInstance.ResetRPG();
        }

        [ConsoleCommand("hunt.genxptable")]
        private void cmdGenerateXPTable(ConsoleSystem.Arg arg)
        {
            if (!arg.CheckPermissions()) return;
            arg.ReplyWith("Gerando Tabela");
            var levelMultiplier = HK.LevelMultiplier;
            var baseXP = HK.BaseXP;
            var levelModule = HK.LevelModule;
            var moduleReducer = HK.ModuleReducer;
            if (arg.HasArgs())
                baseXP = arg.GetInt(0);
            if (arg.HasArgs(2))
                levelMultiplier = arg.GetFloat(1);
            if (arg.HasArgs(3))
                levelModule = arg.GetInt(2);
            if (arg.HasArgs(4))
                moduleReducer = arg.GetFloat(3);
                Config[HK.XPTable] = HuntTablesGenerator.GenerateXPTable(HK.MaxLevel, baseXP, levelMultiplier, levelModule, moduleReducer);
            SaveConfig();
            arg.ReplyWith("Tabela Gerada");
        }

        [HookMethod("OnServerSave")]
        void OnServerSave()
        {
            HuntRPGInstance.SaveRPG();
        }

        public void TeleportPlayerTo(BasePlayer player, Vector3 position)
        {
            ForcePlayerPosition(player, position);
        }

        public Vector3? GetGround(Vector3 position)
        {
            var direction = Vector3.forward;
            var raycastHits = Physics.RaycastAll(position, direction, 25f).GetEnumerator();
            float nearestDistance = 9999f;
            Vector3? nearestPoint = null;
            while (raycastHits.MoveNext())
            {
                var hit = (raycastHits.Current);
                if (hit != null)
                {
                    RaycastHit raycastHit = (RaycastHit)hit;
                    if (raycastHit.distance < nearestDistance)
                    {
                        nearestDistance = raycastHit.distance;
                        nearestPoint = raycastHit.point;
                    }
                }
            }
            return nearestPoint;
        }

        public void LogToConsole(string message)
        {
            Puts(String.Format("Hunt: {0}",message));
        }

        public bool IsOwner(object buildingBlock, BasePlayer player)
        {
            if (BuildingOwners == null) return false;
            string owner = (string) BuildingOwners.Call("FindBlockData", new[] {buildingBlock});
            return owner == RPGHelper.SteamId(player);
        }
    }
}

namespace Hunt.RPG
{

    class HuntRPG
    {
        private Dictionary<string, RPGInfo> RPGConfig;
        private PluginMessagesConfig MessagesTable;
        private Dictionary<string, Skill> SkillTable;
        private Dictionary<int, long> XPTable;
        private Dictionary<int, string> TameTable;
        private Dictionary<string, ItemInfo> ItemTable;
        private Dictionary<string, int> ResearchTable;
        private Dictionary<string, string> PlayersFurnaces;
        private readonly Dictionary<string, float> PlayerLastPercentChange;
        private readonly Dictionary<string, Dictionary<string,float>> SkillsCooldowns;
        private Dictionary<BuildingGrade.Enum, float> UpgradeBuildingTable;
        private Dictionary<string, float> MaxStatsTable;
        private readonly HuntPlugin PluginInstance;
        readonly Random RandomGenerator = new Random();

        public HuntRPG(HuntPlugin pluginInstance)
        {
            PluginInstance = pluginInstance;
            SkillsCooldowns = new Dictionary<string, Dictionary<string, float>>();
            PlayerLastPercentChange = new Dictionary<string, float>();
        }

        public void ConfigRPG(PluginMessagesConfig messagesTable, Dictionary<int, long> xpTable, Dictionary<string, float> maxStatsTable, Dictionary<BuildingGrade.Enum, float> upgradeBuildTable, Dictionary<string, Skill> skillTable, Dictionary<string, int> researchSkillTable, Dictionary<string, ItemInfo> itemTable, Dictionary<int, string> tameTable, Dictionary<string, RPGInfo> rpgConfig, Dictionary<string, string> playerFurnaces)
        {
            MessagesTable = messagesTable;
            XPTable = xpTable;
            SkillTable = skillTable;
            MaxStatsTable = maxStatsTable;
            ItemTable = itemTable;
            TameTable = tameTable;
            RPGConfig = rpgConfig;
            ResearchTable = researchSkillTable;
            UpgradeBuildingTable = upgradeBuildTable;
            PlayersFurnaces = playerFurnaces;
        }

        private RPGInfo RPGInfo(BasePlayer player)
        {
            var steamId = RPGHelper.SteamId(player);
            if (RPGConfig.ContainsKey(steamId)) return RPGConfig[steamId];
            RPGConfig[steamId] = new RPGInfo(player.displayName);
            PluginInstance.SaveRPG(RPGConfig, PlayersFurnaces);
            return RPGConfig[steamId];
        }

        private RPGInfo RPGInfo(string steamId)
        {
            return RPGConfig.ContainsKey(steamId) ? RPGConfig[steamId] : null;
        }

        public void HandleChatCommand(BasePlayer player, string[] args)
        {
            if (args.Length == 0)
            {
                ChatMessage(player, MessagesTable.GetMessage(HMK.Help));
                return;
            }
            var rpgInfo = RPGInfo(player);

            switch (args[0].ToLower())
            {
                case "about":
                    ChatMessage(player, MessagesTable.GetMessage(HMK.About));
                    break;
                case "shortcuts":
                    ChatMessage(player, MessagesTable.GetMessage(HMK.Shortcuts));
                    break;
                case "p":
                case "profile":
                    DisplayProfile(player);
                    break;
                case "pp":
                case "profilepreferences":
                    ChatMessage(player, MessagesTable.GetMessage(HMK.ProfilePreferences));
                    break;
                case "sts":
                case "statset":
                    SetStatsCommand(player, args, rpgInfo);
                    break;
                case "sks":
                case "skillset":
                    SetSkillsCommand(player, args, rpgInfo);
                    break;
                case "skill":
                    DisplaySkillCommand(player, args);
                    break;
                case "skilllist":
                    ListSkills(player);
                    break;
                case "lvlup":
                    LevelUpChatHandler(player, args, rpgInfo);
                    break;
                case "research":
                    ReserachItem(player, args, rpgInfo);
                    break;
                case "xp":
                    ChatMessage(player, XPProgression(rpgInfo));
                    break;
                case "xp%":
                    ChangePlayerXPMessagePreference(player, args, rpgInfo);
                    break;
                case "craftmsg":
                    ToogleCraftMessage(player, rpgInfo);
                    break;
                case "ba":
                    ToogleBlinkArrow(player, rpgInfo);
                    break;
                case "aba":
                    ToogleAutoBlinkArrow(player, rpgInfo);
                    break;
                default:
                    ChatMessage(player, MessagesTable.GetMessage(HMK.InvalidCommand, new[]{args[0]}));
                    break;
            }
        }

        private void ToogleAutoBlinkArrow(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.AutoToggleBlinkArrow = !rpgInfo.Preferences.AutoToggleBlinkArrow;
            var toggleBlinkArrowStatus = rpgInfo.Preferences.AutoToggleBlinkArrow ? "On" : "Off";
            ChatMessage(player, String.Format("Auto Toggle Blink Arrow is now {0}", toggleBlinkArrowStatus));
        }

        private void ToogleBlinkArrow(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.UseBlinkArrow = !rpgInfo.Preferences.UseBlinkArrow;
            var blinkArrowStatus = rpgInfo.Preferences.UseBlinkArrow ? "On" : "Off";
            ChatMessage(player, String.Format("Blink Arrow is now {0}", blinkArrowStatus));
        }

        private void ToogleCraftMessage(BasePlayer player, RPGInfo rpgInfo)
        {
            rpgInfo.Preferences.ShowCraftMessage = !rpgInfo.Preferences.ShowCraftMessage;
            var craftMessageStatus = rpgInfo.Preferences.ShowCraftMessage ? "On" : "Off";
            ChatMessage(player, String.Format("Craft message is now {0}",craftMessageStatus));
        }

        public bool IsNight()
        {
            var dateTime = TOD_Sky.Instance.Cycle.DateTime;
            return dateTime.Hour >= 19 || dateTime.Hour <= 5;
        }

        private void ChangePlayerXPMessagePreference(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            var commandArgs = args.Length - 1;
            if (commandArgs != 1)
            {
                InvalidCommand(player, args);
                return;
            }
            float xpPercent;
            if (!Single.TryParse(args[1], out xpPercent))
            {
                InvalidCommand(player, args);
                return;
            }
            rpgInfo.Preferences.ShowXPMessagePercent = xpPercent/100;
            ChatMessage(player, String.Format("XP will be shown at every {0:P} change", rpgInfo.Preferences.ShowXPMessagePercent));
        }

        private void DisplaySkillCommand(BasePlayer player, string[] args)
        {
            int commandArgs = args.Length - 1;
            if (commandArgs != 1)
            {
                InvalidCommand(player, args);
                return;
            }
            var skillName = args[1];
            if (!SkillTable.ContainsKey(skillName))
            {
                ChatMessage(player, HMK.InvalidSkillName);
                return;
            }
            var sb = new StringBuilder();
            RPGHelper.SkillInfo(sb, SkillTable[skillName]);
            ChatMessage(player, sb.ToString());
        }

        private void ListSkills(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.AppendLine("==================");
            sb.AppendLine("Availabel Skills:");
            foreach (var skill in SkillTable)
                RPGHelper.SkillInfo(sb, skill.Value);
            sb.AppendLine("==================");
            ChatMessage(player, sb.ToString());
        }

        public bool OnAttacked(BasePlayer player, HitInfo hitInfo)
        {
            var baseNpc = hitInfo.Initiator as BaseNPC;
            var basePlayer = hitInfo.Initiator as BasePlayer;
            bool canEvade = baseNpc != null || basePlayer != null && player.userID != basePlayer.userID;
            if (!canEvade) return false;
            var randomFloat = Random(0, 1);
            RPGInfo rpgInfo = RPGInfo(player);
            var evasion = RPGHelper.GetEvasion(rpgInfo, MaxStatsTable[HRK.AgiEvasionGain]);
            bool evaded = randomFloat <= evasion;
            if (evaded)
            {
                ChatMessage(player, "Dodged!");
                return true;
            }
            var blockPercent = RPGHelper.GetBlock(rpgInfo, MaxStatsTable[HRK.StrBlockGain]);
            //var total = hitInfo.damageTypes.Total();
            float[] array = hitInfo.damageTypes.types;
            for (int index = 0; index < array.Length; index++)
            {
                var damage = array[index];
                damage = damage - (damage * blockPercent);
                hitInfo.damageTypes.Set((DamageType)index, damage);
            }
            //var blocked = hitInfo.damageTypes.Total();
            //ChatMessage(player, String.Format("Blocked {0:F1}/{1}", total-blocked, total));
            return false;
        }

        double Random(double a, double b)
        {
            return a + RandomGenerator.NextDouble() * (b - a);
        }

        public ItemCraftTask OnItemCraft(ItemCraftTask item)
        {
            BasePlayer player = item.owner;
            var itemName = item.blueprint.targetItem.displayName.translated.ToLower();
            if (!ItemTable.ContainsKey(itemName))
                return null;
            var blueprintTime = ItemTable[itemName].BlueprintTime;
            
            var rpgInfo = RPGInfo(player);
            float craftingTime = blueprintTime;
            float craftingReducer = RPGHelper.GetCraftingReducer(rpgInfo, MaxStatsTable[HRK.IntCraftingReducer]);
            var amountToReduce = (craftingTime*craftingReducer);    
            float reducedCraftingTime = craftingTime - amountToReduce;
            item.blueprint.time = reducedCraftingTime;
            if(rpgInfo.Preferences.ShowCraftMessage)
                ChatMessage(player, String.Format("Crafting will end in {0:F} seconds. Reduced in {1:F} seconds", reducedCraftingTime, amountToReduce));
            return item;
        }

        public void OnGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null) return;
            var gatherType = dispenser.gatherType;
            RPGInfo rpgInfo = RPGInfo(player);
            int experience = item.amount;
            if (rpgInfo == null) return;
            if (gatherType == ResourceDispenser.GatherType.Tree)
            {
                if (rpgInfo.Skills.ContainsKey(HRK.LumberJack))
                {
                    var modifier = SkillTable[HRK.LumberJack].Modifiers[HRK.GatherModifier];
                    int newAmount = SkillMethods.GatherModifier(rpgInfo.Skills[HRK.LumberJack], Convert.ToInt32(modifier.Args[0]), item.amount);
                    item.amount = newAmount;
                }
                experience = item.amount;
            }
            if (gatherType == ResourceDispenser.GatherType.Ore)
            {
                if (rpgInfo.Skills.ContainsKey(HRK.Miner))
                {
                    var modifier = SkillTable[HRK.Miner].Modifiers[HRK.GatherModifier];
                    int newAmount = SkillMethods.GatherModifier(rpgInfo.Skills[HRK.Miner], Convert.ToInt32(modifier.Args[0]), item.amount);
                    item.amount = newAmount;
                }
                experience = (int) ((float)item.amount/3);
            }
            if (gatherType == ResourceDispenser.GatherType.Flesh)
            {
                if (rpgInfo.Skills.ContainsKey(HRK.Hunter))
                {
                    var modifier = SkillTable[HRK.Hunter].Modifiers[HRK.GatherModifier];
                    int newAmount = SkillMethods.GatherModifier(rpgInfo.Skills[HRK.Hunter], Convert.ToInt32(modifier.Args[0]), item.amount);
                    item.amount = newAmount;
                }
                experience = item.amount * 5;
            }
            ExpGain(rpgInfo, experience, player);
        }

        private void ExpGain(RPGInfo rpgInfo, int experience, BasePlayer player)
        {
            var steamId = RPGHelper.SteamId(player);
            if (IsNight())
                experience *= 2;
            if (rpgInfo.AddExperience(experience, RequiredExperience(rpgInfo.Level)))
            {
                NotifyLevelUp(player, rpgInfo);
                PlayerLastPercentChange[steamId] = 0;
            }
            else
            {
                var currentPercent = CurrentPercent(rpgInfo);
                if (!PlayerLastPercentChange.ContainsKey(steamId))
                    PlayerLastPercentChange.Add(steamId, currentPercent);
                var lastPercent = PlayerLastPercentChange[steamId];
                var requiredPercentChange = rpgInfo.Preferences.ShowXPMessagePercent;
                float percentChange = currentPercent - lastPercent;
                if (percentChange < requiredPercentChange) return;
                ChatMessage(player, XPProgression(rpgInfo));
                PlayerLastPercentChange[steamId] = currentPercent;
            }
                
        }

        private void NotifyLevelUp(BasePlayer player, RPGInfo rpgInfo)
        {
            ChatMessage(player, String.Format("<color=yellow>Level Up! You are now level {0}</color>", rpgInfo.Level));
            DisplayProfile(player);
            PluginInstance.SaveRPG(RPGConfig, PlayersFurnaces, false);
        }

        private long RequiredExperience(int level)
        {
            return XPTable[level];
        }

        public string XPProgression(RPGInfo rpgInfo)
        {
            var percent = CurrentPercent(rpgInfo);
            string nightBonus = "";
            if (IsNight())
                nightBonus = "Bonus Night Exp On";
            return String.Format("Current XP: {0:P}. {1}", percent, nightBonus);
        }

        private float CurrentPercent(RPGInfo rpgInfo)
        {
            return rpgInfo.Experience/(float) (RequiredExperience(rpgInfo.Level));
        }

        public string Profile(RPGInfo rpgInfo, BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.AppendLine();
            sb.AppendLine(String.Format("========{0}========", rpgInfo.SteamName));
            sb.AppendLine(String.Format("Level: {0}", rpgInfo.Level));
            sb.AppendLine(String.Format("Damage Block: {0:P}", RPGHelper.GetBlock(rpgInfo, MaxStatsTable[HRK.StrBlockGain])));
            sb.AppendLine(String.Format("Evasion Chance: {0:P}", RPGHelper.GetEvasion(rpgInfo, MaxStatsTable[HRK.AgiEvasionGain])));
            sb.AppendLine(String.Format("Crafting Reducer: {0:P}", RPGHelper.GetCraftingReducer(rpgInfo, MaxStatsTable[HRK.IntCraftingReducer])));
            sb.AppendLine(XPProgression(rpgInfo));
            sb.Append(String.Format("<color={0}>Agi: {1}</color> | ","green", rpgInfo.Agility));
            sb.Append(String.Format("<color={0}>Str: {1}</color> | ", "red", rpgInfo.Strength));
            sb.Append(String.Format("<color={0}>Int: {1}</color>", "blue", rpgInfo.Intelligence));
            sb.AppendLine();
            sb.AppendLine(String.Format("Stats Points: {0}", rpgInfo.StatsPoints));
            sb.AppendLine(String.Format("Skill Points: {0}", rpgInfo.SkillPoints));
            sb.AppendLine(String.Format("========<color={0}>Skills</color>========", "purple"));
            foreach (var skill in rpgInfo.Skills)
                sb.AppendLine(String.Format("{0}: {1}/{2}", skill.Key, skill.Value, SkillTable[skill.Key].MaxPoints));
            sb.AppendLine("====================");
            return sb.ToString();
        }

        private void ChatMessage(BasePlayer player, IEnumerable<string> messages)
        {
            foreach (string message in messages)
                ChatMessage(player, message);
        }

        private void ChatMessage(BasePlayer player, string message)
        {
            player.ChatMessage(string.Format("<color={0}>{1}</color>: {2}", MessagesTable.ChatPrefixColor, MessagesTable.ChatPrefix, message));
        }

        public bool ReserachItem(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            int commandArgs = args.Length - 1;
            if (commandArgs != 1)
            {
                InvalidCommand(player, args);
                return false;
            }
            
            if (!PlayerHaveSkill(player, rpgInfo, HRK.Researcher)) return false;
            var playerResearchPoints = rpgInfo.Skills[HRK.Researcher];
            var itemname = args[1];
            itemname = itemname.ToLower();
            if (!ItemTable.ContainsKey(itemname))
            {
                ChatMessage(player, MessagesTable.GetMessage(HMK.ItemNotFound, new[] { itemname }));
                return false;
            }

            var itemInfo = ItemTable[itemname];
            itemname = itemInfo.Shortname;
            var definition = ItemManager.FindItemDefinition(itemname);
            if (definition == null)
            {
                ChatMessage(player, MessagesTable.GetMessage(HMK.ItemNotFound, new[] { itemname }));
                return false;
            }
            if (!itemInfo.CanResearch)
            {
                ChatMessage(player, MessagesTable.GetMessage(HMK.ResearchBlocked, new []{ itemname }));
                return false;
            }
            var playerContainer = player.inventory.containerMain;
            var hasItem = player.inventory.AllItems().Any(item => item.info.shortname.Equals(itemname));
            if (!hasItem)
            {
                ChatMessage(player, String.Format("In order to research an item you must have it on your inventory"));
                return false;
            }
            if (!ResearchTable.ContainsKey(itemInfo.ItemCategory))
            {
                ChatMessage(player, "You can research itens of this type");
                return false;
            }
            var requiredSkillPoints = ResearchTable[itemInfo.ItemCategory];
            if (playerResearchPoints < requiredSkillPoints)
            {
                ChatMessage(player, String.Format("Your research skills are not hight enought. Required {0}", requiredSkillPoints));
                return false;
            }

            var steamId = RPGHelper.SteamId(player);
            float availableAt = 0;
            var time = Time.realtimeSinceStartup;
            var playerCooldowns = PlayerCooldowns(steamId);
            var isReady = RPGHelper.IsSkillReady(playerCooldowns, ref availableAt, time, HRK.Researcher);
            if (isReady)
            {
                var random = Random(0, 1);
                if (random > 0.6)
                {
                    ChatMessage(player, String.Format("You managed to reverse enginier the {0}. The blueprint its on your inventory", definition.displayName.translated));
                    player.inventory.GiveItem(ItemManager.CreateByItemID(definition.itemid, 1, true), playerContainer);
                    NoticeArea.ItemPickUp(definition,1, true);
                }
                else
                {
                    ChatMessage(player, String.Format("OPS! While you were trying to research the {0} you accidently broke it.", definition.displayName.translated));
                    var itemInstance = player.inventory.FindItemID(definition.itemid);
                    player.inventory.Take(new List<Item> { itemInstance }, definition.itemid, 1);
                }
                SetCooldown(rpgInfo, time, playerCooldowns, HRK.Researcher);
            }
            else
            {
                var formatedTimeLeft = RPGHelper.TimeLeft(availableAt, time);
                ChatMessage(player, String.Format("You have tried this moments ago, give it a rest. Time left to research again: {0}",formatedTimeLeft));
            }
            return true;
        }

        private bool PlayerHaveSkill(BasePlayer player, RPGInfo rpgInfo, string skillKey,bool sendMsg = true)
        {
            if (rpgInfo.Skills.ContainsKey(skillKey)) return true;
            if (sendMsg)
                ChatMessage(player, MessagesTable.GetMessage(HMK.SkillNotLearned));
            return false;
        }

        private void SetCooldown(RPGInfo rpgInfo, float time, Dictionary<string, float> playerCooldowns, string skillKey)
        {
            var modifier = SkillTable[skillKey].Modifiers[HRK.CooldownModifier];
            var availableAt = SkillMethods.CooldownModifier(rpgInfo.Skills[skillKey], Convert.ToInt32(modifier.Args[0]),
                Convert.ToInt32(modifier.Args[1]), time);
            playerCooldowns[skillKey] = availableAt;
        }

        private Dictionary<string, float> PlayerCooldowns(string steamId)
        {
            if (!SkillsCooldowns.ContainsKey(steamId))
                SkillsCooldowns.Add(steamId, new Dictionary<string, float>());
            Dictionary<string, float> playerCooldowns = SkillsCooldowns[steamId];
            return playerCooldowns;
        }

        private void SetSkillsCommand(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            int commandArgs = args.Length - 1;
            if (args.Length < 3 || (commandArgs%2) != 0)
            {
                InvalidCommand(player, args);
                return;
            }
            var pointsSpent = new List<string>();
            int pairs = (commandArgs / 2) + 1;
            for (int i = 1; i < pairs; i++)
            {
                int index = i * 2 - 1;
                string skillKey = args[index];
                int points;
                if (!Int32.TryParse(args[index + 1], out points))
                {
                    InvalidCommand(player, args);
                    continue;
                }

                if (SkillTable.ContainsKey(skillKey))
                {
                    var skill = SkillTable[skillKey];
                    if (!skill.Enabled)
                    {
                        pointsSpent.AddRange(MessagesTable.GetMessage(HMK.SkillDisabled));
                        continue;
                    }
                    string reason;
                    var pointsAdded = rpgInfo.AddSkill(skill, points, out reason);
                    if (pointsAdded > 0)
                    {
                        pointsSpent.Add(String.Format("<color={0}>{1}: +{2}</color>", "purple", skillKey,
                            pointsAdded));
                        if (!skill.Name.Equals(HRK.Tamer)) continue;
                        var tamerSkill = rpgInfo.Skills[HRK.Tamer];
                        PluginInstance.GiveTamePermission(RPGHelper.SteamId(player), HPK.CanTame);
                        for (int j = 1; j <= tamerSkill; j++)
                            PluginInstance.GiveTamePermission(RPGHelper.SteamId(player), TameTable[j]);
                    }
                        
                    else
                    {
                        pointsSpent.AddRange(MessagesTable.GetMessage(reason));
                        pointsSpent.AddRange(MessagesTable.GetMessage(HMK.SkillInfo));
                    }
                            
                }
                else
                    pointsSpent.AddRange(MessagesTable.GetMessage(HMK.InvalidSkillName));
            }
            ChatMessage(player, pointsSpent);
        }

        private void SetStatsCommand(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            int commandArgs = args.Length - 1;
            if (args.Length < 3 || (commandArgs%2) != 0)
                InvalidCommand(player, args);
            else
            {
                var pointsSpent = new List<string>();
                int pairs = (commandArgs/2) + 1;
                for (int i = 1; i < pairs; i++)
                {
                    int index = i*2 - 1;
                    int points;
                    if (!Int32.TryParse(args[index + 1], out points))
                    {
                        InvalidCommand(player, args);
                        continue;
                    }

                    switch (args[index].ToLower())
                    {
                        case "agi":
                            if (rpgInfo.AddAgi(points))
                                pointsSpent.Add(String.Format("<color={0}>Agi: +{1}</color>", "green", points));
                            else
                                pointsSpent.AddRange(MessagesTable.GetMessage(HMK.NotEnoughtPoints));
                            break;
                        case "str":
                            if (rpgInfo.AddStr(points))
                            {
                                pointsSpent.Add(String.Format("<color={0}>Str: +{1}</color>", "red", points));
                            }
                            else
                                pointsSpent.AddRange(MessagesTable.GetMessage(HMK.NotEnoughtPoints));
                            break;
                        case "int":
                            if (rpgInfo.AddInt(points))
                                pointsSpent.Add(String.Format("<color={0}>Int: +{1}</color>", "blue", points));
                            else
                                pointsSpent.AddRange(MessagesTable.GetMessage(HMK.NotEnoughtPoints));
                            break;
                        default:
                            InvalidCommand(player, args);
                            break;
                    }
                }
                ChatMessage(player, pointsSpent);
            }
        }

        private void LevelUpChatHandler(BasePlayer player, string[] args, RPGInfo rpgInfo)
        {
            if (!player.IsAdmin()) return;
            var callerPlayer = player;
            int commandArgs = args.Length - 1;
            if (commandArgs > 2 && commandArgs < 1)
                InvalidCommand(player, args);
            else
            {
                int levelIndex = 1;
                if (commandArgs  == 2)
                {
                    levelIndex = 2;
                    string playerToSearch = args[1].ToLower();
                    var activePlayerList = BasePlayer.activePlayerList;
                    var playersFound = (from basePlayer in activePlayerList let displayName = basePlayer.displayName.ToLower() where displayName.Equals(playerToSearch) select basePlayer).ToDictionary(basePlayer => basePlayer.displayName);
                    if (playersFound.Count > 1)
                    {
                        var playerFoundNames = String.Join(",", playersFound.Select(basePlayer => basePlayer.Key).ToArray());
                        ChatMessage(callerPlayer, String.Format("Multiple players found. {0}", playerFoundNames));
                        return;
                    }
                    if (playersFound.Count == 0)
                    {
                        ChatMessage(callerPlayer, "No player found with that name!");
                        return;
                    }
                    player = playersFound.First().Value;
                    rpgInfo = RPGInfo(player);
                }
                int desiredLevel;
                if (!Int32.TryParse(args[levelIndex], out desiredLevel))
                {
                    InvalidCommand(callerPlayer, args);
                    return;
                }
                if (desiredLevel <= rpgInfo.Level) return;
                LevelUpPlayer(rpgInfo, desiredLevel);
                NotifyLevelUp(player, rpgInfo);
                if (callerPlayer != player)
                    ChatMessage(callerPlayer, String.Format("Player {0} lvlup to {1}", player, desiredLevel));
            }
        }

        public void LevelUpPlayer(RPGInfo rpgInfo, int desiredLevel)
        {
            var levelsToUp = desiredLevel - rpgInfo.Level;
            for (int i = 0; i < levelsToUp; i++)
            {
                long requiredXP = RequiredExperience(rpgInfo.Level);
                rpgInfo.AddExperience(requiredXP, requiredXP);
            }
        }

        private void InvalidCommand(BasePlayer player, string[] args)
        {
            ChatMessage(player, MessagesTable.GetMessage(HMK.InvalidCommand, new[] {args[0]}));
        }

        public void ResetRPG()
        {
            foreach (var rpgInfoPair in RPGConfig)
            {
                var rpgInfo = rpgInfoPair.Value;
                if (!rpgInfo.Skills.ContainsKey(HRK.Tamer))
                    continue;
                PluginInstance.RevokeTamePermission(rpgInfoPair.Key, HPK.CanTame);
                PluginInstance.RevokeTamePermission(rpgInfoPair.Key, HPK.CanTameWolf);
                PluginInstance.RevokeTamePermission(rpgInfoPair.Key, HPK.CanTameBear);
            }
            RPGConfig.Clear();
            PlayersFurnaces.Clear();
            PluginInstance.SaveRPG(RPGConfig, PlayersFurnaces);
        }

        public void SaveRPG()
        {
            PluginInstance.SaveRPG(RPGConfig, PlayersFurnaces);
        }

        public void DisplayProfile(BasePlayer player)
        {
            ChatMessage(player, Profile(RPGInfo(player), player));
        }

        public void OnDeath(BasePlayer player)
        {
            RPGInfo(player).Died();
            ChatMessage(player, String.Format("Oh no man! You just died! You lost {0:P} of XP because of this....", HK.DeathReducer));
        }

        public void PlayerInit(BasePlayer player, bool dataWasUpdated)
        {
            if(dataWasUpdated)
                ChatMessage(player, MessagesTable.GetMessage(HMK.DataUpdated));
            DisplayProfile(player);
            var steamId = RPGHelper.SteamId(player);
            if(!PlayerLastPercentChange.ContainsKey(steamId))
                PlayerLastPercentChange.Add(steamId, CurrentPercent(RPGInfo(player)));
        }

        public void OnBuildingBlockUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
        {
            var items = buildingBlock.blockDefinition.grades[(int) grade].costToBuild;
            int total = items.Sum(item => (int) item.amount);
            int experience = (int) Math.Ceiling(UpgradeBuildingTable[grade]*total);
            ExpGain(RPGInfo(player), experience, player);
        }

        public void OnDeployItem(Deployer deployer, BaseEntity baseEntity)
        {
            var player = deployer.ownerPlayer;
            var item = deployer.GetItem();
            var itemDef = item.info;
            var type = baseEntity.GetType();
            if (type != typeof (BaseOven) || !itemDef.displayName.translated.ToLower().Equals("furnace")) return;
            var baseOven = (BaseOven)baseEntity;
            var instanceId = RPGHelper.OvenId(baseOven);
            if (PlayersFurnaces.ContainsKey(instanceId))
            {
                ChatMessage(player, "Contact the developer, tell him wrong Id usage for furnace.");
                return;
            }
            PlayersFurnaces.Add(instanceId, RPGHelper.SteamId(player));
        }

        public void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            var instanceId = RPGHelper.OvenId(oven);
            if (!PlayersFurnaces.ContainsKey(instanceId))
                return;
            var steamId = Convert.ToUInt64(PlayersFurnaces[instanceId]);
            var player = BasePlayer.FindByID(steamId) ?? BasePlayer.FindSleeping(steamId);
            var rpgInfo = player == null ? RPGInfo(PlayersFurnaces[instanceId]) : RPGInfo(player);
            if (rpgInfo == null)
                return;
            if (!rpgInfo.Skills.ContainsKey(HRK.Blacksmith))
                return;
            var skillPoints = rpgInfo.Skills[HRK.Blacksmith];
            double random = Random(0, 1);
            float skillChance = (float)skillPoints/7;
            float maybeGiveAmount = (float)skillPoints/2;
            int amountToGive = (int) Math.Ceiling(maybeGiveAmount);
            if (random > skillChance)
                return;
            var itemList = oven.inventory.itemList;
            var itensCanMelt = (from item in itemList let itemModCookable = item.info.GetComponent<ItemModCookable>() where itemModCookable != null select item).ToList();
            foreach (var item in itensCanMelt)
            {
                var itemModCookable = item.info.GetComponent<ItemModCookable>();
                oven.inventory.Take(null, item.info.itemid, amountToGive);
                var itemToGive = ItemManager.Create(itemModCookable.becomeOnCooked, amountToGive);
                if (!itemToGive.MoveToContainer(oven.inventory))
                    itemToGive.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
            }
        }

        public bool OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            var weapon = hitInfo.Weapon.GetOwnerItemDefinition().displayName.translated.ToLower();
            if (SkillTable.ContainsKey(HRK.BlinkArrow))
                if (!SkillTable[HRK.BlinkArrow].Enabled)
                    return false;
            if (!weapon.Equals("hunting bow"))
                return false;
            var steamId = RPGHelper.SteamId(player);
            float availableAt = 0;
            var time = Time.realtimeSinceStartup;
            var rpgInfo = RPGInfo(player);
            if (!PlayerHaveSkill(player, rpgInfo, HRK.BlinkArrow, false)) return false;
            var playerCooldowns = PlayerCooldowns(steamId);
            var isReady = RPGHelper.IsSkillReady(playerCooldowns, ref availableAt, time, HRK.BlinkArrow);
            if (isReady)
            {
                if (rpgInfo.Preferences.AutoToggleBlinkArrow)
                    rpgInfo.Preferences.UseBlinkArrow = true;
                if (!rpgInfo.Preferences.UseBlinkArrow) return false;
                var newPos = PluginInstance.GetGround(hitInfo.HitPositionWorld);
                if (newPos == null)
                {
                    ChatMessage(player, "Can't blink there!");
                    return false;
                }
                var position = (Vector3)newPos;
                var buildingBlock = GetBuildingBlock(position);
                if (buildingBlock != null)
                {
                    if (!PluginInstance.IsOwner(buildingBlock, player))
                    {
                        ChatMessage(player, "Can't blink to other player house!");
                        return false;
                    }
                }
                PluginInstance.TeleportPlayerTo(player, position);
                SetCooldown(rpgInfo, time, playerCooldowns, HRK.BlinkArrow);
                return true;
            }
            if (!rpgInfo.Preferences.UseBlinkArrow) return false;
            ChatMessage(player, String.Format("Blinked recently! You might get dizzy, give it a rest. Time left to blink again: {0}", RPGHelper.TimeLeft(availableAt, time)));
            if (rpgInfo.Preferences.AutoToggleBlinkArrow)
                rpgInfo.Preferences.UseBlinkArrow = false;
            return false;
        }

        public object GetBuildingBlock(Vector3 position)
        {
            var hits = Physics.OverlapSphere(position, 3f);
            foreach (var hit in hits)
            {
                if (hit.GetComponentInParent<BuildingBlock>() != null)
                {
                    return hit.GetComponentInParent<BuildingBlock>();
                }
            }
            return null;
        }

        //public void OnItemAddedToContainer(ItemContainer itemContainer, Item item)
        //{
        //    var player = itemContainer.playerOwner;
        //    if(player == null) return;
        //    item.info.displayDescription
        //}
    }

    public static class HuntTablesGenerator
    {
        public static Dictionary<int, long> GenerateXPTable(int maxLevel, int baseExp, float levelMultiplier, int levelModule, float moduleReducer)
        {
            var xpTable = new Dictionary<int, long>();
            long previousLevel = baseExp;
            xpTable.Add(0, baseExp);
            for (int i = 0; i < maxLevel; i++)
            {
                if (i%levelModule == 0)
                    levelMultiplier -= moduleReducer;
                long levelRequiredXp = (long)(previousLevel * levelMultiplier);
                xpTable.Add(i+1, levelRequiredXp);
                previousLevel = levelRequiredXp;
            }
            return xpTable;
        }

        public static PluginMessagesConfig GenerateMessageTable()
        {
            var messagesConfig = new PluginMessagesConfig("Hunt", "lightblue");
            messagesConfig.AddMessage(HMK.Help, new List<string>
            {
                "To get an overview about the Hunt RPG, type \"/hunt about\"",
                "To see you available shortcuts commdands, type \"/hunt shortcuts\"",
                "To see you player profile, type \"/hunt profile\"",
                "To see you current xp, type \"/hunt xp\"",
                "To see how to change you profile preferences, type \"/hunt profilepreferences\"",
                "To see you current health, type \"/hunt health\"",
                "To see the skill list type \"/hunt skilllist\"",
                "To see info about a specific skill type \"/hunt skill <skillname>\"",
                "To spend your available stats points, type \"/hunt statset <stats> <points> \". Ex: /hunt statset agi 3",
                "To spend your available skill points, type \"/hunt skillset <skillname> <points> \". Ex: /hunt skillset lumberjack 1",
            });
            messagesConfig.AddMessage(HMK.Shortcuts, new List<string>
            {
                "\"/hunt\" = \"/h\"",
                "\"/hunt profile\" = \"/h p\"",
                "\"/hunt profilepreferences\" = \"/h pp\"",
                "\"/hunt statset\" = \"/h sts\".",
                "You can set multiple stats at a time like this \"/h sts agi 30 str 45\".",
                "\"/hunt skillset\" = \"/h sks\"",
                "You can set multiple skillpoints at a time like this \"/h sks lumberjack 3 miner 2\".",
                "\"/hunt health\" = \"/h h\"",
            });
            messagesConfig.AddMessage(HMK.ProfilePreferences, new List<string>()
            {
                "To see change the % changed need to show the xp message, type \"/hunt xp% <percentnumber>\"",
                "To toggle crafting message type \"/hunt craftmsg\"",
                "To toggle blink arrow skill type \"/hunt ba\"",
                "To toggle blink arrow skill auto toggle type \"/hunt aba\"",
            });         
            messagesConfig.AddMessage(HMK.About, HuntAbout());
            messagesConfig.AddMessage(HMK.DataUpdated, RPGHelper.WrapInColor("Plugin was updated to new version!", OC.Yellow));
            messagesConfig.AddMessage(HMK.DataUpdated, RPGHelper.WrapInColor("Your profile needed to be reset, but your level was saved. You just need to redistribute."));
            messagesConfig.AddMessage(HMK.DataUpdated, RPGHelper.WrapInColor("Furnaces were not saved though, so build new ones for the blacksmith skill to be applied (If you have, or when you get it)!", OC.Red));
            messagesConfig.AddMessage(HMK.InvalidCommand, "You ran the \"{0}\" command incorrectly. Type \"/hunt\" to get help");
            messagesConfig.AddMessage(HMK.SkillInfo, "Type \"/hunt skill <skillname>\" to see the skill info");
            messagesConfig.AddMessage(HMK.NotEnoughtPoints, RPGHelper.WrapInColor("You don't have enought points to set!"));
            messagesConfig.AddMessage(HMK.NotEnoughLevels, RPGHelper.WrapInColor("You dont have the minimum level to learn this skill!"));
            messagesConfig.AddMessage(HMK.NotEnoughStrength, RPGHelper.WrapInColor("You dont have enough strenght to learn this skill!"));
            messagesConfig.AddMessage(HMK.NotEnoughAgility, RPGHelper.WrapInColor("You dont have enough agility to learn this skill!"));
            messagesConfig.AddMessage(HMK.NotEnoughIntelligence, RPGHelper.WrapInColor("You dont have enough intelligence to learn this skill!"));
            messagesConfig.AddMessage(HMK.InvalidSkillName, RPGHelper.WrapInColor("There is no such skill! Type \"/hunt skilllist\" to see the available skills"));
            messagesConfig.AddMessage(HMK.SkillDisabled, RPGHelper.WrapInColor("This skill is blocked in this server."));
            messagesConfig.AddMessage(HMK.ItemNotFound, RPGHelper.WrapInColor("Item {0} not found."));
            messagesConfig.AddMessage(HMK.ResearchBlocked, RPGHelper.WrapInColor("Item {0} research is blocked by in this server."));
            messagesConfig.AddMessage(HMK.SkillNotLearned, RPGHelper.WrapInColor("You havent learned this skill yet."));
            messagesConfig.AddMessage(HMK.AlreadyAtMaxLevel, RPGHelper.WrapInColor("You have mastered this skill already!"));
            return messagesConfig;
        }

        private static List<string> HuntAbout()
        {
            var aboutMessages = new List<string>();
            aboutMessages.Add("=================================================");
            aboutMessages.Add("The Hunt RPG system in development.");
            aboutMessages.Add("It is consisted of levels, stats atributes, skills and later on specializations.");
            aboutMessages.Add("Currently there are 3 attributes, each of then give you and specific enhancement.");
            aboutMessages.Add("Strenght gives you more health, it will not be displayed in the Health Bar, but it is considered for healing and getting hurt.");
            aboutMessages.Add("Agillity gives you dodge change");
            aboutMessages.Add("Intelligence decreases your items crafting time");
            aboutMessages.Add("Right now you can level up by gathering resources.");
            aboutMessages.Add("Each level gives you 1 point in each attribute. And 3 more to distribute.");
            aboutMessages.Add("Each level gives you 1 skill point to distribute");
            aboutMessages.Add("Each skill have its required level, and later on it will require specific stats.");
            aboutMessages.Add("To see the all the available skills and its description type \"/hunt skilllist\"");
            aboutMessages.Add("To learn more about Hunt RPG go to the plugin page at <link>");
            aboutMessages.Add("=================================================");
            return aboutMessages;
        }


        public static Dictionary<string, Skill> GenerateSkillTable()
        {
            var skillTable = new Dictionary<string, Skill>();
            var lumberJack = new Skill(HRK.LumberJack, "This skill allows you to gather wood faster. Each point gives you 10% more wood per hit.", 0, 20);
            var woodAndFleshModifier = new Modifier(HRK.GatherModifier, new List<object>(){10});
            lumberJack.AddModifier(HRK.GatherModifier, woodAndFleshModifier);
            skillTable.Add(HRK.LumberJack, lumberJack);
            var miner = new Skill(HRK.Miner, "This skill allows you to gather stones faster. Each point gives you 5% more stones per hit.", 0, 20);
            miner.AddModifier(HRK.GatherModifier, new Modifier(HRK.GatherModifier, new List<object>(){5}));
            skillTable.Add(HRK.Miner, miner);
            var hunter = new Skill(HRK.Hunter, "This skill allows you to gather resources faster from animals. Each point gives you 10% more resources per hit.", 0, 20);
            hunter.AddModifier(HRK.GatherModifier, woodAndFleshModifier);
            skillTable.Add(HRK.Hunter, hunter);
            var researcher = new Skill(HRK.Researcher, "This skill allows you to research items you have. Each level enables a type of type to be researched and decreases 2 minutes of cooldown. Table: Level 1 - Tools (10 min); Level 2 - Clothes (8 min); Level 3 - Construction and Resources (6 min); Level 4 - Ammunition and Medic (4 min); Level 5 - Weapons (2 min)", 30, 5);
            researcher.SkillpointsPerLevel = 7;
            researcher.Usage = "To research an item type \"/research \"Item Name\" \". In order to research an item, you must have it on your invetory, and have the required skill level for that item tier.";
            researcher.AddRequiredStat("int", (int) Math.Floor(researcher.RequiredLevel*2.5d));
            researcher.AddModifier(HRK.CooldownModifier, new Modifier(HRK.CooldownModifier, new List<object>() {10,2}));
            skillTable.Add(HRK.Researcher, researcher);
            var blacksmith = new Skill(HRK.Blacksmith, "This skill allows your furnaces to melt more resources each time. Each level gives increase the productivity by 1.",30, 5);
            blacksmith.SkillpointsPerLevel = 7;
            blacksmith.AddRequiredStat("str", (int)Math.Floor(blacksmith.RequiredLevel * 2.5d));
            skillTable.Add(HRK.Blacksmith, blacksmith);
            var blinkarrow = new Skill(HRK.BlinkArrow, "This skill allows you to blink to your arrow destination from time to time. Each level deacreases the cooldown in 2 minutes.", 150, 5);
            blinkarrow.Usage = "Just shoot an Arrow at desired blink location. To toogle this skill type \"/h ba\" . To change the auto toggle for this skill type \"/h aba\"";
            blinkarrow.AddModifier(HRK.CooldownModifier, new Modifier(HRK.CooldownModifier, new List<object>() {9, 2}));
            blinkarrow.SkillpointsPerLevel = 10;
            blinkarrow.AddRequiredStat("agi", (int)Math.Floor(blinkarrow.RequiredLevel * 2.5d));
            blinkarrow.Enabled = false;
            skillTable.Add(HRK.BlinkArrow, blinkarrow);
            var tamer = new Skill(HRK.Tamer, "This skill allows you to tame a animal as your pet. Level 1 allows chicken, level 2 allows boar, level 3 allows stag, level 4 allows wolf, level 5 allows bear.", 50, 5);
            tamer.SkillpointsPerLevel = 5;
            tamer.Usage = "Type \"/pet \" to toggle taming. To tame get close to the animal and press your USE button(E). After tamed press USE looking at something, if its terrain he will move, if its a player or other animal it he will attack. If looking at him it will start following you. To set the pet free type \"/pet free\".";
            skillTable.Add(HRK.Tamer, tamer);
            return skillTable;
        }

        public static Dictionary<string, ItemInfo> GenerateItemTable()
        {
            var itemDict = new Dictionary<string, ItemInfo>();
            var itemsDefinition = ItemManager.GetItemDefinitions();
            foreach (var itemDefinition in itemsDefinition)
            {
                var newInfo = new ItemInfo {Shortname = itemDefinition.shortname, CanResearch = true, ItemId = itemDefinition.itemid, ItemCategory = itemDefinition.category.ToString()};
                var blueprint = ItemManager.FindBlueprint(itemDefinition);
                if (blueprint != null)
                    newInfo.BlueprintTime = blueprint.time;
                itemDict.Add(itemDefinition.displayName.translated.ToLower(), newInfo);
            }
            return itemDict;
        }

        public static Dictionary<string, int> GenerateResearchTable()
        {
            var researchTable = new Dictionary<string, int>
            {
                {"Tool", 1},
                {"Attire", 2},
                {"Construction", 3},
                {"Resources", 3},
                {"Medical", 4},
                {"Ammunition", 4},
                {"Weapon", 5}
            };
            return researchTable;
        }

        public static Dictionary<int, string> GenerateTameTable()
        {
            var tameTable = new Dictionary<int, string>
            {
                {1, HPK.CanTameChicken},
                {2, HPK.CanTameBoar},
                {3, HPK.CanTameStag},
                {4, HPK.CanTameWolf},
                {5, HPK.CanTameBear}
            };
            return tameTable;
        }

        public static Dictionary<BuildingGrade.Enum, float> GenerateUpgradeBuildingTable()
        {
            var upgradeBuildingTable = new Dictionary<BuildingGrade.Enum, float>();
            upgradeBuildingTable.Add(BuildingGrade.Enum.Twigs, 1f);
            upgradeBuildingTable.Add(BuildingGrade.Enum.Wood, 1.5f);
            upgradeBuildingTable.Add(BuildingGrade.Enum.Stone, 3f);
            upgradeBuildingTable.Add(BuildingGrade.Enum.Metal, 10f);
            upgradeBuildingTable.Add(BuildingGrade.Enum.TopTier, 3f);
            return upgradeBuildingTable;
        }

        public static Dictionary<string, float> GenerateMaxStatsTable()
        {
            var maxStatsTable = new Dictionary<string, float>();
            maxStatsTable.Add(HRK.StrBlockGain, 0.00095f);
            maxStatsTable.Add(HRK.AgiEvasionGain, 0.000625f);
            maxStatsTable.Add(HRK.IntCraftingReducer, 0.001f);
            return maxStatsTable;
        }
    }


    public class ItemInfo
    {
        public int ItemId { get; set; }
        public string Shortname { get; set; }
        public float BlueprintTime { get; set; }
        public bool CanResearch { get; set; }
        public string ItemCategory { get; set; }
    }

    public class PluginMessagesConfig
    {
        public Dictionary<string, List<string>> Messages { set; get; }
        public string ChatPrefix { set; get; }
        public string ChatPrefixColor { set; get; }

        public PluginMessagesConfig(string chatPrefix, string chatPrefixColor)
        {
            Messages = new Dictionary<string, List<string>>();
            ChatPrefix = chatPrefix;
            ChatPrefixColor = chatPrefixColor;
        }

        public void AddMessage(string key, string message)
        {
            if (Messages.ContainsKey(key))
                Messages[key].Add(message);
            else
                Messages.Add(key, new List<string> {message});
        }

        public void AddMessage(string key, List<string> message)
        {
            if (Messages.ContainsKey(key))
                Messages[key].AddRange(message);
            else
                Messages.Add(key, message);
        }

        public List<string> GetMessage(string key, string[] args = null)
        {
            var strings = new List<string>();
            if (!Messages.ContainsKey(key)) return strings;
            var messageList = Messages[key];
            strings.AddRange(messageList.Select(message => args == null ? message : string.Format(message, args)));
            return strings;
        }
    }

    public class ProfilePreferences
    {
        public ProfilePreferences()
        {
            ShowXPMessagePercent = 0.25f;
            ShowCraftMessage = true;
            UseBlinkArrow = true;
            AutoToggleBlinkArrow = true;
        }

        public float ShowXPMessagePercent { get; set; }
        public bool ShowCraftMessage { get; set; }
        public bool UseBlinkArrow { get; set; }
        public bool AutoToggleBlinkArrow { get; set; }
    }

    public static class RPGHelper
    {
        public static string SteamId(BasePlayer player)
        {
            return player.userID.ToString();
        }

        public static void SkillInfo(StringBuilder sb, Skill skill)
        {
            if (!skill.Enabled) return;
            sb.AppendLine(String.Format("{0} - Required Level: {1}", RPGHelper.WrapInColor(skill.Name, OC.LightBlue), skill.RequiredLevel));
            if (skill.SkillpointsPerLevel > 1)
                sb.AppendLine(String.Format("Each skill level costs {0} skillpoints",
                    skill.SkillpointsPerLevel));

            if (skill.RequiredStats.Count > 0)
            {
                StringBuilder sbs = new StringBuilder();
                foreach (var requiredStat in skill.RequiredStats)
                    sbs.Append(String.Format("{0}: {1} |", requiredStat.Key, requiredStat.Value));
                sb.AppendLine(String.Format("Required stats: {0}", sbs));
            }
            sb.AppendLine(String.Format("{0}", skill.Description));
            if (skill.Usage != null)
                sb.AppendLine(String.Format("{0}{1}",RPGHelper.WrapInColor("Usage: ", OC.Teal) ,skill.Usage));
            sb.AppendLine("-----------------");
        }

        public static string WrapInColor(string msg, string color=OC.Orange)
        {
            return String.Format("<color={1}>{0}</color>", msg, color);
        }

        public static float GetEvasion(RPGInfo rpgInfo, float pointMultiplier)
        {
            return rpgInfo.Agility * pointMultiplier;
        }

        public static float GetBlock(RPGInfo rpgInfo, float pointMultiplier)
        {
            return rpgInfo.Strength * pointMultiplier;
        }

        public static float GetCraftingReducer(RPGInfo rpgInfo, float pointMultiplier)
        {
            return rpgInfo.Intelligence * pointMultiplier;
        }

        public static string TimeLeft(float availableAt, float time)
        {
            var timeLeft = availableAt - time;
            var formatableTime = new DateTime(TimeSpan.FromSeconds(timeLeft).Ticks);
            var formatedTimeLeft = String.Format("{0:mm\\:ss}", formatableTime);
            return formatedTimeLeft;
        }

        public static bool IsSkillReady(Dictionary<string, float> playerCooldowns, ref float availableAt, float time, string skillKey)
        {
            bool isReady;
            if (playerCooldowns.ContainsKey(skillKey))
            {
                availableAt = playerCooldowns[skillKey];
                isReady = time >= availableAt;
            }
            else
            {
                isReady = true;
                playerCooldowns.Add(skillKey, availableAt);
            }
            return isReady;
        }

        public static string OvenId(BaseOven oven)
        {
            var position = oven.transform.position;
            return String.Format("X{0}Y{1}Z{2}", position.x, position.y, position.z);
        }
    }

    public class RPGInfo
    {
        public RPGInfo(string steamName)
        {
            SteamName = steamName;
            Level = 0;
            Skills = new Dictionary<string, int>();
            Preferences = new ProfilePreferences();
        }

        public bool AddExperience(long xp,long requiredXp)
        {
            Experience += xp;
            if (Experience < requiredXp) return false;
            if (Level == HK.MaxLevel) return false;
            Experience = Experience-requiredXp;
            LevelUp();
            return true;
        }

        public void Died()
        {
            var removedXP = (long)(Experience*HK.DeathReducer);
            Experience -= removedXP;
            if (Experience < 0)
                Experience = 0;
        }

        private void LevelUp()
        {
            Level++;
            Agility++;
            Strength++;
            Intelligence++;
            StatsPoints += 3;
            SkillPoints += 1;
        }

        public bool AddAgi(int points)
        {
            int absPoints = Math.Abs(points);
            if (StatsPoints < absPoints) return false;
            StatsPoints -= absPoints;
            Agility += absPoints;
            return true;
        }

        public bool AddStr(int points)
        {
            int absPoints = Math.Abs(points);
            if (StatsPoints < absPoints) return false;
            StatsPoints -= absPoints;
            Strength += absPoints;
            return true;
        }

        public bool AddInt(int points)
        {
            int absPoints = Math.Abs(points);
            if (StatsPoints < absPoints) return false;
            StatsPoints -= absPoints;
            Intelligence += absPoints;
            return true;
        }

        public int AddSkill(Skill skill, int points, out string reason)
        {
            int pointsToAdd = Math.Abs(points);
            var requiredPoints = pointsToAdd * skill.SkillpointsPerLevel;
            if (SkillPoints < requiredPoints)
            {
                reason = HMK.NotEnoughtPoints;
                return 0;
            }
            if (Level < skill.RequiredLevel)
            {
                reason = HMK.NotEnoughLevels;
                return 0;
            }
            foreach (var requiredStat in skill.RequiredStats)
            {
                switch (requiredStat.Key.ToLower())
                {
                    case "str":
                        if (Strength < requiredStat.Value)
                        {
                            reason = HMK.NotEnoughStrength;
                            return 0;
                        }
                    break;
                    case "agi":
                        if (Agility < requiredStat.Value)
                        {
                            reason = HMK.NotEnoughAgility;
                            return 0;
                        }
                    break;
                    case "int":
                        if (Intelligence < requiredStat.Value)
                        {
                            reason = HMK.NotEnoughIntelligence;
                            return 0;
                        }
                        break;
                }
            }
            if (Skills.ContainsKey(skill.Name))
            {
                int existingPoints = Skills[skill.Name];
                if (existingPoints + points > skill.MaxPoints)
                    pointsToAdd = skill.MaxPoints - existingPoints;
                if(pointsToAdd >  0)
                    Skills[skill.Name] += pointsToAdd;
            }
            else
            {
                if (points > skill.MaxPoints)
                    pointsToAdd = skill.MaxPoints;
                Skills.Add(skill.Name, pointsToAdd);
            }
            
            if (pointsToAdd <= 0)
            {
                reason = HMK.AlreadyAtMaxLevel;
                return 0;
            }
            reason = "";
            SkillPoints -= pointsToAdd * skill.SkillpointsPerLevel;
            return pointsToAdd;
        }

        public string SteamName { get; set; }
        public int Level { get; set; }
        public long Experience { get; set; }
        public int Agility { get; set; }
        public int Strength { get; set; }
        public int Intelligence { get; set; }
        public int StatsPoints { get; set; }
        public int SkillPoints { get; set; }
        public Dictionary<string,int> Skills { get; set; }

        public ProfilePreferences Preferences { get; set; }

    }

    public class Skill
    {
        public Skill(string name, string description, int requiredLevel, int maxPoints)
        {
            Name = name;
            Enabled = true;
            Description = description;
            RequiredLevel = requiredLevel;
            MaxPoints = maxPoints;
            RequiredSkills = new Dictionary<string, int>();
            Modifiers = new Dictionary<string, Modifier>();
            RequiredStats = new Dictionary<string, int>();
            SkillpointsPerLevel = 1;
        }

        public void AddRequiredStat(string stat, int points)
        {
            if(!RequiredStats.ContainsKey(stat))
                RequiredStats.Add(stat, points);
        }

        public void AddRequiredSkill(string skillName, int pointsNeeded)
        {
            if (!RequiredSkills.ContainsKey(skillName))
                RequiredSkills.Add(skillName, pointsNeeded);
        }

        public void AddModifier(string modifier, Modifier handler)
        {
            if (!Modifiers.ContainsKey(modifier))
                Modifiers.Add(modifier, handler);
        }

        public string Name { get; set; }
        public bool Enabled { get; set; }
        public string Description { get; set; }
        public string Usage { get; set; }
        public int RequiredLevel { get; set; }
        public int MaxPoints { get; set; }
        public Dictionary<string,int> RequiredSkills { get; set; }
        public Dictionary<string, Modifier> Modifiers { get; set;}
        public Dictionary<string,int> RequiredStats { get; set; }
        public int SkillpointsPerLevel { get; set; }
    }

    public class Modifier
    {
        public Modifier(string identifier, List<object> args)
        {
            Identifier = identifier;
            Args = args;
        }

        public string Identifier { get; set; }

        public List<object> Args { get; set; }
    }
 


    public class SkillMethods
    {
        const string IncorrectNumberOfParameters = "Incorrect number of parameters";

        public static int GatherModifier(int skillpoints, int levelmodule, int itemamount)
        {
            var baseMultiplier = (float)skillpoints / (float) levelmodule;
            baseMultiplier += 1;
            float newAmount = (float) (baseMultiplier * (float) itemamount);
            return (int)Math.Ceiling(newAmount);
        }
        
        public static float CooldownModifier(int skillpoints, int basecooldown, int levelmodule, float currenttime)
        {
            float baseCooldown = basecooldown* 60;
            float timeToReduce = ((skillpoints - 1) * levelmodule) * 60;
            float finalCooldown = baseCooldown - timeToReduce;
            return finalCooldown + currenttime;
        }
    }
}

namespace Hunt.RPG.Keys
{
    static class HK
    {
        public const string ConfigVersion = "VERSION";
        public const string DataVersion = "DATA_VERSION";
        public const string DataFileName = "Hunt_Data";
        public const string Profile = "PROFILE";
        public const string Furnaces = "FURNACES";
        public const string MessagesTable = "MESSAGESTABLE";
        public const string XPTable = "XPTABLE";
        public const string MaxStatsTable = "MAXSTATSTABLE";
        public const string SkillTable = "SKILLTABLE";
        public const string ItemTable = "ITEMTABLE";
        public const string ResearchSkillTable = "RESEARCHSKILLTABLE";
        public const string TameTable = "TAMETABLE";
        public const string UpgradeBuildTable = "UPGRADEBUILDTABLE";
        public const int MaxLevel = 200;
        public const int BaseXP = 383;
        public const float LevelMultiplier = 1.105f;
        public const int LevelModule = 10;
        public const float ModuleReducer = 0.005f;
        public const float DeathReducer = 0.05f;
    }
    static class HMK
    {
        public const string SkillDisabled = "skill_disabled";
        public const string ResearchBlocked = "research_blocked";
        public const string ProfilePreferences = "preferences";
        public const string Help = "help";
        public const string Shortcuts = "hunt_shortcuts";
        public const string DataUpdated = "data_updated";
        public const string AlreadyAtMaxLevel = "already_at_max_level";
        public const string SkillInfo = "skill_info";
        public const string NotEnoughIntelligence = "not_enought_int";
        public const string NotEnoughAgility = "not_enought_agi";
        public const string NotEnoughStrength = "not_enought_str";
        public const string NotEnoughLevels = "not_enought_levels";
        public const string About = "hunt_about";
        public const string SkillNotLearned = "skill_not_learner";
        public const string ItemNotFound = "item_not_found";
        public const string InvalidCommand = "invalid_command";
        public const string NotEnoughtPoints = "not_enought_points";
        public const string InvalidSkillName = "invalid_skill_name";
    }

    public static class HPK
    {
        public const string CanTame = "cannpc";
        public const string CanTameChicken = "canchicken";
        public const string CanTameBoar = "canboar";
        public const string CanTameStag = "canstag";
        public const string CanTameWolf = "canwolf";
        public const string CanTameBear = "canbear";
    }
    static class HRK
    {
        public const string Tamer = "tamer";
        public const string BlinkArrow = "blinkarrow";
        public const string Blacksmith = "blacksmith";
        public const string Researcher = "researcher";
        public const string LumberJack = "lumberjack";
        public const string Miner = "miner";
        public const string Hunter = "hunter";
        public const string GatherModifier = "gather";
        public const string CooldownModifier = "cooldown";
        public const string IntCraftingReducer = "int_crafting_reducer_percent";
        public const string AgiEvasionGain = "agi_evasion_percent_gain";
        public const string StrBlockGain = "str_block_percent_gain";
    }
    public static class OC
    {
        public const string Aqua = "aqua";
        public const string Black = "black";
        public const string Blue = "blue";
        public const string Brown = "brown";
        public const string Cyan = "cyan";
        public const string DarkBlue = "darkblue";
        public const string Magenta = "magenta";
        public const string Green = "green";
        public const string LightBlue = "lightblue";
        public const string Maroon = "maroon";
        public const string Navy = "navy";
        public const string Olive = "olive";
        public const string Orange = "orange";
        public const string Purple = "purple";
        public const string Red = "red";
        public const string Teal = "teal";
        public const string Yellow = "yellow";
    }
}


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\IndestructableBuildings.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System;
using System.Collections.Generic;

using Rust;

namespace Oxide.Plugins
{

    [Info("Indestructable Buildings", "Mughisi", "1.0.1", ResourceId=966)]
    class IndestructableBuildings : RustPlugin
    {

        #region Configuration Data

        bool configChanged;

        // Plugin settings
        string defaultChatPrefix = "Protector";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultProtectFoundations = true;
        bool defaultProtectAllBuildingBlocks = true;
        bool defaultInformPlayer = true;
        float defaultInformInterval = 30;

        bool protectFoundations;
        bool protectAllBuildingBlocks;
        bool informPlayer;
        float informInterval;

        // Messages
        string defaultHelpText = "Damage to {0} has been disabled.";
        string defaultInformMessage = "You cannot deal damage to {0}!";

        string helpText;
        string informMessage;

        #endregion

        class OnlinePlayer
        {
            public BasePlayer Player;
            public float LastInformTime;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        [OnlinePlayers] Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();
        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        protected override void LoadDefaultConfig()
        {
            Log("Created a new default configuration file.");
            Config.Clear();
            LoadVariables();
        }

        void Loaded()
        {
            LoadVariables();

            // Save config changes when required
            if (configChanged)
            {
                Log("The configuration file was updated.");
                SaveConfig();
            }
        }

        void LoadVariables()
        {
            // Settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Options
            protectFoundations = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectFoundations", defaultProtectFoundations)));
            protectAllBuildingBlocks = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectAllBuildingBlocks", defaultProtectAllBuildingBlocks)));
            informPlayer = bool.Parse(Convert.ToString(GetConfigValue("Options", "StickyGrenades", defaultInformPlayer)));
            informInterval = float.Parse(Convert.ToString(GetConfigValue("Options", "InformInterval", defaultInformInterval)));

            // Messages
            helpText = Convert.ToString(GetConfigValue("Messages", "HelpText", defaultHelpText));
            informMessage = Convert.ToString(GetConfigValue("Messages", "InformMessage", defaultInformMessage));
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var block = entity as BuildingBlock;
            if (!block) return;
            if (((block.blockDefinition.hierachyName == "foundation" || block.blockDefinition.hierachyName == "foundation.triangle") && protectFoundations) || protectAllBuildingBlocks)
                info.damageTypes = new DamageTypeList();

            if (info.damageTypes.Total() != 0f) return;

            var player = info.Initiator as BasePlayer;
            if (player && informPlayer && onlinePlayers[player].LastInformTime + informInterval < GetTimestamp())
            {
                onlinePlayers[player].LastInformTime = GetTimestamp();
                SendChatMessage(player, informMessage, (protectAllBuildingBlocks ? "buildings" : "foundations"));
            }
        }

        void OnPlayerInit(BasePlayer player) 
            => onlinePlayers[player].LastInformTime = 0f;

        void SendHelpText(BasePlayer player)
        {
            if (!protectFoundations && !protectAllBuildingBlocks) return;
            SendChatMessage(player, helpText, (protectAllBuildingBlocks ? "buildings" : "foundations"));
        }

        #region Helper Methods

        void Log(string message) 
            => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, params object[] arguments) 
            => PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}", arguments);
        
        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }
        private long GetTimestamp()
            => Convert.ToInt64((System.DateTime.UtcNow.Subtract(epoch)).TotalSeconds);

        #endregion

    }

}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\InventoryCleaner.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("Admin Inventory Cleaner", "TheDoc - Uprising Servers", "1.0.0")]
    class InventoryCleaner : RustPlugin
    {
        [ChatCommand("cleaninv")]
        void cmdChatCleanInv(BasePlayer player, string command, string[] args)
        {
            player.inventory.Strip();
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\InventoryViewer.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("Inventory Viewer", "Mughisi", "1.0.0")]
    class InventoryViewer : RustPlugin
    {

        #region Configuration Data
        // Do not modify these values, to configure this plugin edit
        // 'InventoryViewer.json' in your server's config folder.
        // <drive>:\...\server\<server identity>\oxide\config\

        bool configChanged;
        bool configCreated;

        // Plugin settings
        string defaultChatPrefix = "Inspector";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultAllowAdmin = true;
        bool defaultAllowModerator = false;

        bool allowAdmin;
        bool allowModerator;

        // Plugin messages
        string defaultNotAllowed = "You are not allowed to use this command.";
        string defaultNoPlayersFound = "Couldn't find any players matching that name.";
        string defaultMultiplePlayersFound = "Multiple players found with that name. Select one of these players by using '/viewinv list <number>':";
        string defaultInvalidSelection = "Invalid number, use the number in front of the player's name. Use /viewinv list to check the list again";
        string defaultInvalidArguments = "Invalid arguments! Use '/viewinv <name>' or '/viewinv list <number>'";
        string defaultNoListAvailable = "You don't have a player list available, use '/viewin <name>' instead.";
        string defaultTargetDied = "The player you were looting died.";

        string notAllowed;
        string noPlayersFound;
        string multiplePlayersFound;
        string invalidSelection;
        string invalidArguments;
        string noListAvailable;
        string targetDied;

        #endregion

        class OnlinePlayer
        {
            public BasePlayer Player;
            public BasePlayer Target;
            public LootableCorpse View;
            public List<BasePlayer> Matches;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        [OnlinePlayers]
        Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();

        void Loaded() => LoadConfigValues();

        protected override void LoadDefaultConfig()
        {
            configCreated = true;
            Log("New configuration file created.");
        }

        void Unloaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (onlinePlayers[player].View != null)
                    CloseInventoryView(player, onlinePlayers[player].View);
            }
        }

        void OnTick()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (onlinePlayers[player].View != null)
                {
                    if (!player.inventory.loot.IsLooting())
                    {
                        CloseInventoryView(player, onlinePlayers[player].View);
                        return;
                    }

                    if (player.inventory.loot.containers[0].playerOwner.IsDead())
                    {
                        SendChatMessage(player, targetDied);
                        CloseInventoryView(player, onlinePlayers[player].View);
                        return;
                    }

                    player.inventory.loot.SendImmediate();
                    onlinePlayers[player].View.ClientRPC(null, player, "RPC_ClientLootCorpse", new object[0]);
                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (onlinePlayers[player].View != null)
                {
                    if (player != entity as BasePlayer && onlinePlayers[player].View != entity as LootableCorpse) return;
                    info.damageTypes = new DamageTypeList();
                    info.HitMaterial = 0;
                    info.PointStart = Vector3.zero;
                }
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            onlinePlayers[player].View = null;
            onlinePlayers[player].Target = null;
            onlinePlayers[player].Matches = null;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (onlinePlayers[player].View != null)
                CloseInventoryView(player, onlinePlayers[player].View);
        }

        void LoadConfigValues()
        {
            // Plugin settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Plugin options
            allowAdmin = Convert.ToBoolean(GetConfigValue("Options", "AllowAdmins", defaultAllowAdmin));
            allowModerator = Convert.ToBoolean(GetConfigValue("Options", "AllowModerators", defaultAllowModerator));

            // Plugin messages
            notAllowed = Convert.ToString(GetConfigValue("Messages", "NotAllowed", defaultNotAllowed));
            noPlayersFound = Convert.ToString(GetConfigValue("Messages", "NoPlayersFound", defaultNoPlayersFound));
            multiplePlayersFound = Convert.ToString(GetConfigValue("Messages", "MultiplePlayersFound", defaultMultiplePlayersFound));
            invalidSelection = Convert.ToString(GetConfigValue("Messages", "InvalidSelection", defaultInvalidSelection));
            invalidArguments = Convert.ToString(GetConfigValue("Messages", "InvalidArguments", defaultInvalidArguments));
            noListAvailable = Convert.ToString(GetConfigValue("Messages", "NoListAvailable", defaultNoListAvailable));
            targetDied = Convert.ToString(GetConfigValue("Messages", "TargetDied", defaultTargetDied));

            if (configChanged && !configCreated)
            {
                Log("Configuration file updated.");
                SaveConfig();
            }
        }

        [ChatCommand("viewinv")]
        void ViewInventory(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player)) return;

            if (args.Length < 1)
            {
                SendChatMessage(player, invalidArguments);
                return;
            }

            var name = args[0];
            var ply = onlinePlayers[player];
            if (name == "list")
            {
                if (ply.Matches == null)
                {
                    SendChatMessage(player, noListAvailable);
                    return;
                }
                if (args.Length == 1)
                {
                    ShowMatchingPlayers(player);
                    return;
                }
                int index;
                if (!int.TryParse(args[1], out index))
                {
                    SendChatMessage(player, invalidSelection);
                    return;
                }

                if (index > ply.Matches.Count)
                    SendChatMessage(player, invalidSelection);
                else
                    InspectInventory(player, ply.Matches[index - 1]);

                return;
            }

            var matches = FindPlayersByName(name);
            if (matches.Count < 1)
            {
                SendChatMessage(player, noPlayersFound);
                return;
            }
            if (matches.Count > 1)
            {
                ply.Matches = matches;
                ShowMatchingPlayers(player);
                return;
            }

            InspectInventory(player, matches[0]);
        }

        void InspectInventory(BasePlayer player, BasePlayer target)
        {
            var ply = onlinePlayers[player];
            if (ply.View == null)
            {
                OpenInventoryView(player, target);
                return;
            }

            CloseInventoryView(player, ply.View);
            timer.In(1f, () => OpenInventoryView(player, target));
        }

        void OpenInventoryView(BasePlayer player, BasePlayer target)
        {
            var pos = new Vector3(player.transform.position.x, player.transform.position.y, player.transform.position.z);
            var corpse = GameManager.server.CreateEntity("player/player_corpse") as BaseCorpse;
            corpse.parentEnt = null;
            corpse.transform.position = pos;
            corpse.CancelInvoke("RemoveCorpse");

            if (!corpse) return;

            var view = corpse as LootableCorpse;
            ItemContainer[] source = new ItemContainer[] { target.inventory.containerMain, target.inventory.containerWear, target.inventory.containerBelt };
            view.containers = new ItemContainer[source.Length];
            for (int i = 0; i < source.Length; i++)
                view.containers[i] = source[i];
            view.playerName = $"Inventory viewer: {target.displayName}";
            view.playerSteamID = target.userID;
            view.enableSaving = false;
            view.Spawn(true);
            player.inventory.loot.StartLootingEntity(view, false);
            for (int i = 0; i < source.Length; i++)
                view.containers[i] = source[i];
            view.SetFlag(BaseEntity.Flags.Open, true);
            foreach (var container in view.containers)
                player.inventory.loot.containers.Add(container);
            player.inventory.loot.SendImmediate();
            view.ClientRPC(null, player, "RPC_ClientLootCorpse", new object[0]);
            player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            onlinePlayers[player].View = view;
            onlinePlayers[player].Target = target;
        }

        void CloseInventoryView(BasePlayer player, LootableCorpse view)
        {
            if (onlinePlayers[player].View == null) return;

            for (int i = 0; i < view.containers.Length; i++)
                view.containers[i] = new ItemContainer();

            if (player.inventory.loot.IsLooting())
                player.SendConsoleCommand("inventory.endloot", null);

            onlinePlayers[player].View = null;
            onlinePlayers[player].Target = null;

            view.KillMessage();
        }

        List<BasePlayer> FindPlayersByName(string name)
        {
            List<BasePlayer> matches = new List<BasePlayer>();

            foreach (var ply in BasePlayer.activePlayerList)
            {
                if (ply.displayName.ToLower().Contains(name.ToLower()))
                    matches.Add(ply);
            }

            foreach (var ply in BasePlayer.sleepingPlayerList)
            {
                if (ply.displayName.ToLower().Contains(name.ToLower()))
                    matches.Add(ply);
            }

            return matches;
        }

        void ShowMatchingPlayers(BasePlayer player)
        {
            int i = 0;
            SendChatMessage(player, multiplePlayersFound);
            foreach (var ply in onlinePlayers[player].Matches)
            {
                i++;
                SendChatMessage(player, $"{i} - {ply.displayName} ({ply.userID})");
            }
        }

        bool IsAllowed(BasePlayer player)
        {
            var authLevel = player.net.connection.authLevel;
            if (authLevel == 1 && allowModerator) return true;
            if (authLevel == 2 && allowAdmin) return true;
            SendChatMessage(player, notAllowed);
            return false;
        }

        #region Helper methods

        void Log(string message) =>
            Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, string arguments = null) =>
            PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}");

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }
            return value;
        }

        #endregion

    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\ItemConfig.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Rust;

using UnityEngine;

using System;
using System.IO;

using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

using JSONObject = JSON.Object;
using JSONArray = JSON.Array;
using JSONValue = JSON.Value;
using JSONValueType = JSON.ValueType;

namespace Oxide.Plugins
{
    [Info("ItemConfig", "Nogrod", "1.0.9", ResourceId = 806)]
    class ItemConfig : RustPlugin
    {
        //private static readonly FieldInfo ComponentList = typeof(Construction.Library).GetField("componentList", BindingFlags.NonPublic | BindingFlags.Static);

        private string _configpath = "";

        void Loaded()
        {
            _configpath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
        }

        void LoadDefaultConfig()
        {

        }

        private static JSONObject ToJsonObject(object obj)
        {
            return JSONObject.Parse(ToJsonString(obj));
        }

        private static JSONArray ToJsonArray(object obj)
        {
            return JSONArray.Parse(ToJsonString(obj));
        }

        private static string ToJsonString(object obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings
                {
                    ContractResolver = new DynamicContractResolver(),
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                    Converters = new List<JsonConverter> { new Newtonsoft.Json.Converters.StringEnumConverter() }
                });
        }

        private static void StripObject(JSONObject obj)
        {
            if (obj == null) return;
            var keys = obj.Select(entry => entry.Key).ToList();
            foreach (var key in keys)
            {
                if (!key.Equals("shortname") && !key.Equals("itemid"))
                    obj.Remove(key);
            }
        }

        private static void StripArray(JSONArray arr, string key)
        {
            if (arr == null) return;
            foreach (var obj in arr)
            {
                StripObject(obj.Obj[key].Obj);
            }
        }

        private bool CreateDefaultConfig()
        {
            Config.Clear();
            Config["Version"] = Protocol.network;
            var itemList = Resources.LoadAll<ItemDefinition>("items/").ToList();
            var bpList = Resources.LoadAll<ItemBlueprint>("items/").ToList();
            var items = new JSONArray();
            foreach (var definition in itemList)
            {
                var obj = ToJsonObject(definition);
                var mods = definition.GetComponentsInChildren<ItemMod>(true);
                var modArray = new JSONArray();
                foreach (var itemMod in mods)
                {
                    if (itemMod.GetType() == typeof (ItemModMenuOption)) continue;
                    var mod = ToJsonObject(itemMod);
                    if (itemMod.GetType() == typeof(ItemModBurnable))
                    {
                        StripObject(mod["byproductItem"].Obj);
                    }
                    else if (itemMod.GetType() == typeof(ItemModCookable))
                    {
                        StripObject(mod["becomeOnCooked"].Obj);
                    }
                    else if (itemMod.GetType() == typeof(ItemModConsume))
                    {
                        mod["effects"] = ToJsonArray(itemMod.GetComponent<ItemModConsumable>().effects);
                    }
                    else if (itemMod.GetType() == typeof(ItemModSwap))
                    {
                        var becomeItems = mod["becomeItem"].Array;
                        foreach (var entry in becomeItems)
                        {
                            entry.Obj["itemDef"] = entry.Obj.GetObject("itemDef").GetString("shortname", "unnamed");
                        }
                    }
                    if (!mod.Any()) continue;
                    mod["type"] = itemMod.GetType().FullName;
                    modArray.Add(mod);
                }
                var modProjectile = definition.GetComponent<ItemModProjectile>();
                if (modProjectile != null)
                {
                    var projectile = modProjectile.projectileObject.targetObject.GetComponent<Projectile>();
                    var mod = ToJsonObject(projectile);
                    mod.Remove("sourceWeapon");
                    mod.Remove("projectileID");
                    mod.Remove("seed");
                    mod.Remove("velocityScalar");
                    mod["type"] = modProjectile.GetType().FullName;
                    modArray.Add(mod);
                }
                obj["modules"] = modArray;

                items.Add(obj);
            }
            Config["Items"] = JsonObjectToObject(items);
            var bps = ToJsonArray(bpList);
            foreach (var bp in bps)
            {
                StripObject(bp.Obj["targetItem"].Obj);
                foreach (var ing in bp.Obj.GetArray("ingredients"))
                {
                    ing.Obj["itemDef"] = ing.Obj.GetObject("itemDef").GetString("shortname", "unnamed");
                }
            }
            Config["Blueprints"] = JsonObjectToObject(bps);
            /*var constructions = new Dictionary<string, object>();
            Config["Constructions"] = constructions;
            var protectionProperties = new HashSet<ProtectionProperties>();
            var constructionSkinArray = Resources.LoadAll<ConstructionSkin>("Prefabs/build/skins");
            var constructionArray = Resources.LoadAll<Construction>("Prefabs/build/");
            foreach (var construct in constructionArray)
            {
                var common = new Construction.Common(construct, constructionSkinArray);
                var construction = new Dictionary<string, object>();
                var grades = new Dictionary<string, object>();
                for (var g = 0; g < common.grades.Length; g++)
                {
                    var grade = common.grades[g];
                    if (grade == null) continue;
                    var dict = new Dictionary<string, object>();
                    dict["maxHealth"] = grade.maxHealth;
                    var costToBuild = ToJsonArray(grade.costToBuild);
                    foreach (var cost in costToBuild)
                    {
                        cost.Obj["itemDef"] = cost.Obj.GetObject("itemDef").GetString("shortname", "unnamed");
                    }
                    dict["costToBuild"] = JsonObjectToObject(costToBuild);
                    if (grade.damageProtecton != null)
                    {
                        protectionProperties.Add(grade.damageProtecton);
                    }
                    grades[((BuildingGrade.Enum)g).ToString()] = dict;
                }
                construction["grades"] = grades;
                constructions[common.name] = construction;
            }
            var protections = new Dictionary<string, object>();
            Config["DamageProtections"] = protections;
            foreach (var protectionProperty in protectionProperties)
            {
                var damageProtection = new Dictionary<string, object>();
                for (var i = 0; i < protectionProperty.amounts.Length; i++)
                {
                    damageProtection[Enum.GetName(typeof(DamageType), i)] = protectionProperty.amounts[i];
                }
                protections[protectionProperty.name] = damageProtection;
            }*/
            try
            {
                Config.Save(_configpath);
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            LocalPuts("Created new config");
            return LoadConfig();
        }

        private bool LoadConfig()
        {
            try
            {
                Config.Load(_configpath);
            }
            catch (FileNotFoundException)
            {
                return CreateDefaultConfig();
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            return true;
        }

        private void CheckConfig()
        {
            if (Config["Version"] != null && (int) Config["Version"] == Protocol.network) return;
            LocalPuts("Incorrect config version(" + Config["Version"] + ") move to .old");
            Config.Save(string.Format("{0}.old", _configpath));
            CreateDefaultConfig();
        }

        void OnServerInitialized()
        {
            if (!LoadConfig())
                return;
            CheckConfig();
            UpdateItems();
            UpdateBlueprints();
            //UpdateConstructions();
        }

        private void UpdateItems()
        {
            var items = Config["Items"] as List<object>;
            if (items == null)
            {
                LocalPuts("No items in config");
                return;
            }
            var manager = SingletonComponent<ItemManager>.Instance;
            foreach (var item in items)
            {
                var value = ObjectToJsonObject(item);
                if (value.Type != JSONValueType.Object)
                {
                    LocalPuts("Item is not object");
                    continue;
                }
                var obj = value.Obj;
                var itemid = obj.GetInt("itemid", 0);
                var definition = manager.itemList.Find(x => x.itemid == itemid);
                if (definition == null)
                {
                    LocalPuts("Item does not exist: " + obj.GetString("shortname", "") + "(" + itemid + ")");
                    continue;
                }
                UpdateItem(definition, obj);
            }
        }

        private void UpdateBlueprints()
        {
            var bps = Config["Blueprints"] as List<object>;
            if (bps == null)
            {
                LocalPuts("No blueprints in config");
                return;
            }
            var manager = SingletonComponent<ItemManager>.Instance;
            foreach (var blueprint in bps)
            {
                var value = ObjectToJsonObject(blueprint);
                if (value.Type != JSONValueType.Object)
                {
                    LocalPuts("Item is not object");
                    continue;
                }
                var obj = value.Obj;
                var itemid = obj.GetObject("targetItem").GetInt("itemid", 0);
                var bp = manager.bpList.Find(x => x.targetItem.itemid == itemid);
                if (bp == null)
                {
                    LocalPuts("Blueprint does not exist: " + obj.GetObject("targetItem").GetString("shortname", "") + "(" + itemid + ")");
                    continue;
                }
                UpdateBlueprint(bp, obj);
            }
            manager.defaultBlueprints = manager.bpList.Where(x => x.defaultBlueprint).Select(x => x.targetItem.itemid).ToArray();
        }

        private static void UpdateBlueprint(ItemBlueprint bp, JSONObject o)
        {
            bp.rarity = (Rarity)Enum.Parse(typeof(Rarity), o.GetString("rarity", "None"));
            bp.time = o.GetInt("time", 0);
            bp.amountToCreate = o.GetInt("amountToCreate", 1);
            bp.userCraftable = o.GetBoolean("userCraftable", true);
            bp.defaultBlueprint = o.GetBoolean("defaultBlueprint", false);
            var ingredients = o.GetArray("ingredients");
            var manager = SingletonComponent<ItemManager>.Instance;
            bp.ingredients.Clear();
            foreach (var ingredient in ingredients)
            {
                var itemid = ingredient.Obj.GetInt("itemid", 0);
                var definition = manager.itemList.Find(x => x.itemid == itemid);
                bp.ingredients.Add(new ItemAmount(definition, ingredient.Obj.GetFloat("amount", 0)));
            }
        }

        /*private void UpdateConstructions()
        {
            var constructions = Config["Constructions"] as Dictionary<string, object>;
            if (constructions == null)
            {
                LocalPuts("No constructions in config");
                return;
            }
            var componentList = (List<Construction.Common>) ComponentList.GetValue(null);
            var protectionProperties = new HashSet<ProtectionProperties>();
            var manager = SingletonComponent<ItemManager>.Instance;
            foreach (var common in componentList)
            {
                var construction = ObjectToJsonObject(constructions[common.name]);
                var grades = construction.Obj.GetObject("grades");
                for (var g = 0; g < common.grades.Length; g++)
                {
                    var gradeType = (BuildingGrade.Enum) g;
                    if (!grades.ContainsKey(gradeType.ToString()))
                    {
                        common.grades[g] = null;
                        continue;
                    }
                    if (common.grades[g] == null) common.grades[g] = new Construction.Grade();
                    var grade = common.grades[g];
                    var newGrade = grades.GetObject(gradeType.ToString());
                    UpdateConstructionHealth(grade, newGrade.GetFloat("maxHealth", 0));
                    grade.costToBuild.Clear();
                    var costToBuild = newGrade.GetArray("costToBuild");
                    foreach (var cost in costToBuild)
                    {
                        var itemid = cost.Obj.GetInt("itemid", 0);
                        var definition = manager.itemList.Find(x => x.itemid == itemid);
                        grade.costToBuild.Add(new ItemAmount(definition, cost.Obj.GetFloat("amount", 0)));
                    }
                    if (grade.damageProtecton != null)
                    {
                        protectionProperties.Add(grade.damageProtecton);
                    }
                }
            }
            var protections = Config["DamageProtections"] as Dictionary<string, object>;
            if (protections == null)
                return;
            foreach (var protectionProperty in protectionProperties)
            {
                protectionProperty.Clear();
                var damageProtection = protections[protectionProperty.name] as Dictionary<string, object>;
                if (damageProtection == null) continue;
                foreach (var o in damageProtection)
                {
                    protectionProperty.Add((DamageType) Enum.Parse(typeof (DamageType), o.Key), (float)Convert.ToDouble(o.Value));
                }
            }
        }

        private void UpdateConstructionHealth(Construction.Grade grade, float newHealth)
        {
            if (grade.maxHealth == newHealth) return;
            grade.maxHealth = newHealth;
            var bb = UnityEngine.Object.FindObjectsOfType<BuildingBlock>().Where(b => b.currentGrade == grade);
            foreach (var buildingBlock in bb)
            {
                buildingBlock.SetHealthToMax();
            }
        }*/

        private static void UpdateItem(ItemDefinition definition, JSONObject item)
        {
            definition.shortname = item.GetString("shortname", "unnamed");
            definition.itemid = item.GetInt("itemid", 0);
            definition.stackable = item.GetInt("stackable", 1);
            definition.category = (ItemCategory)Enum.Parse(typeof(ItemCategory), item.GetString("category", "Weapon"));
            var condition = item.GetObject("condition");
            definition.condition.enabled = condition.GetBoolean("enabled", false);
            definition.condition.max = condition.GetInt("max", 0);
            definition.condition.repairable = condition.GetBoolean("repairable", false);
            definition.rarity = (Rarity)Enum.Parse(typeof(Rarity), item.GetString("rarity", "None"));
            var modules = item.GetArray("modules").Select(m => m.Obj);
            var cook = 0;
            foreach (var mod in modules)
            {
                var typeName = mod.GetString("type", "");
                if (typeName.Equals("ItemModConsume"))
                {
                    var itemMod = definition.GetComponent<ItemModConsume>();
                    var itemEffects = itemMod.GetComponent<ItemModConsumable>().effects;
                    var effects = mod.GetArray("effects");
                    itemEffects.Clear();
                    foreach (var effect in effects)
                    {
                        itemEffects.Add(new ItemModConsumable.ConsumableEffect
                        {
                            type = (MetabolismAttribute.Type)Enum.Parse(typeof (MetabolismAttribute.Type), effect.Obj.GetString("type", "")),
                            amount = effect.Obj.GetFloat("amount", 0),
                            time = effect.Obj.GetFloat("time", 0)
                        });
                    }
                } 
                else if (typeName.Equals("ItemModContainer"))
                {
                    var itemMod = definition.GetComponent<ItemModContainer>();
                    itemMod.capacity = mod.GetInt("capacity", 6);
                    itemMod.openInDeployed = mod.GetBoolean("openInDeployed", true);
                    itemMod.openInInventory = mod.GetBoolean("openInInventory", true);
                    itemMod.defaultContents.Clear();
                    var defaultContents = mod.GetArray("defaultContents");
                    var manager = SingletonComponent<ItemManager>.Instance;
                    foreach (var content in defaultContents)
                    {
                        var itemid = content.Obj.GetInt("itemid", 0);
                        var def = manager.itemList.Find(x => x.itemid == itemid);
                        itemMod.defaultContents.Add(new ItemAmount(def, content.Obj.GetFloat("amount", 0)));
                    }
                }
                else if (typeName.Equals("ItemModBurnable"))
                {
                    //definition.gameObject.AddComponent<ItemModBurnable>();
                    var itemMod = definition.GetComponent<ItemModBurnable>();
                    itemMod.fuelAmount = mod.GetFloat("fuelAmount", 10f);
                    itemMod.byproductAmount = mod.GetInt("byproductAmount", 1);
                    itemMod.byproductChance = mod.GetFloat("byproductChance", 0.5f);
                    var manager = SingletonComponent<ItemManager>.Instance;
                    var itemid = mod.GetObject("byproductItem").GetInt("itemid", 0);
                    itemMod.byproductItem = manager.itemList.Find(x => x.itemid == itemid);
                }
                else if (typeName.Equals("ItemModCookable"))
                {
                    var itemMods = definition.GetComponents<ItemModCookable>();
                    var itemMod = itemMods[cook++];
                    itemMod.cookTime = mod.GetFloat("cookTime", 30f);
                    itemMod.amountOfBecome = mod.GetInt("amountOfBecome", 1);
                    itemMod.lowTemp = mod.GetInt("lowTemp", 0);
                    itemMod.highTemp = mod.GetInt("highTemp", 0);
                    itemMod.setCookingFlag = mod.GetBoolean("setCookingFlag", false);
                    var become = mod.GetObject("becomeOnCooked");
                    if (become == null)
                    {
                        itemMod.becomeOnCooked = null;
                        continue;
                    }
                    var manager = SingletonComponent<ItemManager>.Instance;
                    var itemid = become.GetInt("itemid", 0);
                    itemMod.becomeOnCooked = manager.itemList.Find(x => x.itemid == itemid);
                }
                else if (typeName.Equals("ItemModSwap"))
                {
                    var itemMod = definition.GetComponent<ItemModSwap>();
                    itemMod.sendPlayerDropNotification = mod.GetBoolean("sendPlayerDropNotification", false);
                    itemMod.sendPlayerPickupNotification = mod.GetBoolean("sendPlayerPickupNotification", false);
                    var items = new List<ItemAmount>();
                    var becomeItems = mod.GetArray("becomeItem");
                    var manager = SingletonComponent<ItemManager>.Instance;
                    foreach (var content in becomeItems)
                    {
                        var itemid = content.Obj.GetInt("itemid", 0);
                        var def = manager.itemList.Find(x => x.itemid == itemid);
                        items.Add(new ItemAmount(def, content.Obj.GetFloat("amount", 0)));
                    }
                    itemMod.becomeItem = items.ToArray();
                }
                else if (typeName.Equals("ItemModProjectile"))
                {
                    var itemMod = definition.GetComponent<ItemModProjectile>();
                    var projectile = itemMod.projectileObject.targetObject.GetComponent<Projectile>();
                    projectile.drag = mod.GetFloat("drag", 0);
                    projectile.thickness = mod.GetFloat("thickness", 0);
                    projectile.remainInWorld = mod.GetBoolean("remainInWorld", false);
                    projectile.stickProbability = mod.GetFloat("stickProbability", 0);
                    projectile.breakProbability = mod.GetFloat("breakProbability", 0);
                    projectile.ricochetChance = mod.GetFloat("ricochetChance", 0);
                    projectile.fullDamageVelocity = mod.GetFloat("fullDamageVelocity", 200);
                    projectile.damageTypes.Clear();
                    var damageTypes = mod.GetArray("damageTypes");
                    foreach (var damageType in damageTypes)
                    {
                        projectile.damageTypes.Add(new DamageTypeEntry
                        {
                            amount = damageType.Obj.GetFloat("amount", 0),
                            type = (DamageType) Enum.Parse(typeof (DamageType), damageType.Obj.GetString("type", ""))
                        });
                    }
                }
            }
        }

        private JSONValue ObjectToJsonObject(object obj)
        {
            if (obj == null)
            {
                return new JSONValue(JSONValueType.Null);
            }
            if (obj is string)
            {
                return new JSONValue((string) obj);
            }
            if (obj is double)
            {
                return new JSONValue((double) obj);
            }
            if (obj is int)
            {
                return new JSONValue((int)obj);
            }
            if (obj is bool)
            {
                return new JSONValue((bool)obj);
            }
            var dict = obj as Dictionary<string, object>;
            if (dict != null)
            {
                var newObj = new JSONObject();
                foreach (var prop in dict)
                {
                    newObj.Add(prop.Key, ObjectToJsonObject(prop.Value));
                }
                return newObj;
            }
            var list = obj as List<object>;
            if (list != null)
            {
                var arr = new JSONArray();
                foreach (var o in list)
                {
                    arr.Add(ObjectToJsonObject(o));
                }
                return arr;
            }
            LocalPuts("Unknown: " + obj.GetType().FullName + " Value: " + obj);
            return new JSONValue(JSONValueType.Null);
        }

        private object JsonObjectToObject(JSONValue obj)
        {
            switch (obj.Type)
            {
                case JSONValueType.String:
                    return obj.Str;
                case JSONValueType.Number:
                    return obj.Number;
                case JSONValueType.Boolean:
                    return obj.Boolean;
                case JSONValueType.Null:
                    return null;
                case JSONValueType.Array:
                    return obj.Array.Select(v => JsonObjectToObject(v.Obj)).ToList();
                case JSONValueType.Object:
                    var dict = new Dictionary<string, object>();
                    foreach (var prop in obj.Obj)
                    {
                        dict[prop.Key] = JsonObjectToObject(prop.Value);                        
                    }
                    return dict;
                default:
                    LocalPuts("Missing type: " + obj.Type);
                    break;
            }
            return null;
        }

        private void LocalPuts(string msg)
        {
            Puts("{0}: {1}", Title, msg);
        }

        [ConsoleCommand("item.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            if (!LoadConfig())
                return;
            CheckConfig();
            UpdateItems();
            UpdateBlueprints();
            //UpdateConstructions();
            LocalPuts("Item config reloaded.");
        }

        [ConsoleCommand("item.reset")]
        void cmdConsoleReset(ConsoleSystem.Arg arg)
        {
            if (!CreateDefaultConfig())
                return;
            UpdateItems();
            UpdateBlueprints();
            //UpdateConstructions();
        }

        class DynamicContractResolver : DefaultContractResolver
        {
            private static bool IsAllowed(JsonProperty property)
            {
                return property.PropertyType.IsPrimitive || property.PropertyType == typeof(List<ItemAmount>) ||
                             property.PropertyType == typeof(ItemAmount[]) ||
                             property.PropertyType == typeof(List<DamageTypeEntry>) ||
                             property.PropertyType == typeof(DamageType) ||
                             property.PropertyType == typeof(List<ItemModConsumable.ConsumableEffect>) ||
                             property.PropertyType == typeof(MetabolismAttribute.Type) ||
                             property.PropertyType == typeof(Rarity) ||
                             property.PropertyType == typeof(Translate.Phrase) ||
                             property.PropertyType == typeof(ItemCategory) ||
                             property.PropertyType == typeof(ItemDefinition) ||
                             property.PropertyType == typeof(ItemDefinition.Condition) ||
                             property.PropertyType == typeof(String);
            }

            protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
            {
                var properties = base.CreateProperties(type, memberSerialization);
                return properties.Where(p => p.DeclaringType == type && IsAllowed(p)).ToList();
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Jail.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("Jail", "Reneb", "2.0.1")]
    class Jail : RustPlugin
    {
        [PluginReference] Plugin ZoneManager;

        [PluginReference] Plugin spawns;

        ////////////////////////////////////////////
        /// FIELDS
        ////////////////////////////////////////////
        StoredData storedData;
        static Hash<string, JailInmate> jailinmates = new Hash<string, JailInmate>();
        public DateTime epoch = new System.DateTime(1970, 1, 1);
        bool hasSpawns = false;
        private Hash<BasePlayer, Plugins.Timer> TimersList = new Hash<BasePlayer, Plugins.Timer>();

        /////////////////////////////////////////
        /// Cached Fields, used to make the plugin faster
        /////////////////////////////////////////
        public BasePlayer cachedPlayer;
        public int cachedTime;
        public int cachedCount;
        public JailInmate cachedJail;
        public int cachedInterval;

        /////////////////////////////////////////
        // Data Management
        /////////////////////////////////////////
        class StoredData
        {
            public HashSet<JailInmate> JailInmates = new HashSet<JailInmate>();
            public StoredData()
            {
            }
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("Jail", storedData);
        }
        void LoadData()
        {
            jailinmates.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("Jail");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var jaildef in storedData.JailInmates)
                jailinmates[jaildef.userid] = jaildef;
        }

        /////////////////////////////////////////
        // class JailInmate
        // Where all informations about a jail inmate is stored in the database
        /////////////////////////////////////////

        public class JailInmate
        {
            public string userid;
            public string x;
            public string y;
            public string z;
            public string jx;
            public string jy;
            public string jz;
            public string expireTime;
            Vector3 jail_position;
            Vector3 free_position;
            int expire_time;

            public JailInmate()
            {
            }

            public JailInmate(BasePlayer player, Vector3 position, int expiretime = -1)
            {
                userid = player.userID.ToString();
                x = player.transform.position.x.ToString();
                y = player.transform.position.y.ToString();
                z = player.transform.position.z.ToString();
                jx = position.x.ToString();
                jy = position.y.ToString();
                jz = position.z.ToString();
                expireTime = expiretime.ToString();
            }
            public void UpdateJail(Vector3 position, int expiretime = -1)
            {
                jx = position.x.ToString();
                jy = position.y.ToString();
                jz = position.z.ToString();
                expireTime = expiretime.ToString();
            }
            public Vector3 GetJailPosition()
            {
                if (jail_position == default(Vector3)) jail_position = new Vector3(float.Parse(jx),float.Parse(jy),float.Parse(jz));
                return jail_position;
            }
            public Vector3 GetFreePosition()
            {
                if (free_position == default(Vector3)) free_position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return free_position;
            }
            public int GetExpireTime()
            {
                if (expire_time == 0) expire_time = int.Parse(expireTime);
                return expire_time;
            }
        }

        /////////////////////////////////////////
        // Oxide Hooks
        /////////////////////////////////////////

        /////////////////////////////////////////
        // Loaded()
        // Called when the plugin is loaded
        /////////////////////////////////////////
        void Loaded()
        {
            LoadData();
            permission.RegisterPermission("canjail", this);
        }

        /////////////////////////////////////////
        // LoadDefaultConfig()
        // Called first when the plugin loads to load the default config
        /////////////////////////////////////////
        void LoadDefaultConfig() { }

        /////////////////////////////////////////
        // Unload()
        // Called when the plugin is unloaded (via oxide.unload or oxide.reload or when the server shutsdown)
        /////////////////////////////////////////
        void Unload()
        {
            foreach (KeyValuePair<BasePlayer, Plugins.Timer> pair in TimersList)
            {
                pair.Value.Destroy();
            }
            TimersList.Clear();
        }

        /////////////////////////////////////////
        // OnPlayerSleepEnded(BasePlayer player)
        // Called when a player wakesup
        /////////////////////////////////////////
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (jailinmates[player.userID.ToString()] != null)
            {
                CheckPlayerExpireTime(player);
                if (!isInZone(player))
                    ForcePlayerPosition(player, jailinmates[player.userID.ToString()].GetJailPosition());
            }
        }

        /////////////////////////////////////////
        // Oxide Permission system
        /////////////////////////////////////////
        bool hasPermission(BasePlayer player) { if (player.net.connection.authLevel > 1) return true; return permission.UserHasPermission(player.userID.ToString(), "canjail"); }

        /////////////////////////////////////////
        // ZoneManager Hooks
        /////////////////////////////////////////

        /////////////////////////////////////////
        // bool isPlayerInZone(string ZoneID, BasePlayer player)
        // Called to see if a player is inside a zone or not
        /////////////////////////////////////////
        bool isInZone(BasePlayer player)
        {
            if (ZoneManager == null) return false;
            return (bool)ZoneManager.Call("isPlayerInZone", "Jail", player);
        }

        /////////////////////////////////////////
        // OnEnterZone(string ZoneID, BasePlayer player)
        // Called when a player enters a Zone managed by ZoneManager
        /////////////////////////////////////////
        void OnEnterZone(string ZoneID, BasePlayer player)
        {
            if (ZoneID == "Jail")
            {
                if (hasPermission(player)) { SendReply(player, string.Format(WelcomeJail, player.displayName)); }
                else if (jailinmates[player.userID.ToString()] == null) { SendReply(player, KeepOut); }
            }
        }

        /////////////////////////////////////////
        // OnExitZone(string ZoneID, BasePlayer player)
        // Called when a player leaves a Zone managed by ZoneManager
        /////////////////////////////////////////
        void OnExitZone(string ZoneID, BasePlayer player)
        {
            if (ZoneID == "Jail")
            {
                if (jailinmates[player.userID.ToString()] != null) { SendReply(player, KeepIn); }
            }
        }

        /////////////////////////////////////////
        // Spawns Database Hooks
        /////////////////////////////////////////

        /////////////////////////////////////////
        // int GetSpawnsCount(string spawnfilename)
        // returns the number of spawns in the file
        //
        // Vector3 GetRandomSpawnVector3(string spawnfilename, int max)
        // returns a random spawn between index 1 and index MAX (here is the number of spawns in the file)
        /////////////////////////////////////////
        object FindCell(string userid)
        {
            if (spawns == null) { Puts(NoSpawnDatabase); return null; }
            if (spawnfile == null) { Puts(NoSpawnFile); return null; }
            var count = spawns.Call("GetSpawnsCount", spawnfile);
            if (count is bool) return null;
            if ((int)count == 0) { Puts(EmptySpawnFile); return null; }
            return spawns.Call("GetRandomSpawnVector3", spawnfile, count);
        }

        void LoadSpawnfile()
        {
            if (spawnfile == null) { Puts(NoSpawnFile); return; }
            var count = spawns.Call("GetSpawnsCount", spawnfile);
            if (count is bool)
            {
                Puts("{0} is not a valid spawnfile", spawnfile.ToString());
                Config["spawnfile"] = null;
                spawnfile = null;
                SaveConfig();
                return;
            }
            Puts(JailsLoaded, count.ToString());
        }

        /////////////////////////////////////////
        // Random functions
        /////////////////////////////////////////
        void ForcePlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.transform.position = destination;
            player.ClientRPC(null, player, "ForcePositionTo", new object[] { destination });
            player.TransformChanged();
        }

        int CurrentTime() { return System.Convert.ToInt32(System.DateTime.UtcNow.Subtract(epoch).TotalSeconds); }

        
        private object FindPlayer(string tofind)
        {
            if (tofind.Length == 17)
            {
                ulong steamid;
                if (ulong.TryParse(tofind.ToString(), out steamid))
                {
                    return FindPlayerByID(steamid);
                }
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
            object targetplayer = null;
            foreach (BasePlayer player in onlineplayers.ToArray())
            {

                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return multiplePlayersFound;
                }
            }
            if (targetplayer == null)
                return noPlayersFound;
            return targetplayer;
        }

        private object FindPlayerByID(ulong steamid)
        {
            BasePlayer targetplayer = BasePlayer.FindByID(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            targetplayer = BasePlayer.FindSleeping(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            return null;
        }
        /////////////////////////////////////////
        // Jail functions
        /////////////////////////////////////////

        /////////////////////////////////////////
        // AddPlayerToJail(BasePlayer player, int expiretime)
        // Adds a player to the jail, and saves him in the database
        /////////////////////////////////////////
        void AddPlayerToJail(BasePlayer player, int expiretime)
        {
            var tempPoint = FindCell(player.userID.ToString());
            if (tempPoint == null) { return; }
            JailInmate newjailmate;
            if (jailinmates[player.userID.ToString()] != null) { newjailmate = jailinmates[player.userID.ToString()]; newjailmate.UpdateJail((Vector3)tempPoint, expiretime); }
            else newjailmate = new JailInmate(player, (Vector3)tempPoint, expiretime);
            if (jailinmates[player.userID.ToString()] != null) storedData.JailInmates.Remove(jailinmates[player.userID.ToString()]);
            jailinmates[player.userID.ToString()] = newjailmate;
            storedData.JailInmates.Add(jailinmates[player.userID.ToString()]);
            SaveData();
        }

        /////////////////////////////////////////
        // SendPlayerToJail(BasePlayer player)
        // Sends a player to the jail
        /////////////////////////////////////////
        void SendPlayerToJail(BasePlayer player)
        {
            if (jailinmates[player.userID.ToString()] == null) return;
            ZoneManager.Call("AddPlayerToZoneKeepinlist", "Jail", player);
            ForcePlayerPosition(player, jailinmates[player.userID.ToString()].GetJailPosition());
            SendReply(player, YouAreInJail);
        }

        /////////////////////////////////////////
        // RemovePlayerFromJail(BasePlayer player)
        // Removes a player from the jail (need to be called after SendPlayerOutOfJail, because we need the return point)
        /////////////////////////////////////////
        void RemovePlayerFromJail(BasePlayer player)
        {
            if (jailinmates[player.userID.ToString()] != null) storedData.JailInmates.Remove(jailinmates[player.userID.ToString()]);
            jailinmates[player.userID.ToString()] = null;
            SaveData();
        }

        /////////////////////////////////////////
        // SendPlayerOutOfJail(BasePlayer player)
        // Send player out of the jail
        /////////////////////////////////////////
        void SendPlayerOutOfJail(BasePlayer player)
        {
            if (jailinmates[player.userID.ToString()] == null) return;
            cachedJail = jailinmates[player.userID.ToString()];
            ZoneManager.Call("RemovePlayerFromZoneKeepinlist", "Jail", player);
            ForcePlayerPosition(player, cachedJail.GetFreePosition());
            SendReply(player, YouAreFree);
        }

        /////////////////////////////////////////
        // CheckPlayerExpireTime(BasePlayer player)
        // One function to take care of the timer, calls himself.
        /////////////////////////////////////////
        void CheckPlayerExpireTime(BasePlayer player)
        {
            if (TimersList[player] != null) { TimersList[player].Destroy(); TimersList[player] = null; }
            if (!player.IsConnected()) return;
            if (player.IsDead()) return;
            if (jailinmates[player.userID.ToString()] == null) return;
            cachedJail = jailinmates[player.userID.ToString()];
            cachedInterval = cachedJail.GetExpireTime() - CurrentTime();
            if (cachedInterval < 1)
            {
                SendPlayerOutOfJail(player);
                RemovePlayerFromJail(player);
            }
            else
                TimersList[player] = timer.Once( (float)(cachedInterval + 1), () => CheckPlayerExpireTime(player));
        }

        /////////////////////////////////////////
        // Chat commands
        /////////////////////////////////////////
        [ChatCommand("jail_config")]
        void cmdChatJailConfig(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, NoPermission); return; }
            if(ZoneManager == null) { SendReply(player, NoZoneManager); return; }
            if (spawns == null) { SendReply(player, NoSpawnDatabase); return; }
            if (args.Length < 2)
            {
                SendReply(player, "/jail_config spawnfile jailspawnfile => set the spawns where players will be jailed");
                SendReply(player, "/jail_config zone RADIUS");
                SendReply(player, "You must stand in the center of the radius zone of the jail.");
                return;
            }
            switch(args[0].ToLower())
            {
                case "zone":
                    string[] zoneargs = new string[] { "name", "Jail", "eject", "true", "radius", args[1], "pvpgod", "true", "pvegod", "true", "sleepgod", "true", "undestr", "true", "nobuild", "true", "notp", "true", "nokits", "true", "nodeploy", "true", "nosuicide", "true" };
                    ZoneManager.Call("CreateOrUpdateZone", "Jail", zoneargs, player.transform.position);
                    SendReply(player, JailCreated);
                break;
                case "spawnfile":
                    var count = Interface.GetMod().CallHook("GetSpawnsCount", new object[] { args[1] });
                    if (count == null)
                    {
                        SendReply(player, "SpawnFile {0} is not a valid spawnfile", args[0].ToString());
                        Config["spawnfile"] = null;
                        spawnfile = null;
                    }
                    else
                    {
                        Config["spawnfile"] = args[1];
                        spawnfile = args[1];
                        SendReply(player, "New SpawnFile for Jaild Players: {0}", spawnfile);
                        LoadSpawnfile();
                    }
               break;
                default:
                    return;
                    break;

            }
            SaveConfig();
        }
        [ChatCommand("jail")]
        void cmdChatJail(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, NoPermission); return; }
            if (ZoneManager == null) { SendReply(player, NoZoneManager); return; }
            if(spawns == null) { SendReply(player, NoSpawnDatabase); return; }
            if (args.Length  == 0) { SendReply(player, "/jail PLAYER option:Time(seconds)"); return; }

            var target = FindPlayer(args[0].ToString());
            if (target is string) { SendReply(player, target.ToString()); return; }
            cachedPlayer = (BasePlayer)target;

            cachedTime = -1;
            if (args.Length > 1) int.TryParse(args[1], out cachedTime);
            if (cachedTime != -1) cachedTime += CurrentTime();

            AddPlayerToJail(cachedPlayer, cachedTime);
            SendPlayerToJail(cachedPlayer);

            CheckPlayerExpireTime(cachedPlayer);

            SendReply(player, string.Format("{0} was sent to jail",cachedPlayer.displayName.ToString()));
        }

        [ChatCommand("free")]
        void cmdChatFree(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) { SendReply(player, NoPermission); return; }
            if (ZoneManager == null) { SendReply(player, NoZoneManager); return; }
            if (spawns == null) { SendReply(player, NoSpawnDatabase); return; }
            if (args.Length == 0) { SendReply(player, "/jail PLAYER option:Time(seconds)"); return; }

            var target = FindPlayer(args[0].ToString());
            if (target is string) { SendReply(player, target.ToString()); return; }
            cachedPlayer = (BasePlayer)target;

            SendPlayerOutOfJail(cachedPlayer);
            RemovePlayerFromJail(cachedPlayer);

            CheckPlayerExpireTime(cachedPlayer);

            SendReply(player, string.Format("{0} was freed from jail", cachedPlayer.displayName.ToString()));
        }


        /////////////////////////////////////////
        // Config handler
        // Thx to Bombardir and his code in Pets, stole his way! Much better and cleaner than my old one
        /////////////////////////////////////////
        private static string NoPermission = "You don't have the permission to use this command";
        private static string NoZoneManager = "You can't use the Jail plugin without ZoneManager";
        private static string JailCreated = "You successfully created/updated the jail zone, use /zone_list for more informations";
        private static string noPlayersFound = "No Online player with this name was found";
        private static string NoSpawnDatabase = "No spawns set or no spawns database found http://forum.rustoxide.com/resources/spawns-database.720";
        private static string multiplePlayersFound = "Multiple players found";
        private static string spawnfile = null;
        private static string NoSpawnFile = "No SpawnFile - You must configure your spawnfile first: /jail_config spawnfile FILENAME";
        private static string JailsLoaded = "Jail Plugin: {0} cell spawns were detected and loaded";
        private static string YouAreInJail = "You were arrested and sent to jail";
        private static string YouAreFree = "You were freed from jail";
        private static string KeepOut = "Keep out, no visitors allowed in the jail";
        private static string WelcomeJail = "Welcome to the jail {0}";
        private static string KeepIn = "You are not allowed to leave the Jail";
        private static string EmptySpawnFile = "The spawnfile is empty, can't find any spawn points. Make sure to create a valid Spawn Database first";

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Message: No Permission", ref NoPermission);
            CheckCfg<string>("Message: No ZoneManager", ref NoZoneManager);
            CheckCfg<string>("Message: Jail Created", ref JailCreated);
            CheckCfg<string>("Message: No Player Found", ref noPlayersFound);
            CheckCfg<string>("Message: No SpawnDatabase", ref NoSpawnDatabase);
            CheckCfg<string>("Message: No SpawnFile", ref NoSpawnFile);
            CheckCfg<string>("Message: Loaded Cells", ref JailsLoaded);
            CheckCfg<string>("Message: Sent In Jail", ref YouAreInJail);
            CheckCfg<string>("Message: Freed", ref YouAreFree);
            CheckCfg<string>("Message: KeepOut", ref KeepOut);
            CheckCfg<string>("Message: Welcome ADMIN", ref WelcomeJail);
            CheckCfg<string>("spawnfile", ref spawnfile);
            CheckCfg<string>("Message: KeepIn", ref KeepIn);
            CheckCfg<string>("Message: Empty Spawn file", ref EmptySpawnFile);
            SaveConfig();
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Kits.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Kits", "Reneb", "2.0.5")]
    class Kits : RustPlugin
    {
        private string noAccess;
        private int authlevel;
        private string itemNotFound;
        private string cantUseKit;
        private string maxKitReached;
        private string unknownKit;
        private string kitredeemed;
        private string kitsreset;

        private DateTime epoch;
        private Core.Configuration.DynamicConfigFile KitsConfig;
        private Core.Configuration.DynamicConfigFile KitsData;
        private bool Changed;
        private Dictionary<string, string> displaynameToShortname;

        void Loaded()
        {
            epoch = new System.DateTime(1970, 1, 1);
            displaynameToShortname = new Dictionary<string, string>();
            if (!permission.PermissionExists("vip")) permission.RegisterPermission("vip", this);
            LoadVariables();
            InitializeKits();
        }
        void OnServerInitialized()
        {
            InitializeTable();
        }
        double CurrentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        private void InitializeKits()
        {
            KitsConfig = Interface.GetMod().DataFileSystem.GetDatafile("Kits_List");
            KitsData = Interface.GetMod().DataFileSystem.GetDatafile("Kits_Data");
        }
        private void SaveKits()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("Kits_List");
        }
        private void SaveKitsData()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("Kits_Data");
        }
        private void InitializeTable()
        {
            displaynameToShortname.Clear();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions() as List<ItemDefinition>;
            foreach (ItemDefinition itemdef in ItemsDefinition)
            {
                displaynameToShortname.Add(itemdef.displayName.english.ToString().ToLower(), itemdef.shortname.ToString());
            }
        }
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        private void LoadVariables()
        {
            authlevel = Convert.ToInt32(GetConfig("Settings", "authLevel", 1));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You are not allowed to use this command"));
            itemNotFound = Convert.ToString(GetConfig("Messages", "itemNotFound", "Item not found: "));
            cantUseKit = Convert.ToString(GetConfig("Messages", "cantUseKit", "You are not allowed to use this kit"));
            maxKitReached = Convert.ToString(GetConfig("Messages", "maxKitReached", "You've used all your tokens for this kit"));
            unknownKit = Convert.ToString(GetConfig("Messages", "unknownKit", "This kit doesn't exist"));
            kitredeemed = Convert.ToString(GetConfig("Messages", "kitredeemed", "You've redeemed a kit"));
            kitsreset = Convert.ToString(GetConfig("Messages", "kitsreset", "All kits data from players were deleted"));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Kits: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel >= authlevel)
                return true;
            return false;
        }
        bool hasVip(object source)
        {
            if (!(source is BasePlayer)) return true;
            if (((BasePlayer)source).net.connection.authLevel >= authlevel) return true;
            return permission.UserHasPermission(((BasePlayer)source).userID.ToString(), "vip");
        }
        public object GiveItem(BasePlayer player, string itemname, int amount, ItemContainer pref)
        {
            itemname = itemname.ToLower();

            bool isBP = false;
            if (itemname.EndsWith(" bp"))
            {
                isBP = true;
                itemname = itemname.Substring(0, itemname.Length - 3);
            }
            if (displaynameToShortname.ContainsKey(itemname))
                itemname = displaynameToShortname[itemname];
            var definition = ItemManager.FindItemDefinition(itemname);
            if (definition == null)
                return string.Format("{0} {1}", itemNotFound, itemname);
            int giveamount = 0;
            int stack = (int)definition.stackable;
            if (isBP)
                stack = 1;
            if (stack < 1) stack = 1;
            for (var i = amount; i > 0; i = i - stack)
            {
                if (i >= stack)
                    giveamount = stack;
                else
                    giveamount = i;
                if (giveamount < 1) return true;
                player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, giveamount, isBP), pref);
            }
            return true;
        }
        private void SendTheReply(object source, string msg)
        {
            if (source is BasePlayer)
                SendReply((BasePlayer)source, msg);
            else if (source is ConsoleSystem.Arg)
                SendReply((ConsoleSystem.Arg)source, msg);
            else
                Puts(msg);
        }
        void SendList(object source)
        {
            var kitEnum = KitsConfig.GetEnumerator();
            int authlevel = GetSourceLevel(source);
            bool isvip = hasVip(source);

            while (kitEnum.MoveNext())
            {
                int kitlvl = 0;
                string kitdescription = string.Empty;
                string options = string.Empty;
                string kitname = string.Empty;
                options = string.Empty;
                kitname = kitEnum.Current.Key.ToString();
                var kitdata = kitEnum.Current.Value as Dictionary<string, object>;
                if (kitdata.ContainsKey("description"))
                    kitdescription = kitdata["description"].ToString();
                if (kitdata.ContainsKey("level"))
                {
                    kitlvl = (int)kitdata["level"];
                    options = string.Format("{0} - {1}+", options, kitlvl.ToString());

                }
                if (kitdata.ContainsKey("vip"))
                {
                    options = string.Format("{0} - {1}", options, "vip");
                    if (!isvip) continue;
                }
                if (kitdata.ContainsKey("max"))
                {
                    options = string.Format("{0} - {1} max", options, kitdata["max"].ToString());
                }
                if (kitdata.ContainsKey("cooldown"))
                {
                    options = string.Format("{0} - {1}s cooldown", options, kitdata["cooldown"].ToString());
                }
                if (kitlvl <= authlevel)
                {
                    SendTheReply(source, string.Format("{0} - {1} {2}", kitname, kitdescription, options));
                }
            }
        }
        int GetSourceLevel(object source)
        {
            if (source is BasePlayer)
            {
                return ((BasePlayer)source).net.connection.authLevel;
            }
            return 2;
        }

        void cmdAddKit(BasePlayer player, string[] args)
        {
            if (args.Length < 3)
            {
                SendTheReply(player, "/kit add \"KITNAME\" \"DESCRIPTION\" -option1 -option2 etc, Everything you have in your inventory will be used in the kit");
                SendTheReply(player, "Options avaible:");
                SendTheReply(player, "-maxXX => max times someone can use this kit. Default is infinite.");
                SendTheReply(player, "-cooldownXX => cooldown of the kit. Default is none.");
                SendTheReply(player, "-vip => Allow to give this kit only to vip & admins");
                SendTheReply(player, "-authlevelXX => Level needed to use this plugin: 0, 1 or 2. Default is 0");
                return;
            }
            string kitname = args[1].ToString();
            string desription = args[2].ToString();
            int authlevel = 0;
            int max = -1;
            bool vip = false;
            double cooldown = 0.0;
            if (KitsConfig[kitname] != null)
            {
                SendTheReply(player, string.Format("The kit {0} already exists. Delete it first or change the name.", kitname));
                return;
            }
            if (args.Length > 3)
            {
                object validoptions = VerifyOptions(args, out authlevel, out max, out cooldown, out vip);
                if (validoptions is string)
                {
                    SendTheReply(player, (string)validoptions);
                    return;
                }
            }
            Dictionary<string, object> kitsitems = GetNewKitFromPlayer(player);
            Dictionary<string, object> newkit = new Dictionary<string, object>();
            newkit.Add("items", kitsitems);
            if (authlevel > 0)
                newkit.Add("level", authlevel);
            if (max >= 0)
                newkit.Add("max", max);
            if (vip)
                newkit.Add("vip", true);
            if (cooldown > 0.0)
                newkit.Add("cooldown", cooldown);
            newkit.Add("description", desription);
            KitsConfig[kitname] = newkit;
            SaveKits();
        }
        Dictionary<string, object> GetNewKitFromPlayer(BasePlayer player)
        {
            Dictionary<string, object> kitsitems = new Dictionary<string, object>();
            List<object> wearList = new List<object>();
            List<object> mainList = new List<object>();
            List<object> beltList = new List<object>();

            ItemContainer wearcontainer = player.inventory.containerWear;
            ItemContainer maincontainer = player.inventory.containerMain;
            ItemContainer beltcontainer = player.inventory.containerBelt;

            string itemname = string.Empty;
            foreach (Item item in (List<Item>)wearcontainer.itemList)
            {
                Dictionary<string, object> newObject = new Dictionary<string, object>();


                newObject.Add(item.info.shortname.ToString(), (int)item.amount);
                wearList.Add(newObject);
            }

            foreach (Item item in (List<Item>)maincontainer.itemList)
            {
                Dictionary<string, object> newObject = new Dictionary<string, object>();
                itemname = item.info.shortname.ToString();
                if ((bool)item.isBlueprint)
                    itemname = string.Format("{0} BP", itemname);
                newObject.Add(itemname, (int)item.amount);
                mainList.Add(newObject);
            }
            foreach (Item item in (List<Item>)beltcontainer.itemList)
            {
                Dictionary<string, object> newObject = new Dictionary<string, object>();
                itemname = item.info.shortname.ToString();
                if ((bool)item.isBlueprint)
                    itemname = string.Format("{0} BP", itemname);
                newObject.Add(itemname, (int)item.amount);
                beltList.Add(newObject);
            }
            player.inventory.Strip();
            kitsitems.Add("wear", wearList);
            kitsitems.Add("main", mainList);
            kitsitems.Add("belt", beltList);
            return kitsitems;
        }
        object VerifyOptions(string[] args, out int authlevel, out int max, out double cooldown, out bool vip)
        {
            authlevel = 0;
            max = -1;
            cooldown = 0.0;
            vip = false;
            for (var i = 3; i < args.Length; i++)
            {
                int substring = 0;
                if (args[i].StartsWith("-max"))
                {
                    substring = 4;
                    if (!(int.TryParse(args[i].Substring(substring), out max)))
                        return string.Format("Wrong Number Value for : {0}", args[i].ToString());
                }
                else if (args[i].StartsWith("-cooldown"))
                {
                    substring = 9;
                    if (!(double.TryParse(args[i].Substring(substring), out cooldown)))
                        return string.Format("Wrong Number Value for : {0}", args[i].ToString());
                }
                else if (args[i].StartsWith("-vip"))
                {
                    vip = true;
                }
                else if (args[i].StartsWith("-authlevel"))
                {
                    substring = 10;
                    if (!(int.TryParse(args[i].Substring(substring), out authlevel)))
                        return string.Format("Wrong Number Value for : {0}", args[i].ToString());
                    if (authlevel > 2)
                        authlevel = 2;
                    if (authlevel < 0)
                        authlevel = 0;
                }
                else
                    return string.Format("Wrong Options: {0}", args[i].ToString());
                return true;
            }
            return true;
        }
        void cmdResetKits(BasePlayer player, string[] args)
        {
            KitsData.Clear();
            SendTheReply(player, "All kits data from players were deleted");
            SaveKitsData();
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            if (KitsConfig["autokit"] == null) return;
            object thereturn = Interface.GetMod().CallHook("canRedeemKit", new object[] { player });
            if (thereturn == null)
            {
                player.inventory.Strip();
                GiveKit(player, "autokit");
            }
        }
        void cmdRemoveKit(BasePlayer player, string[] args)
        {
            if (args.Length < 2)
            {
                SendTheReply(player, "Kit must specify the name of the kit that you want to remove");
                return;
            }
            int authlevel = GetSourceLevel(player);
            int kitlvl = 0;
            string kitname = args[1].ToString();
            if (KitsConfig[kitname] == null)
            {
                SendTheReply(player, string.Format("The kit {0} doesn't exist", kitname));
                return;
            }

            var kitdata = (KitsConfig[kitname]) as Dictionary<string, object>;
            if (kitdata.ContainsKey("level"))
                kitlvl = (int)kitdata["level"];
            if (kitlvl > 2)
                kitlvl = 2;
            if (kitlvl > authlevel)
            {
                SendTheReply(player, "You don't have the level to remove this kit");
                return;
            }
            var newKits = new Dictionary<string, object>();
            var enumkits = KitsConfig.GetEnumerator();
            while (enumkits.MoveNext())
            {
                if (enumkits.Current.Key.ToString() != kitname && enumkits.Current.Value != null)
                {
                    newKits.Add(enumkits.Current.Key.ToString(), enumkits.Current.Value);
                }
            }
            KitsConfig.Clear();
            foreach (KeyValuePair<string, object> pair in newKits)
            {
                KitsConfig[pair.Key] = pair.Value;
            }
            SaveKits();
            SendTheReply(player, string.Format("The kit {0} was successfully removed", kitname));
        }
        int GetKitLeft(BasePlayer player, string kitname, int max)
        {
            if (KitsData[player.userID.ToString()] == null) return max;
            var data = KitsData[player.userID.ToString()] as Dictionary<string, object>;
            if (!(data.ContainsKey(kitname))) return max;
            var currentkit = data[kitname] as Dictionary<string, object>;
            if (!(currentkit.ContainsKey("used"))) return max;
            return (max - (int)currentkit["used"]);
        }
        double GetKitTimeleft(BasePlayer player, string kitname, double max)
        {
            if (KitsData[player.userID.ToString()] == null) return 0.0;
            var data = KitsData[player.userID.ToString()] as Dictionary<string, object>;
            if (!(data.ContainsKey(kitname))) return 0.0;
            var currentkit = data[kitname] as Dictionary<string, object>;
            if (!(currentkit.ContainsKey("cooldown"))) return 0.0;
            return ((double)currentkit["cooldown"] - CurrentTime());
        }
        void TryGiveKit(BasePlayer player, string kitname)
        {
            if (KitsConfig[kitname] == null)
            {
                SendTheReply(player, unknownKit);
                return;
            }
            object thereturn = Interface.GetMod().CallHook("canRedeemKit", new object[1] { player });
            if (thereturn != null)
            {
                if (thereturn is string)
                {
                    SendTheReply(player, (string)thereturn);
                }
                return;
            }

            Dictionary<string, object> kitdata = (KitsConfig[kitname]) as Dictionary<string, object>;
            double cooldown = 0.0;
            int kitleft = 1;
            int kitlvl = 0;

            if (kitdata.ContainsKey("level"))
                kitlvl = (int)kitdata["level"];
            if (kitlvl > player.net.connection.authLevel)
            {
                SendTheReply(player, cantUseKit);
                return;
            }
            if (kitdata.ContainsKey("max"))
                kitleft = GetKitLeft(player, kitname, (int)(kitdata["max"]));
            if (kitleft <= 0)
            {
                SendTheReply(player, maxKitReached);
                return;
            }
            if (kitdata.ContainsKey("vip"))
                if (!hasVip(player))
                {
                    SendReply(player, cantUseKit);
                    return;
                }
            if (kitdata.ContainsKey("cooldown"))
                cooldown = GetKitTimeleft(player, kitname, (double)(kitdata["cooldown"]));
            if (cooldown > 0.0)
            {
                SendTheReply(player, string.Format("You must wait {0}s before using this kit again", cooldown.ToString()));
                return;
            }
            object wasGiven = GiveKit(player, kitname);
            if ((wasGiven is bool) && !((bool)wasGiven))
            {
                Puts(string.Format("An error occurred while giving the kit {0} to {1}", kitname, player.displayName.ToString()));
                return;
            }
            proccessKitGiven(player, kitname, kitdata, kitleft);
        }

        void proccessKitGiven(BasePlayer player, string kitname, Dictionary<string, object> kitdata, int kitleft)
        {
            string userid = player.userID.ToString();
            if (KitsData[userid] == null)
            {
                (KitsData[userid]) = new Dictionary<string, object>();
            }
            var playerData = (KitsData[userid]) as Dictionary<string, object>;
            var currentKitData = new Dictionary<string, object>();
            bool write = false;
            if (kitdata.ContainsKey("max"))
            {
                currentKitData.Add("used", (((int)kitdata["max"] - kitleft) + 1));
                write = true;
            }
            if (kitdata.ContainsKey("cooldown"))
            {
                currentKitData.Add("cooldown", ((double)kitdata["cooldown"] + CurrentTime()));
                write = true;
            }
            if (write)
            {
                if (playerData.ContainsKey(kitname))
                    playerData[kitname] = currentKitData;
                else
                    playerData.Add(kitname, currentKitData);
                KitsData[userid] = playerData;
                SaveKitsData();
            }
        }
        object GiveKit(BasePlayer player, string kitname)
        {
            if (KitsConfig[kitname] == null)
            {
                SendTheReply(player, unknownKit);
                return false;
            }
            var kitdata = (KitsConfig[kitname]) as Dictionary<string, object>;
            var kitsitems = kitdata["items"] as Dictionary<string, object>;
            List<object> wearList = kitsitems["wear"] as List<object>;
            List<object> mainList = kitsitems["main"] as List<object>;
            List<object> beltList = kitsitems["belt"] as List<object>;
            ItemContainer pref = player.inventory.containerWear;

            if (wearList.Count > 0)
            {
                pref = player.inventory.containerWear;
                foreach (object items in wearList)
                {
                    foreach (KeyValuePair<string, object> pair in items as Dictionary<string, object>)
                    {
                        GiveItem(player, (string)pair.Key, (int)pair.Value, pref);
                    }
                }
            }

            if (mainList.Count > 0)
            {
                pref = player.inventory.containerMain;
                foreach (object items in mainList)
                {
                    foreach (KeyValuePair<string, object> pair in items as Dictionary<string, object>)
                    {
                        GiveItem(player, (string)pair.Key, (int)pair.Value, pref);
                    }
                }
            }
            if (beltList.Count > 0)
            {
                pref = player.inventory.containerBelt;
                foreach (object items in beltList)
                {
                    foreach (KeyValuePair<string, object> pair in items as Dictionary<string, object>)
                    {
                        GiveItem(player, (string)pair.Key, (int)pair.Value, pref);
                    }
                }
            }
            SendTheReply(player, kitredeemed);
            return true;
        }
        [ChatCommand("kit")]
        void cmdChatKits(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 0 && (args[0].ToString() == "add" || args[0].ToString() == "reset" || args[0].ToString() == "remove"))
            {
                if (!hasAccess(player))
                {
                    SendReply(player, noAccess);
                    return;
                }
                if (args[0].ToString() == "add")
                    cmdAddKit(player, args);
                else if (args[0].ToString() == "reset")
                    cmdResetKits(player, args);
                else if (args[0].ToString() == "remove")
                    cmdRemoveKit(player, args);
                return;
            }
            if (args.Length == 0)
            {
                SendList(player);
                return;
            }
            TryGiveKit(player, args[0]);
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\LimitedSuicide.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("LimitedSuicide", "playrust.io / dcode", "1.0.1", ResourceId = 835)]
    public class LimitedSuicide : RustPlugin
    {
        // Default configuration: Once per 300 seconds
        private static int defaultLimit = 1;
        private static int defaultTimespan = 300;

        // Loaded configuration
        private int limit = defaultLimit;
        private int timespan = defaultTimespan;

        // Suicide timestamps
        private Dictionary<ulong, List<DateTime>> suicides = new Dictionary<ulong, List<DateTime>>();

        protected override void LoadDefaultConfig() {
            Config["limit"] = defaultLimit;
            Config["timespan"] = defaultTimespan;
            SaveConfig();
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            try {
                limit = Convert.ToInt32(Config["limit"]);
                if (limit < 1) limit = 1;
            } catch (Exception ex) {
                Puts("[LimitedSuicide] Illegal configuration value for 'limit': {0}", ex.Message);
            }
            try {
                timespan = Convert.ToInt32(Config["timespan"]);
                if (timespan < 1) timespan = 1;
            } catch (Exception ex) {
                Puts("[LimitedSuicide] Illegal configuration value for 'timespan': {0}", ex.Message);
            }
        }

        [HookMethod("OnRunCommand")]
        object OnRunCommand(ConsoleSystem.Arg arg) {
            if (arg.connection == null || arg.connection.player == null || arg.cmd.name != "kill")
                return null;
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return null;
            List<DateTime> times;
            DateTime now = DateTime.UtcNow;
            if (suicides.TryGetValue(player.userID, out times)) {
                int n = 0;
                for (var i = 0; i < times.Count;) {
                    var time = times[i];
                    if (time < now.AddSeconds(-timespan))
                        times.RemoveAt(i);
                    else {
                        ++n; ++i;
                    }
                }
                if (n >= limit) {
                    player.ChatMessage("You may only suicide " + (limit == 1 ? "once" : limit + " times") + " per " + timespan + " seconds.");
                    return true;
                }
                times.Add(now);
            } else {
                times = new List<DateTime>();
                times.Add(now);
                suicides.Add(player.userID, times);
            }
            return null;
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\LootConfig.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

using System.Collections.Generic;
using System.Linq;

using Rust;

using System;
using System.IO;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

using UnityEngine;

using JSONObject = JSON.Object;
using JSONArray = JSON.Array;
using JSONValue = JSON.Value;
using JSONValueType = JSON.ValueType;

namespace Oxide.Plugins
{
    [Info("LootConfig", "Nogrod", "1.0.0")]
    class LootConfig : RustPlugin
    {
        private readonly Regex _findLoot = new Regex("loot|crate|supply_drop", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private string _configpath = "";

        void Loaded()
        {
            _configpath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
        }

        new void LoadDefaultConfig()
        {
        }

        private static JSONObject ToJsonObject(object obj)
        {
            return JSONObject.Parse(ToJsonString(obj));
        }

        private static string ToJsonString(object obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings
            {
                ContractResolver = new DynamicContractResolver(),
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                Converters = new List<JsonConverter> { new Newtonsoft.Json.Converters.StringEnumConverter() }
            });
        }

        private bool CreateDefaultConfig()
        {
            Config.Clear();
            Config["Version"] = Protocol.network;
            var containers = Resources.FindObjectsOfTypeAll<LootContainer>();
            foreach (var lootContainer in containers)
            {
                if (Config[lootContainer.lootDefinition.name.Substring(10)] != null) continue;
                var obj = ToJsonObject(lootContainer);
                StripLoot(obj.GetObject("lootDefinition"), obj, "lootDefinition");
                Config[lootContainer.lootDefinition.name.Substring(10)] = JsonObjectToObject(obj);
            }
            try
            {
                Config.Save(_configpath);
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            LocalPuts("Created new config");
            return LoadConfig();
        }

        private bool LoadConfig()
        {
            try
            {
                Config.Load(_configpath);
            }
            catch (FileNotFoundException)
            {
                return CreateDefaultConfig();
            }
            catch (Exception e)
            {
                LocalPuts(e.Message);
                return false;
            }
            return true;
        }

        private void CheckConfig()
        {
            if (Config["Version"] != null && (int)Config["Version"] == Protocol.network) return;
            LocalPuts("Incorrect config version(" + Config["Version"] + ") move to .old");
            if (Config["Version"] != null) Config.Save(string.Format("{0}.old", _configpath));
            CreateDefaultConfig();
        }

        private void UpdateLoot()
        {
            var containers = Resources.FindObjectsOfTypeAll<LootContainer>();
            var done = new HashSet<LootSpawn>();
            // Cleanup old instances
            var loot = Resources.FindObjectsOfTypeAll<LootSpawn>();
            foreach (var lootContainer in containers)
            {
                done.Add(lootContainer.lootDefinition);
            }
            foreach (var lootSpawn in loot)
            {
                if (!done.Contains(lootSpawn))
                {
                    UnityEngine.Object.Destroy(lootSpawn);
                }
            }
            done.Clear();
            // Cleanup done
            foreach (var lootContainer in containers)
            {
                var obj = ObjectToJsonObject(Config[lootContainer.lootDefinition.name.Substring(10)]).Obj;
                lootContainer.maxDefinitionsToSpawn = obj.GetInt("maxDefinitionsToSpawn", 0);
                lootContainer.minSecondsBetweenRefresh = obj.GetFloat("minSecondsBetweenRefresh", 3600);
                lootContainer.maxSecondsBetweenRefresh = obj.GetFloat("maxSecondsBetweenRefresh", 7200);
                lootContainer.destroyOnEmpty = obj.GetBoolean("destroyOnEmpty", true);
                if (!done.Contains(lootContainer.lootDefinition))
                {
                    UpdateLootSpawn(lootContainer.lootDefinition, obj, "lootDefinition");
                    done.Add(lootContainer.lootDefinition);
                }
            }
        }

        private void UpdateLootSpawn(LootSpawn lootSpawn, JSONObject obj, string path)
        {
            var value = obj.GetValue(path);
            if (value != null && value.Type == JSONValueType.Array && value.Array.Length > 0)
            {
                lootSpawn.items = new ItemAmount[0];
                lootSpawn.blueprints = new ItemAmount[0];
                lootSpawn.subSpawn = new LootSpawn.Entry[value.Array.Length];
                for (var i = 0; i < lootSpawn.subSpawn.Length; i++)
                {
                    lootSpawn.subSpawn[i] = new LootSpawn.Entry { category = ScriptableObject.CreateInstance<LootSpawn>(), weight = value.Array[i].Obj.GetInt("weight", 0) };
                    UpdateLootSpawn(lootSpawn.subSpawn[i].category, value.Array[i].Obj, "category");
                }
                return;
            }
            var itemsValue = obj.GetValue("items");
            if (itemsValue != null && itemsValue.Type == JSONValueType.Array && itemsValue.Array.Length > 0)
            {
                var items = itemsValue.Array;
                lootSpawn.items = new ItemAmount[items.Length];
                for (var i = 0; i < items.Length; i++)
                {
                    var def = ItemManager.FindItemDefinition(items[i].Obj.GetString("item", "unnamed"));
                    //TODO null check
                    lootSpawn.items[i] = new ItemAmount(def, items[i].Obj.GetFloat("amount", 0));
                }
            }
            var blueprintsValue = obj.GetValue("blueprints");
            if (blueprintsValue != null && blueprintsValue.Type == JSONValueType.Array && blueprintsValue.Array.Length > 0)
            {
                var blueprints = blueprintsValue.Array;
                lootSpawn.blueprints = new ItemAmount[blueprints.Length];
                for (var i = 0; i < blueprints.Length; i++)
                {
                    var def = ItemManager.FindItemDefinition(blueprints[i].Obj.GetString("item", "unnamed"));
                    //TODO null check
                    lootSpawn.blueprints[i] = new ItemAmount(def, blueprints[i].Obj.GetFloat("amount", 0));
                }
            }
        }

        void OnServerInitialized()
        {
            if (!LoadConfig())
                return;
            var prefabs = GameManifest.Get().pooledStrings.ToList().ConvertAll(p => p.str).Where(p => _findLoot.IsMatch("loot|crate|supply_drop")).ToArray();
            foreach (var source in prefabs)
            {
                GameManager.server.FindPrefab(source);
            }
            CheckConfig();
            UpdateLoot();
        }

        private void StripLoot(JSONObject obj, JSONObject parent = null, string path = null)
        {
            var value = obj.GetValue("subSpawn");
            if (value != null && value.Type == JSONValueType.Array && value.Array.Length > 0)
            {
                if (parent != null)
                {
                    parent[path] = obj.GetArray("subSpawn");
                }
                obj.Remove("items");
                obj.Remove("blueprints");
                StripSubCategoryLoot(obj.GetArray("subSpawn"));
                return;
            }
            obj.Remove("subSpawn");
            var items = obj.GetValue("items");
            if (items != null && items.Type == JSONValueType.Array)
            {
                foreach (var item in items.Array)
                {
                    StripEntry(item.Obj);
                }
            }
            var bps = obj.GetValue("blueprints");
            if (bps != null && bps.Type == JSONValueType.Array)
            {
                foreach (var bp in bps.Array)
                {
                    StripEntry(bp.Obj);
                }
            }
            if (parent != null && path != null && path.Equals("category"))
            {
                parent["items"] = items;
                parent["blueprints"] = bps;
                parent.Remove("category");
            }
        }

        private static void StripEntry(JSONObject obj)
        {
            obj["item"] = obj.GetObject("itemDef").GetString("shortname", "unnamed");
            obj.Remove("itemDef");
            obj.Remove("itemid");
        }

        private void StripSubCategoryLoot(JSONArray arr)
        {
            //float sum = arr.Sum(x => x.Obj.GetFloat("weight", 0)), curSum = sum;
            foreach (var entry in arr)
            {
                StripLoot(entry.Obj.GetObject("category"), entry.Obj, "category");
                //curSum -= entry.Obj.GetFloat("weight", 0);
                //entry.Obj["percent"] = Math.Round((sum - curSum)/(sum/100f), 2);
            }
        }

        private JSONValue ObjectToJsonObject(object obj)
        {
            if (obj == null)
            {
                return new JSONValue(JSONValueType.Null);
            }
            if (obj is string)
            {
                return new JSONValue((string)obj);
            }
            if (obj is double)
            {
                return new JSONValue((double)obj);
            }
            if (obj is int)
            {
                return new JSONValue((int)obj);
            }
            if (obj is bool)
            {
                return new JSONValue((bool)obj);
            }
            var dict = obj as Dictionary<string, object>;
            if (dict != null)
            {
                var newObj = new JSONObject();
                foreach (var prop in dict)
                {
                    newObj.Add(prop.Key, ObjectToJsonObject(prop.Value));
                }
                return newObj;
            }
            var list = obj as List<object>;
            if (list != null)
            {
                var arr = new JSONArray();
                foreach (var o in list)
                {
                    arr.Add(ObjectToJsonObject(o));
                }
                return arr;
            }
            LocalPuts("Unknown: " + obj.GetType().FullName + " Value: " + obj);
            return new JSONValue(JSONValueType.Null);
        }

        private object JsonObjectToObject(JSONValue obj)
        {
            switch (obj.Type)
            {
                case JSONValueType.String:
                    return obj.Str;
                case JSONValueType.Number:
                    return obj.Number;
                case JSONValueType.Boolean:
                    return obj.Boolean;
                case JSONValueType.Null:
                    return null;
                case JSONValueType.Array:
                    return obj.Array.Select(v => JsonObjectToObject(v.Obj)).ToList();
                case JSONValueType.Object:
                    var dict = new Dictionary<string, object>();
                    foreach (var prop in obj.Obj)
                    {
                        dict[prop.Key] = JsonObjectToObject(prop.Value);
                    }
                    return dict;
                default:
                    LocalPuts("Missing type: " + obj.Type);
                    break;
            }
            return null;
        }

        private void LocalPuts(string msg)
        {
            Puts("{0}: {1}", Title, msg);
        }

        [ConsoleCommand("loot.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            if (!LoadConfig())
                return;
            CheckConfig();
            UpdateLoot();
            LocalPuts("Loot config reloaded.");
        }

        class DynamicContractResolver : DefaultContractResolver
        {
            private static bool IsAllowed(JsonProperty property)
            {
                return property.PropertyType.IsPrimitive||
                        property.PropertyType == typeof(ItemAmount[]) ||
                        property.PropertyType == typeof(ItemDefinition) ||
                        property.PropertyType == typeof(String) ||
                        property.PropertyType == typeof(LootSpawn) ||
                        property.PropertyType == typeof(LootSpawn.Entry[]);
            }

            protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
            {
                var properties = base.CreateProperties(type, memberSerialization);
                return properties.Where(p => (p.DeclaringType == type || p.DeclaringType == typeof(LootContainer)) && IsAllowed(p)).ToList();
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\MazeGen.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using Oxide.Core;
//using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;


namespace Oxide.Plugins
{
    [Info("MazeGen", "4seti [Lunatiq] for Rust Planet", "0.1.2", ResourceId = 947)]
    public class MazeGen : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion

        #region VARS
        [PluginReference] Plugin ZoneManager;
        [PluginReference] Plugin RemoverTool;
        private Quaternion currentRot;
        static FieldInfo supports = typeof(BuildingBlock).GetField("supports", (BindingFlags.Instance | BindingFlags.NonPublic));
        private FieldInfo serverinput = typeof(BasePlayer).GetField("serverInput", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo keycode = typeof(KeyLock).GetField("keyCode", BindingFlags.NonPublic | BindingFlags.Instance);
        private FieldInfo codelock = typeof(CodeLock).GetField("code", BindingFlags.NonPublic | BindingFlags.Instance);
        private MethodInfo inventoryClear = typeof(ItemContainer).GetMethod("Clear", BindingFlags.NonPublic | BindingFlags.Instance);        
        private FieldInfo firstKeyCreated = typeof(KeyLock).GetField("firstKeyCreated", BindingFlags.NonPublic | BindingFlags.Instance);
        private object closestEnt;
        private Vector3 closestHitpoint;
        private Dictionary<string, Vector3> mazes = new Dictionary<string, Vector3>();
        private int mazeTPAcess = 2;
        private int tpUsageDelay = 60;

        private Dictionary<string, string> defMsg = new Dictionary<string, string>()
                {
                    {"Usage", "<color=#FFB300>Usage: /maze NAME xSize ySize zSize GenType(0-4)</color>"},
                    {"TooLarge", "<color=#FFB300>For now maximum size of Lab is 10.000 cells, in case of lags</color>"},
                    {"RemoveReq", "<color=#FFB300>RemoverTool required to do so!</color>"},
                    {"MazeRm", "<color=#FFB300>Usage: /maze_rm name, type /maze_list for all mazes avail</color>"},
                    {"MazeErrorNotFound", "<color=#FFB300>Maze with name \"{0}\" not found!</color>"},               
                    {"MazeNewError", "<color=#FFB300>Maze with name \"{0}\" already exists!</color>"},                    
                    {"MazeList", "<color=#81F23F>Next mazes are avaliable:</color>"},
                    {"MazeListEmpty", "<color=#FFB300>No Mazes avaliable!</color>"},
                    {"MazeNew", "<color=#81F23F>New maze created! SizeX: {0} - SizeY: {1} - SizeZ: {2}, Mode: {3}</color>"},
                    {"Enter_message", "<color=#81F23F>You are entering Labyrinth, good luck, stranger!</color>"},
                    {"TooSoonTP", "<color=#FFB300>You are trying to teleport too soon from last one!</color>"},
                    {"TPUsage", "<color=#FFB300>Usage: /maze_tp NAME, names are listed in /maze_list!</color>"}
                };
        private bool topFloor = false;
        private bool mazeAutoZone = true; 
        private bool EntranceExit = true;
        private bool L_Ladders = true;
        #endregion

        void Loaded()
        {
            Log("Loaded");
        }
		
		private Dictionary<string, string> messages = new Dictionary<string,string>();
        private Dictionary<string, DateTime> mazeTPUsage = new Dictionary<string, DateTime>();
		
		protected override void LoadDefaultConfig()
        {
            Warn("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
		
		// Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
		
		[HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            try
            {
                LoadConfig();               
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
                var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);               
                if (cfgMessages != null)
                    foreach (var pair in cfgMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);

                //Booleans
                mazeTPAcess = GetConfig<int>("mazeTPAcess", 2);
                mazeAutoZone = GetConfig<bool>("mazeAutoZone", true);
                EntranceExit = GetConfig<bool>("EntranceExit", true);
                tpUsageDelay = GetConfig<int>("tpUsageDelay", 30);
                L_Ladders = GetConfig<bool>("L_Ladders", true);
                topFloor = GetConfig<bool>("topFloor", false);

                if (verNum < Version || messages.Count < defMsg.Count)
                {
                    foreach (var pair in defMsg)
                        if (!messages.ContainsKey(pair.Key))
                            messages[pair.Key] = pair.Value;
                    Config["version"] = Version;
                    Config["messages"] = messages;
                    Config["mazeTPAcess"] = mazeTPAcess;
                    Config["EntranceExit"] = EntranceExit;
                    Config["mazeAutoZone"] = mazeAutoZone;
                    Config["tpUsageDelay"] = tpUsageDelay;
                    Config["L_Ladders"] = L_Ladders;
                    SaveConfig();
                    Warn("Config version updated to: " + Version.ToString() + " please check it");
                }
                LoadMazesData();
            }
            catch (Exception ex)
            {
                Error("OnServerInitialized failed: " + ex.Message);
            }
            
        }

		void LoadVariables()
        {
            Config["messages"] = defMsg;
            Config["topFloor"] = topFloor;
            Config["mazeTPAcess"] = mazeTPAcess;
            Config["mazeAutoZone"] = mazeAutoZone;
            Config["EntranceExit"] = EntranceExit;
            Config["L_Ladders"] = L_Ladders;
            Config["version"] = Version;
        }

        [ChatCommand("maze_tp")]
        void cmdMazeTP(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel < mazeTPAcess) return;
            if (args.Length == 0)
            {
                player.ChatMessage(messages["TPUsage"]);
                return;
            }
            string userID = player.userID.ToString();
            if (mazeTPUsage.ContainsKey(userID))
            {
                if ((DateTime.Now - mazeTPUsage[userID]).Minutes >= tpUsageDelay || hasAccess(player)) // TP For admins or for normal users with delay
                {
                    DoMazeTP(player, args[0], userID);
                }
                else
                {
                    player.ChatMessage(messages["TooSoonTP"]);
                }

            }
            else
            {
                DoMazeTP(player, args[0], userID);
            }
        }

        private void DoMazeTP(BasePlayer player, string name, string userID)
        {
            if (mazes.ContainsKey(name))
            {
                ForcePlayerPosition(player, mazes[name]);
                mazeTPUsage[userID] = DateTime.Now;
            }
            else
                player.ChatMessage(string.Format(messages["MazeErrorNotFound"], name));
        }



        [ChatCommand("maze_rm")]
        void cmdMazeRm(BasePlayer player, string cmd, string[] args)       
        {
            if (!hasAccess(player)) return;
            if (RemoverTool == null)
            {
                player.ChatMessage(messages["RemoveReq"]);
                return;
            }
            if (args.Length > 0)
            {
                string maze = args[0];
                if (mazes.ContainsKey(maze))
                {
                    var vector = mazes[maze];
                    RemoverTool.Call("RemoveAllFrom", vector);
                    mazes.Remove(maze);
                    if (ZoneManager != null) ZoneManager.Call("EraseZone", maze);
                    SaveMazesData();
                    player.ChatMessage("Maze removed!");
                }
                else
                {
                    player.ChatMessage(string.Format(messages["MazeErrorNotFound"], maze));
                }
            }
            else
            {
                player.ChatMessage(messages["MazeRm"]);
            }
            
        }
        [ChatCommand("maze_list")]
        void cmdMazeList(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel < mazeTPAcess) return;
            if (mazes.Count > 0)
            {
                player.ChatMessage(messages["MazeList"]);
                foreach (var maze in mazes)
                {
                    player.ChatMessage(maze.Key);
                }
            }
            else
                player.ChatMessage(messages["MazeListEmpty"]);
        }
        [ChatCommand("maze")]
        void cmdMaze(BasePlayer player, string cmd, string[] args)
        {
            // Check if the player is an admin.
            if (!hasAccess(player)) return;

            if (args == null || args.Length == 0)
            {
                player.ChatMessage(messages["Usage"]);
                return;
            }

            if (args.Length > 4)
            {
                string name = args[0];
                if (mazes.ContainsKey(name))
                {
                    player.ChatMessage(string.Format(messages["MazeNewError"], name));
                    return;
                }

                int sx = Convert.ToInt32(args[1]);
                int sy = Convert.ToInt32(args[2]);
                int sz = Convert.ToInt32(args[3]);
                if (sx < 2 || sy < 2 || sz < 1)
                {
                    player.ChatMessage(messages["Usage"]);
                    return;
                }
                int genType = Convert.ToInt32(args[4]);
                if (sx * sy * sz > 10000)
                {
                    player.ChatMessage(messages["TooLarge"]);
                    return;
                }               

                // Adjust height so you don't automatically paste in the ground
                float heightAdjustment = 0.5f;

                // Get player camera view directly from the player
                if (!TryGetPlayerView(player, out currentRot))
                {
                    SendReply(player, "Couldn't find your eyes");
                    return;
                }

                // Get what the player is looking at
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint))
                {
                    SendReply(player, "Couldn't find any Entity");
                    return;
                }

                // Check if what the player is looking at is a collider
                var baseentity = closestEnt as Collider;
                if (baseentity == null)
                {
                    SendReply(player, "You are not looking at a Structure, or something is blocking the view.");
                    return;
                }

                closestHitpoint.y = closestHitpoint.y + heightAdjustment;
                
                List<object> structureData = new List<object>();
                List<object> deployData = new List<object>();
                Maze maze = new Maze(sx, sy, sz, genType);                               

                player.ChatMessage(string.Format(messages["MazeNew"], sx, sy, sz, genType));

                for (int x = 0; x < sx; x++)
                {
                    for (int y = 0; y < sy; y++)
                    {
                        for (int z = 0; z < sz; z++)
                        {
                            //Building Objects
                            structureData.AddRange(maze.CompleteMaze[x, y, z].GetCellObjects(sz, topFloor, EntranceExit, L_Ladders));
                            //Deployments - wall.low when L_Ladders = true, else - box + cupboards
                            deployData.AddRange(maze.CompleteMaze[x, y, z].GetCellDeploys(EntranceExit, L_Ladders));
                        }
                    }
                }
                if (EntranceExit)
                {
                    Vector3 OriginRotation = new Vector3(0f, currentRot.eulerAngles.y, 0f);
                    Quaternion OriginRot = Quaternion.Euler(OriginRotation); ;
                    Vector3 TempPos = OriginRot * (new Vector3(0f, 0f, 6f));
                    Vector3 NewPos = TempPos + closestHitpoint;
                    mazes.Add(name, NewPos);
                    structureData.AddRange(maze.GetEntranceExit());
                }
                else
                    mazes.Add(name, closestHitpoint);
                SaveMazesData();

                PasteBuilding(structureData, closestHitpoint, currentRot.eulerAngles.y, heightAdjustment);
                PasteDeployables(deployData, closestHitpoint, currentRot.eulerAngles.y, heightAdjustment, player);
                if (ZoneManager != null && mazeAutoZone)
                {
                    string zone_radius = ((int)Math.Pow((sx * 1.5f) * (sx * 1.5f) + (sy * 1.5f) * (sy * 1.5f), 0.5) + 15).ToString();
                    
                    string[] zoneargs = new string[] { "name", name, "eject", "false", "radius", zone_radius, "pvpgod", "true", 
                        "pvegod", "true", "sleepgod", "true", "enter_message", messages["Enter_message"], "undestr", "true", "nobuild", "true", "notp", "true", "nokits", 
                        "true", "nodeploy", "true", "nosuicide", "true" };
                    Vector3 zone_place = new Vector3(closestHitpoint.x + (sx / 2) * 3, closestHitpoint.y + (sy / 2) * 3, closestHitpoint.z);
                    ZoneManager.Call("CreateOrUpdateZone", name, zoneargs, zone_place);
                }
            }
            else
                player.ChatMessage(messages["Usage"]);
        }

        void SaveMazesData()
        {
            Dictionary<string, object> mazes_norm = new Dictionary<string, object>();
            Dictionary<string, float> posNormalized;
            foreach (var maze in mazes)
            {
                posNormalized = new Dictionary<string, float>();
                posNormalized.Add("x", maze.Value.x);
                posNormalized.Add("y", maze.Value.y);
                posNormalized.Add("z", maze.Value.z);
                mazes_norm.Add(maze.Key, posNormalized);
            }
            Interface.GetMod().DataFileSystem.WriteObject<Dictionary<string, object>>("MazeGen-data", mazes_norm);
            Log("Data Saved");
        }
        void LoadMazesData()
        {
            try
            {
                Dictionary<string, object> mazes_norm = new Dictionary<string, object>();
                Dictionary<string, object> posNormalized;
                mazes_norm = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, object>>("MazeGen-data");
                mazes = new Dictionary<string, Vector3>();
                foreach (var maze in mazes_norm)
                {
                    posNormalized = maze.Value as Dictionary<string, object>;
                    mazes.Add(maze.Key, new Vector3(Convert.ToSingle(posNormalized["x"]), Convert.ToSingle(posNormalized["y"]), 
                        Convert.ToSingle(posNormalized["z"])));
                }
            }
            catch
            {
                mazes = new Dictionary<string, Vector3>();
                Warn("Mazes data corrupted! New data created");
                SaveMazesData();
            }
        }

        #region copy-paste stolen methods :P thx to Reneb
        bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null || input.current == null || input.current.aimAngles == Vector3.zero)
                return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
            {
                if (hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }
            if (closestEnt is bool)
                return false;
            return true;
        }

        void PasteBuilding(List<object> structureData, Vector3 targetPoint, float targetRot, float heightAdjustment)
        {
            Vector3 OriginRotation = new Vector3(0f, targetRot, 0f);
            //Quaternion OriginRot = Quaternion.EulerRotation(OriginRotation);
            Quaternion OriginRot = Quaternion.Euler(OriginRotation); ; 
            foreach (Dictionary<string, object> structure in structureData)
            {
                Dictionary<string, object> structPos = structure["pos"] as Dictionary<string, object>;
                Dictionary<string, object> structRot = structure["rot"] as Dictionary<string, object>;
                string prefabname = (string)structure["prefabname"];
                BuildingGrade.Enum grade = (BuildingGrade.Enum)structure["grade"];
                Quaternion newAngles = Quaternion.Euler((new Vector3(Convert.ToSingle(structRot["x"]), Convert.ToSingle(structRot["y"]), Convert.ToSingle(structRot["z"]))) + OriginRotation);
                Vector3 TempPos = OriginRot * (new Vector3(Convert.ToSingle(structPos["x"]), Convert.ToSingle(structPos["y"]), Convert.ToSingle(structPos["z"])));
                Vector3 NewPos = TempPos + targetPoint;
                GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
                if (newPrefab != null)
                {
                    var block = SpawnStructure(newPrefab, NewPos, newAngles, grade);
                    block.enableStability = false;
                    //block.isClient = true;
                    //supports.SetValue(block, null);
                    //var supp = supports.GetValue(block) as BuildingBlock.Support;                
                    if (block && block.HasSlot(BaseEntity.Slot.Lock))
                    {
                        TryPasteLock(block, structure);
                    }
                }
            }
        }
        void PasteDeployables(List<object> deployablesData, Vector3 targetPoint, float targetRot, float heightAdjustment, BasePlayer player)
        {
            Vector3 OriginRotation = new Vector3(0f, targetRot, 0f);
            Quaternion OriginRot = Quaternion.Euler(OriginRotation);
            foreach (Dictionary<string, object> deployable in deployablesData)
            {

                Dictionary<string, object> structPos = deployable["pos"] as Dictionary<string, object>;
                Dictionary<string, object> structRot = deployable["rot"] as Dictionary<string, object>;
                string prefabname = (string)deployable["prefabname"];

                Quaternion newAngles = Quaternion.Euler((new Vector3(Convert.ToSingle(structRot["x"]), Convert.ToSingle(structRot["y"]), Convert.ToSingle(structRot["z"]))) + OriginRotation);
                Vector3 TempPos = OriginRot * (new Vector3(Convert.ToSingle(structPos["x"]), Convert.ToSingle(structPos["y"]), Convert.ToSingle(structPos["z"])));
                Vector3 NewPos = TempPos + targetPoint;

                GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
                if (newPrefab != null)
                {
                    BaseEntity entity = GameManager.server.CreateEntity(newPrefab, NewPos, newAngles);
                    if (entity == null) return;
                    entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
                    entity.Spawn(true);
                    if (entity.GetComponent<StorageContainer>())
                    {
                        var box = entity.GetComponent<StorageContainer>();
                        inventoryClear.Invoke(box.inventory, null);
                        var items = deployable["items"] as List<object>;
                        foreach (var itemDef in items)
                        {
                            var item = itemDef as Dictionary<string, object>;
                            var i = ItemManager.CreateByItemID(Convert.ToInt32(item["id"]), Convert.ToInt32(item["amount"]), Convert.ToBoolean(item["blueprint"]));
                            i.MoveToContainer(box.inventory);
                        }

                        if (box.HasSlot(BaseEntity.Slot.Lock))
                            TryPasteLock(box, deployable);
                    }
                    else if (entity.GetComponent<Signage>())
                    {
                        var sign = entity.GetComponent<Signage>();
                        var signData = deployable["sign"] as Dictionary<string, object>;
                        sign.text = (string)signData["text"];
                        if (Convert.ToBoolean(signData["locked"]))
                            sign.SetFlag(BaseEntity.Flags.Locked, true);
                        sign.SendNetworkUpdate();
                    }
                }
                else
                {
                    SendReply(player, prefabname);
                }

            }
        }

        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return false;
            }
            return true;
        }

        void TryPasteLock(BaseCombatEntity lockableEntity, IDictionary<string, object> structure)
        {
            BaseEntity lockentity = null;
            if (structure.ContainsKey("codelock"))
            {
                lockentity = GameManager.server.CreateEntity("build/locks/lock.code", Vector3.zero, new Quaternion());
                lockentity.OnDeployed(lockableEntity);
                var code = (string)structure["codelock"];
                if (!string.IsNullOrEmpty(code))
                {
                    var @lock = lockentity.GetComponent<CodeLock>();
                    codelock.SetValue(@lock, (string)structure["codelock"]);
                    @lock.SetFlag(BaseEntity.Flags.Locked, true);
                }
            }
            else if (structure.ContainsKey("keycode"))
            {
                lockentity = GameManager.server.CreateEntity("build/locks/lock.key", Vector3.zero, new Quaternion());
                lockentity.OnDeployed(lockableEntity);
                var code = Convert.ToInt32(structure["keycode"]);
                var @lock = lockentity.GetComponent<KeyLock>();
                if ((code & 0x80) != 0)
                {
                    // Set the keycode only if that lock had keys before. Otherwise let it be random.
                    keycode.SetValue(@lock, (code & 0x7F));
                    firstKeyCreated.SetValue(@lock, true);
                    @lock.SetFlag(BaseEntity.Flags.Locked, true);
                }

            }

            if (lockentity)
            {
                lockentity.gameObject.Identity();
                lockentity.SetParent(lockableEntity, "lock");
                lockentity.Spawn(true);
                lockableEntity.SetSlot(BaseEntity.Slot.Lock, lockentity);
            }
        }

        BuildingBlock SpawnStructure(GameObject prefab, Vector3 pos, Quaternion angles, BuildingGrade.Enum grade)
        {
            GameObject build = UnityEngine.Object.Instantiate(prefab);
            if (build == null) return null;
            BuildingBlock block = build.GetComponent<BuildingBlock>();
            if (block == null) return null;
            block.transform.position = pos;
            block.transform.rotation = angles;
            block.gameObject.SetActive(true);
            block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);
            block.Spawn(true);
            block.SetGrade(grade);
            block.health = block.MaxHealth();
            return block;

        }
        #endregion
        public class Maze
        {           
            public MazeCell[,,] CompleteMaze;

            public Maze(int x_size, int y_size, int z_size, int genType = 0)
            {
                CompleteMaze = new MazeCell[x_size, y_size, z_size];
                for (int x = 0; x < x_size; x++)
                {
                    for (int y = 0; y < y_size; y++)
                    {
                        for (int z = 0; z < z_size; z++)
                        {
                            CompleteMaze[x, y, z] = new MazeCell(x, y, z);
                        }
                    }
                }
                GenerateMaze(x_size, y_size, z_size, genType);

            }
            private void GenerateMaze(int maxX, int maxY, int maxZ, int genType = 0)
            {
                System.Random rnd = new System.Random();
                int sX = rnd.Next(maxX), sY = rnd.Next(maxY), sZ = rnd.Next(maxZ); //Random Generation Start Point attempt
                //int sX = 0, sY = 0, sZ = 0;
                CompleteMaze[0, 0, 0].WBot = false;
               
                List<MazeCell> mList = new List<MazeCell>();                
                
                mList.Add(CompleteMaze[rnd.Next(maxX), rnd.Next(maxY), rnd.Next(maxZ)]);
                CompleteMaze[sX, sY, sZ].visited = true;

                if (maxZ > 1)
                    CompleteMaze[maxX - 1, maxY - 1, rnd.Next(1, maxZ)].WTop = false;
                else
                    CompleteMaze[maxX - 1, maxY - 1, 0].WTop = false;
                int index = 0;
                int dir = 0;
                int nX = 0, nY = 0, nZ = 0;
                int tX, tY, tZ;
                bool found = false;

                //TEST - making UP/Down ways much less to apear (attempt atleast) :P
                int floor_chance_init = (int)((maxX * maxY * maxZ)/50) > 0 ? (int)((maxX * maxY * maxZ)/50) : 1;
                int floor_chance = floor_chance_init;
                int floor_switch = 1;
                int norm_item = 0;
                do
                {
                    switch (genType)
                    {
                        case 0:
                            //Latest
                            index = mList.Count - 1;
                            break;
                        case 1:
                            //Random!
                            index = rnd.Next(mList.Count);
                            break;
                        case 2:
                            if (rnd.Next(2) == 1) //50/50 Newest/Random
                                index = rnd.Next(mList.Count);
                            else
                                index = rnd.Next(mList.Count - 1);
                            break;
                        case 3:
                            if (rnd.Next(4) == 1)//75/25 Newest/Random
                                index = rnd.Next(mList.Count);
                            else
                                index = rnd.Next(mList.Count - 1);
                            break;
                        case 4:
                            if (rnd.Next(4) != 1)//25/75 Newest/Random
                                index = rnd.Next(mList.Count);
                            else
                                index = rnd.Next(mList.Count - 1);
                            break;
                        default:
                            index = mList.Count - 1;
                            break;
                    }

                    nX = mList[index].x;
                    nY = mList[index].y;
                    nZ = mList[index].z;
                    //int[] randomNumbers;
                    var randomNumbers = Enumerable.Range(0, 5).OrderBy(x => rnd.Next()).Take(5).ToList();
                    //var randomNumbers = Enumerable.Range(0, 6).OrderBy(x => rnd.Next()).Take(6).ToList();
                    found = false;
                    tX = nX; tY = nY; tZ = nZ;

                    foreach (int item in randomNumbers)
                    {
                        norm_item = item;
                        if (item == 4)
                        {                            
                            int up_down = rnd.Next(floor_chance + 1);
                            if (up_down == floor_chance)
                            {                                
                                norm_item = 4;
                            }
                            else if (up_down == floor_chance - 1)
                            {
                                norm_item = 5;
                            }
                            else
                                continue;
                        }
                        switch (norm_item)
                        {
                            case 0:
                                tY = nY + 1; tX = nX; tZ = nZ; found = true;
                                break;
                            case 1:
                                tY = nY; tX = nX + 1; tZ = nZ; found = true;
                                break;
                            case 2:
                                tY = nY - 1; tX = nX; tZ = nZ; found = true;
                                break;
                            case 3:
                                tY = nY; tX = nX - 1; tZ = nZ; found = true;
                                break;
                            case 4:
                                tY = nY; tX = nX; tZ = nZ + 1; found = true;
                                break;
                            case 5:
                                tY = nY; tX = nX; tZ = nZ - 1; found = true;
                                break;
                        }

                        if (tY >= 0 && tX >= 0 && tZ >= 0 && tX < maxX && tY < maxY && tZ < maxZ && found)
                        {
                            if (!CompleteMaze[tX, tY, tZ].visited)//Double Floor check
                                if ((tZ - nZ > 0 && CompleteMaze[tX, tY, tZ].Floor) || (tZ - nZ < 0 && CompleteMaze[nX, nY, nZ].Floor) || tZ - nZ == 0)
                                {
                                    if (tZ - nZ > 0 && tZ > 1)
                                    {
                                        if (CompleteMaze[tX, tY, tZ - 2].Floor)
                                            dir = norm_item;
                                            break;
                                    }
                                    else
                                    {
                                        dir = norm_item;
                                        break;
                                    }
                                }
                        }
                        found = false;
                    }
                    if (!found)
                    {
                        if (mList.Count == 1)//Temp check for tricky params when maze generation being corrupted
                            if (CheckAroundAvail(mList[0]))
                            {
                                if (mList[0].z < CompleteMaze.GetLength(2) - 1)
                                {
                                    if (!CompleteMaze[mList[0].x, mList[0].y, mList[0].z + 1].visited)
                                    {
                                        CompleteMaze[nX, nY, nZ].Floor = false;
                                        mList.Add(CompleteMaze[nX, nY, nZ + 1]);
                                        CompleteMaze[nX, nY, nZ + 1].visited = true;
                                    }
                                }
                                else if (mList[0].z > 0)
                                {
                                    if (!CompleteMaze[mList[0].x, mList[0].y, mList[0].z - 1].visited)
                                    {
                                        CompleteMaze[nX, nY, nZ - 1].Floor = false;
                                        mList.Add(CompleteMaze[nX, nY, nZ - 1]);
                                        CompleteMaze[nX, nY, nZ - 1].visited = true;
                                    }
                                }
                            }
                            else
                                mList.RemoveAt(index);
                        else
                            mList.RemoveAt(index);
                    }
                    else
                    {
                        for (int m = mList.Count - 1; m > 0; m--) //Test Algorythm, should increase passage length for 1-4 creation variants
                        {
                            if (!CheckAroundAvail(mList[m]))
                                mList.RemoveAt(m);
                        }
                        if (dir == 4 || dir == 5)
                        {
                            floor_switch++;
                            floor_chance *= floor_switch;
                        }
                        else
                        {
                            if (floor_chance > 100) floor_chance = (int)Math.Sqrt(floor_chance);
                            else if (floor_chance > floor_chance_init * 2)
                                floor_chance = floor_chance - 1 > 0 ? floor_chance - 1 : 3;
                        }
                        switch (dir)
                        {
                            case 0:
                                CompleteMaze[nX, nY, nZ].WTop = false;
                                CompleteMaze[tX, tY, tZ].WBot = false;
                                break;
                            case 1:
                                CompleteMaze[nX, nY, nZ].WRight = false;
                                CompleteMaze[tX, tY, tZ].WLeft = false;
                                break;
                            case 2:
                                CompleteMaze[nX, nY, nZ].WBot = false;
                                CompleteMaze[tX, tY, tZ].WTop = false;
                                break;
                            case 3:
                                CompleteMaze[nX, nY, nZ].WLeft = false;
                                CompleteMaze[tX, tY, tZ].WRight = false;
                                break;
                            case 4:
                                CompleteMaze[nX, nY, nZ].Floor = false;
                                break;
                            case 5:
                                CompleteMaze[tX, tY, tZ].Floor = false;
                                break;
                        }
                        CompleteMaze[tX, tY, tZ].visited = true;
                        mList.Add(CompleteMaze[tX, tY, tZ]);
                    }
                } while (mList.Count > 0);
            }
            private bool CheckAroundAvail(MazeCell mc)
            {
                if (mc.x > 0)                
                    if (!CompleteMaze[mc.x - 1, mc.y, mc.z].visited)
                        return true;
                if (mc.y > 0)
                    if (!CompleteMaze[mc.x, mc.y - 1, mc.z].visited)
                        return true;
                if (mc.z > 0)
                    if (!CompleteMaze[mc.x, mc.y, mc.z - 1].visited)
                        return true;
                if (mc.x < CompleteMaze.GetLength(0) - 1)
                    if (!CompleteMaze[mc.x + 1, mc.y, mc.z].visited)
                        return true;
                if (mc.y < CompleteMaze.GetLength(1) - 1)
                    if (!CompleteMaze[mc.x, mc.y + 1, mc.z].visited)
                        return true;
                if (mc.z < CompleteMaze.GetLength(2) - 1)
                    if (!CompleteMaze[mc.x, mc.y, mc.z + 1].visited)
                        return true;

                return false;
            }

            private static object GetDeploy(string dName, Vector3 playerRot, Vector3 pos)
            {
                Dictionary<string, object> data = new Dictionary<string, object>();
                Dictionary<string, object> posCleanData = new Dictionary<string, object>();
                Dictionary<string, object> rotCleanData = new Dictionary<string, object>();

                if (dName == "items/large_woodbox_deployed")
                    data.Add("items", new List<object>());

                data.Add("prefabname", dName);

                posCleanData.Add("x", pos.x);
                posCleanData.Add("y", pos.y);
                posCleanData.Add("z", pos.z);
                data.Add("pos", posCleanData);

                rotCleanData.Add("x", playerRot.x);
                rotCleanData.Add("y", playerRot.y);
                rotCleanData.Add("z", playerRot.z);
                data.Add("rot", rotCleanData);
                return data;
            }

            public List<object> GetEntranceExit()
            {
                List<object> entranceExit = new List<object>();
                Vector3 playerRot = new Vector3(0, 0, 0);
                Vector3 blockV3 = new Vector3(0, 0, 6f);
                entranceExit.Add(GetBlock("build/foundation", 4, playerRot, blockV3));
                blockV3 = new Vector3(0, 0, 3f);
                entranceExit.Add(GetBlock("build/foundation", 4, playerRot, blockV3));
                blockV3 = new Vector3(0, 0, 0);
                entranceExit.Add(GetBlock("build/foundation", 4, playerRot, blockV3));
                blockV3 = new Vector3(0, 0, 4.5f);
                entranceExit.Add(GetBlock("build/wall", 4, new Vector3(0, -90f, 0), blockV3));
                blockV3 = new Vector3(-1.5f, 0, 6f);
                entranceExit.Add(GetBlock("build/wall", 4, playerRot, blockV3));
                blockV3 = new Vector3(1.5f, 0, 6f);
                entranceExit.Add(GetBlock("build/wall", 4, playerRot, blockV3)); 
                blockV3 = new Vector3(0, 0, 3f);
                entranceExit.Add(GetBlock("build/block.halfheight", 4, playerRot, blockV3));
                blockV3 = new Vector3(0, 1.5f, 3f);
                entranceExit.Add(GetBlock("build/block.halfheight.slanted", 4, new Vector3(0f, 180f, 0f), blockV3));
                blockV3 = new Vector3(0, 0, 0f);
                entranceExit.Add(GetBlock("build/block.halfheight.slanted", 4, new Vector3(0f, 180f, 0f), blockV3)); 

                return entranceExit;
            }

            private static object GetBlock(string bName, int grade, Vector3 playerRot, Vector3 pos)
            {
                Dictionary<string, object> data = new Dictionary<string, object>();
                Dictionary<string, object> posCleanData = new Dictionary<string, object>();
                Dictionary<string, object> rotCleanData = new Dictionary<string, object>();


                data.Add("prefabname", bName);
                data.Add("grade", grade);

                posCleanData.Add("x", pos.x);
                posCleanData.Add("y", pos.y);
                posCleanData.Add("z", pos.z);
                data.Add("pos", posCleanData);

                rotCleanData.Add("x", playerRot.x);
                rotCleanData.Add("y", playerRot.y);
                rotCleanData.Add("z", playerRot.z);
                data.Add("rot", rotCleanData);
                return data;
            }

            public class MazeCell
            {
                public bool WTop = true;
                public bool WLeft = true;
                public bool WRight = true;
                public bool WBot = true;
                public bool visited = false;
                public bool Floor = true;
                public int x, y, z;
                public MazeCell(int _x, int _y, int _z)
                {
                    x = _x;
                    y = _y;
                    z = _z;
                }
                public List<object> GetCellDeploys(bool EntranceExit = true, bool L_Ladders = true)
                {
                    List<object> cellDeploys = new List<object>();
                    Vector3 playerRot = new Vector3(0, 0, 0);
                    Vector3 blockV3;
                    float zShift = 3f;
                    float xShift = 3f;
                    float yShift = 3f;
                    float entranceShift = EntranceExit ? 9f : 0f;
                    if (!this.Floor && !L_Ladders)
                    {
                        //Crazy way to create random rotated ladder
                        blockV3 = new Vector3(x * xShift + xShift / 4, z * zShift, y * yShift + yShift / 4 + entranceShift);
                        cellDeploys.Add(GetDeploy("items/cupboard.tool.deployed", playerRot, blockV3));
                        blockV3 = new Vector3(x * xShift - xShift / 5, z * zShift, y * yShift + yShift / 4 + entranceShift);
                        cellDeploys.Add(GetDeploy("items/large_woodbox_deployed", playerRot, blockV3));

                    }
                    return cellDeploys;
                }

                public List<object> GetCellObjects(int zMax = 1, bool topFloor = false, bool EntranceExit = true, bool L_Ladders = true)
                {
                    List<object> cellObjects = new List<object>();
                    float zShift = 3f;
                    float xShift = 3f;
                    float yShift = 3f;
                    float entranceShift = EntranceExit ? 9f : 0f;
                    Vector3 wallRot = new Vector3(0, -90f, 0);                    
                    Vector3 playerRot = new Vector3(0, 0, 0);
                    Vector3 blockV3;
                    //Foundation
                    if (z == 0)
                    {
                        blockV3 = new Vector3(x * xShift, 0, y * yShift + entranceShift);
                        cellObjects.Add(GetBlock("build/foundation", 4, playerRot, blockV3));
                    }
                    if (x == 0 && this.WLeft)
                    {
                        blockV3 = new Vector3(-xShift / 2, z * zShift, y * yShift + entranceShift);
                        cellObjects.Add(GetBlock("build/wall", 4, playerRot, blockV3));                        
                    }

                    if (y == 0 && this.WBot)
                    {
                        blockV3 = new Vector3(x * xShift, z * zShift, -yShift / 2 + entranceShift);
                        cellObjects.Add(GetBlock("build/wall", 4, wallRot, blockV3));                        
                    }

                    //normal walls
                    //TOP
                    if (this.WTop)
                    {
                        blockV3 = new Vector3((x * xShift), z * zShift, y * yShift + yShift / 2 + entranceShift);
                        cellObjects.Add(GetBlock("build/wall", 4, wallRot, blockV3));
                    }
                    //Right
                    if (this.WRight)
                    {
                        blockV3 = new Vector3((x * xShift) + xShift / 2, z * zShift, y * yShift + entranceShift);
                        cellObjects.Add(GetBlock("build/wall", 4, playerRot, blockV3));
                    }

                    if (this.Floor && (z < zMax - 1 || topFloor))
                    {
                        blockV3 = new Vector3(x * xShift, z * zShift + zShift, y * yShift + entranceShift);
                        cellObjects.Add(GetBlock("build/floor", 4, playerRot, blockV3));                        
                    }
                    else if (z < zMax - 1 && L_Ladders)
                    {
                        if (!this.WBot)
                        {
                            //Low Wall ladder - Rotation |""
                            blockV3 = new Vector3(x * xShift - 0.4f, z * zShift + 0.9f, y * yShift - 0.7f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(-35f, 0, 90f), blockV3)); //|
                            blockV3 = new Vector3(x * xShift + 0.3f, z * zShift + 2.3f, y * yShift + 0.3f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(-30f, 90f, 90f), blockV3)); //""
                        }
                        else if (!this.WTop) //Rotation |_ 
                        {
                            //Low Wall
                            blockV3 = new Vector3(x * xShift - 0.3f, z * zShift + 0.9f, y * yShift + 0.7f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(40f, 0, 90f), blockV3));//|
                            blockV3 = new Vector3(x * xShift + 0.3f, z * zShift + 2.3f, y * yShift - 1.2f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(-30f, 90f, 90f), blockV3));//_
                        }
                        else if (!this.WLeft) //Rotation ""| 
                        {
                            blockV3 = new Vector3(x * xShift + 1.5f, z * zShift + 2.3f, y * yShift - 0.7f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(30f, 0, 90f), blockV3)); //|
                            blockV3 = new Vector3(x * xShift - 0.7f, z * zShift + 0.9f, y * yShift + 0.3f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(-35f, 90f, 90f), blockV3)); //""
                        }
                        else //Rotation |_
                        {
                            blockV3 = new Vector3(x * xShift - 0.4f, z * zShift + 2.3f, y * yShift + 0.6f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(-35f, 0, 90f), blockV3));//|
                            blockV3 = new Vector3(x * xShift + 0.5f, z * zShift + 0.9f, y * yShift - 1.2f + entranceShift);
                            cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(40f, 90f, 90f), blockV3)); //""
                        }
                        ////Low Wall
                        //blockV3 = new Vector3(x * xShift-0.4f, z * zShift + zShift, y * yShift);
                        //cellObjects.Add(GetBlock("build/wall.low", 4, new Vector3(0f, 0, 90f), blockV3));                        

                        //blockV3 = new Vector3(x * xShift, z * zShift, y * yShift);
                        //cellObjects.Add(GetBlock("build/block.halfheight.slanted", 4, new Vector3(0, 0, 0), blockV3));                        
                    }

                    return cellObjects;

                }               
            }
        }

    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\NoDistanceLoot.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;


namespace Oxide.Plugins
{
    [Info("NoDistanceLoot", "4seti [Lunatiq] for Rust Planet", "0.1.1", ResourceId = 000)]
    public class NoDistanceLoot : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion


        void Loaded()
        {
            Log("Loaded");
        }

        Dictionary<BasePlayer, string> looters = new Dictionary<BasePlayer, string>();

        [HookMethod("OnPlayerLoot")]
        void OnPlayerLoot(PlayerLoot lootInventory, UnityEngine.Object entry)
        {
            BasePlayer looter = lootInventory.GetComponent("BasePlayer") as BasePlayer;
            if (looters.ContainsKey(looter))            
                looters.Remove(looter);
            
            if (entry is BasePlayer)
            {
                BasePlayer target = entry as BasePlayer;              
                if (target.IsAlive() && !target.IsSleeping())
                {
                    looter.ChatMessage("Finish him before loot!");
                    looter.SendConsoleCommand("inventory.endloot");
                    looter.UpdateNetworkGroup();
                    looter.SendFullSnapshot();
                }
                else if (target.IsSleeping())
                {
                    looters.Add(looter, target.userID.ToString());
                }
            }

        }
        [HookMethod("OnPlayerSleepEnded")]
        void OnPlayerSleepEnded(BasePlayer player)
        {
			if (player != null)
			{
				if (looters.ContainsValue(player.userID.ToString()))
				{
					var looter = looters.FirstOrDefault(x => x.Value == player.userID.ToString()).Key;		
					if(looter.IsConnected()){					
						looter.SendConsoleCommand("inventory.endloot");
						looter.UpdateNetworkGroup();
						looter.SendFullSnapshot();
					}					
						looters.Remove(looter);					
				}
			}
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\NoSigns.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Signs", "bawNg", 0.4)]
    class NoSigns : RustPlugin
    {
        string notAllowedMessage = "<color=red>You are not allowed to use signs on this server</color>";

        void Loaded()
        {
            var signs = UnityEngine.Object.FindObjectsOfType<Signage>();
            Puts($"[No Signs] Removing {signs.Length} signs from the map...");
            foreach (var sign in signs) sign.Kill();
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            var player = container.playerOwner;
            if (!player || !item.info) return;
            
            if (!player.IsAdmin() && item.info.shortname.StartsWith("sign."))
            {
                PrintToChat(player, notAllowedMessage);
                item.Remove(0f);
            }
        }

        object OnCanCraft(ItemCrafter item_crafter, ItemBlueprint blueprint, int amount)
        {
            if (item_crafter.containers.Count < 1) return false;

            var item = blueprint.targetItem;
            if (!item) return null;

            var player = item_crafter.containers[0].playerOwner;
            if (!player) return null;

            if (!player.IsAdmin() && item.shortname.StartsWith("sign."))
            {
                PrintToChat(player, notAllowedMessage);
                return false;
            }

            return null;
        }

        void OnEntityBuilt(Planner planner, GameObject game_object)
        {
            if (game_object == null) return; // sphere check failed

            var player = planner.ownerPlayer;
            var entity = game_object.GetComponent<Signage>();
            if (!player || !entity) return;

            if (!player.IsAdmin() && entity.LookupPrefabName().StartsWith("signs/"))
            {
                PrintToChat(player, notAllowedMessage);
                entity.Kill();
            }
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\PathFinding.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust
// Reference: RustBuild

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("PathFinding", "Reneb", "0.0.5")]
    class PathFinding : RustPlugin
    { 
        public class Pathfinder
        {
            public SortedList<float, List<PathfindNode>> SortNode;
            public Hash<Vector3, PathfindNode> NodeList;
            public Hash<Vector3, bool> ClosedList;
            public List<PathfindNode> RunDetection;

            public PathfindNode targetNode;

            public float currentPriority;

            public int Loops;

            public bool shouldBreak;
             
            public Pathfinder()
            {
                SortNode = new SortedList<float, List<PathfindNode>>();
                NodeList = new Hash<Vector3, PathfindNode>();
                RunDetection = new List<PathfindNode>();
                ClosedList = new Hash<Vector3, bool>();
            }
            public List<Vector3> FindPath(Vector3 sourcePos, Vector3 targetPos)
            {
                Reset();
                this.targetNode = new PathfindNode(this);
                PathfindGoal(this, this.targetNode, targetPos);
                PathfindFirst(this, new PathfindNode(this), sourcePos);
                 
                while (true) 
                {
                    currentPriority = SortNode.Keys[0];
                    foreach (PathfindNode pathnode in (SortNode[currentPriority]))
                        RunDetection.Add(pathnode);
                    SortNode.Remove(currentPriority);
                    foreach (PathfindNode pathnode in RunDetection)
                    {
                        pathnode.DetectAdjacentNodes();
                        if (pathnode.isGoal) { targetNode.parentNode = pathnode; shouldBreak = true; }
                    }
                    RunDetection.Clear();
                    Loops++;
                    if (Loops > MaxLoops) { Reset(); return null; }
                    if (shouldBreak) break;
                }
                
                PathfindNode parentnode = targetNode.parentNode;
                List<Vector3> PlayerPath = new List<Vector3>();
                while (true)
                {
                    PlayerPath.Add(parentnode.position);
                    parentnode = parentnode.parentNode;
                    if (parentnode == null) break;
                }
                PlayerPath.Reverse();
                PlayerPath.RemoveAt(0);
                Reset();
                return PlayerPath;
            }
            public void Reset()
            {
                currentPriority = 0f;
                SortNode.Clear();
                RunDetection.Clear();
                NodeList.Clear();
                Loops = 0;
                shouldBreak = false;
            }

            public void AddToPriorityList(PathfindNode currentNode)
            {
                if (!SortNode.ContainsKey(currentNode.F)) SortNode.Add(currentNode.F, new List<PathfindNode>());
                ((List<PathfindNode>)SortNode[currentNode.F]).Add(currentNode);
            }
        }

        public class PathfindNode
        {
            // FIELDS
            public float H = 0f;
            public float G = 0f;
            public float F = 0f;
            public PathfindNode parentNode = null;
            public PathfindNode north = null;
            public PathfindNode northeast = null;
            public PathfindNode northwest = null;
            public PathfindNode east = null;
            public PathfindNode south = null;
            public PathfindNode southeast = null;
            public PathfindNode southwest = null;
            public PathfindNode west = null;
            public Vector3 position;
            public Vector3 positionEyes;
            public bool isGoal = false;
            public Pathfinder pathfinder;

            /// 
            /// PathfindNode()
            /// Raw pathfind creation
            public PathfindNode(Pathfinder pathfinder)
            {
                this.pathfinder = pathfinder;
            }

            /// 
            /// PathfindNode(PathfindNode parentnode, Vector3 position, bool diagonal)
            /// This is called by all new pathnodes
            public PathfindNode(Pathfinder pathfinder, PathfindNode parentnode, Vector3 position, bool diagonal)
            {
                this.pathfinder = pathfinder;
                this.position = position;
                this.positionEyes = new Vector3(position.x, Mathf.Ceil(position.y) + 0.5f, position.z);
                this.parentNode = parentnode;
                CalculateManhattanDistance(this, pathfinder.targetNode);
                CalculateMovementCost(this, diagonal);
                this.F = this.H + this.G;
                pathfinder.AddToPriorityList(this);
            }

            // METHODS 

            // DetectAdjacentNodes()
            // This automatically creates the surrounding pathnodes
            public void DetectAdjacentNodes()
            {
                if(!pathfinder.ClosedList[this.positionEyes + VectorForward])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorForward, blockLayer))
                        north = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorForward, false);
                if (!pathfinder.ClosedList[this.positionEyes + VectorRight])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorRight, blockLayer))
                        east = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorRight, false);
                if (!pathfinder.ClosedList[this.positionEyes + VectorBack])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorBack, blockLayer))
                        south = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorBack, false);
                if (!pathfinder.ClosedList[this.positionEyes + VectorLeft])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorLeft, blockLayer))
                        west = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorLeft, false);

                if (!pathfinder.ClosedList[this.positionEyes + VectorForwardRight])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorForwardRight, blockLayer))
                        northeast = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorForwardRight, true);
                if (!pathfinder.ClosedList[this.positionEyes + VectorForwardLeft])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorForwardLeft, blockLayer))
                        northwest = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorForwardLeft, true);
                if (!pathfinder.ClosedList[this.positionEyes + VectorBackLeft])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorBackLeft, blockLayer))
                    southeast = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorBackLeft, true);
                if (!pathfinder.ClosedList[this.positionEyes + VectorBackRight])
                    if (!Physics.Linecast(this.positionEyes, this.positionEyes + VectorBackRight, blockLayer))
                     southwest = FindPathNodeOrCreate(this.pathfinder, this, this.positionEyes + VectorBackRight, true);
            }
        }
        // Here we calculate the movement cost between 2 points.
        private static void CalculateMovementCost(PathfindNode currentNode, bool diagonal) { currentNode.G = currentNode.parentNode.G + (diagonal ? 14f : 10f); }

        // Here we calculate the distance between the current node and the target node
        private static void CalculateManhattanDistance(PathfindNode currentNode, PathfindNode targetNode) { currentNode.H = ((Mathf.Abs(currentNode.positionEyes.x - targetNode.positionEyes.x) + Mathf.Abs(currentNode.positionEyes.z - targetNode.positionEyes.z) + Mathf.Abs(currentNode.positionEyes.y - targetNode.positionEyes.y)) * 10); }

        // Create a new node or get the node information
        public static PathfindNode FindPathNodeOrCreate(Pathfinder pathfinder, PathfindNode parentnode, Vector3 position, bool diagonal)
        {
            pathfinder.ClosedList[position] = true;
            if (!FindGroundPosition(position, out GroundPosition, out FixedGroundPosition)) return null;
            if (pathfinder.NodeList[FixedGroundPosition] == null) pathfinder.NodeList[FixedGroundPosition] = new PathfindNode(pathfinder, parentnode, GroundPosition, diagonal);
            else if (pathfinder.NodeList[FixedGroundPosition].isGoal) { pathfinder.targetNode.parentNode = parentnode; parentnode.isGoal = true; }
            return null;
        }

        public static bool FindGroundPosition(Vector3 sourcePos, out Vector3 groundPos, out Vector3 fixedPos)
        {
            groundPos = fixedPos = sourcePos;
            if (Physics.Raycast(sourcePos, Vector3Down, out hitinfo, groundLayer))
            {
                groundPos.y = hitinfo.point.y;
                fixedPos.y = Mathf.Ceil(hitinfo.point.y);
                return true;
            }
            return false;
        }
        public static bool FindRawGroundPosition(Vector3 sourcePos, out Vector3 groundPos)
        {
            groundPos = sourcePos;
            if (Physics.Raycast(sourcePos, Vector3Down, out hitinfo, groundLayer))
            {
                groundPos.y = hitinfo.point.y;
                return true;
            }
            return false;
        }
        public static bool FindRawGroundPositionUP(Vector3 sourcePos, out Vector3 groundPos)
        {
            groundPos = sourcePos;
            if (Physics.Raycast(sourcePos, Vector3UP, out hitinfo, groundLayer))
            {
                groundPos.y = hitinfo.point.y;
                return true;
            }
            return false;
        }
        /// PathfindNode(Vector3 position, Quaternion rotation)
        /// This is called by the First Path

        public static void PathfindFirst(Pathfinder pathfinder, PathfindNode pathfindnode, Vector3 position)
        {
            pathfindnode.position = position;
            pathfindnode.positionEyes = new Vector3(Mathf.Floor(position.x), Mathf.Ceil(position.y) + 0.5f, Mathf.Floor(position.z));
            pathfindnode.H = 0;
            pathfindnode.G = 0;
            pathfindnode.F = 0;
            pathfinder.AddToPriorityList(pathfindnode);
        }

        /// 
        /// PathfindNode(Vector3 position)
        /// This is called by the Goal
        public static void PathfindGoal(Pathfinder pathfinder, PathfindNode pathfindnode, Vector3 position)
        {
            pathfindnode.position = position;
            pathfindnode.positionEyes = new Vector3(Mathf.Floor(position.x), Mathf.Ceil(position.y) + 0.5f, Mathf.Floor(position.z));
            pathfindnode.isGoal = true;
            pathfinder.NodeList[pathfindnode.positionEyes - EyesPosition] = pathfindnode;
        }

        class PathFollower : MonoBehaviour
        {
            public List<Vector3> Paths = new List<Vector3>();
            public float secondsTaken;
            public float secondsToTake;
            public float waypointDone;
            public float speed;
            public Vector3 StartPos;
            public Vector3 EndPos;
            public Vector3 nextPos;
            public BaseEntity entity;
            public BasePlayer player;

            void Awake()
            {
                entity = GetComponent<BaseEntity>();
                if (GetComponent<BasePlayer>() != null) player = GetComponent<BasePlayer>();
                speed = 4f;
            }
            void Move() {
                if (secondsTaken == 0f) FindNextWaypoint();
                Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }
            void Execute_Move()
            {
                if (StartPos != EndPos) {
                    secondsTaken += Time.deltaTime;
                    waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                    nextPos = Vector3.Lerp(StartPos, EndPos, waypointDone);
                    entity.transform.position = nextPos; 
                    if (player != null) player.ClientRPC(null, player, "ForcePositionTo", nextPos);
                    entity.TransformChanged();
                }
            } 
            void FindNextWaypoint()
            {
                if (Paths.Count == 0) { StartPos = EndPos = Vector3.zero; enabled = false; return; }
                SetMovementPoint(Paths[0], 4f); 
            }

            public void SetMovementPoint(Vector3 endpos, float s)
            {
                
                StartPos = entity.transform.position;
                if (endpos != StartPos) {
                    EndPos = endpos;
                    secondsToTake = Vector3.Distance(EndPos, StartPos) / s;
                    entity.transform.rotation = Quaternion.LookRotation(EndPos - StartPos);
                    if (player != null) SetViewAngle(player, entity.transform.rotation);
                    secondsTaken = 0f;
                    waypointDone = 0f;
                } 
                Paths.RemoveAt(0);
            }
            void FixedUpdate() { Move(); }
        }
        static void SetViewAngle(BasePlayer player, Quaternion ViewAngles)
        {
            viewangles.SetValue(player, ViewAngles);
            player.SendNetworkUpdate(BasePlayer.NetworkQueue.Positional);
        }


        public static RaycastHit hitinfo;

        public static Vector3 jumpPosition = new Vector3(0f, 1f, 0f);
        public static Vector3 GroundPosition = new Vector3(0f, 0f, 0f);
        public static Vector3 FixedGroundPosition = new Vector3(0f, 0f, 0f);
        public static Vector3 EyesPosition = new Vector3(0f, 0.5f, 0f);
        public static Vector3 Vector3Down = new Vector3(0f, -1f, 0f);
        public static Vector3 Vector3UP = new Vector3(0f, 1f, 0f);
        public static Vector3 VectorForward = new Vector3(0f, 0f, 1f);
        public static Vector3 VectorBack = new Vector3(0f, 0f, -1f);
        public static Vector3 VectorRight = new Vector3(1f, 0f, 0f);
        public static Vector3 VectorLeft = new Vector3(-1f, 0f, 0f);
        public static Vector3 VectorForwardRight = VectorForward + VectorRight;
        public static Vector3 VectorForwardLeft = VectorForward + VectorLeft;
        public static Vector3 VectorBackRight = VectorBack + VectorRight;
        public static Vector3 VectorBackLeft = VectorBack + VectorLeft;

        public static int groundLayer;
        public static int blockLayer;


        private Quaternion currentRot;
        public Quaternion viewAngle;
        private static FieldInfo serverinput;
        private static FieldInfo viewangles;
        public object closestEnt;
        public Vector3 closestHitpoint;

        private Oxide.Plugins.Timer PathfindingTimer;



        private static int MaxLoops = 500;

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("Max Loops", ref MaxLoops);
            SaveConfig();
        }


        ///////////////////////////////////////////// 
        /// OXIDE HOOKS
        ///////////////////////////////////////////// 

        void OnServerInitialized()
        {
            groundLayer = LayerMask.GetMask(new string[] { "Terrain", "World", "Construction" });
            blockLayer = LayerMask.GetMask(new string[] { "World", "Construction", "Tree" });

            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            viewangles = typeof(BasePlayer).GetField("viewAngles", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

            PathfindingTimer = timer.Once(30f, () => ResetPathFollowers());
        }
        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(PathFollower));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        ///////////////////////////////////////////// 
        /// Outside Plugin Calls
        ///////////////////////////////////////////// 
        
        bool FindAndFollowPath(BaseEntity entity, Vector3 sourcePosition, Vector3 targetPosition)
        {
            //var curtime = Time.realtimeSinceStartup;
            var bestPath = FindBestPath(sourcePosition, targetPosition);
            //Debug.Log((Time.realtimeSinceStartup - curtime).ToString());
            if (bestPath == null) return false;
            FollowPath(entity, bestPath);
            return true;
        }

        void FollowPath(BaseEntity entity, List<Vector3> pathpoints)
        {
            PathFollower pathfollower;
            if (entity.GetComponent<PathFollower>() != null) pathfollower = entity.GetComponent<PathFollower>();
            else pathfollower = entity.gameObject.AddComponent<PathFollower>();
            pathfollower.Paths = pathpoints;
            pathfollower.enabled = true;
        }
        List<Vector3> FindBestPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            List<Vector3> bestPath = FindLinePath(sourcePosition, targetPosition);
            if(bestPath == null) bestPath = FindPath(sourcePosition, targetPosition);
            return bestPath;
        }

        List<Vector3> FindPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            var path = new Pathfinder();
            var FoundPath = path.FindPath(sourcePosition, targetPosition);
            path = null;
            return FoundPath;
        }

        List<Vector3> FindLinePath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            float distance = (int)Mathf.Ceil(Vector3.Distance(sourcePosition, targetPosition));
            Hash<float,Vector3> StraightPath = new Hash<float, Vector3>();
            StraightPath[0f] = sourcePosition;
            Vector3 currentPos;
            for(float i = 1f; i < distance; i++)
            {
                currentPos = Vector3.Lerp(sourcePosition, targetPosition, i/ distance);
                if (!FindRawGroundPosition(currentPos, out GroundPosition))
                    if (!FindRawGroundPositionUP(currentPos, out GroundPosition))
                        return null;
                if (Vector3.Distance(GroundPosition, StraightPath[i - 1f]) > 2) return null;
                if (Physics.Linecast(StraightPath[i - 1f] + jumpPosition, GroundPosition + jumpPosition, blockLayer)) return null;
                StraightPath[i] = GroundPosition;
            }
            if (Physics.Linecast(StraightPath[distance - 1f] + jumpPosition, targetPosition + jumpPosition, blockLayer)) return null;
            StraightPath[distance] = targetPosition;
            StraightPath.Remove(0f);
            
            List<Vector3> straightPath = new List<Vector3>();
            foreach (KeyValuePair<float, Vector3> pair in StraightPath) { straightPath.Add(pair.Value); }
            StraightPath.Clear(); 
            return straightPath;
        }

        ///////////////////////////////////////////// 
        /// Reset part of the plugin
        ///////////////////////////////////////////// 
        void ResetPathFollowers()
        {
            var objects = GameObject.FindObjectsOfType(typeof(PathFollower));
            if (objects != null)
                foreach (PathFollower gameObj in objects)
                    if(gameObj.Paths.Count == 0)
                        GameObject.Destroy(gameObj);
        }

        ///////////////////////////////////////////// 
        /// Debug Command
        ///////////////////////////////////////////// 
        [ChatCommand("path")]
        void cmdChatPath(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1) return;
            if (!TryGetPlayerView(player, out currentRot)) return;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;

            FindAndFollowPath(player, player.transform.position, closestHitpoint);
        }

        bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input == null) return false;
            if (input.current == null) return false;
            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }
        bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            UnityEngine.Ray ray = new UnityEngine.Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = UnityEngine.Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            foreach (var hit in hits)
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.collider;
                        closestHitpoint = hit.point;
                    }

            if (closestEnt is bool) return false;
            return true;
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Pets.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: RustBuild
// Reference: Newtonsoft.Json

using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Pets", "Bombardir", "0.3.2", ResourceId = 851)]
    class Pets : RustPlugin
	{
        private static FieldInfo serverinput;
        private static MethodInfo SetDeltaTimeMethod;
        private static Pets PluginInstance;
        private static BUTTON MainButton;
        private static BUTTON SecondButton;
        private static Dictionary<string, PetInfo> SaveNpcList;
        public enum Act { Move, Attack, Eat, Follow, Sleep, None }

        #region NPC Controller Class

        public class NpcControl : MonoBehaviour 
		{
            private static float ButtonReload = 0.3f;
            private static float DrawReload = 0.05f;
            internal static float LootDistance = 1f;
            internal static float ReloadControl = 60f;
            internal static float MaxControlDistance = 10f;

            internal bool DrawEnabled;
            private InputState input;
            private float NextTimeToPress;
            private float NextTimeToControl;
            private float NextTimeToDraw;

            public NpcAI npc;
            public BasePlayer owner;
		
			void Awake() 
			{
                owner = GetComponent<BasePlayer>();
                input = serverinput.GetValue(owner) as InputState;
				enabled = false;
                NextTimeToPress = 0f;
                NextTimeToControl = 0f;
                NextTimeToDraw = 0f;
                DrawEnabled = GlobalDraw;
			}

            void OnAttacked(HitInfo info)
            {
                if (npc && info.Initiator && npc.action != Act.Attack)
                    npc.Attack(info.Initiator.GetComponent<BaseCombatEntity>());
            }

            void FixedUpdate()
            {
                float time = Time.realtimeSinceStartup;
                if (input.WasJustPressed(MainButton) && NextTimeToPress < time)
                {
                    NextTimeToPress = time + ButtonReload;
                    UpdateAction();
                }
                if (DrawEnabled && npc != null && npc.action < Act.Follow && NextTimeToDraw < time)
                {
                    NextTimeToDraw = time + DrawReload;
                    UpdateDraw();
                }
			}

            void UpdateDraw()
            {
                Vector3 drawpos = npc.action == Act.Move ? npc.targetpoint : npc.targetentity?.transform.position ?? Vector3.zero;
                if (drawpos != Vector3.zero)
                    owner.SendConsoleCommand("ddraw.arrow", new object[] { DrawReload + 0.02f, npc.action == Act.Move ? Color.cyan : npc.action == Act.Attack ? Color.red : Color.yellow, drawpos + new Vector3(0, 5f, 0), drawpos, 1.5f });
            }

            void UpdateAction()
            {
                if (npc != null && input.IsDown(SecondButton))
                    if (npc.action == Act.Follow)
                    {
                        owner.ChatMessage(UnFollowMsg);
                        npc.action = Act.None;
                    }
                    else
                    {
                        owner.ChatMessage(FollowMsg);
                        npc.Attack(owner.GetComponent<BaseCombatEntity>(), Act.Follow);
                    }
                else
                {
                    RaycastHit hit;
                    if (Physics.SphereCast(owner.eyes.position, 0.5f, Quaternion.Euler(input.current.aimAngles) * Vector3.forward, out hit) && hit.transform != transform)
                    {
                        if (npc == null)
                        {
                            BaseNPC hited = hit.transform.GetComponent<BaseNPC>();
                            if (hited != null)
                            {
                                NpcAI OwnedNpc = hited.GetComponent<NpcAI>();
                                if (OwnedNpc != null && OwnedNpc.owner != this)
                                    owner.ChatMessage(NoOwn);
                                else if (NextTimeToControl < Time.realtimeSinceStartup)
                                {
                                    if (!UsePermission || PluginInstance.HasPermission(owner, "can" + hited.modelPrefab.Remove(0, 12).Replace("_skin", "")))
                                    {
                                        if (hit.distance < MaxControlDistance)
                                        {
                                            NextTimeToControl = Time.realtimeSinceStartup + ReloadControl;
                                            owner.ChatMessage(NewPetMsg);
                                            npc = hited.gameObject.AddComponent<NpcAI>();
                                            npc.owner = this;
                                        }
                                        else
                                            owner.ChatMessage(CloserMsg);
                                    }
                                    else
                                        owner.ChatMessage(NoPermPetMsg);
                                }
                                else
                                    owner.ChatMessage(ReloadMsg);
                            }
                        }
                        else
                        {
                            BaseCombatEntity targetentity = hit.transform.GetComponent<BaseCombatEntity>();
                            if (targetentity == null)
                            {
                                npc.targetpoint = hit.point;
                                npc.action = Act.Move;
                            }
                            else
                            {
                                if (targetentity == (BaseCombatEntity)npc.Base)
                                {
                                    if (hit.distance <= LootDistance)
                                    {
                                        owner.inventory.loot.StartLootingEntity((BaseEntity)npc.Base, true);
                                        owner.inventory.loot.AddContainer(npc.inventory);
                                        owner.inventory.loot.SendImmediate();
                                        owner.ClientRPC(owner.net.connection, owner, "RPC_OpenLootPanel", "smallwoodbox");
                                    }
                                }
                                else if (targetentity is BaseCorpse)
                                {
                                    owner.ChatMessage(EatMsg);
                                    npc.Attack(targetentity, Act.Eat);
                                }
                                else
                                {
                                    owner.ChatMessage(AttackMsg);
                                    npc.Attack(targetentity);
                                }
                            }
                        }
                    }
                }
            }
		}

        #endregion
        #region NPC AI Class

        public class NpcAI : MonoBehaviour
        {
            internal static float IgnoreTargetDistance = 70f;
            internal static float HealthModificator = 1.5f;
            internal static float AttackModificator = 2f;
            internal static float SpeedModificator = 1f;

            private static float PointMoveDistance = 1f;
            private static float TargetMoveDistance = 3f;

            private float lastTick;
            private float hungerLose;
            private float thristyLose;
            private float sleepLose;
            private double attackrange;

            internal Act action;
            internal Vector3 targetpoint;
            internal BaseCombatEntity targetentity;

            public NpcControl owner;
            public ItemContainer inventory;
            public BaseNPC Base;
            public NPCAI RustAI;
            public NPCMetabolism RustMetabolism;

            private void Move(Vector3 point)
            {
                Base.state = BaseNPC.State.Normal;
                RustAI.sense.Think();
                Base.steering.Move(Vector3Ex.XZ3D(point - transform.position).normalized, point, NPCSpeed.Gallop);
            }

            internal void OnAttacked(HitInfo info)
            {
                if (info.Initiator && info.Initiator != owner.owner && action != Act.Attack)
                    Attack(info.Initiator.GetComponent<BaseCombatEntity>());
            }

            internal void Attack(BaseCombatEntity ent, Act active = Act.Attack)
            {
                targetentity = ent;
                action = active;
                attackrange = Math.Pow(Vector3Ex.Max(BoundsExtension.XZ3D(Base._collider.bounds).extents) + Base.attack.range + Vector3Ex.Max(BoundsExtension.XZ3D(ent._collider.bounds).extents), 2);
            }

            void Awake()
            {
               RustAI = GetComponent<NPCAI>();
               RustAI.ServerDestroy();
               RustMetabolism = GetComponent<NPCMetabolism>();
               Base = GetComponent<BaseNPC>();
               lastTick = Time.time;
               targetpoint = Vector3.zero;
               action = Act.None;
               hungerLose = RustMetabolism.calories.max*2 / 12000;
               thristyLose = RustMetabolism.hydration.max*3 / 12000;
               sleepLose = RustMetabolism.sleep.max / 12000;
               inventory = new ItemContainer();
               inventory.ServerInitialize((Item)null, 6);
               Base.InitializeHealth(Base.health * HealthModificator, Base.MaxHealth() * HealthModificator);
               Base.locomotion.gallopSpeed *= SpeedModificator;
               Base.locomotion.trotSpeed *= SpeedModificator;
               Base.locomotion.acceleration *= SpeedModificator;
            }

            void FixedUpdate()
            {
                SetDeltaTimeMethod.Invoke( RustAI, new object[] { Time.time - lastTick });
                if ((double)RustAI.deltaTime >= (double)server.NPCTickDelta())
                {
                    lastTick = Time.time;
                    if (!Base.IsStunned())
                    {
                        Base.Tick();

                        if (action != Act.Sleep)
                        {
                            RustMetabolism.sleep.MoveTowards(0.0f, RustAI.deltaTime * sleepLose);
                            RustMetabolism.hydration.MoveTowards(0.0f, RustAI.deltaTime * thristyLose);
                            RustMetabolism.calories.MoveTowards(0.0f, RustAI.deltaTime * hungerLose);
                        }

                        if (action != Act.None)
                            if (action == Act.Move)
                                if (Vector3.Distance(transform.position, targetpoint) < PointMoveDistance)
                                    action = Act.None;
                                else
                                    Move(targetpoint);
                            else if (action == Act.Sleep)
                            {
                                Base.state = BaseNPC.State.Sleeping;
                                Base.sleep.Recover(2f);
                                RustMetabolism.stamina.Run(4f);
                                Base.StartCooldown(2f, true);
                            }
                            else if (targetentity == null)
                            {
                                action = Act.None;
                                Base.state = BaseNPC.State.Normal;
                            }
                            else
                            {
                                float distance = Vector3.Distance(transform.position, targetentity.transform.position);
                                if (distance < IgnoreTargetDistance)
                                {
                                    if (action != Act.Follow && distance <= attackrange)
                                    {
                                        Vector3 normalized = Vector3Ex.XZ3D(targetentity.transform.position - transform.position).normalized;
                                        if (action == Act.Eat)
                                        {
                                            if (Base.diet.Eat(targetentity))
                                            {
                                                Base.Heal(Base.MaxHealth() * 0.01f);
                                                RustMetabolism.calories.Add(RustMetabolism.calories.max * 0.03f);
                                                RustMetabolism.hydration.Add(RustMetabolism.hydration.max * 0.03f);
                                            }
                                        }
                                        else if (Base.attack.Hit(targetentity, (targetentity is BaseNPC ? 1f : 2f) * AttackModificator, false))
                                            transform.rotation = Quaternion.LookRotation(normalized);
                                        Base.steering.Face(normalized);
                                    }
                                    else if (action != Act.Follow || distance > TargetMoveDistance && distance > attackrange)
                                        Move(targetentity.transform.position);
                                }
                                else
                                    action = Act.None;
                            }
                    }
                }
            }

            void OnDestroy ()
            {
                Base.InitializeHealth(Base.health / HealthModificator, Base.MaxHealth() / HealthModificator);
                Base.locomotion.gallopSpeed /= SpeedModificator;
                Base.locomotion.trotSpeed /= SpeedModificator;
                Base.locomotion.acceleration /= SpeedModificator;
                DropUtil.DropItems(inventory, transform.position);
                SaveNpcList.Remove(owner.owner.userID.ToString());
                RustAI.ServerInit();
            }
        }
        #endregion
        #region PetInfo Object to Save
        public class PetInfo
        {
            public uint prefabID;
            public uint parentNPC;
            public float x, y, z;
            public byte[] inventory;
            internal bool NeedToSpawn;

            public PetInfo() 
            {
                NeedToSpawn = true;
            }

            public PetInfo(NpcAI pet)
            {
                x = pet.transform.position.x;
                y = pet.transform.position.y;
                z = pet.transform.position.z;
                prefabID = pet.Base.prefabID;
                parentNPC = pet.Base.net.ID;
                inventory = pet.inventory.Save().ToProtoBytes();
                NeedToSpawn = false;
            }
        }
        #endregion

        #region Config & Initialisation

        private static bool UsePermission = true;
        private static bool GlobalDraw = true;
        private static string CfgButton = "USE";
        private static string CfgSecButton = "RELOAD";
        private static string ReloadMsg = "You can not tame so often! Wait!";
        private static string NewPetMsg = "Now you have a new pet!";
        private static string CloserMsg = "You need to get closer!";
        private static string NoPermPetMsg = "You don't have permission to take this NPC!";
        private static string FollowMsg = "Follow command!";
        private static string UnFollowMsg = "UnFollow command!";
        private static string SleepMsg = "Sleep command!";
        private static string AttackMsg = "Attack!";
        private static string NoPermMsg = "No Permission!";
        private static string ActivatedMsg = "NPC Mode activated!";
        private static string DeactivatedMsg = "NPC Mode deactivated!";
        private static string NotNpc = "You don't have a pet!";
        private static string NpcFree = "Now your per is free!";
        private static string NoOwn = "This npc is already tamed by other player!";
        private static string EatMsg = "Time to eat!";
        private static string DrawEn = "Draw enabled!";
        private static string DrawDis = "Draw disabled!";
        private static string DrawSysDis = "Draw system was disabled by administrator!";
        private static string InfoMsg = "<color=red>Health: {health}%</color>, <color=orange>Hunger: {hunger}%</color>, <color=cyan>Thirst: {thirst}%</color>, <color=teal>Sleepiness: {sleep}%</color>, <color=lightblue>Stamina: {stamina}%</color>";

        void LoadDefaultConfig() { }

        void Init()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Instance | BindingFlags.NonPublic));
            SetDeltaTimeMethod = typeof(NPCAI).GetProperty("deltaTime", (BindingFlags.Public | BindingFlags.Instance)).GetSetMethod(true);
            PluginInstance = this;

            CheckCfg<bool>("Use permissions", ref UsePermission);
            CheckCfg<bool>("Enable draw system", ref GlobalDraw);
            CheckCfg<string>("Main button to controll pet", ref CfgButton);
            CheckCfg<string>("Second button to use follow|unfollow", ref CfgSecButton);
            CheckCfg<float>("Reload time to take new npc", ref NpcControl.ReloadControl);
            CheckCfg<float>("Max distance to take npc", ref NpcControl.MaxControlDistance);
            CheckCfg<float>("Distance to loot npc", ref NpcControl.LootDistance);
            CheckCfg<float>("Distance when target will be ignored by NPC", ref NpcAI.IgnoreTargetDistance);
            CheckCfg<float>("Pet's Health Modificator", ref NpcAI.HealthModificator);
            CheckCfg<float>("Pet's Attack Modificator", ref NpcAI.AttackModificator);
            CheckCfg<float>("Pet's Speed Modificator", ref NpcAI.SpeedModificator);
            CheckCfg<string>("New pet msg", ref NewPetMsg);
            CheckCfg<string>("Closer msg", ref CloserMsg);
            CheckCfg<string>("No take perm msg", ref NoPermPetMsg);
            CheckCfg<string>("Follow msg", ref FollowMsg);
            CheckCfg<string>("UnFollow msg", ref UnFollowMsg);
            CheckCfg<string>("Sleep msg", ref SleepMsg);
            CheckCfg<string>("Attack msg", ref AttackMsg);
            CheckCfg<string>("No command perm msg", ref NoPermMsg);
            CheckCfg<string>("Activated msg", ref ActivatedMsg);
            CheckCfg<string>("Deactivated msg", ref DeactivatedMsg);
            CheckCfg<string>("Reload msg", ref ReloadMsg);
            CheckCfg<string>("No pet msg", ref NotNpc);
            CheckCfg<string>("Free pet msg", ref NpcFree);
            CheckCfg<string>("Already tamed msg", ref NoOwn);
            CheckCfg<string>("Eat msg", ref EatMsg);
            CheckCfg<string>("Draw enabled msg", ref DrawEn);
            CheckCfg<string>("Draw disabled msg", ref DrawDis);
            CheckCfg<string>("Draw system disabled msg", ref DrawSysDis);
            CheckCfg<string>("Info msg", ref InfoMsg);
            SaveConfig();

            MainButton = ConvertStringToButton(CfgButton);
            SecondButton = ConvertStringToButton(CfgSecButton);

            if (UsePermission)
            {
                permission.RegisterPermission("cannpc", this);
                permission.RegisterPermission("canstag", this);
                permission.RegisterPermission("canbear", this);
                permission.RegisterPermission("canwolf", this);
                permission.RegisterPermission("canchicken", this);
                permission.RegisterPermission("canboar", this);
            }

            try { SaveNpcList = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, PetInfo>>("Pets"); } catch { }
            if (SaveNpcList == null) SaveNpcList = new Dictionary<string, PetInfo>();
        }

        #endregion

        #region Unload Hook (destroy all plugin's objects)

        void Unload()
		{
            DestroyAll<NpcControl>();
            DestroyAll<NpcAI>();
		}

        #endregion

        #region Hook OnAttacked for NpcAI

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BaseNPC)
            {
                NpcAI ai = entity.GetComponent<NpcAI>();
                if (ai != null)
                    ai.OnAttacked(hitInfo);
            }
        }

        #endregion

        #region Hook OnPlayerInit (load player's pet)

        void OnPlayerInit(BasePlayer player)
        {
            PetInfo info;
            if (SaveNpcList.TryGetValue(player.userID.ToString(), out info) && info.NeedToSpawn)
            {
                Puts("Loading pet...");
                BaseEntity pet = GameManager.server.CreateEntity(StringPool.Get(info.prefabID), new Vector3(info.x, info.y, info.z));
                if (pet != null)
                {
                    NpcControl comp = player.gameObject.AddComponent<NpcControl>();
                    pet.Spawn(true);
                    comp.npc = pet.gameObject.AddComponent<NpcAI>();
                    comp.npc.owner = comp;
                    comp.npc.inventory.Load(ProtoBuf.ItemContainer.Deserialize(info.inventory));
                    info.NeedToSpawn = false;
                }
            }
        }

        #endregion

        #region Hook OnServerInitialized (kill all pets, then spawn when owner will connect)

        void OnServerInitialized()
        {
            if (Time.realtimeSinceStartup < 100)
                foreach(KeyValuePair<string, PetInfo> entry in SaveNpcList)
                {
                    BaseNetworkable parent = BaseNetworkable.serverEntities.Find(entry.Value.parentNPC);
                    if (parent != null)
                        parent.KillMessage();
                }
        }

        #endregion

        #region Hook OnServerSave (save all pets)

        void OnServerSave()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(NpcAI));
            if (objects != null)
            {
                Puts("Saving pets...");
                foreach (UnityEngine.Object gameObj in objects)
                {
                    NpcAI pet = gameObj as NpcAI;
                    SaveNpcList[pet.owner.owner.userID.ToString()] = new PetInfo(pet);
                }
                Interface.GetMod().DataFileSystem.WriteObject("Pets", SaveNpcList);
            }
        }

        #endregion

        #region PET Command (activate/deactivate npc mode)

        [ChatCommand("pet")]
        void pet(BasePlayer player, string command, string[] args)
        {
            if (!UsePermission || HasPermission(player, "cannpc"))
			{
                NpcControl comp = player.GetComponent<NpcControl>() ?? player.gameObject.AddComponent<NpcControl>();
                if (args.Length > 0)
                {
                    switch (args[0])
                    {
                        case "free":
                            if (comp.npc)
                            {
                                GameObject.Destroy(comp.npc);
                                SendReply(player, NpcFree);
                            }
                            else
                                SendReply(player, NotNpc);
                            break;
                        case "draw":
                            if (GlobalDraw)
                                if (comp.DrawEnabled)
                                {
                                    comp.DrawEnabled = false;
                                    SendReply(player, DrawDis);
                                }
                                else
                                {
                                    comp.DrawEnabled = true;
                                    SendReply(player, DrawEn);
                                }
                            else
                                SendReply(player, DrawSysDis);
                            break;
                        case "sleep":
                            if (comp.npc)
                            {
                                SendReply(player, SleepMsg);
                                comp.npc.action = Act.Sleep;
                            }
                            else
                                SendReply(player, NotNpc);
                            break;
                        case "info":
                            if (comp.npc)
                            {
                                NPCMetabolism meta = comp.npc.RustMetabolism;
                                SendReply(player, InfoMsg
                                    .Replace("{health}", Math.Round(comp.npc.Base.health*  100/comp.npc.Base.MaxHealth()).ToString())
                                    .Replace("{hunger}", Math.Round(meta.hydration.value * 100 / meta.hydration.max).ToString())
                                    .Replace("{thirst}", Math.Round(meta.calories.value * 100 / meta.calories.max).ToString())
                                    .Replace("{sleep}", Math.Round(meta.sleep.value * 100 / meta.sleep.max).ToString())
                                    .Replace("{stamina}", Math.Round(meta.stamina.value * 100 / meta.stamina.max).ToString()));
                            }
                            else
                                SendReply(player, NotNpc);
                            break;
                    }
                }
                else
                {
                    if (comp.enabled)
                    {
                        comp.enabled = false;
                        SendReply(player, DeactivatedMsg);
                    }
                    else
                    {
                        comp.enabled = true;
                        SendReply(player, ActivatedMsg);
                    }
                }
			}
			else
                SendReply(player, NoPermMsg);
        }

        #endregion

        #region Some other plugin methods

        private bool HasPermission(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.userID.ToString(), perm);
        }

        private static void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (UnityEngine.Object gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] == null)
                Config[Key] = var;
            else
                try { var = (T) Convert.ChangeType(Config[Key], typeof(T)); }
                catch { Config[Key] = var; }
        }

        private static BUTTON ConvertStringToButton(string button)
        {
            switch (button)
            {
                case "FORWARD": return BUTTON.FORWARD;
                case "BACKWARD": return BUTTON.BACKWARD;
                case "LEFT": return BUTTON.LEFT;
                case "RIGHT": return BUTTON.RIGHT;
                case "JUMP": return BUTTON.JUMP;
                case "DUCK": return BUTTON.DUCK;
                case "SPRINT": return BUTTON.SPRINT;
                case "INVENTORY": return BUTTON.INVENTORY;
                case "FIRE_PRIMARY": return BUTTON.FIRE_PRIMARY;
                case "FIRE_SECONDARY": return BUTTON.FIRE_SECONDARY;
                case "CHAT": return BUTTON.CHAT;
                case "RELOAD": return BUTTON.RELOAD;
                case "PREVIOUS": return BUTTON.PREVIOUS;
                case "SLOT1": return BUTTON.SLOT1;
                case "SLOT2": return BUTTON.SLOT2;
                case "SLOT3": return BUTTON.SLOT3;
                case "SLOT4": return BUTTON.SLOT4;
                case "SLOT5": return BUTTON.SLOT5;
                case "SLOT6": return BUTTON.SLOT6;
                case "SLOT7": return BUTTON.SLOT7;
                case "SLOT8": return BUTTON.SLOT8;
                case "LOOK_ALT": return BUTTON.LOOK_ALT;
                default: return BUTTON.USE;
            }
        }

        #endregion
    }
}


/* Change Log
 * 0.1.0 (26/03/15)
    - Small optimization and code clean up
    - Configurable Button
    - Inventories!

 * 0.1.1 (05/04/15)
    - Fixed all errors (Null, save)

 * 0.2.0 (05/04/15)
    - Pets save!

 * 0.3.0 (10/04/15)
    - Low size save file.
    - Metabolism 20% faster.
    - Now u can modify standart MAXHP\SPEED\ATTACK
    - Changed Follow\Unfollow cmd use
    - AI slightly improved

 * 0.3.1 (10/04/15)
    - Changed OnAttacked hookname

 * 0.3.2 (11/04/15)
    - Config fix
*/
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Polling.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

/*
 * The MIT License (MIT)
 * Copyright (c) 2015 feramor@computer.org
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.Collections.Generic;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Polling Plugin", "Feramor", "1.0.11", ResourceId = 793)]
    public class Polling : RustPlugin
    {
        #region Other Classes
        public class PollingAnswerDataObject
        {
            public string AnswerText { set; get; }
            public int VoteCount { set; get; }
        }
        public class PollingMainDataObject
        {
            public int ID { set; get; }
            public string Type { set; get; }
            public int Timer { set; get; }
            public string Question { set; get; }
            public string Target { set; get; }
            public List<PollingAnswerDataObject> Answers { set; get; }
            public int isActive { set; get; }
            public List<string> UserList { set; get; }
        }
        public class myConfigObj
        {
            public bool Time_Enabled { set; get; }
            public int Time_Auth { set; get; }
            public bool Kick_Enabled { set; get; }
            public int Kick_Auth { set; get; }
            public bool Ban_Enabled { set; get; }
            public int Ban_Auth { set; get; }
            public bool Airdrop_Enabled { set; get; }
            public int Airdrop_Auth { set; get; }
            public bool Custom_Enabled { set; get; }
            public int Custom_Auth { set; get; }
            public myConfigObj()
            {
            }
        }
        #endregion

        List<PollingMainDataObject> History;
        PollingMainDataObject Current;
        myConfigObj myConfig;
        private static Logger logger = Interface.GetMod().RootLogger;
        public Core.Configuration.DynamicConfigFile mydata;
        Dictionary<string, object> Language = new Dictionary<string, object>();
        Dictionary<string, object> NewConfig = new Dictionary<string, object>();
        Oxide.Core.Libraries.Timer.TimerInstance CurrentPollTimer = null;
        [ChatCommand("poll")]
        private void cmdChatPoll(BasePlayer Player, string Command, string[] Args)
        {
            if (Args.Length > 0)
            {
                if (isCommand(Args[0]))
                {
                    switch (Args[0].ToUpper(new System.Globalization.CultureInfo("en-US")))
                    {
                        #region ? Command
                        case "?":
                            if (Current == null)
                                myPrintToChat(Player, Language["NoPoll"].ToString());
                            else if (Current.UserList.Contains(Player.userID.ToString()) == true)
                                myPrintToChat(Player, Language["AlreadyVoted"].ToString());
                            else
                            {
                                myPrintToChat(Player, Language["CurrentPoll"].ToString(), Current.Question);
                                int i = 1;
                                foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                {
                                    myPrintToChat(Player, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                }
                                myPrintToChat(Player, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                            }
                            break;
                        #endregion
                        #region Clear Command
                        case "CLEAR":
                            if (Player.net.connection.authLevel != 2)
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            else
                            {
                                if (Current != null)
                                {
                                    myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                }
                                else
                                {
                                    History = new List<PollingMainDataObject>();
                                    SaveHistory(History);
                                    History = LoadHistory();
                                    Current = GetCurrentPoll(History);
                                }
                            }
                            break;
                        #endregion Clear Command
                        #region Help Command
                        case "HELP":
                            if (Player.net.connection.authLevel != 2)
                            {
                                myPrintToChat(Player, Language["Help0"].ToString());
                                myPrintToChat(Player, Language["Help1"].ToString());
                                myPrintToChat(Player, Language["Help2"].ToString());
                                myPrintToChat(Player, Language["Help3"].ToString());
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Help0"].ToString());
                                myPrintToChat(Player, Language["Help1"].ToString());
                                myPrintToChat(Player, Language["Help2"].ToString());
                                myPrintToChat(Player, Language["Help3"].ToString());
                                myPrintToChat(Player, Language["Help4"].ToString());
                                myPrintToChat(Player, Language["Help5"].ToString());
                                myPrintToChat(Player, Language["Help6"].ToString());
                                myPrintToChat(Player, Language["Help7"].ToString());
                                myPrintToChat(Player, Language["Help8"].ToString());
                                myPrintToChat(Player, Language["Help9"].ToString());
                            }
                            break;
                        #endregion
                        #region Time Command
                        case "TIME":
                            if (myConfig.Time_Enabled == false)
                            {
                                myPrintToChat(Player, Language["DisabledPoll"].ToString());
                            }
                            else if (Player.net.connection.authLevel >= myConfig.Time_Auth)
                            {
                                if (Args.Length == 3)
                                {
                                    if (IsNumeric(Args[1]))
                                    {
                                        int Timer = Convert.ToInt32(Args[1]);
                                        string DayTime = Args[2].ToUpper(new System.Globalization.CultureInfo("en-US"));

                                        if (DayTime.Equals("DAY") || DayTime.Equals("NIGHT"))
                                        {
                                            if (Current == null)
                                            {
                                                Current = new PollingMainDataObject();
                                                Current.Answers = new List<PollingAnswerDataObject>();
                                                Current.ID = History.Count + 1;
                                                Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + Timer;
                                                Current.Question = string.Format(Language["QestionTime"].ToString(), DayTime);
                                                Current.Target = DayTime;
                                                Current.Type = Args[0].ToUpper(new System.Globalization.CultureInfo("en-US"));
                                                Current.UserList = new List<string>();
                                                PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["Yes"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["No"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                                                Current.isActive = 1;
                                                History.Add(Current);
                                                SaveHistory(History);
                                                foreach (var ActiveUser in BasePlayer.activePlayerList)
                                                {
                                                    myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                                    int i = 1;
                                                    foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                                    {
                                                        myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                                    }
                                                    myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                                                }
                                            }
                                            else
                                            {
                                                myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                            }
                                        }
                                        else
                                        {
                                            myPrintToChat(Player, Language["WrongPoll"].ToString());
                                        }
                                    }
                                    else
                                    {
                                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                                    }
                                }
                                else
                                {
                                    myPrintToChat(Player, Language["WrongPoll"].ToString());
                                }
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            break;
                        #endregion
                        #region Kick Command
                        case "KICK":
                            if (myConfig.Kick_Enabled == false)
                            {
                                myPrintToChat(Player, Language["DisabledPoll"].ToString());
                            }
                            else if (Player.net.connection.authLevel >= myConfig.Kick_Auth)
                            {
                                if (Args.Length == 3)
                                {
                                    if (IsNumeric(Args[1]))
                                    {
                                        int Timer = Convert.ToInt32(Args[1]);
                                        BasePlayer SelectedUser = null;

                                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                                        {
                                            if (ActiveUser.displayName == Args[2] || ActiveUser.userID.ToString() == Args[2])
                                                SelectedUser = ActiveUser;
                                        }

                                        if (SelectedUser != null)
                                        {
                                            if (Current == null)
                                            {
                                                Current = new PollingMainDataObject();
                                                Current.Answers = new List<PollingAnswerDataObject>();
                                                Current.ID = History.Count + 1;
                                                Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + Timer;
                                                Current.Question = string.Format(Language["QuestionKick"].ToString(), SelectedUser.displayName.ToString());
                                                Current.Target = SelectedUser.userID.ToString();
                                                Current.Type = Args[0].ToUpper(new System.Globalization.CultureInfo("en-US"));
                                                Current.UserList = new List<string>();
                                                PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["Yes"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["No"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                                                Current.isActive = 1;
                                                History.Add(Current);
                                                SaveHistory(History);
                                                foreach (var ActiveUser in BasePlayer.activePlayerList)
                                                {
                                                    myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                                    int i = 1;
                                                    foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                                    {
                                                        myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                                    }
                                                    myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                                                }
                                            }
                                            else
                                            {
                                                myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                            }
                                        }
                                        else
                                        {
                                            myPrintToChat(Player, Language["NoUser"].ToString(), Args[2]);
                                        }
                                    }
                                    else
                                    {
                                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                                    }
                                }
                                else
                                {
                                    myPrintToChat(Player, Language["WrongPoll"].ToString());
                                }
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            break;
                        #endregion
                        #region Ban Command
                        case "BAN":
                            if (myConfig.Ban_Enabled == false)
                            {
                                myPrintToChat(Player, Language["DisabledPoll"].ToString());
                            }
                            else if (Player.net.connection.authLevel >= myConfig.Ban_Auth)
                            {
                                if (Args.Length == 3)
                                {
                                    if (IsNumeric(Args[1]))
                                    {
                                        int Timer = Convert.ToInt32(Args[1]);
                                        BasePlayer SelectedUser = null;

                                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                                        {
                                            if (ActiveUser.displayName == Args[2] || ActiveUser.userID.ToString() == Args[2])
                                                SelectedUser = ActiveUser;
                                        }

                                        if (SelectedUser != null)
                                        {
                                            if (Current == null)
                                            {
                                                Current = new PollingMainDataObject();
                                                Current.Answers = new List<PollingAnswerDataObject>();
                                                Current.ID = History.Count + 1;
                                                Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + Timer;
                                                Current.Question = string.Format("Do you want to ban {0} ?", SelectedUser.displayName.ToString());
                                                Current.Target = SelectedUser.userID.ToString();
                                                Current.Type = Args[0].ToUpper(new System.Globalization.CultureInfo("en-US"));
                                                Current.UserList = new List<string>();
                                                PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["Yes"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Language["No"].ToString();
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                                //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                                                Current.isActive = 1;
                                                History.Add(Current);
                                                SaveHistory(History);
                                                foreach (var ActiveUser in BasePlayer.activePlayerList)
                                                {
                                                    myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                                    int i = 1;
                                                    foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                                    {
                                                        myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                                    }
                                                    myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                                                }
                                            }
                                            else
                                            {
                                                myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                            }
                                        }
                                        else
                                        {
                                            myPrintToChat(Player, Language["NoUser"].ToString(), Args[2]);
                                        }
                                    }
                                    else
                                    {
                                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                                    }
                                }
                                else
                                {
                                    myPrintToChat(Player, Language["WrongPoll"].ToString());
                                }
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            break;
                        #endregion
                        #region AIRDROP Command
                        case "AIRDROP":
                            if (myConfig.Airdrop_Enabled == false)
                            {
                                myPrintToChat(Player, Language["DisabledPoll"].ToString());
                            }
                            else if (Player.net.connection.authLevel >= myConfig.Airdrop_Auth)
                            {
                                if (Args.Length == 2)
                                {
                                    if (IsNumeric(Args[1]))
                                    {
                                        int Timer = Convert.ToInt32(Args[1]);
                                        if (Current == null)
                                        {
                                            Current = new PollingMainDataObject();
                                            Current.Answers = new List<PollingAnswerDataObject>();
                                            Current.ID = History.Count + 1;
                                            Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + Timer;
                                            Current.Question = Language["QuestionAirdrop"].ToString();
                                            Current.Target = "-";
                                            Current.Type = Args[0].ToUpper(new System.Globalization.CultureInfo("en-US"));
                                            Current.UserList = new List<string>();
                                            PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                                            newAnswer.AnswerText = Language["Yes"].ToString();
                                            newAnswer.VoteCount = 0;
                                            Current.Answers.Add(newAnswer);
                                            newAnswer = new PollingAnswerDataObject();
                                            newAnswer.AnswerText = Language["No"].ToString();
                                            newAnswer.VoteCount = 0;
                                            Current.Answers.Add(newAnswer);
                                            //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                                            Current.isActive = 1;
                                            History.Add(Current);
                                            SaveHistory(History);
                                            foreach (var ActiveUser in BasePlayer.activePlayerList)
                                            {
                                                myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                                int i = 1;
                                                foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                                {
                                                    myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                                }
                                                myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                                            }
                                        }
                                        else
                                        {
                                            myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                        }
                                    }
                                    else
                                    {
                                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                                    }
                                }
                                else
                                {
                                    myPrintToChat(Player, Language["WrongPoll"].ToString());
                                }
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            break;
                        #endregion
                        #region CUSTOM Command
                        case "CUSTOM":
                            if (myConfig.Custom_Enabled == false)
                            {
                                myPrintToChat(Player, Language["DisabledPoll"].ToString());
                            }
                            else if (Player.net.connection.authLevel >= myConfig.Custom_Auth)
                            {
                                if (Args.Length >= 5)
                                {
                                    if (IsNumeric(Args[1]))
                                    {
                                        int Timer = Convert.ToInt32(Args[1]);
                                        if (Current == null)
                                        {
                                            Current = new PollingMainDataObject();
                                            Current.Answers = new List<PollingAnswerDataObject>();
                                            Current.ID = History.Count + 1;
                                            Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + Timer;
                                            Current.Question = Args[2];
                                            Current.Target = "-";
                                            Current.Type = Args[0].ToUpper(new System.Globalization.CultureInfo("en-US"));
                                            Current.UserList = new List<string>();

                                            for (int i = 4; i <= Args.Length; i++)
                                            {
                                                PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                                                newAnswer.AnswerText = Args[i - 1];
                                                newAnswer.VoteCount = 0;
                                                Current.Answers.Add(newAnswer);
                                            }

                                            //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                                            Current.isActive = 1;
                                            foreach (var ActiveUser in BasePlayer.activePlayerList)
                                            {
                                                myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                                int i = 1;
                                                foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                                {
                                                    myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                                }
                                                myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                                            }
                                        }
                                        else
                                        {
                                            myPrintToChat(Player, Language["AlreadyPoll"].ToString());
                                        }
                                    }
                                    else
                                    {
                                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                                    }
                                }
                                else
                                {
                                    myPrintToChat(Player, Language["WrongPoll"].ToString());
                                }
                            }
                            else
                            {
                                myPrintToChat(Player, Language["Permission"].ToString());
                            }
                            break;
                        #endregion
                        #region HISTORY Command
                        case "HISTORY":
                            if (Args.Length > 1)
                            {
                                if (IsNumeric(Args[1]))
                                {
                                    foreach (PollingMainDataObject Selected in History)
                                    {
                                        if (Selected.ID.ToString() == Args[1])
                                        {
                                            myPrintToChat(Player, Language["VoteResults"].ToString(), Selected.Question);
                                            foreach (PollingAnswerDataObject CurrentAnswer in Selected.Answers)
                                            {
                                                double percent = 0.0;
                                                if (Selected.UserList.Count > 0)
                                                {
                                                    percent = (CurrentAnswer.VoteCount * 100.0) / Selected.UserList.Count;
                                                }
                                                myPrintToChat(Player, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                List<PollingMainDataObject> rHistory = new List<PollingMainDataObject>(History);
                                rHistory.Reverse();
                                myPrintToChat(Player, "Poll History : Last 5 Poll (Total Poll {0})", rHistory.Count);

                                int i = 0;
                                foreach (PollingMainDataObject Selected in rHistory)
                                {
                                    if (i < 5)
                                    {
                                        var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                                        epoch = epoch.AddSeconds(rHistory[i].Timer);
                                        myPrintToChat(Player, string.Format("{0}){1} - {2}", rHistory[i].ID.ToString(), rHistory[i].Question.ToString(), epoch.ToLocalTime().ToString("d/M/yyyy HH:mm:ss")));
                                        i++;
                                    }
                                }
                                rHistory.Clear();
                                GC.Collect();
                            }
                            break;
                        #endregion
                        default:
                            myPrintToChat(Player, Language["WrongPoll"].ToString());
                            break;
                    }
                }
                else
                {
                    #region User Polling
                    if (IsNumeric(Args[0]))
                    {
                        if (Current == null)
                            myPrintToChat(Player, Language["NoPoll"].ToString());
                        else
                        {
                            if (Current.UserList.Contains(Player.userID.ToString()))
                            {
                                myPrintToChat(Player, Language["AlreadyVoted"].ToString());
                            }
                            else
                            {
                                int choice = Convert.ToInt32(Args[0]);
                                if (Current.Answers.Count >= choice && choice > 0)
                                {
                                    Current.Answers[choice - 1].VoteCount += 1;
                                    Current.UserList.Add(Player.userID.ToString());
                                    myPrintToChat(Player, Language["Voted"].ToString(), Current.Answers[choice - 1].AnswerText);
                                    SaveHistory(History);
                                }
                                else
                                {
                                    myPrintToChat(Player, "Current Poll:  {0}", Current.Question);
                                    int i = 1;
                                    foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                    {
                                        myPrintToChat(Player, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        myPrintToChat(Player, Language["WrongPoll"].ToString());
                    }
                    #endregion
                }
            }
            else
            {
                myPrintToChat(Player, Language["WrongPoll"].ToString());
            }
        }
        void Init()
        {
            LoadConfig();
            History = LoadHistory();
            Current = GetCurrentPoll(History);
            myConfig = JsonConvert.DeserializeObject<myConfigObj>((string)JsonConvert.SerializeObject(Config["Config"]).ToString());
            logger.Write(Oxide.Core.Logging.LogType.Info, "Polling : Loaded history file.Currently there are {0} polls in the history.", History.Count.ToString());
            if (Config["Language"] != null)
            {
                Language = (Dictionary<string, object>)Config["Language"];

            }
            if (Config["NewConfig"] != null)
            {
                NewConfig = (Dictionary<string, object>)Config["NewConfig"];

            }
            LoadDefaultLang();
        }
        void LoadDefaultLang()
        {
            //V 1.0.5
            AddLanguage("VoteFailed", "Vote Failed :  {0}");
            AddLanguage("VotePassed", "Vote Passed :  {0}");
            AddLanguage("VoteResults", "Vote Results :  {0}");
            AddLanguage("HaventVoted", "You haven't voted for : {0}");
            AddLanguage("HowTo", "You can use /poll ? to see current poll.");
            AddLanguage("NoPoll", "There is no active poll right now!!!");
            AddLanguage("AlreadyVoted", "You have already voted for this poll!!!");
            AddLanguage("CurrentPoll", "Current Poll :  {0}");
            AddLanguage("DisabledPoll", "This type of poll disabled by Server Owner.");
            AddLanguage("PollStarted", "Poll Started :  {0}");
            AddLanguage("AlreadyPoll", "There is already a poll running.");
            AddLanguage("WrongPoll", "Use /Poll Help to learn how to use Polling System.");
            AddLanguage("Permission", "You don't have permission to use this command!.");
            AddLanguage("NoUser", "There is no user found with name {0}");
            AddLanguage("Voted", "You voted {0} for this poll.");
            AddLanguage("Yes", "Yes");
            AddLanguage("No", "No");
            //V 1.0.6
            AddLanguage("QestionTime", "Do you want to change time to {0} ?");
            AddLanguage("QuestionKick", "Do you want to kick {0} ?");
            AddLanguage("QuestionBan", "Do you want to ban {0} ?");
            AddLanguage("QuestionAirdrop", "Do you want an Airdrop?");
            AddLanguage("HowToVote", "You can use /Poll {0}-{1} to vote");

            AddLanguage("KickChat", "{0} has been kicked by poll results.");
            AddLanguage("KickConsole", "You have been kicked by poll results.");
            AddLanguage("BanChat", "{0} has been banned by poll results.");
            AddLanguage("BanConsole", "You have been banned by poll results.");

            //Help Texts
            AddLanguage("Help0", "*** Avaible user commands ***");
            AddLanguage("Help1", "/Poll Help - For this menu");
            AddLanguage("Help2", "/Poll History [ID] - to see previous polls");
            AddLanguage("Help3", "/Poll [Choice] - to vote for active poll");
            AddLanguage("Help4", "*** Avaible admin commands ***");
            AddLanguage("Help5", "/Poll \"Kick\" \"TIMER\" \"Username\" - For vote to kick ppl");
            AddLanguage("Help6", "/Poll \"Ban\" \"TIMER\" \"Username\" - For vote to ban ppl");
            AddLanguage("Help7", "/Poll \"Airdrop\" \"TIMER\"- For vote to start airdrop");
            AddLanguage("Help8", "/Poll \"Time\" \"TIMER\" \"Day/Night\" - For vote to change server time");
            AddLanguage("Help9", "/Poll \"Custom\" \"TIMER\" \"QUESTION\" \"ANSWER1\" \"ANSWER2\" \"ANSWER3\" ..... - For vote to custom question");

            //Tag
            AddLanguage("ChatTag", "Polling");

            //New Config
            AddConfig("EventCmd", "event.run");
            AddConfig("SkipNight", false);
            AddConfig("SkipTime", "20:00");

            Config["Language"] = Language;
            Config["NewConfig"] = NewConfig;
            SaveConfig();
        }
        void AddLanguage(string Key, string Value)
        {
            try
            {
                Language.Add(Key, Value);
            }
            catch { }
        }
        void AddConfig(string Key, object Value)
        {
            try
            {
                NewConfig.Add(Key, Value);
            }
            catch { }
        }
        public void EndVote()
        {
            switch (Current.Type)
            {
                #region TIME Command
                case "TIME":
                    Current.isActive = 0;
                    if (Current.Answers[0].VoteCount <= Current.Answers[1].VoteCount)
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VoteFailed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                    }
                    else
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VotePassed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                        List<TOD_Sky> Skies = TOD_Sky.Instances;
                        foreach (TOD_Sky Sky in Skies)
                        {
                        if (Current.Target == "DAY")
                            Sky.Cycle.Hour = 10;
                        else
                            Sky.Cycle.Hour = 22;
                        }
                    }
                    break;
                #endregion
                #region KICK Command
                case "KICK":
                    Current.isActive = 0;
                    if (Current.Answers[0].VoteCount <= Current.Answers[1].VoteCount)
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VoteFailed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                    }
                    else
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VotePassed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                            myPrintToChat(ActiveUser, Language["KickChat"].ToString(), BasePlayer.FindByID(Convert.ToUInt64(Current.Target)).displayName.ToString());
                        }
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            if (ActiveUser.userID.ToString() == Current.Target)
                                Network.Net.sv.Kick(ActiveUser.net.connection, Language["KickConsole"].ToString());
                        }
                    }
                    break;
                #endregion
                #region BAN Command
                case "BAN":
                    Current.isActive = 0;
                    if (Current.Answers[0].VoteCount <= Current.Answers[1].VoteCount)
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VoteFailed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                    }
                    else
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VotePassed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                            myPrintToChat(ActiveUser, Language["BanChat"].ToString(), BasePlayer.FindByID(Convert.ToUInt64(Current.Target)).displayName.ToString());
                        }
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            if (ActiveUser.userID.ToString() == Current.Target)
                            {
                                ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", ActiveUser.userID.ToString(), ActiveUser.displayName, "User have been banned by poll results.").ToString(), null);
                                ConsoleSystem.Run.Server.Quiet("server.writecfg", null);
                                Network.Net.sv.Kick(ActiveUser.net.connection, Language["BanConsole"].ToString());

                            }
                        }
                    }
                    break;
                #endregion
                #region AIRDROP Command
                case "AIRDROP":
                    Current.isActive = 0;
                    if (Current.Answers[0].VoteCount <= Current.Answers[1].VoteCount)
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VoteFailed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                    }
                    else
                    {
                        foreach (var ActiveUser in BasePlayer.activePlayerList)
                        {
                            myPrintToChat(ActiveUser, Language["VotePassed"].ToString(), Current.Question);
                            foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                            {
                                double percent = 0.0;
                                if (Current.UserList.Count > 0)
                                {
                                    percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                                }
                                myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                            }
                        }
                        ConsoleSystem.Run.Server.Quiet(NewConfig["EventCmd"].ToString(), null);
                    }
                    break;
                #endregion
                #region CUSTOM Command
                case "CUSTOM":
                    Current.isActive = 0;
                    foreach (var ActiveUser in BasePlayer.activePlayerList)
                    {
                        myPrintToChat(ActiveUser, Language["VoteResults"].ToString(), Current.Question);
                        foreach (PollingAnswerDataObject CurrentAnswer in Current.Answers)
                        {
                            double percent = 0.0;
                            if (Current.UserList.Count > 0)
                            {
                                percent = (CurrentAnswer.VoteCount * 100.0) / Current.UserList.Count;
                            }
                            myPrintToChat(ActiveUser, "{0}  :  {1}({2}%)", CurrentAnswer.AnswerText, CurrentAnswer.VoteCount, percent.ToString("00.00"));
                        }

                    }
                    break;
                #endregion
            }
            SaveHistory(History);
            Current = null;
            CurrentPollTimer = null;
        }
        [HookMethod("OnTick")]
        void OnTick()
        {
            if (Current != null)
            {
                if (CurrentPollTimer == null)
                {
                    if (Current.isActive == 1)
                    {
                        if (Current.Timer != -1)
                        {
                            long CurrentTimer = Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                            float Diff = Convert.ToSingle(Current.Timer - CurrentTimer);
                            if (Diff <= 0)
                                Diff = 1;
                            CurrentPollTimer = Interface.GetMod().GetLibrary<Oxide.Core.Libraries.Timer>("Timer").Once(Diff, () => EndVote(), this);

                            logger.Write(LogType.Info, "Polling : Poll started {0} for {1}", Current.Question,Diff);
                        }
                    }
                }
            }
            else
            {
                if ((bool)NewConfig["SkipNight"] == true)
                {
                    TOD_Sky CurrentTime = TOD_Sky.Instance;
                    if (CurrentTime.Cycle.DateTime.ToString("HH:mm") == ((string)NewConfig["SkipTime"].ToString()))
                    {
                        if (Current == null)
                        {
                            logger.Write(LogType.Warning, "Auto skip poll running");
                            Current = new PollingMainDataObject();
                            Current.Answers = new List<PollingAnswerDataObject>();
                            Current.ID = History.Count + 1;
                            Current.Timer = Convert.ToInt32((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) + 60;
                            Current.Question = string.Format(Language["QestionTime"].ToString(), "DAY");
                            Current.Target = "DAY";
                            Current.Type = "TIME";
                            Current.UserList = new List<string>();
                            PollingAnswerDataObject newAnswer = new PollingAnswerDataObject();
                            newAnswer.AnswerText = Language["Yes"].ToString();
                            newAnswer.VoteCount = 0;
                            Current.Answers.Add(newAnswer);
                            newAnswer = new PollingAnswerDataObject();
                            newAnswer.AnswerText = Language["No"].ToString();
                            newAnswer.VoteCount = 0;
                            Current.Answers.Add(newAnswer);
                            //Current.Answers.Sort(delegate(PollingAnswerDataObject p1, PollingAnswerDataObject p2) { return p1.AnswerText.CompareTo(p2.AnswerText); });
                            Current.isActive = 1;
                            History.Add(Current);
                            SaveHistory(History);
                            foreach (var ActiveUser in BasePlayer.activePlayerList)
                            {
                                myPrintToChat(ActiveUser, Language["PollStarted"].ToString(), Current.Question);
                                int i = 1;
                                foreach (PollingAnswerDataObject CurrentAns in Current.Answers)
                                {
                                    myPrintToChat(ActiveUser, "{0}){1}", i++.ToString(), CurrentAns.AnswerText.ToString());
                                }
                                myPrintToChat(ActiveUser, Language["HowToVote"].ToString(), "1", Current.Answers.Count.ToString());
                            }
                        }
                    }
                }

            }
        }
        [HookMethod("LoadDefaultConfig")]
        void myLoadDefaultConfig()
        {
            myConfigObj myNewConfig = new myConfigObj();
            myNewConfig.Time_Enabled = true;
            myNewConfig.Time_Auth = 2;

            myNewConfig.Kick_Enabled = true;
            myNewConfig.Kick_Auth = 2;

            myNewConfig.Ban_Enabled = true;
            myNewConfig.Ban_Auth = 2;

            myNewConfig.Airdrop_Enabled = true;
            myNewConfig.Airdrop_Auth = 2;

            myNewConfig.Custom_Enabled = true;
            myNewConfig.Custom_Auth = 2;

            Config["Config"] = myNewConfig;
            myConfig = myNewConfig;

            logger.Write(Oxide.Core.Logging.LogType.Info, "Polling : Default Config loaded.");
        }
        void OnPlayerInit(BasePlayer new_player)
        {
            if (Current != null)
            {
                if (Current.UserList.Contains(new_player.userID.ToString()) == false)
                {
                    myPrintToChat(new_player, Language["HaventVoted"].ToString(), Current.Question);
                    myPrintToChat(new_player, Language["HowTo"].ToString());
                }
            }
        }
        public void SaveHistory(List<PollingMainDataObject> Context)
        {
            Interface.GetMod().DataFileSystem.WriteObject<List<PollingMainDataObject>>("Polling", Context);
        }
        public List<PollingMainDataObject> LoadHistory()
        {
            List<PollingMainDataObject> outObject = null;
            try
            {
                outObject = Interface.GetMod().DataFileSystem.ReadObject<List<PollingMainDataObject>>("Polling");
            }
            catch
            {
                outObject = new List<PollingMainDataObject>();
            }
            return outObject;
        }
        public PollingMainDataObject GetCurrentPoll(List<PollingMainDataObject> History)
        {
            PollingMainDataObject ReturnValue = null;
            foreach (PollingMainDataObject Current in History)
            {
                if (Current.isActive == 1)
                {
                    ReturnValue = Current;
                }
            }
            return ReturnValue;
        }
        public bool isCommand(string arg)
        {
            List<string> CommandList = new List<string>();
            CommandList.Add("HELP");
            CommandList.Add("TIME");
            CommandList.Add("KICK");
            CommandList.Add("BAN");
            CommandList.Add("AIRDROP");
            CommandList.Add("CUSTOM");
            CommandList.Add("HISTORY");
            CommandList.Add("?");
            CommandList.Add("CLEAR");
            if (CommandList.IndexOf(arg.ToUpper(new System.Globalization.CultureInfo("en-US"))) != -1)
                return true;
            else
                return false;
        }
        public static System.Boolean IsNumeric(System.Object Expression)
        {
            if (Expression == null || Expression is DateTime)
                return false;

            if (Expression is Int16 || Expression is Int32 || Expression is Int64 || Expression is Decimal || Expression is Single || Expression is Double || Expression is Boolean)
                return true;

            try
            {
                if (Expression is string)
                    Double.Parse(Expression as string);
                else
                    Double.Parse(Expression.ToString());
                return true;
            }
            catch { }
            return false;
        }
        protected void myPrintToChat(BasePlayer Player, string format, params object[] Args)
        {
            Player.SendConsoleCommand("chat.add", 0, string.Format("<color=orange>{0}</color>  {1}", Language["ChatTag"].ToString(), string.Format(format, Args)), 1.0);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Prod.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Prod", "Reneb", "2.1.3", ResourceId = 683)]
    class Prod : RustPlugin
    {

        private int prodAuth;
        private string helpProd;
        private string noAccess;
        private string noTargetfound;
        private string noCupboardPlayers;
        private string Toolcupboard;
        private string noBlockOwnerfound;
        private string noCodeAccess;
        private string codeLockList;
        private string boxNeedsCode;

        private FieldInfo serverinput;
        private FieldInfo codelockwhitelist;
        private Vector3 eyesAdjust;
        private bool Changed;

        [PluginReference]
        Plugin DeadPlayersList;

        [PluginReference]
        Plugin BuildingOwners;

        void Loaded()
        {
            LoadVariables();
            eyesAdjust = new Vector3(0f, 1.5f, 0f);
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            codelockwhitelist = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private void LoadVariables()
        {
            prodAuth = Convert.ToInt32(GetConfig("Prod", "authLevel", 1));
            helpProd = Convert.ToString(GetConfig("Messages", "helpProd", "/prod on a building or tool cupboard to know who owns it."));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You don't have access to this command"));
            noTargetfound = Convert.ToString(GetConfig("Messages", "noTargetfound", "You must look at a tool cupboard or building"));
            noCupboardPlayers = Convert.ToString(GetConfig("Messages", "noCupboardPlayers", "No players has access to this cupboard"));
            Toolcupboard = Convert.ToString(GetConfig("Messages", "Toolcupboard", "Tool Cupboard"));
            noBlockOwnerfound = Convert.ToString(GetConfig("Messages", "noBlockOwnerfound", "No owner found for this building block"));
            noCodeAccess = Convert.ToString(GetConfig("Messages", "noCodeAccess", "No players has access to this Lock"));
            codeLockList = Convert.ToString(GetConfig("Messages", "codeLockList", "CodeLock whitelist:"));
            boxNeedsCode = Convert.ToString(GetConfig("Messages", "boxNeedsCode", "Can't find owners of an item without a Code Lock"));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Prod: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < prodAuth)
                return false;
            return true;
        }

        [ChatCommand("prod")]
        void cmdChatProd(BasePlayer player, string command, string[] args)
        {
            if (!(hasAccess(player)))
            {
                SendReply(player, noAccess);
                return;
            }
            var input = serverinput.GetValue(player) as InputState;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            var target = DoRay(player.transform.position + eyesAdjust, currentRot);
            if (target is bool)
            {
                SendReply(player, noTargetfound);
                return;
            }
            if (target as BuildingBlock)
            {
                GetBuildingblockOwner(player, (BuildingBlock)target);
            }
            else if (target as BuildingPrivlidge)
            {
                GetToolCupboardUsers(player, (BuildingPrivlidge)target);
            }
            else if (target as SleepingBag)
            {
                GetDeployedItemOwner(player, (SleepingBag)target);
            }
            else
            {
                GetStorageBoxCode(player, (StorageContainer)target);
            }
        }
        private void GetStorageBoxCode(BasePlayer player, StorageContainer box)
        {
            if (box.HasSlot(BaseEntity.Slot.Lock))
            {
                BaseLock thelock = box.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
                if (thelock as CodeLock)
                {
                    List<ulong> whitelisted = codelockwhitelist.GetValue(thelock as CodeLock) as List<ulong>;
                    SendReply(player, codeLockList);
                    if (whitelisted.Count == 0)
                    {
                        SendReply(player, noCodeAccess);
                        return;
                    }
                    foreach (ulong userid in whitelisted)
                    {
                        SendBasePlayerFind(player, userid);
                    }
                    return;
                }
            }
            SendReply(player, boxNeedsCode);
        }
        private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem)
        {
            SendReply(player, string.Format("Sleeping Bag '{0}': {1} - {2}", ditem.niceName.ToString(), FindPlayerName(ditem.deployerUserID), ditem.deployerUserID.ToString()));
        }
        private object FindOwnerBlock(BuildingBlock block)
        {
            object returnhook = BuildingOwners?.Call("FindBlockData", block);

            if (returnhook != null)
            {
                if (!(returnhook is bool))
                {
                    ulong ownerid = Convert.ToUInt64(returnhook);
                    return ownerid;
                }
            }
            Puts("Prod: To be able to obtain the owner of a building you need to install the BuildingOwner plugin.");
            return false;
        }

        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player)
                return player.displayName + " (Online)";

            player = BasePlayer.FindSleeping(userId);
            if (player)
                return player.displayName + " (Sleeping)";

            string name = DeadPlayersList?.Call("GetPlayerName", userId) as string;
            if (name != null)
                return name + " (Dead)";

            return "Unknown player";
        }
        private void SendBasePlayerFind(BasePlayer player, ulong ownerid)
        {
            SendReply(player, string.Format("{0} {1}", FindPlayerName(ownerid), ownerid.ToString()));
        }
        private void GetBuildingblockOwner(BasePlayer player, BuildingBlock block)
        {
            object findownerblock = FindOwnerBlock(block);
            if (findownerblock is bool)
            {
                SendReply(player, noBlockOwnerfound);
                return;
            }
            ulong ownerid = (UInt64)findownerblock;
            SendBasePlayerFind(player, ownerid);
        }
        private void GetToolCupboardUsers(BasePlayer player, BuildingPrivlidge cupboard)
        {
            SendReply(player, string.Format("{0} - {1} {2} {3}", Toolcupboard, Math.Round(cupboard.transform.position.x).ToString(), Math.Round(cupboard.transform.position.y).ToString(), Math.Round(cupboard.transform.position.z).ToString()));
            if (cupboard.authorizedPlayers.Count == 0)
            {
                SendReply(player, noCupboardPlayers);
                return;
            }
            foreach (ProtoBuf.PlayerNameID pnid in cupboard.authorizedPlayers)
            {
                SendReply(player, string.Format("{0} - {1}", pnid.username.ToString(), pnid.userid.ToString()));
            }
        }
        private object DoRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = UnityEngine.Physics.RaycastAll(Pos, Aim);
            float distance = 100000f;
            object target = false;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BuildingBlock>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BuildingBlock>();
                    }
                }
                else if (hit.collider.GetComponentInParent<BuildingPrivlidge>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BuildingPrivlidge>();
                    }
                }
                else if (hit.collider.GetComponentInParent<SleepingBag>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<SleepingBag>();
                    }
                }
                else if (hit.collider.GetComponentInParent<StorageContainer>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<StorageContainer>();
                    }
                }
            }
            return target;
        }

        void SendHelpText(BasePlayer player)
        {
            if (hasAccess(player))
                SendReply(player, helpProd);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\RemoverTool.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("RemoverTool", "Reneb & Mughisi", "2.2.12")]
    class RemoverTool : RustPlugin
    {
    	private static DateTime epoch;
        private bool Changed;

        private int removeAuth;
        private int removeAdmin;
        private int removeAll;
        private int removeTarget;
        private double deactivateTimer;
        private double deactivateMaxTimer;
        private bool refundAllowed;
        private bool refundAllGrades;
        private decimal refundRate;
        private bool useToolCupboard;
        private string noAccess;
        private string cantRemove;
        private string tooFar;
        private string noBuildingfound;
        private string noToolCupboard;
        private string noToolCupboardAccess;
        private string noTargetFound;
        private string helpBasic;
        private string helpAdmin;
        private string helpAll;
        private string helpRay;

        private Dictionary<BasePlayer, double> deactivationTimer;
        private Dictionary<BasePlayer, string> removing;
        private double nextCheck;
        private List<BasePlayer> todelete;
        private FieldInfo buildingPrivlidges;
        private FieldInfo serverinput;

        void Loaded() 
        {
        	epoch = new System.DateTime(1970, 1, 1);
            Changed = false;
            deactivationTimer = new Dictionary<BasePlayer, double>();
            removing = new Dictionary<BasePlayer, string>();
            todelete = new List<BasePlayer>();
            nextCheck = CurrentTime() + 1.0;
            buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            LoadVariables();
        }
        void OnServerInitialized()
        {
            
        }
        double CurrentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        void LoadVariables()
        {
            removeTarget = Convert.ToInt32(GetConfig("Remove", "target", 1));
            removeAuth = Convert.ToInt32(GetConfig("Remove", "basic", 0));
            removeAdmin = Convert.ToInt32(GetConfig("Remove", "admin", 2));
            removeAll = Convert.ToInt32(GetConfig("Remove", "all", 2));
            deactivateTimer = Convert.ToDouble(GetConfig("RemoveTimer", "default", 30));
            deactivateMaxTimer = Convert.ToDouble(GetConfig("RemoveTimer", "max", 120));
            refundAllowed = Convert.ToBoolean(GetConfig("Refund", "activated", true));
            refundAllGrades = Convert.ToBoolean (GetConfig ("Refund", "all-grades", false));
            refundRate = Convert.ToDecimal(GetConfig("Refund", "rate", 0.5));
            useToolCupboard = Convert.ToBoolean(GetConfig("ToolCupboard", "activated", true));

            noAccess = Convert.ToString(GetConfig("Messages", "NoAccess", "You don't have the permissions to use this command"));
            cantRemove = Convert.ToString(GetConfig("Messages", "cantRemove", "You are not allowed to remove this"));
            tooFar = Convert.ToString(GetConfig("Messages", "tooFar", "You must get closer to remove this"));
            noBuildingfound = Convert.ToString(GetConfig("Messages", "noBuildingFound", "Couldn't find any structure to remove"));
            noToolCupboard = Convert.ToString(GetConfig("Messages", "noToolCupboard", "You need a Tool Cupboard to remove this"));
            noToolCupboardAccess = Convert.ToString(GetConfig("Messages", "noToolCupboardAccess", "You need access to all Tool Cupboards around you to do this"));
            noTargetFound = Convert.ToString(GetConfig("Messages", "noTargetFound", "Target player not found"));

            helpBasic = Convert.ToString(GetConfig("Messages", "helpBasic", "/remove Optional:Time - To remove start removing"));
            helpAdmin = Convert.ToString(GetConfig("Messages", "helpAdmin", "/remove admin Optional:Time - To remove start removing anything"));
            helpAll = Convert.ToString(GetConfig("Messages", "helpAll", "/remove all Optional:Time - To remove start removing an entire building"));
            helpRay = Convert.ToString(GetConfig("Messages", "helpRay", "/rayremove - To remove the entire building that you are looking at"));
            

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("RemoverTool: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void RemoveAllFrom(Vector3 sourcepos)
        {
            List<Vector3> checkFrom = new List<Vector3>();
            List<UnityEngine.Collider> wasKilled = new List<UnityEngine.Collider>();
            checkFrom.Add(sourcepos);
            var current = 0;
            while (true)
            {
                current++;
                if (current > checkFrom.Count)
                    break;
                var hits = UnityEngine.Physics.OverlapSphere(checkFrom[current - 1], 3f);
                foreach (var hit in hits)
                {
                    if (!(wasKilled.Contains(hit)))
                    {
                        wasKilled.Add(hit);
                        if (hit.GetComponentInParent<BuildingBlock>() != null)
                        {
                            BuildingBlock fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
                            checkFrom.Add(fbuildingblock.transform.position);
                            if (!fbuildingblock.isDestroyed)
                                fbuildingblock.KillMessage();
                        } 
                        else if (hit.GetComponentInParent<BasePlayer>() == null && hit.GetComponentInParent<BaseEntity>() != null)
                        {
                            if(!(hit.GetComponentInParent<BaseEntity>().isDestroyed))
                                hit.GetComponentInParent<BaseEntity>().KillMessage();
                        }
                    }
                }
            }
        }
        void Refund(BasePlayer player, BaseEntity entity)
        {
            if (entity as WorldItem)
            {
                WorldItem worlditem = entity as WorldItem;
                if (worlditem.item != null && worlditem.item.info != null)
                    player.inventory.GiveItem(worlditem.item.info.itemid, 1, true);
            }
            else if( entity as BuildingBlock )
                RefundBuildingBlock(player, entity as BuildingBlock);
        }
        void RefundBuildingBlock(BasePlayer player, BuildingBlock buildingblock)
        {
            if (buildingblock.blockDefinition != null) {
                int buildingblockGrade = (int) buildingblock.grade;

                if (refundAllGrades) {
                    for (int i = buildingblockGrade; i >= 0; i--) {
                        if (buildingblock.blockDefinition.grades [i] != null) {
                            List<ItemAmount> currentCost = buildingblock.blockDefinition.grades [i].costToBuild as List<ItemAmount>;
                            foreach (ItemAmount ia in currentCost) {
                                player.inventory.GiveItem (ia.itemid, Convert.ToInt32 ((decimal) ia.amount * refundRate), true);
                            }
                        }
                    }
                } else {
                    if (buildingblock.blockDefinition.grades [buildingblockGrade] != null) {
                        List<ItemAmount> currentCost = buildingblock.blockDefinition.grades [buildingblockGrade].costToBuild as List<ItemAmount>;
                        foreach (ItemAmount ia in currentCost) {
                            player.inventory.GiveItem (ia.itemid, Convert.ToInt32 ((decimal) ia.amount * refundRate), true);
                        }
                    }

                    if (buildingblock.blockDefinition.grades [0] != null) {
                        List<ItemAmount> currentCost = buildingblock.blockDefinition.grades [0].costToBuild as List<ItemAmount>;
                        foreach (ItemAmount ia in currentCost) {
                            player.inventory.GiveItem (ia.itemid, Convert.ToInt32 ((decimal) ia.amount * refundRate), true);
                        }
                    }
                }
            }
        }
        void OnPlayerAttack(BasePlayer player, HitInfo hitinfo)
        {
            if (hitinfo.HitEntity != null)
            {
                DoHit(player,hitinfo);
            }
        }
        void DoHit(BasePlayer player, HitInfo hitinfo)
        {
            if (removing.Count == 0) return;
            if (!(removing.ContainsKey(player))) return;
            BaseEntity target = hitinfo.HitEntity as BaseEntity;
            if (target.isDestroyed) return;
            string ttype = removing[player];
            if (ttype == "all")
            {
                RemoveAllFrom(target.transform.position);
                return;
            }
            if (!(CanRemoveTarget(player, target, ttype)))
            {
                SendReply(player, cantRemove);
                return;
            }

            if (hitinfo.HitEntity as DroppedItem && ttype != "admin")
                return;

            if (refundAllowed)
                Refund(player,target);

            target.KillMessage();
        }
        bool hasTotalAccess(BasePlayer player)
        {
            List<BuildingPrivlidge> playerpriv = buildingPrivlidges.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0)
            {
                SendReply(player, noToolCupboard);
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool foundplayer = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                {
                    if (pni.userid == player.userID)
                        foundplayer = true;
                }
                if (!foundplayer)
                {
                    SendReply(player, noToolCupboardAccess);
                    return false;
                }
            }
            return true;
        }
        bool CanRemoveTarget(BasePlayer player, BaseEntity entity, string ttype)
        {
            if (entity is BasePlayer) return false;
            if (ttype == "admin") return true;
            if (entity as BuildingBlock)
            {
                object returnhook = Interface.GetMod().CallHook("FindBlockData", new object[] { entity as BuildingBlock });
                if (returnhook != null)
                {
                    if (!(returnhook is bool))
                    {
                        string ownerid = returnhook.ToString();
                        if (ownerid == player.userID.ToString())
                            return true;
                    }
                }
            }
            if (useToolCupboard)
            {
                if (hasTotalAccess(player))
                {
                    if (Vector3.Distance(player.transform.position, entity.transform.position) < 3f)
                        return true;
                    else
                        SendReply(player, tooFar);
                }
            }
            return false;
        }
        void OnTick()
        {
            if (CurrentTime() >= nextCheck)
            {
                var currenttime = CurrentTime();                
                if (removing.Count > 0)
                {
                    foreach (KeyValuePair<BasePlayer, string> pair in removing)
                    {
                        BasePlayer player = pair.Key;
                        if (deactivationTimer.ContainsKey(player) && (player.net != null))
                        {
                            double timetodel = deactivationTimer[player];
                            if (currenttime > timetodel)
                                todelete.Add(player);
                        }
                        else
                            todelete.Add(player);
                    }
                    foreach (BasePlayer player in todelete)
                        DeactivateRemove(player);
                    todelete.Clear();
                }
                nextCheck = currenttime + 1;
            }
        }
        void ActivateRemove(BasePlayer player, string ttype, double removetime)
        {
            if (removing.ContainsKey(player))
                removing[player] = ttype;
            else
                removing.Add(player, ttype);

            if (deactivationTimer.ContainsKey(player))
                deactivationTimer[player] = (removetime + CurrentTime());
            else
                deactivationTimer.Add(player, (removetime + CurrentTime()));

            SendReply(player, string.Format("Remover Tool ({0}): Activated for {1} seconds", ttype, removetime.ToString()));
        }
        void DeactivateRemove(BasePlayer player)
        {
            if (removing.ContainsKey(player))
                removing.Remove(player);
            if (deactivationTimer.ContainsKey(player))
                deactivationTimer.Remove(player);
            if(player.net != null)
                SendReply(player, "Remover Tool: Deactivated");
        }
        void TriggerRemove(BasePlayer player, string[] args, string ttype)
        {
            if (!(hasAccess(player, ttype)))
            {
                SendReply(player, noAccess);
                return;
            }
            var activating = true;
            if (removing.ContainsKey(player))
                activating = false;
            double removetime;
            if (args != null && args.Length >= 1)
            {
                if (double.TryParse(args[args.Length-1].ToString(), out removetime))
                {
                    activating = true;
                    if (removetime > deactivateMaxTimer)
                        removetime = deactivateMaxTimer;
                }
                else
                    removetime = deactivateTimer;
            }
            else
                removetime = deactivateTimer;
            if (activating)
                ActivateRemove(player, ttype, removetime);
            else
                DeactivateRemove(player);
        }
        bool hasAccess(BasePlayer player, string ttype)
        {
            if (ttype == "normal" && player.net.connection.authLevel >= removeAuth)
                return true;
            if (ttype == "admin" && player.net.connection.authLevel >= removeAdmin)
                return true;
            if (ttype == "all" && player.net.connection.authLevel >= removeAll)
                return true;
            if (ttype == "target" && player.net.connection.authLevel >= removeTarget)
                return true;
            return false;
        }
        void TargetRemove(BasePlayer player, string[] args)
        {
            if (!(hasAccess(player, "target")))
            {
                SendReply(player, noAccess);
                return;
            }
            var target = BasePlayer.Find(args[1].ToString());
            if (target == null || target.net == null || target.net.connection == null)
            {
                SendReply(player, noTargetFound);
                return;
            }
            var activating = true;
            if (removing.ContainsKey(target))
                activating = false;
            double removetime;
            if (args != null && args.Length >= 2)
            {
                if (double.TryParse(args[1].ToString(), out removetime))
                {
                    activating = true;
                    if (removetime > deactivateMaxTimer)
                        removetime = deactivateMaxTimer;
                }
                else
                    removetime = deactivateTimer;
            }
            else
                removetime = deactivateTimer;
            if (activating)
                ActivateRemove(target, "normal", removetime);
            else
                DeactivateRemove(target);
        }
        [ChatCommand("remove")]
        void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                TriggerRemove(player, args, "normal");
                return;
            }
            if (args[0].ToString() == "admin")
            {
                TriggerRemove(player, args, "admin");
            }
            else if (args[0].ToString() == "all")
            {
                TriggerRemove(player, args, "all");
            }
            else
            {
                try {
                    int n;
                    if (int.TryParse(args[0], out n))
                        TriggerRemove(player, args, "normal");
                    else
                        TargetRemove(player, args);
                } catch
                {
                    TriggerRemove(player, args, "normal");
                }
            }

        }
        object FindBlockFromRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = UnityEngine.Physics.RaycastAll(Pos, Aim);
            float distance = 100000f;
            object target = false;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BuildingBlock>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BuildingBlock>();
                    }
                }
            }
            return target;
        }
        [ChatCommand("rayremove")]
        void cmdChatRayRemove(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < removeAll)
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            var input = serverinput.GetValue(player) as InputState;
            var currentRot = Quaternion.Euler(input.current.aimAngles);
            var target = FindBlockFromRay(player.transform.position, currentRot * Vector3.forward);
            if (target is bool)
            {
                SendReply(player, noBuildingfound);
                return;
            }
            BuildingBlock blocksource = target as BuildingBlock;
            RemoveAllFrom(blocksource.transform.position);
        }

        void SendHelpText(BasePlayer player)
        {
            if(hasAccess(player,"normal"))
                SendReply(player,helpBasic);
            if(hasAccess(player,"admin"))
                SendReply(player,helpAdmin);
            if (hasAccess(player, "all"))
            {
                SendReply(player, helpAll);
                SendReply(player, helpRay);
            }
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\RustIOTemplate.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Rust:IO Template", "Author name", "1.0.0", ResourceId = 123)]
    public class RustIOTemplate : RustPlugin
    {
        #region Rust:IO Bindings

        private Library lib;
        private MethodInfo isInstalled;
        private MethodInfo hasFriend;
        private MethodInfo addFriend;
        private MethodInfo deleteFriend;

        private void InitializeRustIO() {
            lib = Interface.GetMod().GetLibrary<Library>("RustIO");
            if (lib == null || (isInstalled = lib.GetFunction("IsInstalled")) == null || (hasFriend = lib.GetFunction("HasFriend")) == null || (addFriend = lib.GetFunction("AddFriend")) == null || (deleteFriend = lib.GetFunction("DeleteFriend")) == null) {
                lib = null;
                Puts("{0}: {1}", Title, "Rust:IO is not present. You need to install Rust:IO first in order to use this plugin!");
            }
        }

        private bool IsInstalled() {
            if (lib == null) return false;
            return (bool)isInstalled.Invoke(lib, new object[] {});
        }

        private bool HasFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)hasFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool AddFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)addFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        private bool DeleteFriend(string playerId, string friendId) {
            if (lib == null) return false;
            return (bool)deleteFriend.Invoke(lib, new object[] { playerId, friendId });
        }

        #endregion

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            InitializeRustIO();
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Save.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Newtonsoft.Json
// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Save", "Reneb", 2.0)]
    class Save : RustPlugin
    {
        private int saveAuth;
        private bool Changed;
        private string noAccess;
        private string saved;

        void Loaded()
        {
            LoadVariables();   
        }
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        private void LoadVariables()
        {
            saveAuth = Convert.ToInt32(GetConfig("Settings", "authLevel", 1));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You are not allowed to use this command"));
            saved = Convert.ToString(GetConfig("Messages", "saved", "World & Players saved"));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Save: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        [ConsoleCommand("save.all")]
        void cmdConsoleSave(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < saveAuth)
                {
                    SendReply(arg, noAccess);
                    return;
                }
            }
            SaveRestore.Save();
            SendReply(arg, saved);
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Spawn.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: RustBuild
// Reference: UnityEngine

/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Looking For Gamers, Inc. <support@lfgame.rs>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.IO;
using System.Collections.Generic;
using System.Timers;

// Rust Unity Namespaces
using Rust;
using UnityEngine;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

using LFG;

namespace LFG
{
    public class SpawnPoint
    {
        public float x { set; get; }
        public float y { set; get; }
        public float z { set; get; }

        public SpawnPoint(float x, float y, float z) { this.x = x; this.y = y; this.z = z; }

        public bool isNotSet()
        {
            return this.x == 0.0 && this.y == 0.0 && this.z == 0.0;
        }

        public override string ToString()
        {
            return "x: " + this.x + "; y: " + this.y + "; z: " + this.z + ";";
        }
    }
}

namespace Oxide.Plugins
{
    [Info("Spawn", "Looking For Gamers <support@lfgame.rs>", "1.2.1", ResourceId = 818)]
    public class Spawn : RustPlugin
    {
        #region Other Classes
        public class ConfigObj
        {
            public int countdown { set; get; }
            public int safeDistance { set; get; }
            public string chatPrefix { set; get; }
            public string chatPrefixColor { set; get; }
            public Dictionary<string, List<string>> messages { set; get; }

            public ConfigObj()
            {
                this.messages = new Dictionary<string, List<string>> { };
                this.chatPrefix = "Spawn";
                this.chatPrefixColor = "blue";
            }

            public void addMessage(string key, List<string> message)
            {
                this.messages.Add(key, message);
            }

            public List<string> getMessage(string key, string[] args)
            {
                List<string> strings = new List<string>();
                List<string> messageList;

                if (this.messages.ContainsKey(key))
                {
                    messageList = (List<string>)this.messages[key];
                    foreach (string message in messageList)
                    {
                        strings.Add(string.Format(message, args));
                    }
                }

                return strings;
            }

        }
        #endregion

        public ConfigObj config;
        private string configPath;
        private bool loaded = false;
        private SpawnPoint spawnPoint;
        private string dataFile = "LFG-spawn";
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();

        void SetupConfig()
        {
            if (this.loaded)
            {
                return;
            }

            LoadConfig();
            this.configPath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
            this.config = JsonConvert.DeserializeObject<ConfigObj>((string)JsonConvert.SerializeObject(Config["Config"]).ToString());

            // This all seems 
            try
            {
                this.spawnPoint = Interface.GetMod().DataFileSystem.ReadObject<SpawnPoint>(this.dataFile);
            }
            catch (Exception e)
            {
                this.spawnPoint = new SpawnPoint(0.0F, 0.0F, 0.0F);
                this.SaveData();
            }

            if (this.spawnPoint == null)
            {
                this.spawnPoint = new SpawnPoint(0.0F, 0.0F, 0.0F);
            }

            this.loaded = true;
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject(this.dataFile, this.spawnPoint);
        }

        #region hook methods
        void Loaded()
        {
            this.SetupConfig();
            Print("Spawn by Looking For Gamers, has been started");
        }

        [HookMethod("LoadDefaultConfig")]
        void CreateDefaultConfig()
        {
            ConfigObj localConfig = new ConfigObj();

            localConfig.countdown = 10;
            localConfig.safeDistance = 0;

            localConfig.addMessage("welcome", new List<string>() { "Welcome to spawn!" });
            localConfig.addMessage("countdown", new List<string>() { "You will teleport to spawn in {0} seconds." });
            localConfig.addMessage("spawn", new List<string>() { "You have teleported to spawn." });
            localConfig.addMessage("setSpawn", new List<string>() { "You have set the server spawn point." });
            localConfig.addMessage("noSpawn", new List<string>() { "You have not set the server spawn point yet.", "Type /setspawn to set a spawn." });

            localConfig.addMessage("pendingTeleport", new List<string>() { "You already have a pending teleport." });
            localConfig.addMessage("canceledFromDamage", new List<string>() { "You've been hit! Your teleport has been canceled." });

            localConfig.addMessage("helpSpawn", new List<string>() { "Use /spawn to teleport to spawn." });
            localConfig.addMessage("helpSetSpawn", new List<string>() { "Use /setspawn to set the server spawn point." });
            
            this.config = localConfig;
            Config["Config"] = this.config;
            SaveConfig();

            this.SetupConfig();
        }

        void OnPlayerSpawn(BasePlayer player)
        {
            if (this.spawnPoint.isNotSet())
            {
                if (playerIsAdmin(player))
                {
                    this.chatMessage(player, config.getMessage("noSpawn", new string[] { }));
                }

                return;
            }

            if(playerSpawnedAtSleepingBag(player))
            {
                return;
            }

            this.doTeleport(null, null, player);
            this.chatMessage(player, config.getMessage("welcome", new string[] { }));
        }

        [HookMethod("OnEntityAttacked")]
        object OnEntityAttacked(MonoBehaviour entity, HitInfo hitinfo)
        {
            BasePlayer player = entity as BasePlayer;
            if (player != null)
            {
                if (closeToSpawn(player))
                {
                    return false;
                }

                if (this.timers.ContainsKey(player.userID.ToString()))
                {
                    this.timers[player.userID.ToString()].Stop();
                    this.timers.Remove(player.userID.ToString());
                    this.chatMessage(player, config.getMessage("canceledFromDamage", new string[] { }));
                }
            }

            return null;
        }

        void SendHelpText(BasePlayer player)
        {
            this.chatMessage(player, config.getMessage("helpSpawn", new string[] { }));
            if (playerIsAdmin(player))
            {
                this.chatMessage(player, config.getMessage("helpSetSpawn", new string[] { }));
            }
        }
        #endregion

        #region chat commands
        [ChatCommand("spawn")]
        void commandSpawn(BasePlayer player, string command, string[] args)
        {
            this.teleportToSpawn(player);
        }

        [ChatCommand("setspawn")]
        void commandSetSpawn(BasePlayer player, string command, string[] args)
        {
            if (!playerIsAdmin(player))
            {
                return;
            }

            Vector3 location = player.transform.position;
            this.spawnPoint = new SpawnPoint(location.x, location.y, location.z);
            this.SaveData();
            this.chatMessage(player, config.getMessage("setSpawn", new string[] { }));
        }

        #endregion

        #region console commands
        [ConsoleCommand("spawn.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            this.loaded = false;
            this.SetupConfig();
            this.Print("Spawn Reloaded");
        }

        [ConsoleCommand("spawn.reset")]
        void cmdConsoleReset(ConsoleSystem.Arg arg)
        {
            this.loaded = false;
            this.CreateDefaultConfig();
            this.SetupConfig();
            this.Print("Spawn Reset");
        }

        [ConsoleCommand("Spawn.version")]
        void cmdConsoleVersion(ConsoleSystem.Arg arg)
        {
            this.Print(Version.ToString());
        }
        #endregion

        #region private helpers
        private void Print(object msg)
        {
            Console.ForegroundColor = ConsoleColor.Blue;
            Console.WriteLine("{0}: {1}", Title, msg);
        }

        private void chatMessage(BasePlayer player, List<string> messages)
        {
            foreach (string message in messages)
            {
                player.ChatMessage(string.Format("<color={0}>{1}</color>: " + message, config.chatPrefixColor, config.chatPrefix));
            }
        }

        private bool playerIsAdmin(BasePlayer player)
        {
            return player.net.connection.authLevel == 2;
        }

        private bool closeToSpawn(BasePlayer player)
        {
            Vector3 location = player.transform.position;

            if (Math.Abs(location.x - this.spawnPoint.x) > this.config.safeDistance)
            {
                return false;
            }
            if (Math.Abs(location.y - this.spawnPoint.y) > this.config.safeDistance)
            {
                return false;
            }
            if (Math.Abs(location.z - this.spawnPoint.z) > this.config.safeDistance)
            {
                return false;
            }

            return true;
        }

        private bool playerSpawnedAtSleepingBag(BasePlayer player)
        {
            SleepingBag[] sleepingBags = SleepingBag.FindForPlayer(player.userID, false);
            foreach (SleepingBag sleepingBag in sleepingBags)
            {
                if (sleepingBag.transform.position.Equals(player.transform.position))
                {
                    return true;
                }
            }

            return false;
        }

        private void teleportToSpawn(BasePlayer player)
        {
            if (this.timers.ContainsKey(player.userID.ToString()))
            {
                this.chatMessage(player, config.getMessage("pendingTeleport", new string[] { }));
                return;
            }

            this.chatMessage(player, config.getMessage("countdown", new string[] { this.config.countdown.ToString() }));
            Timer timer = new Timer();
            timer.Interval = this.config.countdown * 1000;
            timer.Elapsed += (timerSender, timerEvent) => doTeleport(timerSender, timerEvent, player);
            timer.Start();
            this.timers[player.userID.ToString()] = timer;
        }

        public void doTeleport(object source, ElapsedEventArgs e, BasePlayer player)
        {
            player.StartSleeping();

            player.transform.position = new UnityEngine.Vector3(this.spawnPoint.x, this.spawnPoint.y, this.spawnPoint.z);
            player.ClientRPC(null, player, "ForcePositionTo", new object[] { player.transform.position });
            player.TransformChanged();
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendFullSnapshot();

            if (this.timers.ContainsKey(player.userID.ToString()))
            {
                this.timers[player.userID.ToString()].Stop();
                this.chatMessage(player, config.getMessage("spawn", new string[] { this.config.countdown.ToString() }));
            }
        }
        #endregion
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\StackSizes.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Looking For Gamers, Inc. <support@lfgame.rs>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// Rust Unity Namespaces
using Rust;
using UnityEngine;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Oxide.Plugins
{
    [Info("Stack Sizes", "Looking For Gamers <support@lfgame.rs>", "1.1.3", ResourceId = 812)]
    public class StackSizes : RustPlugin
    {
        #region Other Classes
        public class configObj
        {
            public List<itemMeta> items { set; get; }
            public configObj() { items = new List<itemMeta>(); }
        }

        public class itemMeta
        {
            public string name { set; get; }
            public int stackSize { set; get; }
            public itemMeta() { stackSize = 1; }
        }
        #endregion

        public configObj config;
        private string configPath;
        private bool loaded = false;

        #region hook methods
        void SetupConfig()
        {
            if (this.loaded)
            {
                return;
            }

            LoadConfig();
            this.configPath = Manager.ConfigPath + string.Format("\\{0}.json", Name);
            this.config = JsonConvert.DeserializeObject<configObj>((string)JsonConvert.SerializeObject(Config["Config"]).ToString());

            try
            {
                this.SetStackSizes();
                this.loaded = true;
            }
            catch (NullReferenceException e)
            {
                this.loaded = false;
            }
        }

        void Loaded()
        {
            //Puts("\n\n---------------------------------------------------------------------------------------------------------------------\n\n");
            this.SetupConfig();
            this.Print("StackSizes by Looking For Gamers, has been started");
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            this.SetupConfig();
        }

        [HookMethod("LoadDefaultConfig")]
        void CreateDefaultConfig()
        {
            configObj localConfig = new configObj();

            localConfig.items = JsonConvert.DeserializeObject<List<itemMeta>>(
                "[" +
                "{'name': 'bone_fragments', 'stackSize': 10000}," +
                "{'name': 'charcoal', 'stackSize': 10000}," +
                "{'name': 'cloth', 'stackSize': 10000}," +
                "{'name': 'fat_animal', 'stackSize': 10000}," +
                "{'name': 'gunpowder', 'stackSize': 10000}," +
                "{'name': 'lowgradefuel', 'stackSize': 10000}," +
                "{'name': 'metal_fragments', 'stackSize': 10000}," +
                "{'name': 'metal_ore', 'stackSize': 10000}," +
                "{'name': 'metal_refined', 'stackSize': 10000}," +
                "{'name': 'paper', 'stackSize': 10000}," +
                "{'name': 'stones', 'stackSize': 100000}," +
                "{'name': 'sulfur', 'stackSize': 10000}," +
                "{'name': 'sulfur_ore', 'stackSize': 100000}," +
                "{'name': 'wood', 'stackSize': 100000}" +
                "]"
            );

            this.config = localConfig;
            Config["Config"] = this.config;

            Config.Save(this.configPath);
            LoadConfig();
        }

        private void SetStackSizes()
        {
            foreach (itemMeta meta in config.items)
            {
                Item item = ItemManager.CreateByName(meta.name, 1);
                item.info.stackable = meta.stackSize;
            }
        }

        private void Print(object msg)
        {
            Puts("{0}: {1}", Title, (string) msg);
        }
        #endregion

        #region console commands
        [ConsoleCommand("stacksizes.reload")]
        void cmdConsoleReload(ConsoleSystem.Arg arg)
        {
            this.SetupConfig();
            this.Print("StackSizes Config reloaded.");
        }

        [ConsoleCommand("stacksizes.version")]
        void cmdConsoleVersion(ConsoleSystem.Arg arg)
        {
            this.Print(Version.ToString());
        }
        #endregion
    }
     
    
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\Telekinesis.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;  
using Rust;

namespace Oxide.Plugins
{

    [Info("Telekinesis", "Bombardir", 0.4)]
	class Telekinesis : RustPlugin
	{
        private static FieldInfo serverinput;
        private static byte authLevel = 2;
		private static List<MonoBehaviour> GodList = new List<MonoBehaviour>();
		
        class TelekinesisComponent : MonoBehaviour 
		{
            public float MaxDistance = 450;
            public float MinDistance = 5;
            public float speed = 3;
			public float RotateSpeed = 2;
            private BaseNetworkable target;
			private BasePlayer TargetPlayer;
            private float distance;
			private float TimeSincePressed;
            private bool IsRotate = false;
            private InputState input;
		
			void Awake() 
			{
				input = serverinput.GetValue( GetComponent<BasePlayer>() ) as InputState;
				TimeSincePressed = Time.realtimeSinceStartup;
				enabled = false;
			}

            void Update()
            {
                if (input.WasJustPressed(BUTTON.USE))
                {
                    if (Time.realtimeSinceStartup - TimeSincePressed > 0.1)
                    {
                        TimeSincePressed = Time.realtimeSinceStartup;
                        if (target != null)
                        {
                            if (TargetPlayer)
                                GodList.Remove(TargetPlayer as MonoBehaviour);
                            target = null; 
                            TargetPlayer = null;
                        }
                        else
                        {
                            RaycastHit hit;
                            Vector3 raypos = transform.position;
                            raypos.y++;
                            if (Physics.Raycast(new Ray(raypos, Quaternion.Euler(input.current.aimAngles) * Vector3.forward), out hit, MaxDistance) && hit.transform != transform)
                            {
                                target = hit.transform.GetComponentInParent<BaseNetworkable>();
                                if (target)
                                {
                                    distance = Vector3.Distance(transform.position, target.transform.position);
                                    TargetPlayer = target.GetComponent<BasePlayer>();
                                    if (TargetPlayer)
                                        GodList.Add(TargetPlayer as MonoBehaviour);
                                }
                            }
                        }
                    }
                }
                else if (input.WasJustPressed(BUTTON.RELOAD))
                    if (Time.realtimeSinceStartup - TimeSincePressed > 0.1)
                    {
                        TimeSincePressed = Time.realtimeSinceStartup;
                        IsRotate = !IsRotate;
                    }
                    
                if (target)   
                {
                    if (input.IsDown(BUTTON.PREVIOUS))
                    {
                        distance++;
                        if (distance > MaxDistance)
                            distance = MaxDistance;
                    } 
                    else if (input.IsDown(BUTTON.NEXT))
                    { 
                        distance--;
                        if (distance < MinDistance)
                            distance = MinDistance; 
                    }
 
                    target.transform.position = Vector3.Lerp(target.transform.position, transform.position +  Quaternion.Euler(input.current.aimAngles) * Vector3.forward * distance, Time.deltaTime * speed);
					if (IsRotate)
						target.transform.rotation = Quaternion.Euler(input.current.aimAngles*RotateSpeed);
                    if (TargetPlayer != null && !TargetPlayer.IsSleeping())
                        TargetPlayer.ClientRPC(null, TargetPlayer, "ForcePositionTo", new object[] { target.transform.position });
                    else
                        target.SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
                }
            }
		}
		
		
		object OnEntityAttacked(MonoBehaviour entity, HitInfo hitinfo)
		{
			if (entity != null && hitinfo != null)
				if (GodList.Contains(entity))
					{
						for (int index = 0; index < 17; ++index)
							hitinfo.damageTypes.Set( (DamageType) index, 0.0f );
						entity.GetComponent<BasePlayer>().metabolism.bleeding.value = 0.0f;
						hitinfo.HitMaterial = 0U;
						return true;
					}
			return null; 
		} 
    
		void LoadDefaultConfig()
		{
			Config["AuthLevel"] = 2;
			SaveConfig();
		}  
	
        void Init()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
			if (Config["AuthLevel"] != null)
				authLevel = Convert.ToByte(Config["AuthLevel"]);
        }
		
		void Unload()
		{	
			var objects = GameObject.FindObjectsOfType(typeof(TelekinesisComponent));
			if (objects != null)
				foreach (var gameObj in objects)
					GameObject.Destroy(gameObj);
		}   
 
        [ChatCommand("tls")]
        void Fly(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel >= authLevel)
			{
                TelekinesisComponent telekinesis = player.GetComponent<TelekinesisComponent>();
                if (!telekinesis)
                    telekinesis = player.gameObject.AddComponent<TelekinesisComponent>();
					
				if (args.Length > 1)
					switch (args[0])
					{
						case "speed":
							telekinesis.speed = Convert.ToSingle(args[1]);
							SendReply(player, "Now, the speed = "+args[1]);
							break;
						case "max":
							telekinesis.MaxDistance = Convert.ToSingle(args[1]);
							SendReply(player, "Now, the max distance = "+args[1]);
							break;
						case "min":
							telekinesis.MinDistance = Convert.ToSingle(args[1]);
							SendReply(player, "Now, the min distance = "+args[1]);
							break;
						case "rotate":
							telekinesis.RotateSpeed = Convert.ToSingle(args[1]);
							SendReply(player, "Now, the rotate speed = "+args[1]);
							break;
						default:
							SendReply(player, "Variables: speed, max, min, rotate");
							break;
					}
				else
					if (telekinesis.enabled)
					{
						telekinesis.enabled = false;
						SendReply(player, "Telekinesis deactivated!");	
					}
					else
					{
						telekinesis.enabled = true;
						SendReply(player, "Telekinesis activated!");
					}
			}
			else
				SendReply(player, "No Permission!");
        }
	}
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\TwigRemover.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Twig Remover", "bawNg", 0.2)]
    class TwigRemover : RustPlugin
    {
        const float cupboardDistance = 60f;
        
        [ConsoleCommand("twigs.count")]
        void cmdCountTwigs(ConsoleSystem.Arg arg)
        {
            if (arg.Player() && !arg.Player().IsAdmin())
            {
                SendReply(arg, "You need to be admin to use that command");
                return;
            }
            var twig_blocks = FindAllCupboardlessTwigBlocks();
            SendReply(arg, $"There are {twig_blocks.Count} twig blocks outside of cupboard range");
        }

        [ConsoleCommand("twigs.remove")]
        void cmdRemoveTwigs(ConsoleSystem.Arg arg)
        {
            if (arg.Player() && !arg.Player().IsAdmin())
            {
                SendReply(arg, "You need to be admin to use that command");
                return;
            }
            PrintToChat("<color=red>Admin is removing all twig blocks outside of cupboard range...</color>");
            var twig_blocks = FindAllCupboardlessTwigBlocks();
            var started_at = Time.realtimeSinceStartup;
            foreach (var building_block in twig_blocks)
                building_block.Kill();
            Puts($"[TwigRemover] Destroyed {twig_blocks.Count} twig blocks in {Time.realtimeSinceStartup - started_at:0.000} seconds");
            PrintToChat($"<color=yellow>Admin has removed {twig_blocks.Count} twig blocks from the map</color>");
        }

        HashSet<BuildingBlock> FindAllCupboardlessTwigBlocks()
        {
            var tool_cupboards = FindAllToolCupboards();
            var twig_blocks = FindAllTwigBuildingBlocks();                        
            var started_at = Time.realtimeSinceStartup;
            Puts($"[TwigRemover] Checking {twig_blocks.Count} twig blocks against {tool_cupboards.Length} tool cupboards...");
            foreach (var cupboard in tool_cupboards)
            {
                foreach (var collider in Physics.OverlapSphere(cupboard.transform.position, cupboardDistance))
                {
                    var building_block = collider.GetComponentInParent<BuildingBlock>();
                    if (building_block) twig_blocks.Remove(building_block);
                }
            }
            Puts($"[TwigRemover] Finding {twig_blocks.Count} cupboardless twig blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return twig_blocks;
        }
        
        HashSet<BuildingBlock> FindAllTwigBuildingBlocks()
        {
            var started_at = Time.realtimeSinceStartup;
            Puts("[TwigRemover] Finding all twig blocks...");
            var building_blocks = UnityEngine.Object.FindObjectsOfType<BuildingBlock>();
            var twig_blocks = new HashSet<BuildingBlock>(building_blocks.Where(block => block.grade == BuildingGrade.Enum.Twigs));
            Puts($"[TwigRemover] Finding {twig_blocks.Count} twig blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return twig_blocks;
        }

        BaseCombatEntity[] FindAllToolCupboards()
        {
            var started_at = Time.realtimeSinceStartup;
            Puts("[TwigRemover] Finding all tool cupboards...");
            var combat_entities = UnityEngine.Object.FindObjectsOfType<BaseCombatEntity>();
            var tool_cupboards = combat_entities.Where(entity => entity.LookupPrefabName() == "items/cupboard.tool.deployed").ToArray();
            Puts($"[TwigRemover] Finding {tool_cupboards.Length} tool cupboards took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return tool_cupboards;
        }
    }
}
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\TwigsDecay.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json
// Reference: UnityEngine

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Text;
using Rust;

namespace Oxide.Plugins
{
    [Info("TwigsDecay", "playrust.io / dcode", "1.4.0", ResourceId = 857)]
    public class TwigsDecay : RustPlugin
    {
        private Dictionary<string, int> damage = new Dictionary<string, int>();
        private int timespan;
        private DateTime lastUpdate = DateTime.Now;
        private List<string> blocks = new List<string>();
        private bool initialized = false;

        // A list of all translateable texts
        private List<string> texts = new List<string>() {
            "Twigs",
            "Wood",
            "Stone",
            "Metal",
            "TopTier",
            "%GRADE% buildings decay by %DAMAGE% HP per %TIMESPAN% minutes.",
            "%GRADE% buildings do not decay."
        };
        private Dictionary<string, string> messages = new Dictionary<string, string>();

        protected override void LoadDefaultConfig() {
            var damage = new Dictionary<string, object>() {
                {"Twigs"    , 1}, // health: 5
                {"Wood"     , 0}, // health: 250
                {"Stone"    , 0}, // health: 500
                {"Metal"    , 0}, // health: 200
                {"TopTier"  , 0}, // health: 1000
                {"Barricade", 0}  // health: 350, 400, 500
            };
            Config["damage"] = damage;
            Config["timespan"] = 288;
            var blocks = new List<object>() {
                "block.halfheight",
                /* stairs */ "block.halfheight.slanted",
                "floor",
                "floor.triangle",
                "foundation",
                "foundation.steps",
                "foundation.triangle",
                // "pillar",
                "roof",
                "wall",
                "wall.doorway",
                // "door.hinged",
                "wall.low",
                "wall.window",
                "wall.window.bars"
            };
            Config["blocks"] = blocks;
            var messages = new Dictionary<string, object>();
            foreach (var text in texts) {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        [HookMethod("Init")]
        private void Init() {
            if (decay.scale > 0f) {
                decay.scale = 0f;
                Puts("{0}: {1}", Title, "Default decay has been disabled");
            }
        }

        [HookMethod("OnServerInitialized")]
        private void OnServerInitialized() {
            LoadConfig();
            try {
                var damageConfig = (Dictionary<string, object>)Config["damage"];
                int val;
                foreach (var cfg in damageConfig)
                    damage.Add(cfg.Key, (val = Convert.ToInt32(cfg.Value)) >= 0 ? val : 0);
                timespan = Convert.ToInt32(Config["timespan"]);
                if (timespan < 0)
                    timespan = 15;
                var blocksConfig = (List<object>)Config["blocks"];
                foreach (var cfg in blocksConfig)
                    blocks.Add(Convert.ToString(cfg));
                initialized = true;
                var customMessages = (Dictionary<string, object>)Config["messages"];
                if (customMessages != null)
                    foreach (var pair in customMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
                Puts("{0}: {1}", Title, "Initialized");
            } catch (Exception ex) {
                PrintError("{0}: {1}", Title, "Failed to load configuration file: " + ex.Message);
            }
        }

        [HookMethod("OnTick")]
        private void OnTick() {
            if (!initialized)
                return;
            var now = DateTime.Now;
            if (lastUpdate > now.AddMinutes(-timespan))
                return;
            lastUpdate = now;
            int blocksDecayed = 0;
            int blocksDestroyed = 0;
            var allBlocks = UnityEngine.Object.FindObjectsOfType<BuildingBlock>();
            int amount;
            foreach (var block in allBlocks) {
                if (block.isDestroyed)
                    continue;
                string grade;
                string name;
                try {
                    grade = block.grade.ToString();
                    name = block.blockDefinition.fullName.Substring(6); // "build/foundation"
                } catch (Exception) {
                    continue;
                }
                if (!blocks.Contains(name))
                    continue;
                if (damage.TryGetValue(grade, out amount) && amount > 0) {
                    block.Hurt(amount, DamageType.Decay, null);
                    ++blocksDecayed;
                    if (block.isDestroyed)
                        ++blocksDestroyed;
                }
            }
            int barricadesDecayed = 0;
            int barricadesDestroyed = 0;
            if (damage.TryGetValue("Barricade", out amount) && amount > 0) {
                var allBarricades = UnityEngine.Object.FindObjectsOfType<Barricade>();
                foreach (var barricade in allBarricades) {
                    if (barricade.isDestroyed)
                        continue;
                    Puts("{0}: {1}", Title, "Start health: "+barricade.startHealth);
                    barricade.Hurt(amount);
                    ++barricadesDecayed;
                    if (barricade.isDestroyed)
                        ++barricadesDestroyed;
                }
            }
            Puts("{0}: {1}", Title, "Decayed " + blocksDecayed + " blocks (" + blocksDestroyed + " destroyed) and "+barricadesDecayed+" barricades ("+barricadesDestroyed+" destroyed)");
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player) {
            var sb = new StringBuilder()
               .Append("<size=18>TwigsDecay</size> by <color=#ce422b>http://playrust.io</color>\n");
            foreach (var dmg in damage) {
                if (dmg.Value > 0)
                    sb.Append("  ").Append(_("%GRADE% buildings decay by %DAMAGE% HP per %TIMESPAN% minutes.", new Dictionary<string, string> {
                        { "GRADE", _(dmg.Key) },
                        { "DAMAGE", dmg.Value.ToString() },
                        { "TIMESPAN", timespan.ToString() }
                    })).Append("\n");
                else
                    sb.Append("  ").Append(_("%GRADE% buildings do not decay.", new Dictionary<string, string>() {
                        { "GRADE", _(dmg.Key) }
                    })).Append("\n");
            }
            player.ChatMessage(sb.ToString().TrimEnd());
        }

        // Translates a string
        private string _(string text, Dictionary<string, string> replacements = null) {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\UniqueName.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ï»¿// Reference: Oxide.Ext.Rust
// Reference: Newtonsoft.Json

/*
 * The MIT License (MIT)
 * Copyright (c) 2015 Feramor
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//Microsoft NameSpaces
using System;
using System.Collections.Generic;

//Oxide NameSpaces
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

//External NameSpaces
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Unique Name Plugin", "Feramor", "1.0.1")]
    public class UniqueName : RustPlugin
    {
        private static Logger logger = Interface.GetMod().RootLogger;
        public Core.Configuration.DynamicConfigFile mySave;

        Dictionary<string, object> UserNames = new Dictionary<string, object>();
        Dictionary<string, object> Users = new Dictionary<string, object>();
        Dictionary<string, object> KickList = new Dictionary<string, object>();
        void Init()
        {
            LoadConfig();
            mySave = Interface.GetMod().DataFileSystem.GetDatafile("UniqueName");

            if (mySave["UserNames"] != null)
                if (((Dictionary<string, object>)mySave["UserNames"]).Count != 0)
                    UserNames = (Dictionary<string, object>) mySave["UserNames"];
            if (mySave["Users"] != null)
                if (((Dictionary<string, object>)mySave["Users"]).Count != 0)
                    Users = (Dictionary<string, object>)mySave["Users"];

            foreach (BasePlayer CurrentPlayer in BasePlayer.activePlayerList)
            {
                CheckPlayer(CurrentPlayer);
            }
            mySaveData();
        }


        void CheckPlayer(BasePlayer Player)
        {
            if (UserNames.ContainsKey(Player.displayName.ToString()))
            {
                if (Player.userID.ToString() != UserNames[Player.displayName.ToString()].ToString())
                {
                    long CurrentTimer = Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                    Dictionary<string, object> User = (Dictionary<string, object>) Users[UserNames[Player.displayName.ToString()].ToString()];

                    if (CurrentTimer >= Convert.ToInt64(User["TIMER"].ToString()))
                    {
                        Users.Remove(UserNames[Player.displayName.ToString()].ToString());
                        UserNames.Remove(Player.displayName.ToString());

                        Dictionary<string, object> NewUser = new Dictionary<string, object>();
                        NewUser.Add("USERNAME", Player.displayName.ToString());
                        NewUser.Add("TIMER", (CurrentTimer + Convert.ToInt64((string)(((Dictionary<string, object>)Config["Settings"])["DeletionTime"]))).ToString());

                        if (Users.ContainsKey(Player.userID.ToString()))
                        {
                            Dictionary<string, object> OldUserName = (Dictionary<string, object>)Users[Player.userID.ToString()];
                            UserNames.Remove(OldUserName["USERNAME"].ToString());
                            Users.Remove(Player.userID.ToString());
                        }

                        Users.Add(Player.userID.ToString(), NewUser);
                        UserNames.Add(Player.displayName.ToString(), Player.userID.ToString());

                        logger.Write(LogType.Info, "UniqueName : User ({0}) replaced SteamID after {1} seconds.", Player.displayName.ToString(), Convert.ToInt64((string)(((Dictionary<string, object>)Config["Settings"])["DeletionTime"])).ToString());
                    }
                    else
                    {
                        try
                        {
                            KickList.Add(Player.userID.ToString(), (CurrentTimer + 30).ToString());
                        }
                        catch { }
                        logger.Write(LogType.Info, "UniqueName : User ({0}) registered under another SteamID kicking.", Player.displayName.ToString());
                    }
                }
                else
                {
                    long CurrentTimer = Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                    Dictionary<string, object> User = (Dictionary<string, object>) Users[UserNames[Player.displayName.ToString()].ToString()];
                    User.Remove("TIMER");
                    User.Add("TIMER",(CurrentTimer + Convert.ToInt64((string)(((Dictionary<string, object>)Config["Settings"])["DeletionTime"]))).ToString());

                    logger.Write(LogType.Info, "UniqueName : User ({0}) extended.", Player.displayName.ToString());
                }
            }
            else
            {
                long CurrentTimer = Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                Dictionary<string, object> NewUser = new Dictionary<string, object>();
                NewUser.Add("USERNAME", Player.displayName.ToString());
                NewUser.Add("TIMER", (CurrentTimer + Convert.ToInt64((string)(((Dictionary<string, object>)Config["Settings"])["DeletionTime"]))).ToString());
                if (Users.ContainsKey(Player.userID.ToString()))
                {
                    Dictionary<string, object> OldUserName = (Dictionary<string, object>)Users[Player.userID.ToString()];
                    UserNames.Remove(OldUserName["USERNAME"].ToString());
                    Users.Remove(Player.userID.ToString());
                }
                Users.Add(Player.userID.ToString(), NewUser);
                UserNames.Add(Player.displayName.ToString(), Player.userID.ToString());

                logger.Write(LogType.Info, "UniqueName : User ({0}) added.", Player.displayName.ToString());
            }
            mySaveData();
        }

        void mySaveData()
        {
            mySave["UserNames"] = UserNames;
            mySave["Users"] = Users;

            Interface.GetMod().DataFileSystem.SaveDatafile("UniqueName");
        }
        void OnTick()
        {
            if (KickList.Count > 0)
            {
                long CurrentTimer = Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
                List<string> DeleteFromKickList = new List<string>();
                foreach (var CurrentPlayer in KickList)
                {
                    if (CurrentTimer > Convert.ToInt64(CurrentPlayer.Value.ToString()))
                    {
                        BasePlayer CurrentPlayerObj = BasePlayer.FindByID(Convert.ToUInt64((String)CurrentPlayer.Key.ToString()));
                        if (CurrentPlayerObj != null)
                        {
                            logger.Write(Oxide.Core.Logging.LogType.Info, "UniqueName : {0} has been kicked.", CurrentPlayerObj.displayName.ToString());
                            Network.Net.sv.Kick(CurrentPlayerObj.net.connection, "This name reserved on this server.Please change your name to enter this server.");
                        }
                        DeleteFromKickList.Add(CurrentPlayer.Key.ToString());
                    }
                }
                foreach(string Current in DeleteFromKickList)
                {
                    KickList.Remove(Current);
                }
            }
        }
        [HookMethod("LoadDefaultConfig")]
        void myLoadDefaultConfig()
        {
            Dictionary<string, object> NewConfig = new Dictionary<string, object>();
            NewConfig.Add("DeletionTime", "604800");
            Config["Settings"] = NewConfig;
            logger.Write(Oxide.Core.Logging.LogType.Info, "UniqueName : Default Config loaded.");
        }
        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer new_player)
        {
            try
            {
                KickList.Remove(new_player.userID.ToString());
            }
            catch { }
            CheckPlayer(new_player);
        }
    }
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\cs\ZoneManager.cs
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Rust;

namespace Oxide.Plugins
{
    [Info("ZoneManager", "Reneb", "2.0.12", ResourceId = 739)]
    class ZoneManager : RustPlugin
    {
        ////////////////////////////////////////////
        /// FIELDS
        ////////////////////////////////////////////
        StoredData storedData;

        static Hash<string, ZoneDefinition> zonedefinitions = new Hash<string, ZoneDefinition>();
        public Hash<BasePlayer, string> LastZone = new Hash<BasePlayer, string>();
        public static Hash<BasePlayer, List<Zone>> playerZones = new Hash<BasePlayer, List<Zone>>();

        public static int triggerLayer;
        public static int playersMask;

        public FieldInfo[] allZoneFields;
        public FieldInfo cachedField;
        public static FieldInfo fieldInfo;
         
        /////////////////////////////////////////
        /// Cached Fields, used to make the plugin faster
        /////////////////////////////////////////
        public static Vector3 cachedDirection;
        public Collider[] cachedColliders;
        public DamageTypeList emptyDamageType;
        public List<DamageTypeEntry> emptyDamageList;
        public BasePlayer cachedPlayer;

        /////////////////////////////////////////
        // ZoneLocation
        // Stored information for the zone location and radius
        /////////////////////////////////////////
        public class ZoneLocation
        {
            public string x;
            public string y;
            public string z;
            public string r;
            Vector3 position;
            float radius;

            public ZoneLocation() { }

            public ZoneLocation(Vector3 position, string radius)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();

                r = radius.ToString();

                this.position = position;
                this.radius = float.Parse(radius);
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
            public float GetRadius()
            {
                if (radius == 0f)
                    radius = float.Parse(r);
                return radius;
            }
            public string String()
            {
                return string.Format("Pos({0},{1},{2}) - Rad({3})", x, y, z, r);
            }
        }
        /////////////////////////////////////////
        // RadiationZone
        // is a MonoBehaviour
        // This is needed for zones that use radiations only
        /////////////////////////////////////////
        public class RadiationZone : MonoBehaviour
        {
            public TriggerRadiation radiation;
            Zone zone;

            void Awake()
            {
                radiation = gameObject.AddComponent<TriggerRadiation>();
                zone = GetComponent<Zone>();
                radiation.RadiationAmount = float.Parse(zone.info.radiation);
                radiation.radiationSize = GetComponent<UnityEngine.SphereCollider>().radius;
                radiation.interestLayers = playersMask;
            }
            void OnDestroy()
            {
                GameObject.Destroy(radiation);
            }

        }
        /////////////////////////////////////////
        // Zone
        // is a Monobehavior
        // used to detect the colliders with players
        // and created everything on it's own (radiations, locations, etc)
        /////////////////////////////////////////
        public class Zone : MonoBehaviour
        {
            public ZoneDefinition info;
            public List<BasePlayer> inTrigger = new List<BasePlayer>();
            public List<BasePlayer> whiteList = new List<BasePlayer>();
            public List<BasePlayer> keepInList = new List<BasePlayer>();
            RadiationZone radiationzone;
            float radiationamount;

            void Awake()
            {
                gameObject.layer = triggerLayer;
                gameObject.name = "Zone Manager";
                gameObject.AddComponent<UnityEngine.SphereCollider>();
                gameObject.SetActive(true);
            }
            public void SetInfo(ZoneDefinition info)
            {
                this.info = info;
                GetComponent<UnityEngine.Transform>().position = info.Location.GetPosition();
                GetComponent<UnityEngine.SphereCollider>().radius = info.Location.GetRadius();
                radiationamount = 0f;
                if (float.TryParse(info.radiation, out radiationamount))
                    radiationzone = gameObject.AddComponent<RadiationZone>();
            }
            void OnDestroy()
            {
                if (radiationzone != null)
                    GameObject.Destroy(radiationzone);
            }
            void OnTriggerEnter(Collider col)
            {
                if (col.GetComponentInParent<BasePlayer>())
                {
                    inTrigger.Add(col.GetComponentInParent<BasePlayer>());
                    OnEnterZone(this, col.GetComponentInParent<BasePlayer>());
                }
            }
            void OnTriggerExit(Collider col)
            {
                if (col.GetComponentInParent<BasePlayer>())
                {
                    inTrigger.Remove(col.GetComponentInParent<BasePlayer>());
                    OnExitZone(this, col.GetComponentInParent<BasePlayer>());
                }
            }
        }

        /////////////////////////////////////////
        // ZoneDefinition
        // Stored informations on the zones
        /////////////////////////////////////////
        public class ZoneDefinition
        {

            public string name;
            public string radius;
            public ZoneLocation Location;
            public string ID;
            public string eject;
            public string pvpgod;
            public string pvegod;
            public string sleepgod;
            public string undestr;
            public string nobuild;
            public string notp;
            public string nochat;
            public string nodeploy;
            public string nokits;
            public string nosuicide;
            public string killsleepers;
            public string radiation;
            public string enter_message;
            public string leave_message;

            public ZoneDefinition()
            {

            }

            public ZoneDefinition(Vector3 position)
            {
                this.radius = "20";
                Location = new ZoneLocation(position, this.radius);
            }

        }
        /////////////////////////////////////////
        // Data Management
        /////////////////////////////////////////
        class StoredData
        {
            public HashSet<ZoneDefinition> ZoneDefinitions = new HashSet<ZoneDefinition>();
            public StoredData()
            {
            }
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("ZoneManager", storedData);
        }
        void LoadData()
        {
            zonedefinitions.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("ZoneManager");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var zonedef in storedData.ZoneDefinitions)
                zonedefinitions[zonedef.ID] = zonedef;
        }
        /////////////////////////////////////////
        // OXIDE HOOKS
        /////////////////////////////////////////

        /////////////////////////////////////////
        // Loaded()
        // Called when the plugin is loaded
        /////////////////////////////////////////
        void Loaded()
        {
            permission.RegisterPermission("zone", this);
            permission.RegisterPermission("candeploy", this);
            permission.RegisterPermission("canbuild", this);
            triggerLayer = UnityEngine.LayerMask.NameToLayer("Trigger");
            playersMask = LayerMask.GetMask(new string[] { "Player (Server)" });
            LoadData();
        }
        /////////////////////////////////////////
        // Unload()
        // Called when the plugin is unloaded
        /////////////////////////////////////////
        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(Zone));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }
        void Unloaded()
        {
            SaveData();
        }
        /////////////////////////////////////////
        // OnServerInitialized()
        // Called when the server is initialized
        /////////////////////////////////////////
        void OnServerInitialized()
        {
            allZoneFields = typeof(ZoneDefinition).GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic);
            emptyDamageType = new DamageTypeList();
            emptyDamageList = new List<DamageTypeEntry>();
            foreach (KeyValuePair<string, ZoneDefinition> pair in zonedefinitions)
            {
                NewZone(pair.Value);
            }
        }

        /////////////////////////////////////////
        // OnEntityBuilt(Planner planner, GameObject gameobject)
        // Called when a buildingblock was created
        /////////////////////////////////////////
        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner.ownerPlayer == null) return;
            if (hasTag(planner.ownerPlayer, "nobuild"))
            {
                if (!hasPermission(planner.ownerPlayer, "canbuild"))
                {
                    gameobject.GetComponentInParent<BuildingBlock>().Kill(BaseNetworkable.DestroyMode.Gib);
                    SendMessage(planner.ownerPlayer, "You are not allowed to build here");
                }
            }
        }
        /////////////////////////////////////////
        // OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)
        // Called when an item was deployed
        /////////////////////////////////////////
        void OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)
        {
            if (deployer.ownerPlayer == null) return;
            if (hasTag(deployer.ownerPlayer, "nodeploy"))
            {
                if (!hasPermission(deployer.ownerPlayer, "candeploy"))
                {
                    deployedEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                    SendMessage(deployer.ownerPlayer, "You are not allowed to deploy here");
                }
            }
        }
         
        /////////////////////////////////////////
        // OnPlayerChat(ConsoleSystem.Arg arg)
        // Called when a user writes something in the chat, doesn't take in count the commands
        /////////////////////////////////////////
        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null) return null;
            if (arg.connection.player == null) return null;
            if (hasTag((BasePlayer)arg.connection.player, "nochat"))
            {
                SendMessage((BasePlayer)arg.connection.player, "You are not allowed to chat here");
                return false;
            }
            return null;
        }

        /////////////////////////////////////////
        // OnRunCommand(ConsoleSystem.Arg arg)
        // Called when a user executes a command
        /////////////////////////////////////////
        object OnRunCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null) return null;
            if (arg.connection == null) return null;
            if (arg.connection.player == null) return null;
            if (arg.cmd == null) return null;
            if (arg.cmd.name == null) return null;
            if ((string)arg.cmd.name == "kill" && hasTag((BasePlayer)arg.connection.player, "nosuicide"))
            {
                SendMessage((BasePlayer)arg.connection.player, "You are not allowed to suicide here");
                return false;
            }
            return null;
        }

        /////////////////////////////////////////
        // OnPlayerDisconnected(BasePlayer player)
        // Called when a user disconnects
        /////////////////////////////////////////
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (hasTag(player, "killsleepers")) player.Die();
        }

        /////////////////////////////////////////
        // OnEntityAttacked(BaseCombatEntity entity, HitInfo hitinfo)
        // Called when any entity is attacked
        /////////////////////////////////////////
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (entity is BasePlayer)
            {
                cachedPlayer = entity as BasePlayer;
                if (cachedPlayer.IsSleeping())
                {
                    if (hasTag(cachedPlayer, "sleepgod"))
                        CancelDamage(hitinfo);
                }
                else if (hitinfo.Initiator != null)
                {
                    if (hitinfo.Initiator is BasePlayer)
                    {
                        if (hasTag(cachedPlayer, "pvpgod"))
                            CancelDamage(hitinfo);
                    }
                    else if (hasTag(cachedPlayer, "pvegod"))
                        CancelDamage(hitinfo);
                }
            }
            else if ((entity is BuildingBlock) || (entity is WorldItem))
            {
                if (hitinfo != null && hitinfo.Initiator != null)
                {
                    if (hitinfo.Initiator is BasePlayer)
                    {
                        if (hasTag(hitinfo.Initiator as BasePlayer, "undestr"))
                            CancelDamage(hitinfo);
                    }
                }
            }
        }

        /////////////////////////////////////////
        // OnEntityDeath(BaseNetworkable basenet)
        // Called when any entity is spawned
        /////////////////////////////////////////
        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if(entity is BasePlayer)
            {
                cachedPlayer = entity as BasePlayer;
                if(playerZones[cachedPlayer] != null)
                    playerZones[cachedPlayer].Clear(); 
            }
        }

        /////////////////////////////////////////
        // OnEntitySpawned(BaseNetworkable basenet)
        // Called when any entity is spawned
        /////////////////////////////////////////
        void OnEntitySpawned(BaseNetworkable basenet)
        {
            if (basenet is TimedExplosive)
            {
                timer.Once(4f, () => CheckExplosivePosition(basenet as TimedExplosive));
            }
        }

        /////////////////////////////////////////
        // Outside Plugin Hooks
        /////////////////////////////////////////

        /////////////////////////////////////////
        // canRedeemKit(BasePlayer player)
        // Called from the Kits plugin (Reneb) when trying to redeem a kit
        /////////////////////////////////////////
        object canRedeemKit(BasePlayer player)
        {
            if (hasTag(player, "nokits")) { return "You may not redeem a kit inside this area"; }
            return null;
        }

        /////////////////////////////////////////
        // canTeleport(BasePlayer player)
        // Called from Teleportation System (Mughisi) when a player tries to teleport
        /////////////////////////////////////////
        object canTeleport(BasePlayer player)
        {
            if (hasTag(player, "notp")) { return "You may not teleport in this area"; }
            return null;
        }

        /////////////////////////////////////////
        // External calls to this plugin
        /////////////////////////////////////////

        /////////////////////////////////////////
        // CreateOrUpdateZone(string ZoneID, object[] args)
        // Create or Update a zone from an external plugin
        // ZoneID should be a name, like Arena (for an arena plugin) (even if it's called an ID :p)
        // args are the same a the /zone command
        // args[0] = "radius" args[1] = "50" args[2] = "eject" args[3] = "true", etc
        // Third parameter is obviously need if you create a NEW zone (or want to update the position)
        /////////////////////////////////////////
        bool CreateOrUpdateZone(string ZoneID, string[] args, Vector3 position = default(Vector3))
        {
            var zonedef = zonedefinitions[ZoneID];
            if (zonedefinitions[ZoneID] != null) storedData.ZoneDefinitions.Remove(zonedefinitions[ZoneID]);
            if (zonedef == null)
            {
                zonedef = new ZoneDefinition();
                zonedef.ID = ZoneID;
            }

            string editvalue;
            for (int i = 0; i < args.Length; i = i + 2)
            {

                cachedField = GetZoneField(args[i]);
                if (cachedField == null) continue;

                switch (args[i + 1])
                {
                    case "true":
                    case "1":
                        editvalue = "true";
                        break;
                    case "null":
                    case "0":
                    case "false":
                    case "reset":
                        editvalue = null;
                        break;
                    default:
                        editvalue = (string)args[i + 1];
                        break;
                }
                cachedField.SetValue(zonedef, editvalue);
                if (args[i].ToLower() == "radius") { if (zonedef.Location != null) zonedef.Location = new ZoneLocation(zonedef.Location.GetPosition(), editvalue); }
            }

            if (position != default(Vector3)) { zonedef.Location = new ZoneLocation((Vector3)position, (zonedef.radius != null) ? zonedef.radius : "20"); }
            
            zonedefinitions[ZoneID] = zonedef;
            storedData.ZoneDefinitions.Add(zonedefinitions[ZoneID]);
            SaveData();
            if (zonedef.Location == null) return false;
            RefreshZone(ZoneID);
            return true;
        }
        bool EraseZone(string ZoneID)
        {
            if (zonedefinitions[ZoneID] == null) return false;
            
            storedData.ZoneDefinitions.Remove(zonedefinitions[ZoneID]);
            zonedefinitions[ZoneID] = null;
            SaveData();
            RefreshZone(ZoneID);
            return true;
        }
        List<BasePlayer> GetPlayersInZone(string ZoneID)
        {
            List<BasePlayer> baseplayers = new List<BasePlayer>();
            foreach (KeyValuePair<BasePlayer, List<Zone>> pair in playerZones)
            {
                foreach (Zone zone in pair.Value)
                {
                    if (zone.info.ID == ZoneID)
                    {
                        baseplayers.Add(pair.Key);
                    }
                }
            }
            return baseplayers;
        }
        bool isPlayerInZone(string ZoneID, BasePlayer player)
        {
            if (playerZones[player] == null) return false;
            foreach (Zone zone in playerZones[player])
            {
                if (zone.info.ID == ZoneID)
                {
                    return true;
                }
            }
            return false;
        }
        bool AddPlayerToZoneWhitelist(string ZoneID, BasePlayer player)
        {
            Zone targetZone = GetZoneByID(ZoneID);
            if (targetZone == null) return false;
            AddToWhitelist(targetZone, player);
            return true;
        }
        bool AddPlayerToZoneKeepinlist(string ZoneID, BasePlayer player)
        {
            Zone targetZone = GetZoneByID(ZoneID);
            if (targetZone == null) return false;
            AddToKeepinlist(targetZone, player);
            return true;
        }
        bool RemovePlayerFromZoneWhitelist(string ZoneID, BasePlayer player)
        {
            Zone targetZone = GetZoneByID(ZoneID);
            if (targetZone == null) return false;
            RemoveFromWhitelist(targetZone, player);
            return true;
        }
        bool RemovePlayerFromZoneKeepinlist(string ZoneID, BasePlayer player)
        {
            Zone targetZone = GetZoneByID(ZoneID);
            if (targetZone == null) return false;
            RemoveFromKeepinlist(targetZone, player);
            return true; 
        }
        /////////////////////////////////////////
        // Random Commands
        /////////////////////////////////////////
        void AddToWhitelist(Zone zone, BasePlayer player) { if (!zone.whiteList.Contains(player)) zone.whiteList.Add(player); }
        void RemoveFromWhitelist(Zone zone, BasePlayer player) { if (zone.whiteList.Contains(player)) zone.whiteList.Remove(player); }
        void AddToKeepinlist(Zone zone, BasePlayer player) { if (!zone.keepInList.Contains(player)) zone.keepInList.Add(player); }
        void RemoveFromKeepinlist(Zone zone, BasePlayer player) { if (zone.keepInList.Contains(player)) zone.keepInList.Remove(player); }

        Zone GetZoneByID(string ZoneID)
        {
            var objects = GameObject.FindObjectsOfType(typeof(Zone));
            if (objects != null)
                foreach (Zone gameObj in objects)
                {
                    if (gameObj.info.ID == ZoneID) return gameObj;
                }

            return null;
        }

        void NewZone(ZoneDefinition zonedef)
        {
            if (zonedef == null) return;
            var newgameObject = new UnityEngine.GameObject();
            var newZone = newgameObject.AddComponent<Zone>();
            newZone.SetInfo(zonedef);
        }
        void RefreshZone(string zoneID)
        {
            var objects = GameObject.FindObjectsOfType(typeof(Zone));
            if (objects != null)
                foreach (Zone gameObj in objects)
                {
                    if (gameObj.info.ID == zoneID)
                    {
                        foreach (KeyValuePair<BasePlayer, List<Zone>> pair in playerZones)
                        {
                            if (pair.Value.Contains(gameObj)) playerZones[pair.Key].Remove(gameObj);
                        }
                        GameObject.Destroy(gameObj);
                        break;
                    }
                }
            if (zonedefinitions[zoneID] != null)
            {
                NewZone(zonedefinitions[zoneID]);
            }
        }

        int GetRandom(int min, int max) { return UnityEngine.Random.Range(min, max); }

        FieldInfo GetZoneField(string name)
        {
            name = name.ToLower();
            foreach (FieldInfo fieldinfo in allZoneFields) { if (fieldinfo.Name == name) return fieldinfo; }
            return null;
        }
        static bool hasTag(BasePlayer player, string tagname)
        {
            if (playerZones[player] == null) { return false; }
            if (playerZones[player].Count == 0) { return false; }
            fieldInfo = typeof(ZoneDefinition).GetField(tagname, BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic);
            foreach (Zone zone in playerZones[player])
            {
                if (fieldInfo.GetValue(zone.info) != null)
                    return true;
            }
            return false;
        }



        BasePlayer FindPlayerByRadius(Vector3 position, float rad)
        {
            cachedColliders = Physics.OverlapSphere(position, rad, playersMask);
            foreach (Collider collider in cachedColliders)
            {
                if (collider.GetComponentInParent<BasePlayer>())
                    return collider.GetComponentInParent<BasePlayer>();
            }
            return null;
        }
        void CheckExplosivePosition(TimedExplosive explosive)
        {
            if (explosive == null) return;
            var objects = GameObject.FindObjectsOfType(typeof(Zone));
            if (objects != null)
                foreach (Zone zone in objects)
                {
                    if (zone.info.undestr != null)
                    {
                        if (Vector3.Distance(explosive.GetEstimatedWorldPosition(), zone.transform.position) <= (zone.info.Location.GetRadius()))
                            explosive.KillMessage();
                    }
                }
        }

        void CancelDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = emptyDamageType;
            hitinfo.DoHitEffects = false;
            hitinfo.HitMaterial = 0;
        }
        static void OnEnterZone(Zone zone, BasePlayer player)
        {
            if (playerZones[player] == null) playerZones[player] = new List<Zone>();
            if (!playerZones[player].Contains(zone)) playerZones[player].Add(zone);
            if (zone.info.enter_message != null) SendMessage(player, zone.info.enter_message);
            if (zone.info.eject != null && !isAdmin(player) && !zone.whiteList.Contains(player) && !zone.keepInList.Contains(player)) EjectPlayer(zone, player);
            Interface.CallHook("OnEnterZone", zone.info.ID, player);
        }
        static void OnExitZone(Zone zone, BasePlayer player)
        {
            if (playerZones[player].Contains(zone)) playerZones[player].Remove(zone);
            if (zone.info.leave_message != null) SendMessage(player, zone.info.leave_message);
            if (zone.keepInList.Contains(player)) AttractPlayer(zone, player);
            Interface.CallHook("OnExitZone", zone.info.ID, player);
        }

        static void EjectPlayer(Zone zone, BasePlayer player)
        {
            cachedDirection = player.transform.position - zone.transform.position;
            player.transform.position = zone.transform.position + (cachedDirection / cachedDirection.magnitude * (zone.GetComponent<UnityEngine.SphereCollider>().radius + 1f));
            player.ClientRPC(null, player, "ForcePositionTo", new object[] { player.transform.position });
            player.TransformChanged();
        }
        static void AttractPlayer(Zone zone, BasePlayer player)
        {
            cachedDirection = player.transform.position - zone.transform.position;
            player.transform.position = zone.transform.position + (cachedDirection / cachedDirection.magnitude * (zone.GetComponent<UnityEngine.SphereCollider>().radius - 1f));
            player.ClientRPC(null, player, "ForcePositionTo", new object[] { player.transform.position });
            player.TransformChanged();
        }
        static bool isAdmin(BasePlayer player)
        {
            if (player.net.connection.authLevel > 0)
                return true;
            return false;
        }
        bool hasPermission(BasePlayer player, string permname)
        {
            if (player.net.connection.authLevel > 1)
                return true;
            return permission.UserHasPermission(player.userID.ToString(), permname);
        }
        //////////////////////////////////////////////////////////////////////////////
        /// Chat Commands
        //////////////////////////////////////////////////////////////////////////////
        [ChatCommand("zone_add")]
        void cmdChatZoneAdd(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            var newzoneinfo = new ZoneDefinition(player.transform.position);
            newzoneinfo.ID = GetRandom(1, 99999999).ToString();
            NewZone(newzoneinfo);
            if (zonedefinitions[newzoneinfo.ID] != null) storedData.ZoneDefinitions.Remove(zonedefinitions[newzoneinfo.ID]);
            zonedefinitions[newzoneinfo.ID] = newzoneinfo;
            LastZone[player] = newzoneinfo.ID;
            storedData.ZoneDefinitions.Add(zonedefinitions[newzoneinfo.ID]);
            SaveData();
            SendMessage(player, "New Zone created, you may now edit it: " + newzoneinfo.Location.String());
        }
        [ChatCommand("zone_reset")]
        void cmdChatZoneReset(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            zonedefinitions.Clear();
            storedData.ZoneDefinitions.Clear();
            SaveData();
            Unload();
            SendMessage(player, "All Zones were removed");
        }
        [ChatCommand("zone_remove")]
        void cmdChatZoneRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            if (args.Length == 0) { SendMessage(player, "/zone_remove XXXXXID"); return; }
            if (zonedefinitions[args[0]] == null) { SendMessage(player, "This zone doesn't exist"); return; }
            storedData.ZoneDefinitions.Remove(zonedefinitions[args[0]]);
            zonedefinitions[args[0]] = null;
            SaveData();
            RefreshZone(args[0]);
            SendMessage(player, "Zone " + args[0] + " was removed");
        }
        [ChatCommand("zone_edit")]
        void cmdChatZoneEdit(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            if (args.Length == 0) { SendMessage(player, "/zone_edit XXXXXID"); return; }
            if (zonedefinitions[args[0]] == null) { SendMessage(player, "This zone doesn't exist"); return; }
            LastZone[player] = args[0];
            SendMessage(player, "Editing zone ID: " + args[0]);
        }
        [ChatCommand("zone_list")]
        void cmdChatZoneList(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            SendMessage(player, "========== Zone list ==========");
            if (zonedefinitions.Count == 0) { SendMessage(player, "empty"); return; }
            foreach (KeyValuePair<string, ZoneDefinition> pair in zonedefinitions)
            {
                SendMessage(player, string.Format("{0} => {1} - {2}", pair.Key, pair.Value.name, pair.Value.Location.String()));
            }
        }
        [ChatCommand("zone")]
        void cmdChatZone(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "zone")) { SendMessage(player, "You don't have access to this command"); return; }
            if (LastZone[player] == null) { SendMessage(player, "You must first say: /zone_edit XXXXXID"); return; }
            object value;

            if (args.Length < 2)
            {
                SendMessage(player, "/zone option value/reset");
                foreach (FieldInfo fieldinfo in allZoneFields)
                {
                    value = fieldinfo.GetValue(zonedefinitions[LastZone[player]]);
                    switch (fieldinfo.Name)
                    {
                        case "Location":
                            value = ((ZoneLocation)value).String();
                            break;
                        default:
                            if (value == null) value = "false";
                            break;
                    }
                    SendMessage(player, string.Format("{0} => {1}", fieldinfo.Name, value.ToString()));
                }
                return;
            }
            string editvalue;
            for (int i = 0; i < args.Length; i = i + 2)
            {

                cachedField = GetZoneField(args[i]);
                if (cachedField == null) continue;

                switch (args[i + 1])
                {
                    case "true":
                    case "1":
                        editvalue = "true";
                        break;
                    case "null":
                    case "0":
                    case "false":
                    case "reset":
                        editvalue = null;
                        break;
                    default:
                        editvalue = args[i + 1];
                        break;
                }
                cachedField.SetValue(zonedefinitions[LastZone[player]], editvalue);
                if (args[i].ToLower() == "radius") { zonedefinitions[LastZone[player]].Location = new ZoneLocation(zonedefinitions[LastZone[player]].Location.GetPosition(), editvalue); }
                SendMessage(player, string.Format("{0} set to {1}", cachedField.Name, editvalue));
            }
            RefreshZone(LastZone[player]);
            SaveData();
        }
        static void SendMessage(BasePlayer player, string message) { player.SendConsoleCommand("chat.add", new object[] { "0", string.Format("<color=#FA58AC>{0}:</color> {1}", "ZoneManager", message), 1.0 }); }
    }
}
