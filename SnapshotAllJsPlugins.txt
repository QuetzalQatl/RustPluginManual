
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\BountyBoard.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var BountyBoard = {
	Title: "Bounty Board",
	Author: "Killparadise",
	Version: V(1, 0, 1),
	HasConfig: true,
	Init: function() {
		this.getData();
		global = importNamespace("");
	},

	OnServerInitialized: function() {
		this.msgs = this.Config.Messages;
		this.prefix = this.Config.Prefix;
		command.AddChatCommand("bty", this.Plugin, "cmdBounty");
	},

	LoadDefaultConfig: function() {
		this.Config.authLevel = 2;
		this.Config.Settings = {
			"autoBounties": true,
			"maxBounty": 100000,
			"targetModifier": 2,
			"staffCollect": false,
			"useEcon": false
		};

		this.Config.Prefix = "BountyBoard";

		this.Config.Messages = {
			"curBounty": "The Current Bounty on your head is: ",
			"invSyn": "Syntax Invalid, Please try again. {cmd}",
			"noBty": "Target has no Bounty!",
			"setTar": "Target set. Happy Hunting.",
			"setTrgWarn": " Made you his target! Watch out!",
			"curTar": "Your current target is: ",
			"offline": "That Player is currently offline.",
			"btyClaim": "<color=lime>plyrName</color> has taken the bounty of <color=green>btyAmt</color> from <color=red>deadPlyr</color>!",
			"staff": "Sorry, Staff cannot collect Bounties from slain players.",
			"btyPlaced": "Someone placed a <color=green>{bty}</color> bounty on you!",
			"notEnough": "Not Enough <color=red>{RssName}</color>",
			"overMax": "You cannot exceed the max bounty of <color=red>{maxBty}</color>",
			"notFound": "Item Not Found.",
			"currBty": "The Current Bounty on your head is: ",
			"resetData": "BountyBoard Data Reset",
			"btySet": "<color=green>{bty}</color> bounty has been set!",
			"negBty": "You cannot set a negative bounty!"
		};

		this.Config.Help = [

			"/bty - Check the current bounty on your head",
	    "/bty add playername amt itemname - Add a bounty onto a targeted player.",
	    "/bty board - shows the Bounty Board of everyone who has a bounty."
		];
		this.Config.AdminHelp = [

			"/bty reset - resets all of the bounty board data"
		];
	},

	OnPlayerInit: function(player) {
		this.checkPlayerData(player);
	},

	//----------------------------------------
	//          Finding Player Info
	//----------------------------------------
	findPlayerByName: function(player, args) {
		try {
			var global = importNamespace("");
			var found = [],
				matches = [];
			var playerName = args[1].toLowerCase();
			var itPlayerList = global.BasePlayer.activePlayerList.GetEnumerator();
			while (itPlayerList.MoveNext()) {

				var displayName = itPlayerList.Current.displayName.toLowerCase();

				if (displayName.search(playerName) > -1) {
					found.push(itPlayerList.Current);
				}

				if (playerName.length === 17) {
					if (rust.UserIDFromPlayer(displayName).search(playerName)) {
						found.push(itPlayerList.Current);
					}
				}
			}

			if (found.length) {
				foundID = rust.UserIDFromPlayer(found[0]);
				found.push(foundID);
				return found;
			} else {
				rust.SendChatMessage(player, this.prefix, this.msgs.NoPlyrs, "0");
				return false;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},

	findPlayerByID: function(playerid) {
		var global = importNamespace("");
		var targetPlayer = global.BasePlayer.Find(playerid);
		if (targetPlayer) {
			return targetPlayer;
		} else {
			return false;
		}
	},

	//----------------------------------------
	//          Data Handling
	//----------------------------------------
	getData: function() {
		BountyData = data.GetData('Bounty');
		BountyData = BountyData || {};
		BountyData.PlayerData = BountyData.PlayerData || {};
		BountyData.Board = BountyData.Board || {};
	},

	saveData: function() {
		data.SaveData('Bounty');
	},

	checkPlayerData: function(player) {
		var steamID = rust.UserIDFromPlayer(player);
		var authLvl = player.net.connection.authLevel;
		BountyData.PlayerData[steamID] = BountyData.PlayerData[steamID] || {};
		BountyData.PlayerData[steamID].Target = BountyData.PlayerData[steamID].Target || "";
		BountyData.PlayerData[steamID].Bounty = BountyData.PlayerData[steamID].Bounty || [];
		BountyData.PlayerData[steamID].BountyType = BountyData.PlayerData[steamID].BountyType || [];
		BountyData.PlayerData[steamID].isStaff = BountyData.PlayerData[steamID].isStaff || (authLvl > 0) || false;
		this.saveData();
	},

	//----------------------------------------
	//          Command Handling
	//----------------------------------------
	cmdBounty: function(player, cmd, args) {
		try {
			var steamID = rust.UserIDFromPlayer(player);
			var authLvl = player.net.connection.authLevel;
			switch (args[0]) {
				case "add":
					this.addBounty(player, cmd, args);
					break;
				case "target":
					this.setTarget(player, cmd, args);
					break;
				case "board":
					this.checkBoard(player, cmd, args);
					break;
				case "help":
					this.BtyHelp(player);
					break;
				case "reset":
					if (authLvl >= this.Config.authLevel) {
						this.resetData(player, cmd, args);
					} else if (authLvl < this.Config.authLevel) {
						rust.SendChatMessage(player, this.prefix, this.msgs.noPerms, "0");
						return false;
					} else {
						rust.SendChatMessage(player, this.prefix, this.msgs.invSyn.replace("{cmd}", "/bty arg"), "0");
						return false;
					}
				default:
					if (BountyData.PlayerData[steamID] === undefined) {
						print("Player Data not Found for " + steamID + " Attempting to build");
						this.checkPlayerData(player);
					} else {
						if (BountyData.PlayerData[steamID].Bounty.length > 0) {
							rust.SendChatMessage(player, this.prefix, this.msgs.currBty + " " + "<color=green>" + BountyData.PlayerData[steamID].Bounty + "</color>", "0");
						} else {
							rust.SendChatMessage(player, this.prefix, this.msgs.currBty + " " + "<color=green>" + "0" + "</color>", "0");
						}
					}
					break;
			}
		} catch (e) {
			print(e.message.toString())
		}
	},

	resetData: function(player, cmd, args) {
		try {
			delete BountyData.PlayerData;
			delete BountyData.Board;
			this.saveData();
			this.getData();
			rust.SendChatMessage(player, this.prefix, this.msgs.resetData, "0");
		} catch (e) {
			print(e.message.toString())
		}
	},

	setTarget: function(player, cmd, args) {
		if (args.length === 2) {
			var pName = this.findPlayerByName(player, args);
			var steamID = rust.UserIDFromPlayer(player);
		} else if (args.length === 1) {
			rust.SendChatMessage(player, this.prefix, this.msgs.curTar, "0");
		} else {
			rust.SendChatMessage(player, this.prefix, this.msgs.invSyn.replace("{cmd}", "/bty target playername"), "0");
		}

		if (pName[0].displayName !== player.displayName && BountyData.PlayerData[pName[1]].Bounty !== "" && pName[0].IsConnected()) {
			BountyData.PlayerData[steamID].Target = pName[0].displayName;
			rust.SendChatMessage(player, this.prefix, this.msgs.setTar, "0");
			rust.SendChatMessage(pName[0], this.prefix, player.displayName + this.msgs.setTrgWarn, "0");
		} else if (!pName[0].IsConnected()) {
			rust.SendChatMessage(player, this.prefix, this.msgs.offline, "0");
		} else {
			rust.SendChatMessage(player, this.prefix, this.msgs.noBty, "0");
		}
	},

	addBounty: function(player, cmd, args) {
		try {
			var steamID = rust.UserIDFromPlayer(player);
			var authLvl = player.net.connection.authLevel;
			var main = player.inventory.containerMain;
			var mainList = main.itemList.GetEnumerator();
			var argObj = {
				"plyrName": args[1],
				"amt": Number(args[2]),
				"itemName": args[3]
			};

			var targetPlayer = this.findPlayerByName(player, args);
			if (!BountyData.PlayerData[targetPlayer[1]]) this.checkPlayerData(targetPlayer[0]);
			while (mainList.MoveNext()) {
				var name = mainList.Current.info.shortname,
					amount = mainList.Current.amount,
					condition = mainList.Current.condition;
				if (name === argObj.itemName && argObj.amt <= amount && argObj.amt <= this.Config.Settings.maxBounty && argObj.amt > 0) {
					break;
				}
			}

			if (argObj.amt > amount) {
				rust.SendChatMessage(player, this.prefix, this.msgs.notEnough.replace("{RssName}", argObj.itemName), "0");
				return false;
			} else if (argObj.amt <= 0) {
				rust.SendChatMessage(player, this.prefix, this.msgs.negBty, "0");
			} else if (argObj.amt > this.Config.Settings.maxBounty) {
				rust.SendChatMessage(player, this.prefix, this.msgs.overMax.replace("{maxBty}", this.Config.Settings.maxBounty), "0");
				return false;
			} else if (name !== argObj.itemName) {
				rust.SendChatMessage(player, this.prefix, this.msgs.notFound, "0");
				return false;
			}

			var definition = global.ItemManager.FindItemDefinition(name);
			main.Take(null, Number(definition.itemid), argObj.amt);
			if (this.checkForDupes(targetPlayer[1], argObj.itemName, argObj.amt)) {} else {
				BountyData.PlayerData[targetPlayer[1]].Bounty.push(argObj.amt + " " + argObj.itemName);
				BountyData.PlayerData[targetPlayer[1]].BountyType.push(argObj.itemName);
			}
			rust.SendChatMessage(targetPlayer[0], this.prefix, this.msgs.btyPlaced.replace("{bty}", argObj.amt + " " + argObj.itemName), "0");
			rust.SendChatMessage(player, this.prefix, this.msgs.btySet.replace("{bty}", argObj.amt + " " + argObj.itemName), "0");
			if (argObj.amt > amount) {
				rust.SendChatMessage(player, this.prefix, this.msgs.notEnough.replace("{RssName}", argObj.itemName), "0");
				return false;
			}
			this.saveData();
			this.updateBoard(targetPlayer[1], false, argObj.amt, argObj.itemName);
		} catch (e) {
			print(e.message.toString())
		}
	},

	//----------------------------------------
	//          Board Handling
	//----------------------------------------
	updateBoard: function(targetID, claimed, amount, itemName) {
		//TODO: update the bounty board with new bounties and claimed bounties.
		var getPlayer = this.findPlayerByID(targetID);

		if (claimed && itemName === null && amount === 0) {
			delete BountyData.Board[targetID];
			BountyData.PlayerData[targetID].Bounty = [];
			BountyData.PlayerData[targetID].BountyType = [];
			return this.saveData();
		}

		if (BountyData.Board[targetID] === undefined) {
			BountyData.Board[targetID] = {};
			BountyData.Board[targetID].Name = getPlayer.displayName;
			BountyData.Board[targetID].Amount = [amount + " " + itemName];
			BountyData.Board[targetID].ItemType = [itemName];
		} else if (claimed === false && BountyData.Board[targetID] !== undefined) {
			BountyData.Board[targetID].Amount = BountyData.PlayerData[targetID].Bounty;
			BountyData.Board[targetID].ItemType = BountyData.PlayerData[targetID].BountyType;
		}
		this.saveData();
	},

	checkForDupes: function(targetID, itemName, amt) {
		try {
			var boardData = BountyData.Board[targetID];
			var playerData = BountyData.PlayerData[targetID];
			var i = 0;
			if (boardData === undefined) {
				return false;
			}
			for (i; i < boardData.Amount.length; i++) {
				var itemTypeName = boardData.Amount[i].split(" ").pop();
				if (itemName === itemTypeName) {
					var storedAmt = boardData.Amount[i].split(" ").shift();
					var newAmt = Number(storedAmt) + Number(amt);
					boardData.Amount[i] = newAmt + " " + itemName;
					boardData.ItemType[i] = itemName;
					playerData.Bounty[i] = newAmt + " " + itemName;
					playerData.BountyType[i] = itemName;
					return true;
				}
			}
			return false;
		} catch (e) {
			print(e.message.toString());
		}
	},

	checkBoard: function(player, cmd, args) {
		rust.SendChatMessage(player, "", "<color=orange>------Bounty Board------</color>", "0");
		for (var key in BountyData.Board) {
			rust.SendChatMessage(player, "", "<color=red>" + BountyData.Board[key].Name + ": " + BountyData.Board[key].Amount + "</color>", "0");
		}
		rust.SendChatMessage(player, "", "<color=orange>------Happy Hunting------</color>", "0");
	},

	claimBounty: function(victimID, attackerID) {
		var amount = BountyData.Board[victimID].Amount,
			item = BountyData.Board[victimID].ItemType,
			claimed = false;
		var getPlayer = this.findPlayerByID(attackerID);
		var i = 0;
		for (i; i < amount.length; i++) {
			this.giveItem(getPlayer, item[i], amount[i].split(" ").shift());
		}
		claimed = true;
		this.updateBoard(victimID, claimed, 0, null);
	},

	giveItem: function(player, itemName, amount) {
		try {
			itemName = itemName.toLowerCase();
			var definition = global.ItemManager.FindItemDefinition(itemName);
			if (definition == null) return print("Unable to Find an Item for Bounty.");
			player.inventory.GiveItem(global.ItemManager.CreateByItemID(Number(definition.itemid), Number(amount), false), player.inventory.containerMain);
		} catch (e) {
			print(e.message.toString());
		}
	},

	OnEntityDeath: function(entity, hitinfo) {
		try {
			var victim = entity;
			var attacker = hitinfo.Initiator;

			if (victim.ToPlayer() && attacker.ToPlayer() && victim.displayName !== attacker.displayName) {
				var victimID = rust.UserIDFromPlayer(victim),
					attackerID = rust.UserIDFromPlayer(attacker);
				if (!BountyData.PlayerData[victimID] && !victim.IsConnected()) {
					return false;
				} else if (!BountyData.PlayerData[victimID] && victim.IsConnected()) {
					print("Data File not found for " + victim.displayName + ", attempting build now...");
					this.checkPlayerData(victim);
				} else if (!BountyData.PlayerData[attackerID]) {
					print("Data File not found for " + attacker.displayName + ", attempting build now...");
					this.checkPlayerData(attacker);
				}

				if (BountyData.PlayerData[attackerID].isStaff && !this.Config.Settings.staffCollect) {
					rust.SendChatMessage(attacker, this.prefix, this.msgs.staff, "0");
					return false;
				}
				if (BountyData.PlayerData[victimID].Bounty.length > 0 && victim.displayName !== attacker.displayName) {
					var rpObj = {
						plyrName: attacker.displayName,
						btyAmt: BountyData.PlayerData[victimID].Bounty,
						deadPlyr: victim.displayName
					}
					rust.BroadcastChat(this.prefix, this.msgs.btyClaim.replace(/plyrName|btyAmt|deadPlyr/g, function(matched) {
						return rpObj[matched]
					}), "0");
					this.claimBounty(victimID, attackerID);

				} else if (victim.ToPlayer() && victim.displayName === attacker.displayName) {
					return false;
				}
			}
		} catch (e) {
			print(e.message.toString())
		}
	},

	BtyHelp: function(player) {
		rust.SendChatMessage(player, null, "--------------BountyBoard Commands------------", "0");
		var authLvl = player.net.connection.authLevel;
		for (var i = 0; i < this.Config.Help.length; i++) {
			rust.SendChatMessage(player, null, this.Config.Help[i], "0");
		}
		if (authLvl >= 2) {
			rust.SendChatMessage(player, null, "<color=orange>--------------Admin Commands------------</color>", "0");
			for (var j = 0; j < this.Config.AdminHelp.length; j++) {
				rust.SendChatMessage(player, null, this.Config.AdminHelp[j], "0");
			}
		}
	}
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\MageMotd.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var MageMotd = {
    Title : "Mage MOTD",
    Author : "Risin",
    Version : V(1, 0, 0),
    HasConfig : true,
    Init : function () {
        print("Mage MOTD: Starting...");
    },
    OnServerInitialized : function () {
        command.AddConsoleCommand("motd.test", this.Plugin, "showMotd");
        command.AddChatCommand("motd.change", this.Plugin, "changeMotd");
    },
    LoadDefaultConfig : function () {
        this.Config.authLevel = 1;
        this.Config = {"motd" : "Some Random MOTD, you should probably change me."};
    },
    OnPluginLoaded : function () {
        print("Mage MOTD: Loaded!");
    },
    OnPlayerInit: function(player) {
        rust.SendChatMessage(player, this.title, this.Config.motd, 0)
    },
    changeMotd : function (player, cmd, args) {
        if (player.net.connection.authLevel >= 2) {
            var new_motd = "";
            args.forEach(function(value) {
                new_motd += value + " ";
            });
            
            this.Config.motd = new_motd;
            this.SaveConfig();
            rust.SendChatMessage(player,  this.Title, "<color=#A347FF>MOTD Changed to: </color>" + new_motd, 0);
            rust.BroadcastChat(this.Title, this.Config.motd, 0);
            return;
        } else {
            rust.SendChatMessage(player, this.Title, "You don't have the required permission to do that!", 0);
        }
    },
    showMotd : function () {
        var motd = this.Config.motd;
        print(motd);
    },
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\MKToprewardsplayer.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var MKToprewardsplayer = {
	Name : Name = "toprewardsplayer",
    Title : "Top/Rewards Player",
	Description : "Show Top Players by number of murders committed, and give a reward for it.",
    Version : V(0, 0, 04),
    HasConfig : true,
	Author : "LEO318x",
    OnServerInitialized : function () {
		dataLang = data.GetData("MKlanguages");
    },
	Init : function () {
		// User Options
			command.AddChatCommand("top", this.Plugin, "cmdTop");
			command.AddChatCommand("stats", this.Plugin, "cmdStats");
			command.AddChatCommand("exchange", this.Plugin, "cmdMKexchange");
			command.AddChatCommand("yes", this.Plugin, "cmdYes");
	},
    LoadDefaultConfig : function () {
		// Enable or Disable Options
		this.Config.Options = {
			"MySQL" : true, //If false the top10 not working, only stats and rewards
			"MySQLKEY" : 'TheKey0123$', //This is the key to interactuar con la pagina, no es el password de la base de datos
			"WebStats" : true, //Only True if MySQL is true.
			"URL" : 'http://yourwebpageorIP/request.php', //URL to stats
			"Language": "en", //Default Lenguage
			"TPReward" : true, //Disabled for now
			"Players" : true, //Disabled for now
			"Animalkills" : true, //Disabled for now
			"SuicideDeaths" : true, //Working
			"Naturalcausesdeath" : true, //Disabled for now
		},
		
		// Points
		this.Config.Points = {
			"PlayerKillerPoint" : 2, //Point to the killer
			"AnimalKillerPoint": 1, //Point to kill animal
			"PlayerDeathPoint" : 2, //Point lost for Death
			"PlayerDeathEnvironment" : 3, //Natural cause
			"PlayerSuicide" : 5, //Suicides
		},
		
		// Money
		this.Config.Money = {
			"Killing" : 100, // 0 to disable, if disable the player can not exchange items
			"KillingAnimal" : 50, //0 to disable, if disable the player can not exchange items
			"Respawn" : 50, //0 to disable, apply only natural deaths and suicides
		},
		
		this.Config.Prices = {
		/*	//Resources //Disabled for now
				//Resources Easy Items
					"battery_small": 100,
					"bone_fragment": 100,
					"can_beans_em": 100,
					"can_tuna_empty": 100,
					"charcoal": 100,
					"cloth": 100,
					"fat_animal": 100,
					"gunpowder": 100,
					"lowgradefuel": 100,
					"metal_fragments": 100,
					"metal_ore": 100,
					"metal_refined": 100,
					"paper": 100,
					"skull_human": 100,
					"skull_wolf": 100,
					"stones": 100,
					"sulfur": 100,
					"sulfur_ore": 100,
					"wood" : 100,
				
				//Resources Moderated Items

				//Resources Hight Items	*/
			
			//Tools
				//Tools Easy Items
				"axe_salvaged": 125,
				"flare": 50,
				"hammer": 10,
				"hammer_salvaged": 50,
				"hatchet": 75,
				"icepick_salvaged": 200,
				"pickaxe": 110,
				"rock": 100,
				"stonehatchet": 50,
				"torch": 100,
				
			/*//Medical //Disabled for now
				//Medical Easy Items
				"antiradpills": 100,
				"bandage": 100,
				"blood": 100,
				"largemedkit": 100,
				"syringe_medical": 100,*/
			
			/*//Food //Disabled for now
				//Food Easy Items
				"apple": 100,
				"black": 100,
				"blueberries": 100,
				"can_beans": 100,
				"can_tuna": 100,
				"chicken_cooke": 100,
				"chocholate": 100,
				"granobar": 100,
				"smallwaterbottle": 100,
				"wolfmeat_cooke": 100,*/
				
			//Attire
				//Attire Easy Items
				"bucket_helmet": 100,
				"burlap_gloves": 100,
				"bulap_shirt": 100,
				"burlap_shoes": 100,
				"burlap_trousers": 100,
				"coffeecan_helmet": 100,
				"hazmat_boots": 100,
				"hazmat_gloves": 100,
				"hazmat_helmet": 100,
				"hazmat_jacket": 100,
				"hazmat_pants": 100,
				"jacket_snow": 100,
				"jacket_snow2": 100,
				"jacket_snow3": 100, 
				"metal_facemask": 100,
				"metal_plate_torso": 100,
				"urban_boots": 100,
				"urban_jacket": 100,
				"urban_pants": 100,
				"urban_shirt": 100,
				"vagabond_jack": 100,
				
			//Items
				//Items Easy Items
				"bed": 100,
				"box_wooden": 25,
				"box_wooden_large": 60,
				"campfire": 100,
				"furnace": 80,
				"latern": 10,
				"sleepingbag": 10,
				
			//Construction
				//Construction Easy Items
				"building_planner": 10,
				"cupboard.tool": 100,
				"lock.code": 175,
				"lock.key": 25,
				
			//Weapon
				//Weapon Easy Items
				"bow_hunting": 50,
				"knife_bone": 10,
				"pistol_eoka": 100,
				"pistol_revolver": 200,
				"rifle_ak": 800,
				"rifle_bolt": 600,
				"shotgun_water": 200,
				"smg_thompson": 300,
				"spear_stone": 30,
				"spear_wooden": 30,
				
			//Ammunition
				//Ammunition Easy Items
				"ammo_pisto": 50,
				"ammo_rifle": 50,
				"ammo_shotgun": 50,
				"arrow_wooden": 50,
			
			//Traps
				//Traps Hard Items
				"trap_bear": 200,
		},
		
		this.Config.ItemsPerPurchase = {
			//Resources
				//Resources Easy Items
					"battery_small": 1,
					"bone_fragment": 1,
					"can_beans_em": 1,
					"can_tuna_empty": 1,
					"charcoal": 1,
					"cloth": 1,
					"fat_animal": 1,
					"gunpowder": 1,
					"lowgradefuel": 1,
					"metal_fragments": 1,
					"metal_ore": 1,
					"metal_refined": 1,
					"paper": 1,
					"skull_human": 1,
					"skull_wolf": 1,
					"stones": 1,
					"sulfur": 1,
					"sulfur_ore": 1,
					"wood" : 1,
				
				//Resources Moderated Items

				//Resources Hight Items	
			
			//Tools
				//Tools Easy Items
				"axe_salvaged": 1,
				"flare": 1,
				"hammer": 1,
				"hammer_salvaged": 1,
				"hatchet": 1,
				"icepick_salvaged": 1,
				"pickaxe": 1,
				"rock": 1,
				"stonehatchet": 1,
				"torch": 1,
				
			//Medical
				//Medical Easy Items
				"antiradpills": 1,
				"bandage": 1,
				"blood": 1,
				"largemedkit": 1,
				"syringe_medical": 1,
			
			//Food
				//Food Easy Items
				"apple": 1,
				"black": 1,
				"blueberries": 1,
				"can_beans": 1,
				"can_tuna": 1,
				"chicken_cooke": 1,
				"chocholate": 1,
				"granobar": 1,
				"smallwaterbottle": 1,
				"wolfmeat_cooke": 1,
				
			//Attire
				//Attire Easy Items
				"bucket_helmet": 1,
				"burlap_gloves": 1,
				"bulap_shirt": 1,
				"burlap_shoes": 1,
				"burlap_trousers": 1,
				"coffeecan_helmet": 1,
				"hazmat_boots": 1,
				"hazmat_gloves": 1,
				"hazmat_helmet": 1,
				"hazmat_jacket": 1,
				"hazmat_pants": 1,
				"jacket_snow": 1,
				"jacket_snow2": 1,
				"jacket_snow3": 1, 
				"metal_facemask": 1,
				"metal_plate_torso": 1,
				"urban_boots": 1,
				"urban_jacket": 1,
				"urban_pants": 1,
				"urban_shirt": 1,
				"vagabond_jack": 1,
				
			//Items
				//Items Easy Items
				"bed": 1,
				"box_wooden": 1,
				"box_wooden_large": 1,
				"campfire": 1,
				"furnace": 1,
				"latern": 1,
				"sleepingbag": 1,
				
			//Construction
				//Construction Easy Items
				"building_planner": 1,
				"cupboard.tool": 1,
				"lock.code": 1,
				"lock.key": 1,
				
			//Weapon
				//Weapon Easy Items
				"bow_hunting": 1,
				"knife_bone": 1,
				"pistol_eoka": 1,
				"pistol_revolver": 1,
				"rifle_ak": 1,
				"rifle_bolt": 1,
				"shotgun_water": 1,
				"smg_thompson": 1,
				"spear_stone": 1,
				"spear_wooden": 1,
				
			//Ammunition
				//Ammunition Easy Items
				"ammo_pisto": 1,
				"ammo_rifle": 1,
				"ammo_shotgun": 1,
				"arrow_wooden": 1,
			
			//Traps
				//Traps Hard Items
				"trap_bear": 1,
				
		},
		
		this.Config.URL = {
			"URL" : this.Config.Options['URL']+"?key="+this.Config.Options['MySQLKEY'], //don't touch :)
		},

		// Mensajes
		this.Config.Messages = {
			"TypeDeath0" : "Generic",
			"TypeDeath1" : "Hunger",
			"TypeDeath2" : "Thirst",
			"TypeDeath3" : "Cold",
			"TypeDeath4" : "Drowned",
			"TypeDeath5" : "Heat",
			"TypeDeath6" : "Bleeding",
			"TypeDeath7" : "Poison",
			"TypeDeath8" : "Suicide",
			"TypeDeath9" : "Bullet",
			"TypeDeath10" : "Slash",
			"TypeDeath11" : "Blunt",
			"TypeDeath12" : "Fall",
			"TypeDeath13" : "Radiation",
			"TypeDeath14" : "Bite",
			"TypeDeath15" : "Stab",
			"TypeDeath16" : "LAST",
		}
    },
	OnPlayerInit : function (player){
			playerID = rust.UserIDFromPlayer(player);
			Data = "&op=3&userid="+playerID;
			URL = this.Config.URL['URL'];
			webrequests.EnqueueGet(URL+Data, function(code, response) {
				if(response == "KEY-NOT-EQUAL"){
					print(dataLang.en["msg1"]);
				}else if(response == playerID){
					print(dataLang.en["msg2"]);
				}else{
						Data = "&op=1&userid="+playerID+"&name="+player.displayName+"&points=0&killings=0&deaths=0&suicides=0&money=0";
						webrequests.EnqueueGet(URL+Data, function(code, response) {
							if(response == "SUCCESS-PLAYER-ADDED"){
								print(dataLang.en["msg3"]);
							}else{
								print(dataLang.en["msg4"]);
								print("ERROR-CONNECT_345|------->"+response);
							}
						}, this.Plugin);					
					};
			}, this.Plugin);
	},
	
	//Exchange items
	cmdMKexchange : function(player, cmd, args){
		global = importNamespace("");
		playerID = rust.UserIDFromPlayer(player);
		args = args.toString().split(",");
		Name = args[0];
		if(args[0]=="" && args[1]=="" && args[2]){
			rust.SendChatMessage(player, "SERVER", "<color=#FF0000>"+dataLang.en["msg11"]+"</color>", "");
		}else{
			Price = this.Config.Prices[args[0]];
			Value = this.Config.ItemsPerPurchase[args[0]] * args[1];
			Total = (this.Config.Prices[args[0]] * args[1]).toFixed(2);
			dataObj = data.GetData("MKexchanges");
			if(dataObj[playerID]){
				dataObj[playerID] = {
					"Status" : "OK",
					"Name" : args[0],
					"Value" : Value,
					"Total": Total,
				}	
			}else{
				dataObj[playerID] = {
					"Status" : "OK",
					"Name" : args[0],
					"Value" : Value,
					"Total": Total,
				}
			}
			data.SaveData("MKexchanges");
			rust.SendChatMessage(player, "SERVER", "<color=#FFC000>"+eval(dataLang.en["msg5"])+"</color>", "");
			rust.SendChatMessage(player, "SERVER", "<color=#00FF1A>"+dataLang.en["msg6"]+"</color>", "");
			}
			//Blueprint //Disabled for now
				//inv.GiveItem(global.ItemManager.CreateByItemID(11864, 1, false), inv.containerMain);
	},
	
	cmdYes : function(player){
		playerID = rust.UserIDFromPlayer(player);
		dataObj = data.GetData("MKexchanges");
		URL = this.Config.URL['URL'];
		Data = "&op=8&userid="+playerID+"&money="+dataObj[playerID]["Total"];
			if(dataObj[playerID]["Status"]!="NO"){			
				webrequests.EnqueueGet(URL+Data, function(code, response) {				
					if(response=="SUCCESS"){
						var inv = player.inventory;
						inv.GiveItem(global.ItemManager.CreateByName(dataObj[playerID]["Name"], parseInt(dataObj[playerID]["Value"])), inv.containerMain);
						rust.SendChatMessage(player, "SERVER", dataLang.en["msg7"], "");
						dataObj[playerID] ={
							"Status" : "NO",
							"Name" : 0,
							"Value": 0,
							"Total": 0,
						}						
					}else if(response=="FAIL"){
						rust.SendChatMessage(player, "SERVER", dataLang.en["msg8"], "");
						rust.SendChatMessage(player, "SERVER", dataLang.en["msg9"], "");
						dataObj[playerID] ={
							"Status" : "NO",
							"Name" : 0,
							"Value": 0,
							"Total": 0,
						}
					}else{
						rust.SendChatMessage(player, "SERVER", dataLang.en["msg10"], "");
					}
				data.SaveData("MKexchanges");
				},  this.Plugin);
			}else{
					rust.SendChatMessage(player, "SERVER", dataLang.en["msg12"], "");
			}			
	},
	
	
	// When user write in chat "/top", this code below its executed
	cmdTop : function (player) {
		Data = "&op=2&req=1";
		webrequests.EnqueueGet(this.Config.URL['URL']+Data, function(code, response) {
			response = JSON.parse(response);
			for (var i = 0; i < 10; i++){
				rust.SendChatMessage(player, "SERVER", eval(dataLang.en["msg13"]), "");
			}
		}, this.Plugin);				
	},
	cmdStats : function (player){
		playerID = rust.UserIDFromPlayer(player);
		Data = "&op=2&req=2&userid="+playerID;
		webrequests.EnqueueGet(this.Config.URL['URL']+Data, function(code, response) {
			response = JSON.parse(response);
			print(response[0]['points']);
			rust.SendChatMessage(player, "SERVER", eval(dataLang.en["msg14"]), "");
			rust.SendChatMessage(player, "SERVER", eval(dataLang.en["msg15"]), "");
		},  this.Plugin);
	},

	OnEntityDeath : function (entity, hitinfo){
		if(hitinfo == null){
			if(this.Config.Options["Naturalcausesdeath"]){
				if(entity.ToPlayer()){
					this.PlayerDiedFromNaturalCause(entity);					
				}
			}
		}else{
			if(entity.ToPlayer()){
				this.PlayerDeath(entity, hitinfo);
			}else if(entity.GetComponent("BaseNPC")){
				this.EntityDeath(entity, hitinfo);
			}	
		}		
	},

	EntityDeath : function(victim, hitinfo){
		if(hitinfo.Initiator.ToPlayer()){
			attacker = hitinfo.Initiator.ToPlayer();
			animal = victim.GetComponent("BaseNPC");
			killer = attacker.displayName;
			killerid = rust.UserIDFromPlayer(attacker);
			killed = "NPC";
			killedid = "npc";
			type = "pve";
			URL = this.Config.URL['URL']
			Data = "&op=7&userid="+killerid+"&name="+killer+"&useridD=2&nameD="+killed+"&points="+this.Config.Points['AnimalKillerPoint']+"&money="+this.Config.Money['KillingAnimal'];
			webrequests.EnqueueGet(URL+Data, function(code, response) {
				 
				},  this.Plugin);
			rust.SendChatMessage(attacker, "SERVER", eval(dataLang.en["msg16"]), "");
		}
		
	},
	
	PlayerDeath : function (victim, hitinfo){
		var Rust = importNamespace("Rust");
		if(hitinfo.damageTypes.GetMajorityDamageType() == Rust.DamageType.Suicide){
			if(this.Config.Options["SuicideDeaths"]){
				killed = victim.displayName;
				killeid = rust.UserIDFromPlayer(victim);
				killer = "suicide";
				type = "naturalcause";
				Data = "&op=4&userid="+killeid+"&name="+killed+"&pointsleft="+this.Config.Points['PlayerSuicide']+"&money="+this.Config.Money['Respawn'];
				webrequests.EnqueueGet(this.Config.URL['URL']+Data, function(code, response) {
					rust.SendChatMessage(victim, "SERVER", eval(dataLang.en["msg17"]), "");
					rust.SendChatMessage(victim, "SERVER", eval(dataLang.en["msg18"]), "");
				},  this.Plugin);
			}
		}else if(hitinfo.Initiator.ToPlayer()){
			attacker = hitinfo.Initiator.ToPlayer();
			if (rust.UserIDFromPlayer(attacker) == rust.UserIDFromPlayer(victim)){
				if(this.Config.Options["Naturalcausesdeath"]){
					killed = victim.displayName;
					killeid = rust.UserIDFromPlayer(victim);	
					type = "naturalcause";
					URL = this.Config.URL['URL'];
					Data = "&op=5&userid="+killeid+"&name="+killed+"&pointsleft="+this.Config.Points['PlayerDeathEnvironment']+"&money="+this.Config.Money['Respawn'];
					webrequests.EnqueueGet(URL+Data, function(code, response) {
						rust.SendChatMessage(victim, "SERVER", eval(dataLang.en["msg19"]), "");
						rust.SendChatMessage(victim, "SERVER", eval(dataLang.en["msg20"]), "");
					},  this.Plugin);
				}
			}else {
				if(this.Config.Options["Players"]){
					killer = attacker.displayName;
					killerid = rust.UserIDFromPlayer(attacker);
					killed = victim.displayName;
					killedid = rust.UserIDFromPlayer(victim);
					type = "pvp";
					URL = this.Config.URL['URL'];
					// weapon
					if(!victim.IsConnected()){
						Data = "&op=6&userid="+killerid+"&name="+killer+"&useridD="+killedid+"+&nameD="+killed+"&pointsleft="+this.Config.Points['PlayerDeathPoint']+"&points="+this.Config.Points['PlayerKillerPoint']+"&money="+this.Config.Money['Killing'];
						webrequests.EnqueueGet(URL+Data, function(code, response) {
						rust.SendChatMessage(attacker, "SERVER", eval(dataLang.en["msg21"]), "");
						rust.BroadcastChat("SERVER", eval(dataLang.en["msg22"]), "");
						},  this.Plugin);
					
					}else{
						Data = "&op=6&userid="+killerid+"&name="+killer+"&useridD="+killedid+"+&nameD="+killed+"&pointsleft="+this.Config.Points['PlayerDeathPoint']+"&points="+this.Config.Points['PlayerKillerPoint']+"&money="+this.Config.Money['Killing'];
						webrequests.EnqueueGet(URL+Data, function(code, response) {
						rust.SendChatMessage(attacker, "SERVER", eval(dataLang.en["msg21"]), "");
						rust.SendChatMessage(victim, "SERVER", eval(dataLang.en["msg23"]), "");						
						},  this.Plugin);
					}	
				}
			}
		}
	},
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\RanksAndTitles.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var RanksAndTitles = {
	Title: "Ranks And Titles",
	Author: "Killparadise",
	Version: V(1, 4, 8),
	ResourceId: 830,
	Url: "http://oxidemod.org/resources/ranks-and-titles.830/",
	HasConfig: true,
	Init: function() {
		global = importNamespace("");
		UnityEngine = importNamespace("UnityEngine");
		this.loadTitleData();
		command.AddChatCommand("rt", this.Plugin, "switchCmd");
		command.AddChatCommand("rtdebug", this.Plugin, "debug");
	},

	OnServerInitialized: function() {
		msgs = this.Config.Messages;
		prefix = this.Config.Prefix;
		GroupsAPI = plugins.Find('RotAG-Groups');
		chatHandler = plugins.Find('chathandler');
		clansOn = plugins.Find('RustIOClans');
		if (chatHandler) {
			chatHandler = true;
		} else {
			chatHandler = false;
		}
		if (GroupsAPI) {
			GroupsAPI = true;
		} else {
			GroupsAPI = false;
		}
		this.updateConfig();
	},

	updateConfig: function() {
		if (this.Config.Version !== "1.4") {
			print("[RanksAndTitles] Updating Config, to latest version.")
			this.LoadDefaultConfig();
		} else {
			return false;
		}
	},

	LoadDefaultConfig: function() {
		this.Config.authLevel = 2;
		this.Config.Version = "1.4";
		this.Config.Settings = {
			"Settings": true,
			"deBugOff": true,
			"karma": true,
			"colorSupport": true,
			"useTitles": false,
			"noAdmin": false,
			"usePunishSystem": true,
			"chatNameColor": "#1bd228",
			"staffchatNameColor": "#1bd228"
		};
		this.Config.Punishment = [{
			"rank": 0,
			"multiplier": 2
		}, {
			"rank": 0.5,
			"multiplier": 2.5
		}, {
			"rank": 1,
			"multiplier": 3
		}, {
			"rank": 2,
			"multiplier": 4
		}, {
			"rank": 3,
			"multiplier": 5
		}, {
			"rank": 4,
			"multiplier": 6
		}, {
			"rank": 5,
			"multiplier": 7
		}, {
			"rank": 6,
			"multiplier": 8
		}];
		this.Config.Titles = [{
			"authLvl": 0,
			"title": "Player",
			"Exclude": false,
			"Color": "#FFFFFF"
		}, {
			"authLvl": 0,
			"title": "Donor",
			"Exclude": true,
			"Color": "#ffa500ff"
		}, {
			"authLvl": 1,
			"title": "Mod",
			"Exclude": true,
			"Color": "#add8e6ff"
		}, {
			"authLvl": 2,
			"title": "Admin",
			"Exclude": true,
			"Color": "#800000ff"
		}, {
			"authLvl": 2,
			"title": "Owner",
			"Exclude": true,
			"Color": "#505886"
		}];
		this.Config.Ranks = [{
			"rank": 0,
			"title": "Civilian",
			"karma": 0,
			"killsNeeded": 0,
			"Color": "#FFFFFF",
			"karmaModifier": 1
		}, {
			"rank": 0.5,
			"title": "Small Timer",
			"karma": -1.0,
			"killsNeeded": 1.0,
			"Color": "#ff0000ff",
			"karmaModifier": 1.0
		}, {
			"rank": 0.5,
			"title": "Wannabe",
			"karma": 1.0,
			"killsNeeded": 1.0,
			"Color": "#0000a0ff",
			"karmaModifier": 1.0
		}, {
			"rank": 1.0,
			"title": "Murderer",
			"karma": -10.0,
			"killsNeeded": 10.0,
			"Color": "#ff0000ff",
			"karmaModifier": 5.0
		}, {
			"rank": 1.0,
			"title": "Recruit",
			"karma": 10.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 5.0
		}, {
			"rank": 2.0,
			"title": "Serial Killer",
			"karma": -20.0,
			"killsNeeded": 20.0,
			"Color": "#ff0000ff",
			"karmaModifier": 15.0
		}, {
			"rank": 2.0,
			"title": "Soldier",
			"karma": 20.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 15.0
		}, {
			"rank": 3.0,
			"title": "Bandit",
			"karma": -25.0,
			"killsNeeded": 25.0,
			"Color": "#ff0000ff",
			"karmaModifier": 30.0
		}, {
			"rank": 3.0,
			"title": "General",
			"karma": 25.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 30.0
		}, {
			"rank": 4.0,
			"title": "Captain",
			"karma": -35.0,
			"killsNeeded": 35.0,
			"Color": "#ff0000ff",
			"karmaModifier": 40.0
		}, {
			"rank": 4.0,
			"title": "Icon",
			"karma": 35.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 40.0
		}, {
			"rank": 5.0,
			"title": "Bandit Lord",
			"karma": -50.0,
			"killsNeeded": 50.0,
			"Color": "#ff0000ff",
			"karmaModifier": 50.0
		}, {
			"rank": 5.0,
			"title": "Hero",
			"karma": 50.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 50.0
		}, {
			"rank": 6.0,
			"title": "Badass",
			"karma": -100.0,
			"killsNeeded": 100.0,
			"Color": "#ff0000ff",
			"karmaModifier": 100.0
		}, {
			"rank": 6.0,
			"title": "Legend",
			"karma": 100.0,
			"killsNeeded": "disabled",
			"Color": "#0000a0ff",
			"karmaModifier": 100.0
		}];
		this.Config.Prefix = {
			"Prefixes": true,
			"ranks": "Ranks",
			"titles": "Titles",
			"ranksandtitles": "RanksAndTitles"
		};
		this.Config.Messages = {
			"Messages": true,
			"Promoted": "You've been Promoted to: ",
			"NoPlyrs": "No Players Found...",
			"plyrWiped": "Player Wiped!",
			"dataRfrsh": "Data Refreshed!",
			"noPerms": "You do not have permission to use this command.",
			"setSuccs": "Player Title Set Successfully!",
			"needTitle": "You need to enter a title for the player!",
			"kills": "Your Kill count is: ",
			"deaths": "Your Death count is: ",
			"kdr": "Your KDR is currently: ",
			"karma": "Your current Karma is: ",
			"rank": "Your current Rank is: ",
			"title": "Your current Title is: ",
			"badSyntaxRt": "The command syntax was incorrect, please use /rt set playername title",
			"infoRanks": "Ranks for players this is an automated system based on kills & karma; this also supports a Bandit Vs Hero Karma System.",
			"infoTitles": "Titles is a system for a community or calm server, allowing owners to set and create custom user titles.",
			"convert": "The Server Admin has switched to Ranks, please use /rtrefresh to reload your player ranks and titles data.",
			"finished": "Great! The plugin will now build the correct data and configurations.",
			"errors": "Incorrect command structure, please try again.",
			"customFnd": "Using Custom Title... Skipping Change...",
			"loseKarma": "You've lost Karma!",
			"gainKarma": "You've gained Karma!",
			"reset": "Player Reset back to Ranks Tree!",
			"cleardata": "Data has been fully cleared!",
			"titlesSet": "The Server is currently using Titles only. No stats avaliable!",
			"switchRanks": "Successfully turned titles only Off!",
			"switchTitles": "Successfully turned titles only On!",
			"broadcast": "The Admin has switched the Titles system, please use /rt refresh to reload player data!",
			"adminsOn": "Admins ranks turned on.",
			"adminsOff": "Admins rankings turned off.",
			"badSyntaxRemove": "Incorrect Syntax please use /rt remove playername",
			"help": "/rt help - Get RanksAndTitles Command Help",
			"badSyntaxKarma": "Invalid syntax please use /rt karma",
			"clearData": "Server Data Wiped...",
			"noData": "No Player Data Found... Attempting to Build.",
			"debugDis": "Debug is currently disabled.",
			"debugRan": "Ran Debug! Thanks!",
			"Demoted": "You've been demoted!",
			"setKarma": "Karma successfully set!",
			"setKarma0": "You can only use numbers to set a players karma.",
			"plyrKarma": " Karma level is: ",
			"checkFailed": "Check failed..",
			"addKarma": "Karma added to player successfully",
			"removeKarma": "Karma removed from player successfully",
			"punishMsg": "You've killed a rankName you've lost an extra karmaAmt Karma!"
		};
		this.Config.Help = [

			"/rt - display your rank or title",
			"/rt stats - get your current stats if in ranks mode",
			"/rt refresh - refreshes your data file, recommended only used after system switch"
		];
		this.Config.AdminHelp = [

			"/rt wipe playername - Wipes the sleceted players Kills, Deaths, KDR, and Karma",
			"/rt set playername title - Sets a custom title to the selected player, this must be a title in config (NOT RANK)",
			"/rt remove playername - removes a given players custom title, and sets them back into the ransk tree",
			"/rt switch - switch titles only mode on and off, this will use config title automatically without Ranks system",
			"/rt noadmin - Removes admins (auth 2 or higher) from ranks system no kills, or ranks will be given.",
			"/rt kset playername karma - set a selected players karma level",
			"/rt kcheck playername - check the selected players karma",
			"/rt kadd playername karma - adds the entered amount of karma to the selected player",
			"/rt krem playername karma - removes the entered amount of karma from the selected player"
		];
	},

	/*-----------------------------------------------------------------
	            When the Player finishes loading in
	------------------------------------------------------------------*/
	OnPlayerInit: function(player) {
		var steamID = rust.UserIDFromPlayer(player);
		this.checkPlayerData(player, steamID);
	},

	/*-----------------------------------------------------------------
	            All of our data handling
	------------------------------------------------------------------*/
	loadTitleData: function() {
		//Lets get our own data and then check to see if theres a groups data file
		TitlesData = data.GetData('RanksandTitles');
		TitlesData = TitlesData || {};
		TitlesData.PlayerData = TitlesData.PlayerData || {};
		GroupData = data.GetData("Groups");
		GroupData = GroupData || {};
	},

	checkPlayerData: function(player, steamID) {
		//Okay lets check our data file for player data
		try {
			var authLvl = player.net.connection.authLevel;
			TitlesData.PlayerData[steamID] = TitlesData.PlayerData[steamID] || {};
			TitlesData.PlayerData[steamID].PlayerID = TitlesData.PlayerData[steamID].PlayerID || steamID;
			TitlesData.PlayerData[steamID].RealName = TitlesData.PlayerData[steamID].RealName || this.getName(player);
			TitlesData.PlayerData[steamID].Title = TitlesData.PlayerData[steamID].Title || "";
			TitlesData.PlayerData[steamID].Rank = TitlesData.PlayerData[steamID].Rank || 0;
			TitlesData.PlayerData[steamID].Kills = TitlesData.PlayerData[steamID].Kills || 0;
			TitlesData.PlayerData[steamID].KDR = TitlesData.PlayerData[steamID].KDR || 0;
			TitlesData.PlayerData[steamID].Deaths = TitlesData.PlayerData[steamID].Deaths || 0;
			TitlesData.PlayerData[steamID].Karma = TitlesData.PlayerData[steamID].Karma || 0;
			TitlesData.PlayerData[steamID].isAdmin = TitlesData.PlayerData[steamID].isAdmin || (authLvl >= 2) || false;
			TitlesData.PlayerData[steamID].hidden = TitlesData.PlayerData[steamID].hidden || false;
			this.saveData();
			this.setRankTitle(steamID, player);
		} catch (e) {
			print(e.message.toString());
		}
	},
	//This function is here so that if a player has an exisiting Group Tag, we don't grab that tag.
	//same with the color tag, but that wont be an issue soon.
	getName: function(player) {
		if (GroupsAPI || clansOn) {
			var realName = player.displayName.split("] ").pop();
		} else {
			var realName = player.displayName;
		}
		return realName;
	},

	saveData: function() {
		//Save our data to our titles data file
		data.SaveData('RanksandTitles');
	},

	//Player data refresh, plugs into the /rt refresh command, this runs through the players data and re assignns everything.
	//Checks if data is present, if not it will attempt to build the players data spot
	refreshData: function(player, cmd, args) {
		var steamID = rust.UserIDFromPlayer(player);
		if (TitlesData.PlayerData[steamID] === undefined) {
			print("No Data found, Attempting to build Data");
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noData, "0");
		} else {
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.dataRfrsh, "0");
		}
		TitlesData.PlayerData[steamID].Title = "";
		this.checkPlayerData(player, steamID);
	},

	/*-----------------------------------------------------------------
	            Our functions to find players
	------------------------------------------------------------------*/

	//Find player by name this supports partial names, full names, and steamIDs its also case-insensitive
	findPlayerByName: function(player, args) {
		try {
			var global = importNamespace("");
			var found = [],
				foundID;
			var playerName = args[1].toLowerCase();
			var itPlayerList = global.BasePlayer.activePlayerList.GetEnumerator();
			while (itPlayerList.MoveNext()) {

				var displayName = itPlayerList.Current.displayName.toLowerCase();

				if (displayName.search(playerName) > -1) {
					print("found match " + displayName);
					found.push(itPlayerList.Current);
				}

				if (playerName.length === 17) {
					if (rust.UserIDFromPlayer(displayName).search(playerName)) {
						found.push(itPlayerList.Current);
					}
				}
			}

			if (found.length) {
				foundID = rust.UserIDFromPlayer(found[0]);
				found.push(foundID);
				return found;
			} else {
				rust.SendChatMessage(player, prefix.titles, msgs.NoPlyrs, "0");
				return false;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},

	//This function is rarely used and currently is no longer needed if I remember correct.
	//Best to ignore it for now.
	findPlayer: function(playerid) {
		var global = importNamespace("");
		var targetPlayer = global.BasePlayer.Find(playerid);
		if (targetPlayer) {
			return targetPlayer;
		} else {
			return false;
		}
	},

	//This is a dangerous function as it wipes the entire player data section of our plugins data.
	clearData: function(player, cmd, args) {
		try {
			delete TitlesData.PlayerData;
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.clearData, "0");
			TitlesData.PlayerData = TitlesData.PlayerData || {};
			this.saveData();
			this.loadTitleData();
		} catch (e) {
			print(e.message.toString());
		}
	},

	/*--------------------Switch Command Handling----------------------------*/

	//This is our switch case statement this is called by /rt it then grabs the second word in the text and compares it to one below
	//if a match is found, it will launch that function accordingly.
	switchCmd: function(player, cmd, args) {
		try {
			var steamID = rust.UserIDFromPlayer(player),
				authLvl = player.net.connection.authLevel,
				useTitles = this.Config.Settings.useTitles;
			switch (args[0]) {
				case "stats":
					if (!useTitles) {
						this.checkStats(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.titlesSet, "0");
						return false;
					}
					break;
				case "hide":
					if (authLvl >= this.Config.authLevel) {
						this.hideCmd(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						return false;
					}
					break;
				case "wipe":
					if (authLvl >= this.Config.authLevel) {
						this.wipePlayer(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						return false;
					}
					break;
				case "set":
					if (authLvl >= this.Config.authLevel && args.length >= 2) {
						this.giveTitle(player, cmd, args);
					} else if (authLvl < this.Config.authLevel) {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						return false;
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.badSyntaxRt, "0");
						return false;
					}
					break;
				case "kset":
					if (args.length >= 1 && authLvl >= this.Config.authLevel) {
						this.setKarma(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
					}
					break;
				case "kcheck":
					if (args.length >= 1 && authLvl >= this.Config.authLevel) {
						this.checkKarma(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
					}
					break;
				case "kadd":
					if (args.length >= 1 && authLvl >= this.Config.authLevel) {
						this.addKarma(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
					}
					break;
				case "krem":
					if (args.length >= 1 && authLvl >= this.Config.authLevel) {
						this.removeKarma(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
					}
					break;
				case "remove":
					if (authLvl >= this.Config.authLevel && args.length >= 1) {
						this.removeTitle(player, cmd, args);
					} else if (authLvl < this.Config.authLevel) {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						return false;
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.badSyntaxRemove, "0");
						return false;
					}
					break;
				case "clear":
					if (authLvl >= this.Config.authLevel) {
						this.clearData(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						return false;
					}
					break;
				case "refresh":
					this.refreshData(player, cmd, args);
					break;
				case "switch":
					if (useTitles && (authLvl >= this.Config.authLevel)) {
						this.Config.Settings.useTitles = false;
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.switchRanks, "0");
						rust.BroadcastChat(prefix.ranksandtitles, "<color=red>" + msgs.broadcast + "</color>", "0");
					} else if ((authLvl >= this.Config.authLevel) && !useTitles) {
						this.Config.Settings.useTitles = true;
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.switchTitles, "0");
						rust.BroadcastChat(prefix.ranksandtitles, "<color=red>" + msgs.broadcast + "</color>", "0");
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
						break;
					}
					this.SaveConfig();
					break;
				case "noadmin":
					if (authLvl >= this.Config.authLevel) {
						this.noAdmin(player, cmd, args);
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noPerms, "0");
					}
					break;
				case "help":
					this.rtHelp(player, cmd, args);
					break;
				default:
					if (!useTitles && TitlesData.PlayerData[steamID] !== undefined) {
						rust.SendChatMessage(player, prefix.ranks, msgs.rank + TitlesData.PlayerData[steamID].Rank + " (" + TitlesData.PlayerData[steamID].Title + ")", "0");
					} else if (useTitles && TitlesData.PlayerData[steamID] !== undefined) {
						rust.SendChatMessage(player, prefix.titles, msgs.title + " " + TitlesData.PlayerData[steamID].Title, "0");
					} else {
						rust.SendChatMessage(player, prefix.ranksandtitles, msgs.noData, "0");
						this.checkPlayerData(player, steamID);
					}
					break;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},

	/*-----------------------------------------------------------------
	                 Get our Counts and set Ranks
	 ------------------------------------------------------------------*/

	//This is the arithmatic function to grab the closes karma number from our ranks
	getClosest: function(arr, closestTo) {
		try {
			arr = this.getRanksArray();
			if (arr.length > 0) {

				for (var i = 0; i < arr.length; i++) {
					if (closestTo >= 0) {
						if (arr[i] <= closestTo && arr[i] >= 0) closest = arr[i];
					} else if (closestTo <= 0) {
						if (arr[i] >= closestTo && arr[i] <= 0) closest = arr[i];
					}
				}
			}
			return closest;
		} catch (e) {
			print(e.message.toString())
		}
	},

	getRanksArray: function() {
		try {
			var temp = [];

			for (var i = 0; i < this.Config.Ranks.length; i++) {
				if (this.Config.Settings.karma) {
					temp.push(this.Config.Ranks[i].karma);
				} else {
					if (this.Config.Ranks[i].killsNeeded !== "disabled") {
						temp.push(this.Config.Ranks[i].killsNeeded);
					}
				}
			}
			return temp;
		} catch (e) {
			print(e.message.toString());
		}
	},

	checkPunish: function(killerID, victimID) {
		try {
			if (this.Config.Settings.usePunishSystem && this.Config.Settings.karma) {
				var punish = this.Config.Punishment;
				var player = this.findPlayer(killerID),
					karma;
				for (var i = 0; i < punish.length; i++) {
					if (TitlesData.PlayerData[killerID].Rank === punish[i].rank && TitlesData.PlayerData[victimID].Karma < 0 && TitlesData.PlayerData[killerID].Karma < 0) {
						karma = TitlesData.PlayerData[victimID].Karma * punish[i].multiplier;
					} else if (TitlesData.PlayerData[killerID].Rank === punish[i].rank && TitlesData.PlayerData[victimID].Karma > 0 && TitlesData.PlayerData[killerID].Karma > 0) {
						karma = TitlesData.PlayerData[victimID].Karma * punish[i].multiplier;
					} else {
						return 0;
					}
				}
				var rplObj = {
					rankName: "<color=lime>" + TitlesData.PlayerData[victimID].Title + "</color>",
					karmaAmt: "<color=red>" + karma + "</color>"
				};
				rust.SendChatMessage(player, prefix.ranksandtitles, msgs.punishMsg.replace(/rankName|karmaAmt/gi, function(matched) {
					return rplObj[matched];
				}), "0");
				return karma;
			} else {
				return 0;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},
	//this is our main hub all player data hits this function and is then sent else where if need be
	//or it will continue through the process. This is the default ranks function
	//it checks certain features and if a special case is not found, it will run its code.
	setRankTitle: function(playerID, player) {
		if (playerID === "Test") return true;

		for (var ii = 0; ii < this.Config.Titles.length; ii++) {
			if (TitlesData.PlayerData[playerID].Title === this.Config.Titles[ii].title) {
				return false;
			}
		}

		if (TitlesData.PlayerData[playerID].isAdmin && noAdmin) {
			print("Admins turned off for rankings. Skipping Admin.");
			return false;
		} else if (useTitles) {
			return this.setTitle(playerID, player);
		} else {
			var i = 0,
				j = this.Config.Ranks.length,
				useTitles = this.Config.Settings.useTitles,
				kills = TitlesData.PlayerData[playerID].Kills,
				karma = TitlesData.PlayerData[playerID].Karma,
				karmaOn = this.Config.Settings.karma,
				noAdmin = this.Config.Settings.noAdmin,
				oldRank = TitlesData.PlayerData[playerID].Rank;

			for (i; i < j; i++) {
				if (karmaOn && this.getClosest([], karma) === this.Config.Ranks[i].karma) {
					TitlesData.PlayerData[playerID].Title = this.Config.Ranks[i].title;
					TitlesData.PlayerData[playerID].Rank = this.Config.Ranks[i].rank;
				} else if (!karmaOn && this.getClosest([], kills) === this.Config.Ranks[i].killsNeeded) {
					TitlesData.PlayerData[playerID].Title = this.Config.Ranks[i].title;
					TitlesData.PlayerData[playerID].Rank = this.Config.Ranks[i].rank;
				}
			}
			this.checkPromo(oldRank, TitlesData.PlayerData[playerID].Rank, player);
		}
		this.saveData();
	},

	//This is our function if Titles Only mode is set to true, this function is called by our main hub and then sets titles instead
	//of ranks to a players name. it then sends this data back to our data file to be saved
	setTitle: function(playerID, player) {
		if (playerID === "Test") return true;
		var i = 0,
			j = this.Config.Titles.length,
			useTitles = this.Config.Settings.useTitles;

		for (i; i < j; i++) {
			if (useTitles) {
				TitlesData.PlayerData[playerID].Title = this.Config.Titles[i].title;
			}
		}
		this.saveData();
	},

	/*-----------------------------------------------------------------
	            Check for promotions
	------------------------------------------------------------------*/

	//This is called by our main hub if a players rank increases it will display the message "you've been promoted!"
	//this may not exist for long and may be merged into the main hub function soon.
	checkPromo: function(oldRank, currRank, player) {
		var steamID = rust.UserIDFromPlayer(player);
		if (currRank > oldRank) {
			rust.SendChatMessage(player, prefix.ranks, "<color=green>" + msgs.Promoted + "</color>" + " " + TitlesData.PlayerData[steamID].Title, "0");
		} else if (currRank < oldRank) {
			rust.SendChatMessage(player, prefix.ranks, "<color=red>" + msgs.Demoted + "</color>", "0");
		}

	},

	/*-----------------------------------------------------------------
	                    Grab Karma and Karma Commands
	------------------------------------------------------------------*/

	//A simple function to allow our users to set custom karma modifiers for each rank this searches our config file
	//for karmaModifier to the matching title of the killed players ID it then send the found number back to the death function
	//to add or subtract the appropriate karma.
	getKarma: function(victimID) {
		var i = 0,
			j = this.Config.Ranks.length;
		for (i; i < j; i++) {
			if (this.Config.Ranks[i].title === TitlesData.PlayerData[victimID].Title) {
				return this.Config.Ranks[i].karmaModifier;
			} else {
				return 1;
			}
		}
	},

	/*-----------------------------------------------------------------
	                    Check for Deaths
	------------------------------------------------------------------*/

	//This is our death function this is the primary function, if this breaks. Everything breaks
	//it has several fail safe checks to make sure data is present, and make sure it isn't corrupt
	//if so it stops the check and tells the admin about the problem needing to be addressed
	//Hopefully soon this function will maintain itself 100% automatically it's due for a good re write to optimize its functionality
	//It then assigns ids, makes sure everyone involved was players, makes sure which system to use
	//and then sends appropriate data where it needs to go, it then runs the players through the
	//KDR and ranks functions (remember our hub?) this process may also change during the re write.
	OnEntityDeath: function(entity, hitinfo) {
		try {
			var victim = entity,
				attacker = hitinfo.Initiator,
				victimID,
				killerID;
			var useTitles = this.Config.Settings.useTitles;

			if (victim.ToPlayer() && attacker.ToPlayer() && !useTitles && victim.displayName !== attacker.displayName) {
				var killer = attacker.ToPlayer();
				killerID = rust.UserIDFromPlayer(killer);
				victimID = rust.UserIDFromPlayer(victim);

				if (!TitlesData.PlayerData[killerID]) {
					print("Killer does not have registered Data in Data File.");
					print("Attempting to create killer Data file...");
					this.checkPlayerData(killer, killerID);
				} else if (!TitlesData.PlayerData[victimID] && victim.IsConnected()) {
					print("Victim does not have registered Data in Data File");
					print("Attempting to create Victim Data File...");
					this.checkPlayerData(victim, victimID);
				}

				var karmaOn = this.Config.Settings.karma;
				if (karmaOn && TitlesData.PlayerData[victimID].Karma >= 0) {
					TitlesData.PlayerData[killerID].Kills += 1;
					TitlesData.PlayerData[victimID].Deaths += 1;
					TitlesData.PlayerData[killerID].Karma -= (this.getKarma(victimID) - this.checkPunish(killerID, victimID));
					rust.SendChatMessage(killer, prefix.ranks, msgs.loseKarma + " (" + this.getKarma(victimID) + ")", "0");
				} else if (karmaOn && TitlesData.PlayerData[victimID].Karma < 0) {
					TitlesData.PlayerData[killerID].Kills += 1;
					TitlesData.PlayerData[victimID].Deaths += 1;
					TitlesData.PlayerData[killerID].Karma += (this.getKarma(victimID) + this.checkPunish(killerID, victimID));
					rust.SendChatMessage(killer, prefix.ranks, msgs.gainKarma + " (" + this.getKarma(victimID) + ")", "0");
				} else {
					TitlesData.PlayerData[killerID].Kills += 1;
					TitlesData.PlayerData[victimID].Deaths += 1;
				}
				this.setRankTitle(killerID, killer);
				this.updateKDR(TitlesData.PlayerData[victimID].Kills, TitlesData.PlayerData[victimID].Deaths, victim.ToPlayer());
				this.updateKDR(TitlesData.PlayerData[killerID].Kills, TitlesData.PlayerData[killerID].Deaths, killer);
			} else if (victim.ToPlayer() && victim.displayName === attacker.displayName) {
				var victimID = rust.UserIDFromPlayer(victim);
				TitlesData.PlayerData[victimID].Deaths += 1;
				this.updateKDR(TitlesData.PlayerData[victimID].Kills, TitlesData.PlayerData[victimID].Deaths, victim.ToPlayer());
			} else {
				return false;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},

	/*-----------------------------------------------------------------
	                     Command Handling
	------------------------------------------------------------------*/

	setKarma: function(player, cmd, args) {
		var getPlayer = this.findPlayerByName(player, args);
		var karmaAmt = Number(args[2]);
		if (getPlayer && typeof(karmaAmt) === "number") {
			TitlesData.PlayerData[getPlayer[1]].Karma = karmaAmt;
			this.saveData();
			rust.SendChatMessage(player, prefix.ranks, msgs.setKarma, "0");
		} else {
			rust.SendChatMessage(player, prefix.ranks, msgs.setKarma0, "0");
		}
	},

	checkKarma: function(player, cmd, args) {
		var getPlayer = this.findPlayerByName(player, args);
		if (getPlayer) {
			rust.SendChatMessage(player, prefix.ranks, getPlayer[0].displayName + msgs.plyrKarma + TitlesData.PlayerData[getPlayer[1]].Karma, "0");
		} else {
			rust.SendChatMessage(player, prefix.ranks, msgs.checkFailed, "0");
		}
	},

	addKarma: function(player, cmd, args) {
		var getPlayer = this.findPlayerByName(player, args);
		var karmaAmt = Number(args[2]);
		if (typeof(karmaAmt) === "number") {
			TitlesData.PlayerData[getPlayer[1]].Karma += karmaAmt;
			this.saveData();
			rust.SendChatMessage(player, prefix.ranks, msgs.addKarma, "0");
		}
	},

	removeKarma: function(player, cmd, args) {
		var getPlayer = this.findPlayerByName(player, args);
		var karmaAmt = Number(args[2]);
		if (typeof(karmaAmt) === "number") {
			TitlesData.PlayerData[getPlayer[1]].Karma -= karmaAmt;
			this.saveData();
			rust.SendChatMessage(player, prefix.ranks, msgs.removeKarma, "0");
		}
	},

	//this function is caused by our death checker, this sends data to our data file to keep track of a KDR for the
	//player normally it is called twice each kill (called at the same time) luckily it processes and handles the
	//Ids efficiently so it knows where to send what.
	updateKDR: function(kills, deaths, player) {
		var steamID = rust.UserIDFromPlayer(player);
		var killsToDeaths = kills / deaths;
		killsToDeaths = Math.ceil(killsToDeaths * 100) / 100;
		TitlesData.PlayerData[steamID].KDR = killsToDeaths;
		this.saveData();
	},

	//this is our function that is called by /rt stats it is setup so it will display the currently asking players
	//stats from the data file. It searches the playerdata via steamID.
	checkStats: function(player, cmd, args) {
		var steamID = rust.UserIDFromPlayer(player);
		rust.SendChatMessage(player, prefix.ranks, msgs.kills + TitlesData.PlayerData[steamID].Kills, "0");
		rust.SendChatMessage(player, prefix.ranks, msgs.deaths + TitlesData.PlayerData[steamID].Deaths, "0");
		rust.SendChatMessage(player, prefix.ranks, msgs.kdr + TitlesData.PlayerData[steamID].KDR, "0");
		if (this.Config.Settings.karma) rust.SendChatMessage(player, prefix.ranks, msgs.karma + TitlesData.PlayerData[steamID].Karma, "0");
	},

	//Wipe player resets the chosen players kills, deaths, kdr, and their karma (if its turned on) it does a quick search
	//for the player using our find function and then sends the data to the target player to replace the current set data
	//it then saves and finishes up.
	wipePlayer: function(player, cmd, args) {
		var target = this.findPlayerByName(player, args) || "";
		if (target[1].length) {
			TitlesData.PlayerData[target[1]].Kills = 0;
			TitlesData.PlayerData[target[1]].Deaths = 0;
			TitlesData.PlayerData[target[1]].KDR = 0;
			if (this.Config.Settings.karma) TitlesData.PlayerData[target[1]].Karma = 0;
			rust.SendChatMessage(player, prefix.ranks, msgs.plyrWiped, "0");
			this.saveData();
			this.setRankTitle(target[1], target[0]);
		} else if (!target[1].length) {
			rust.SendChatMessage(player, prefix.ranks, msgs.NoPlyrs, "0");
			return false;
		} else {
			rust.SendChatMessage(player, prefix.ranks, msgs.NoPlyrs, "0");
			return false;
		}
	},

	//This function is used by the remove command, when called it will find the target player
	//grab his file, and then set his title to nothing. It will then run him through the hub function
	//to set his new ranks title instead. This is so if a player with a custom title wishes to
	//go back to the ranks system, he can do so upon asking an admin.
	removeTitle: function(player, cmd, args) {
		try {
			var getPlayer = this.findPlayerByName(player, args);
			TitlesData.PlayerData[getPlayer[1]].Title = "";
			this.saveData();
			this.setRankTitle(getPlayer[1], getPlayer[0]);
			rust.SendChatMessage(player, prefix.ranks, msgs.reset + " " + getPlayer[0].displayName, "0");
		} catch (e) {
			print(e.message.toString());
		}
	},

	//These are our series of commands that are useable and called on by our Switch above. Each one
	//speaks for itself and should be easy to tell what it does.

	hideCmd: function(player, cmd, args) {
		var steamID = rust.UserIDFromPlayer(player);
		if (!TitlesData.PlayerData[steamID].hidden) {
			TitlesData.PlayerData[steamID].hidden = true;
			rust.SendChatMessage(player, prefix.titles, "Your tag is now hidden!", "0");
		} else {
			TitlesData.PlayerData[steamID].hidden = false;
			rust.SendChatMessage(player, prefix.titles, "Your tag is no longer hidden!", "0");
		}
		this.saveData();
	},

	giveTitle: function(player, cmd, args) {

		var getPlayer = this.findPlayerByName(player, args);
		var getPlayerData = TitlesData.PlayerData,
			j = this.Config.Titles.length,
			i = 0;
		if (args[2].length) {
			for (i; i < j; i++) {
				if (args[2].toLowerCase() === this.Config.Titles[i].title.toLowerCase()) {
					getPlayer[0].displayName = getPlayerData[getPlayer[1]].RealName + "[" + this.Config.Titles[i].title + "]";
					TitlesData.PlayerData[getPlayer[1]].Title = this.Config.Titles[i].title;
				}
			}
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.setSuccs, "0");
		} else {
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.needTitle, "0");
			return false;
		}
		this.saveData();
	},

	noAdmin: function(player, cmd, args) {
		var noAdmin = this.Config.Settings.noAdmin;
		if (noAdmin) {
			this.Config.Settings.noAdmin = false;
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.adminsOn, "0");
		} else {
			this.Config.Settings.noAdmin = true;
			rust.SendChatMessage(player, prefix.ranksandtitles, msgs.adminsOff, "0");
		}
		this.SaveConfig();
	},

	rtHelp: function(player, cmd, args) {
		rust.SendChatMessage(player, null, "--------------RanksAndTitles Commands------------", "0");
		var authLvl = player.net.connection.authLevel;
		for (var i = 0; i < this.Config.Help.length; i++) {
			rust.SendChatMessage(player, null, this.Config.Help[i], "0");
		}
		if (authLvl >= 2) {
			rust.SendChatMessage(player, null, "<color=orange>--------------Admin Commands------------</color>", "0");
			for (var j = 0; j < this.Config.AdminHelp.length; j++) {
				rust.SendChatMessage(player, null, this.Config.AdminHelp[j], "0");
			}
		}
	},

	SendHelpText: function(player) {
		rust.SendChatMessage(player, prefix.ranksandtitles, msgs.help, "0");
	},

	/*-----------------------------------------------------------------
	                        Chat Handling(New)
	------------------------------------------------------------------*/

	//This function is used by playerchat to grab the correct colors for the rank, or title used by the player
	//it will then send back the found color for the chat function to use.
	getColor: function(steamID) {
		//This is for custom titles being set with ranks may be removed with recent fixes
		for (var i = 0; i < this.Config.Titles.length; i++) {
			if (TitlesData.PlayerData[steamID].Title === this.Config.Titles[i].title) {
				color = this.Config.Titles[i].Color;
				return color;
			}
		}


		if (!this.Config.Settings.useTitles) {
			for (var i = 0; i < this.Config.Ranks.length; i++) {
				if (TitlesData.PlayerData[steamID].Title === this.Config.Ranks[i].title) {
					color = this.Config.Ranks[i].Color;
					return color;
				}
			}
		} else {
			for (var i = 0; i < this.Config.Titles.length; i++) {
				if (TitlesData.PlayerData[steamID].Title === this.Config.Titles[i].title) {
					color = this.Config.Titles[i].Color;
					return color;
				}
			}
		}
	},

	grabPlayerData : function(steamID, key) {
        return TitlesData.PlayerData[steamID][key]
    },

	//Our char function is called whenever a chat message is sent, it grabs a slew of information including, player files, the message
	//the player title and realname, and the steamId, using all of this it checks to make sure the chat wasn't empty or a command
	//then if checks if color support is activated if so it will sent the chat with the colored title
	//if its not enabled then it will send a default message with the players assigned title without the color.
	//We have to make sure we return false afterwards or else we will get double chat messages with every chat sent.
	OnPlayerChat: function(arg) {
		try {
			if (!chatHandler) {
				var global = importNamespace("");
				var player = arg.connection.player,
					authLevel = player.net.connection.authLevel,
					msg = arg.GetString(0, "text");
				var steamID = rust.UserIDFromPlayer(player);
				var title = TitlesData.PlayerData[steamID].Title,
					hidden = TitlesData.PlayerData[steamID].hidden,
					colorOn = this.Config.Settings.colorSupport,
					color = this.getColor(steamID);
				var displayName = player.displayName;
				if (msg.substring(1, 1) === "/" || msg === "") return false;
				if (hidden || title === "") {
					global.ConsoleSystem.Broadcast("chat.add", steamID, "<color=" + this.Config.Settings.chatNameColor + ">" + displayName + "</color> " + msg);
					print(player.displayName + ": " + msg);
					return false;
				} else if (colorOn && authLevel === 0) {
					global.ConsoleSystem.Broadcast("chat.add", steamID, "<color=" + this.Config.Settings.chatNameColor + ">" + displayName + "</color>" + " <color=" + color + ">[" + title + "]</color> " + msg);
					print(player.displayName + ": " + msg);
					return false;
				} else if (!colorOn && authLevel === 0) {
					global.ConsoleSystem.Broadcast("chat.add", steamID, "<color=" + this.Config.Settings.chatNameColor + ">" + displayName + " [" + title + "] " + "</color>" + msg);
					print(player.displayName + ": " + msg);
					return false;
				} else if (authLevel >= 1 && colorOn) {
					global.ConsoleSystem.Broadcast("chat.add", steamID, "<color=" + this.Config.Settings.staffchatNameColor + ">" + displayName + "</color>" + " <color=" + color + ">[" + title + "]</color> " + msg);
					print(player.displayName + ": " + msg);
					return false;
				} else if (authLevel >= 1 && !colorOn) {
					global.ConsoleSystem.Broadcast("chat.add", steamID, "<color=" + this.Config.Settings.staffchatNameColor + ">" + displayName + " [" + title + "] " + "</color> " + msg);
					print(player.displayName + ": " + msg);
					return false;
				}
			} else {
				return null;
			}
		} catch (e) {
			print(e.message.toString());
		}
	},

	/*-----------------------------------------------------------------
	                        Debugger
	------------------------------------------------------------------*/
	//Simple debugger that will place lots of information into the console for issue disputes
	debug: function(player, cmd, args) {
		try {
			var authLvl = player.net.connection.authLevel;
			if (!this.Config.Settings.deBugOff || authLvl >= 2) {
				var steamID = rust.UserIDFromPlayer(player);
				GroupData = data.GetData("Groups");
				print("----Starting Debug-----");
				print("--------Current Player Debug-----------");
				print("Player ID: " + TitlesData.PlayerData[steamID].PlayerID);
				print("Titles Real Name: " + TitlesData.PlayerData[steamID].RealName);
				print("Real name after adjustment: " + TitlesData.PlayerData[steamID].RealName.split("] ").pop());
				print("Groups Name: " + GroupData.PlayerData[steamID].RealName);
				print("Group: " + GroupData.PlayerData[steamID].Group);
				print("Player Title: " + TitlesData.PlayerData[steamID].Title);
				print("Player Rank: " + TitlesData.PlayerData[steamID].Rank);
				print("Player Kills: " + TitlesData.PlayerData[steamID].Kills);
				print("Player Deaths: " + TitlesData.PlayerData[steamID].Deaths);
				print("-------End Player Debug-------");
				print("--------Server Info-------");
				print("Config Version: " + this.Config.version);
				print("Groups Returns Data: " + GroupsAPI);
				print("Colors On: " + this.Config.Settings.colorSupport);
				print("Karma On: " + this.Config.Settings.karma);
				print("Use Titles Only Enabled: " + this.Config.Settings.useTitles);
				print("Admins turned off: " + this.Config.Settings.onAdmin);
				print("Number of Ranks: " + this.Config.Ranks.length);
				print("Number of Titles: " + this.Config.Titles.length);
				print("------End Server Info------");
				print("-----Start Function Debug-------");
				print("setRankTitle Responding: " + this.setRankTitle("Test"));
				print("setTitle Responding: " + this.setTitle("Test"));
				print("setCustomTitle Responding: " + this.setCustomTitle("Test"));
				print("-------End Function Debug--------");
				print("----End Debug----");
				rust.SendChatMessage(player, prefix.ranksandtitles, msgs.debugRan, "0");
			} else {
				rust.SendChatMessage(player, prefix.ranksandtitles, msgs.debugDis, "0");
			}
		} catch (e) {
			print(e.message.toString());
		}
	}
}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\rules.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var rules = {
        Title: "Rules",
        Author: "Killparadise",
        Version: V(1, 5, 0),
        HasConfig: true,
        Init: function() {
            notifier = plugins.Find("notifier");
                if (notifier) {
                    print('Loaded Rules from Config: ' + this.Config.setRules.length);
                    notifierFound = true;
                } else {
                    print('Loaded Rules from Config: ' + this.Config.setRules.length);
                    command.AddChatCommand("rules", this.Plugin, "switchRules");
                    notifierFound = false;
                }

                if (this.Config.settings.repeatDisplay) {
                    var rules = this.Config.setRules;
                    this.rulesDelay = timer.Repeat(this.Config.settings.interval, 0, function() {
                        rust.BroadcastChat('', "---------Server Rules--------", 0);
                        for (var i = 0; i < rules.length; i++) {
                            rust.BroadcastChat('RULES', rules[i], 0)
                        }
                    }, this.Plugin);
                }
        },

        LoadDefaultConfig: function() {
            print("Config Changes with new update, Updating Config file.");
            this.Config.setRules = [
                "1. No Cheating!",
                "2. No Abusing broken mechanics!",
                "3. Respect thy fellow players"
            ];

            this.Config.RulesFr = [
                "1. place french translations here.",
            ];

            this.Config.RulesSp = [
                "1. place Spanish translations here."
            ];

            this.Config.settings = {
                "authLvl": 2,
                "repeatDisplay": true,
                "welcomeMsg": true,
                "interval": 200
            }

            this.Config.Messages = {
                "AddBadSyntax": ['Incorrect Syntax, please use: /rules add "rule here" Example: /rules add "Example Rule Here"'],
                "DelBadSyntax": ["Incorrect Syntax, please use:", "/rules del ruleNumber", "Example: /rules del 1"],
                "Default": ["No Permissions to use this command."],
                "welcome": "Welcome {player} to our server!",
                "badSyntaxGen": "Incorrect Syntax please try again.",
                "title": "---------Server Rules--------"
            }
        },

        OnPlayerInit: function(player) {
            if (!notifierFound) {
                try {
                    if (this.Config.settings.welcomeMsg) {
                        var msg = this.Config.Messages.welcome.toString();
                        msg = msg.replace("{player}", player.displayName);
                        rust.SendChatMessage(player, "RULES", msg, "0");
                        this.cmdShowRules(player);
                    }
                } catch (e) {
                    print(e.message.toString());
                }
            }
        },



        /*-----------------------------------------------------------------
                         Commands for Rules
        ------------------------------------------------------------------*/

        switchRules: function(player, cmd, args) {
            if (args.length >= 0) {
                switch (args[0]) {
                    case "add":
                        this.cmdAddRule(player, cmd, args);
                        break;
                    case "del":
                        this.cmdDelRule(player, cmd, args);
                        break;
                    case "fr":
                        this.cmdShowRules(player, "fr");
                        break;
                    case "sp":
                        this.cmdShowRules(player, "sp");
                        break;
                    default:
                        var rules = this.Config.setRules;
                        rust.SendChatMessage(player, '', this.Config.Messages.title, 0);
                        for (var i = 0; i < rules.length; i++) {
                            rust.SendChatMessage(player, "RULES", rules[i], "0");
                        }
                        break;
                }
            } else {
                rust.SendChatMessage(player, "RULES", this.Config.Messages.badSyntaxGen, "0");
            }
          },

            cmdShowRules: function(player, lang) {
                      if (lang === "fr") {
                        var rules = this.Config.RulesFr;
                        rust.SendChatMessage(player, '', this.Config.Messages.title, 0);
                        for (var i = 0; i < rules.length; i++) {
                            rust.SendChatMessage(player, "RULES", rules[i], "0");
                        }
                      } else if (lang === "sp") {
                        var rules = this.Config.RulesSp;
                        rust.SendChatMessage(player, '', this.Config.Messages.title, 0);
                        for (var i = 0; i < rules.length; i++) {
                            rust.SendChatMessage(player, "RULES", rules[i], "0");
                        }
                      }
                },

                cmdAddRule: function(player, cmd, args) {
                    var authLvl = player.net.connection.authLevel;
                    var rules = this.Config.setRules;
                    var rulLen = rules.length + 1;

                    if (args.length < 2) {
                        for (var j = 0; j < this.Config.Messages.AddBadSyntax.length; j++) {
                            rust.SendChatMessage(player, "RULES", this.Config.Messages.AddBadSyntax[j], "0");
                            return;
                        }
                    } else {

                        if (authLvl >= 2 && args[1].length) {
                            rules.push(rulLen + "." + " " + args[1]);
                            rust.SendChatMessage(player, "RULES", "Rule added successfully.", "0")
                            this.SaveConfig();
                        } else if (authLvl <= 1) {
                            rust.SendChatMessage(player, "RULES", "No Permissions to use this command.", "0");
                        }
                    }
                },

                cmdDelRule: function(player, cmd, args) {
                    var authLvl = player.net.connection.authLevel;
                    var rules = this.Config.setRules;
                    var tempSave = [];
                    if (authLvl >= 2 && args.length < 2) {
                        for (var j = 0; j < this.Config.Messages.DelBadSyntax.length; j++) {
                            rust.SendChatMessage(player, "RULES", this.Config.Messages.DelBadSyntax[j], "0");
                            return;
                        }
                    } else if (authLvl >= 2 && args.length >= 2) {
                        for (var i = 0; i < rules.length; i++) {
                            try {
                                if (rules.indexOf(rules[i]) != (args[1] - 1)) {
                                    tempSave.push(rules[i]);
                                } else {
                                    continue;
                                }
                            } catch (e) {
                                print(e.message.toString());
                            }
                        }
                        this.Config.setRules = [];
                        for (var ii = 0; ii < tempSave.length; ii++) {
                            this.Config.setRules.push(tempSave[ii]);
                        }
                        rust.SendChatMessage(player, "RULES", "Rule Deleted Successfully", "0");
                        this.SaveConfig();
                        return;
                    } else {
                        rust.SendChatMessage(player, "RULES", "No Permissions to use this command.", "0");
                    }
                },

                SendHelpText: function(player) {
                    var authLvl = player.net.connection.authLevel;
                    rust.SendChatMessage(player, "RULES", "/rules - Show the list of server rules", "0");
                    if (authLvl >= 2) {
                        rust.SendChatMessage(player, "RULES", '/rules add "Rule in quotes here" - Add a new rule to the list', "0");
                        rust.SendChatMessage(player, "RULES", "/rules del # - removes the rule listed with given number", "0");
                    }
                }
        };

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\js\titles.js
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

var titles = {
    Title: "Titles",
    Author: "Killparadise",
    Version: V(0, 1, 1),
    HasConfig: true,
    Init: function() {
        this.loadTitleData();
    },
    OnServerInitialized: function() {
        print(this.Title + " Is now loading, please wait...");
        //command.AddChatCommand("show", this.Plugin, "cmdShowPlayer");
    },

    LoadDefaultConfig: function() {
        this.Config.authLevel = 2;
        this.Config.Settings = {
            "showPlayer": true,
            "groupsSet": false,
            "displayLvl": true
        };
        this.Config.Titles = {
            "Admin": "Admin",
            "Moderator": "Mod",
            "Player": "Player"
        };
    },
    cmdShowPlayer: function(player, cmd, args) {
        if (authLevel >= this.Config.authLevel) {
            if (!showPlayer) {
                showPlayer = true;
                for (var i = 0; i < authConfig.PlayerData.length; i++) {
                    if (authConfig.PlayerData[i].Title === this.Config.Titles.Player) {
                        player.displayName = authConfig.PlayerData[i].RealName + " " + "[" + authConfig.PlayerData[i].Title + "]";
                        rust.SendChatMessage(player, "TITLES", "Successfully turned on titles for Players", "0");
                        print("Returned Users with 'Player' " + authConfig.PlayerData[i]);
                    } else {
                        print("Returned No Users with 'Player' " + authConfig.PlayerData[i]);
                        return false;
                    }
                }
            } else {
                showPlayer = false;
                for (var ii = 0; ii < authConfig.PlayerData.length; ii++) {
                    if (authConfig.PlayerData[ii].Title === this.Config.Titles.Player) {
                        player.displayName = authConfig.PlayerData[ii].RealName;
                        rust.SendChatMessage(player, "TITLES", "Successfully turned off titles for Player", "0");
                        print("Returned Users with 'Player' " + authConfig.PlayerData[ii].Title);
                    } else {
                        print("Returned No Users with 'Player' " + authConfig.PlayerData[ii].Title);
                        return false;
                    }
                }
            }
        } else {
            rust.SendChatMessage(player, "TITLES", "You do not have permission to use this command!", "0");
        }
    },


    loadTitleData: function() {
        authConfig = data.GetData('Titles');
        authConfig = authConfig || {};
        authConfig.PlayerData = authConfig.PlayerData || {};
    },


    checkPlayerData: function(player) {
        // pID = rust.UserIDFromPlayer( player );
        authConfig.PlayerData[pID] = authConfig.PlayerData[pID] || {};
        authConfig.PlayerData[pID].RealName = authConfig.PlayerData[pID].RealName || player.displayName || "";
        authConfig.PlayerData[pID].Title = authConfig.PlayerData[pID].Title || "";
        authConfig.PlayerData[pID].authLvl = authConfig.PlayerData[pID].authLvl || authLevel || "";
        showPlayer = this.Config.Settings.showPlayer;
        //groupsSet = this.checkForGroups(player, pID) || false;
        this.setTitle(player, showPlayer, pID);
    },


    saveTitleData: function() {
        data.SaveData('Titles');
    },

    setTitle: function(player, showPlayer, pID) {
        //Get our title and name for our data
        authName = authConfig.PlayerData[pID].Title;
        realName = authConfig.PlayerData[pID].RealName;

        switch (authLevel) {
            case 0:
                authConfig.PlayerData[pID].Title = this.Config.Titles.Player;
                if (showPlayer) {
                    player.displayName = authConfig.PlayerData[pID].RealName + " " + "[" + authConfig.PlayerData[pID].Title + "]";
                } else {
                    player.displayName = authConfig.PlayerData[pID].RealName;
                    return false;
                }
                break;
            case 1:
                authConfig.PlayerData[pID].Title = this.Config.Titles.Moderator;
                player.displayName = authConfig.PlayerData[pID].RealName + " " + "[" + authConfig.PlayerData[pID].Title + "]";
                if (this.Config.Settings.displayLvl) rust.SendChatMessage(player, "Titles", "Your title is: " +this.Config.Titles.Moderator, "0");
                break;
            case 2:
                authConfig.PlayerData[pID].Title = this.Config.Titles.Admin;
                player.displayName = authConfig.PlayerData[pID].RealName + " " + "[" + authConfig.PlayerData[pID].Title + "]";
                if (this.Config.Settings.displayLvl) rust.SendChatMessage(player, "Titles", "Your title is: " +this.Config.Titles.Admin, "0");
                break;
            default:
                authConfig.PlayerData[pID].Title = "Not Found";
                player.displayName = authConfig.PlayerData[pID].RealName;
                break;
        }
        this.saveTitleData();
    },

    checkForGroups: function(player, pID) {
        var GroupsDataExists = data.GetData("Groups") ? true : false;

        if (GroupsDataExists) {
            GroupsData = data.GetData("Groups");
            pData = GroupsData.PlayerData[pID];
            authConfig.PlayerData[pID].RealName = pData.RealName;
            groupsDisplayName = player.displayName;
            return true;
        } else {
            print("Groups Data not found, no need to grab anything.");
            return false;
        }
    },

    OnPlayerInit: function(player) {
        pID = rust.UserIDFromPlayer(player);
        authLevel = player.net.connection.authLevel;
        this.checkPlayerData(player);
    }

}
