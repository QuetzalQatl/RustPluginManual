
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\0-logger.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Logger"
PLUGIN.Version = V(0, 2, 8)
PLUGIN.Description = "Logs all chat commands used by players with auth level to the server log and/or chat."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/670/"
PLUGIN.ResourceId = 670
PLUGIN.HasConfig = true

local debug = false

local compatible = true
function PLUGIN:Init()
    self:LoadDefaultConfig()
    if plugins.Exists("chathandler") then compatible = false end
end

function PLUGIN:OnRunCommand(arg)
    if not arg then return end
    if not arg.connection then return end
    if not arg.connection.player then return end
    if not arg.cmd then return end
    if not arg.cmd.namefull then return end
    local player = arg.connection.player
    local console = arg.cmd.namefull
    local chat = arg:GetString(0, "text")
    if self.Config.Settings.CommandLogging ~= "false" then
        if self:PermissionsCheck(player) then
            local excluded
            for key, value in pairs(self.Config.Settings.Exclusions) do if value == console then excluded = true; break end end
            if not excluded then
                print("[" .. self.Title .. "] " .. player.displayName .. " ran console command: " .. console)
                if self.Config.Settings.Broadcast ~= "false" then
                    rust.BroadcastChat(self.Config.Settings.ChatName, player.displayName .. " ran console command: " .. console)
                end
            elseif chat:sub(1, 1) == "/" then
                print("[" .. self.Title .. "] " .. player.displayName .. " ran chat command: " .. chat)
                if self.Config.Settings.Broadcast ~= "false" then
                    rust.BroadcastChat(self.Config.Settings.ChatName, player.displayName .. " ran chat command: " .. chat)
                end
            end
        end
    end
end

function PLUGIN:OnPlayerChat(arg)
    if not arg then return end
    if not arg.connection then return end
    if not arg.connection.player then return end
    local player = arg.connection.player
    local chat = arg:GetString(0, "text")
    if not chat or chat == "" or chat:sub(1, 1) == "/" then return end
    if self.Config.Settings.ChatLogging ~= "false" and compatible ~= "false" then
        print(player.displayName .. ": " .. chat)
    end
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.Broadcast = self.Config.Settings.Broadcast or "true"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "LOGGER"
    self.Config.Settings.ChatLogging = self.Config.Settings.ChatLogging or "false"
    self.Config.Settings.CommandLogging = self.Config.Settings.CommandLogging or "true"
    self.Config.Settings.Exclusions = self.Config.Settings.Exclusions or {
        "chat.say", "craft.add", "craft.cancel", "global.kill", "global.respawn", "global.respawn_sleepingbag", "global.status", "global.wakeup", "inventory.endloot"
    }
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\00-Economics.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Economics"
PLUGIN.Title = "Economics"
PLUGIN.Version = V(1, 6, 0)
PLUGIN.Description = "Basic Economy System."
PLUGIN.Author = "Bombardir"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 717

----------------------------------------- LOCALS -----------------------------------------
local USERS, API, base_economy, cmds, msgs  = {}, {}, {}, {}, {}
local function SendMessage(player, msg)
	rust.SendChatMessage(player, msgs.ChatName, msg)
end
local function HasAcces(player)
	return player:GetComponent("BaseNetworkable").net.connection.authLevel >= API.Admin_Auth_LvL
end
------------------------------------------------------------------------------------------

----------------------------------------- API -----------------------------------------
function base_economy:Set(money)
	self[1] = money
	API.SaveData()
end

function base_economy:Transfer(base_eco, money)
	if self:Withdraw(money) then
		base_eco:Deposit(money)
		return true
	else
		return false 
	end
end

function base_economy:Deposit(money)
	self:Set(self[1] + money)
end

function base_economy:Withdraw(money)
	if self[1] >= money then
		self:Set(self[1] - money)
		return true
	else
		return false
	end
end

function GetEconomyAPI()
	return API
end

function PLUGIN.GetEconomyAPI()
	return API
end
 
function API.SaveData()
	datafile.SaveDataTable( "Economics" )
end

function API:GetUserDataFromPlayer(player)
	return self:GetUserData(rust.UserIDFromPlayer(player))
end

function API:GetUserData(steamid)
	local data = USERS[steamid]
	if not data then
		data = {}
		data[1] = self.StartMoney
		setmetatable(data, {__index = base_economy})
		USERS[steamid] = data
	end
	return data
end 
---------------------------------------------------------------------------------------

function PLUGIN:Init()
	USERS = datafile.GetDataTable( "Economics" ) or {}
	
	API.StartMoney = self.Config.StartMoney or 1000
	API.Admin_Auth_LvL = self.Config.Admin_Auth_LvL or 2
	API.Transfer_Fee = self.Config.Transfer_Fee or 0.01
	
	self.Config.Transfer_Fee = API.Transfer_Fee
	self.Config.StartMoney = API.StartMoney
	self.Config.Admin_Auth_LvL = API.Admin_Auth_LvL
	if self.Config.CleanBase == nil then self.Config.CleanBase = true end
	
	for k, v in pairs(USERS) do
		if self.Config.CleanBase and v[1] == API.StartMoney then -- Clean Base
			USERS[k] = nil
		else
			setmetatable(USERS[k], {__index = base_economy}) -- Bind Functions
		end 
	end
	datafile.SaveDataTable( "Economics" )
	
	cmds = self.Config.Commands or {}
	cmds.Balance = cmds.Balance or "balance"
	cmds.SetMoney = cmds.SetMoney or "setmoney"
	cmds.Transfer = cmds.Transfer or "transfer"
	cmds.Deposit = cmds.Deposit or "deposit"
	cmds.Withdraw = cmds.Withdraw or "withdraw"
	self.Config.Commands = cmds
	
	msgs = self.Config.Messages or {}
	msgs.ChatName = msgs.ChatName or "[Economy]"
	msgs.NoPermission = msgs.NoPermission or "No Permission!"
	msgs.NoPlayer = msgs.NoPlayer or "No Player Found!"
	msgs.New_Player_Balance = msgs.New_Player_Balance or "New player balance: %s"
	msgs.Syntax_Error = msgs.Syntax_Error or "Syntax Error! /%s <name/steamid> <money>"
	msgs.Withdraw_Error = msgs.Withdraw_Error or "'%s' has not enough money!"
	msgs.My_Balance = msgs.My_Balance or "Your Balance: %s"
	msgs.Balance = msgs.Balance or "Player Balance: %s"
	msgs.Transfer_Money_Error = msgs.Transfer_Money_Error or  "You do not have enough money!"
	msgs.Transfer_Negative_Error = msgs.Transfer_Negative_Error or "Money can not be negative!"
	msgs.Transfer_Error = msgs.Transfer_Error or "You can not transfer money yourself!"
	msgs.Transfer_Succes = msgs.Transfer_Succes or "You have successfully transferred money to '%s'!"
	msgs.Transfer_Succes_To = msgs.Transfer_Succes_To or "'%s' has transferred money to you! Check your balance '/balance'!"
	msgs.Save_Succes = msgs.Save_Succes or "Economics data saved!"
	msgs.Help = msgs.Help or  {"/balance - check your balance","/transfer <name> <money> - transfer [money] to [name] player for small fee"}
	self.Config.Messages = msgs
	
	self:SaveConfig()
	
	command.AddConsoleCommand( "eco.c", self.Plugin, "CC_Eco" )
	
	if cmds.Balance ~= "" then command.AddChatCommand(cmds.Balance, self.Plugin, "C_Balance") end
	if cmds.SetMoney ~= "" then command.AddChatCommand(cmds.SetMoney, self.Plugin, "C_Setmoney") end
	if cmds.Transfer ~= "" then command.AddChatCommand(cmds.Transfer, self.Plugin, "C_Transfer") end
	if cmds.Deposit ~= "" then command.AddChatCommand(cmds.Deposit, self.Plugin, "C_Deposit") end
	if cmds.Withdraw ~= "" then command.AddChatCommand(cmds.Withdraw, self.Plugin, "C_Withdraw") end
end

function PLUGIN:SendHelpText(player)
    for i=1,#msgs.Help do
		SendMessage(player, msgs.Help[i])
	end
end

function PLUGIN:C_Transfer(player, cmd, args)
	if args.Length > 1 then
		local money = tonumber(args[1]) 
		if money then
			if money > 0 then
				local target   = global.BasePlayer.Find(args[0])
				if target then
					if target ~= player then
						if API:GetUserDataFromPlayer(player):Withdraw(money) then
							API:GetUserDataFromPlayer(target):Deposit(money*(1-API.Transfer_Fee))
							SendMessage(player, msgs.Transfer_Succes:format(target.displayName))
							SendMessage(target, msgs.Transfer_Succes_To:format(player.displayName))
						else
							SendMessage(player, msgs.Transfer_Money_Error)
						end
					else
						SendMessage(player, msgs.Transfer_Error)
					end
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Transfer_Negative_Error)
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.Transfer))
		end
	else
		SendMessage(player, msgs.Syntax_Error:format(cmds.Transfer))
	end
end

function PLUGIN:C_Balance(player, cmd, args)
	if args.Length > 0 then
		if HasAcces(player) then
			local target   = global.BasePlayer.Find(args[0])
			if target then
				SendMessage(player, msgs.Balance:format( API:GetUserDataFromPlayer(target)[1] )) 
			else
				SendMessage(player, msgs.NoPlayer)
			end
		else
			SendMessage(player, msgs.NoPermission)
		end
	else
		SendMessage(player, msgs.My_Balance:format(API:GetUserDataFromPlayer(player)[1]))
	end
end

function PLUGIN:C_Setmoney(player, cmd, args) 
	if HasAcces(player) then
		if args.Length > 1 then
			local money = tonumber(args[1])
			if money then
				local target   = global.BasePlayer.Find(args[0])
				if target then
					local data = API:GetUserDataFromPlayer(target)
					data:Set(money)
					SendMessage(player, msgs.New_Player_Balance:format( data[1] )) 
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Syntax_Error:format(cmds.SetMoney))
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.SetMoney))
		end
	else
		SendMessage(player, msgs.NoPermission)
	end
end

function PLUGIN:C_Deposit(player, cmd, args) 
	if HasAcces(player) then
		if args.Length > 1 then
			local money = tonumber(args[1])
			if money then
				local target   = global.BasePlayer.Find(args[0])
				if target then
					local data = API:GetUserDataFromPlayer(target)
					data:Deposit(money)
					SendMessage(player, msgs.New_Player_Balance:format( data[1] )) 
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Syntax_Error:format(cmds.Deposit))
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.Deposit))
		end
	else
		SendMessage(player, msgs.NoPermission)
	end
end

function PLUGIN:C_Withdraw(player, cmd, args) 
	if HasAcces(player) then
		if args.Length > 1 then
			local money = tonumber(args[1])
			if money then
				local target   = global.BasePlayer.Find(args[0])
				if target then
					local data = API:GetUserDataFromPlayer(target)
					if data:Withdraw(money) then
						SendMessage(player, msgs.New_Player_Balance:format( data[1] ))
					else
						SendMessage(player, msgs.Withdraw_Error:format( target.displayName ))
					end
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Syntax_Error:format(cmds.Withdraw))
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.Withdraw))
		end
	else
		SendMessage(player, msgs.NoPermission)
	end
end

function PLUGIN:CC_Eco(arg)
	local reply = ""
	local player
	if arg.connection then
		player = arg.connection.player
	end
	if not player or HasAcces(player) then
		local cmd = arg:GetString( 0, "" )
		if cmd == "save" then
			API.SaveData()
			reply = "Economics data saved!"
		elseif cmd == "deposit" or cmd == "balance" or cmd == "withdraw" or cmd == "setmoney" then
			local steam  = arg:GetString( 1, "" )
			local target = global.BasePlayer.Find(steam)
			local userdata
			if target then
				userdata = API:GetUserDataFromPlayer( target )
				steam = target.displayName
			elseif steam:match("%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d") then
				userdata = API:GetUserData(steam)
			end
			if userdata then
				if cmd == "balance" then
					reply =  "Balance(" .. steam .. ") = " .. tostring(userdata[1]) 
				else
					local money = tonumber(arg:GetString( 2, "" ))
					if money then
						if cmd == "setmoney" then
							userdata:Set(money)
							reply = "(SetMoney) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						elseif cmd == "deposit" then
							userdata:Deposit(money)
							reply = "(Deposit) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						elseif userdata:Withdraw(money) then
							reply = "(Withdraw) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						else
							reply = "This user haven't enough money!"
						end
					else
						reply =  "Syntax Error! (eco.c " .. cmd .. " <steam/name> <money>)"
					end
				end
			else
				reply = "No user with steam/name: '" .. steam .. "' !"
			end
		else
			reply = "Economy Commands: 'eco.c deposit', 'eco.c save','eco.c balance', 'eco.c withdraw', 'eco.c setmoney'"  
		end
	else
		reply = "No permission!"
	end
	arg:ReplyWith(reply)
	return true
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\0friendsAPI.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "FriendsAPI"
PLUGIN.Description  = "An API to manage friends"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(1, 2, 0)
PLUGIN.HasConfig    = true
PLUGIN.ResourceID   = 686



function PLUGIN:Init()
    command.AddChatCommand("friend", self.Object, "cmdFriend")
    self:LoadDefaultConfig()
    self:LoadDataFile()
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings                        = self.Config.Settings or {}
    self.Config.Settings.MaxFriends             = self.Config.Settings.MaxFriends or 30

    self.Config.Messages                        = self.Config.Messages or {}
    self.Config.Messages.List                   = self.Config.Messages.List or "Friends {count}: "
    self.Config.Messages.NoFriends              = self.Config.Messages.NoFriends or "You dont have friends :("
    self.Config.Messages.NotOnFriendlist        = self.Config.Messages.NotOnFriendlist or "{target} not found on your friendlist"
    self.Config.Messages.FriendRemoved          = self.Config.Messages.FriendRemoved or "{target} was removed from your friendlist"
    self.Config.Messages.PlayerNotFound         = self.Config.Messages.PlayerNotFound or "Player not found"
    self.Config.Messages.CantAddSelf            = self.Config.Messages.CantAddSelf or "You cant add yourself"
    self.Config.Messages.AlreadyOnList          = self.Config.Messages.AlreadyOnList or "{target} is already your friend"
    self.Config.Messages.FriendAdded            = self.Config.Messages.FriendAdded or "{target} is now your friend"
    self.Config.Messages.FriendlistFull         = self.Config.Messages.FriendlistFull or "Your friendlist is full"
    self.Config.Messages.HelpText               = self.Config.Messages.HelpText or "use /friend <add|remove|list> <name/steamID> to add/remove/list friends"
end
-- --------------------------------
-- datafile handling
-- --------------------------------
local DataFile = "friends"
local Data = {}
function PLUGIN:LoadDataFile()
    local data = datafile.GetDataTable(DataFile)
    Data = data or {}
end
function PLUGIN:SaveDataFile()
    datafile.SaveDataTable(DataFile)
end
-- --------------------------------
-- builds output messages by replacing wildcards
-- --------------------------------
local function buildOutput(str, tags, replacements)
    for i = 1, #tags do
        str = string.gsub(str, tags[i], replacements[i])
    end
    return str
end
-- --------------------------------
-- handles chat command /friend
-- --------------------------------
function PLUGIN:cmdFriend(player, cmd, args)
if not player then return end
    local args = self:ArgsToTable(args, "chat")
    local func, target = args[1], args[2]
    local playerSteamID = rust.UserIDFromPlayer(player)
    if not func or func ~= "add" and func ~= "remove" and func ~= "list" then
        rust.SendChatMessage(player, "Syntax: /friend <add/remove> <name/steamID> or /friend list")
        return
    end
    if func ~= "list" and not target then
        rust.SendChatMessage(player, "Syntax: /friend <add/remove> <name/steamID>")
        return
    end
    if func == "list" then
        local friendlist = self:GetFriendlist(playerSteamID)
        if friendlist then
            local i, playerCount = 1, 0
            local friendlistString = ""
            local friendlistTbl = {}
            -- build friendlist string
            for _, value in pairs(friendlist) do
                playerCount = playerCount + 1
                friendlistString = friendlistString..value..", "
                if playerCount == 8 then
                    friendlistTbl[i] = friendlistString
                    friendlistString = ""
                    playerCount = 0
                    i = i + 1
                end
            end
            -- remove comma at the end
            if string.sub(friendlistString, -2, -2) == "," then
                friendlistString = string.sub(friendlistString, 1, -3)
            end
            -- output friendlist
            if #friendlistTbl >= 1 then
                rust.SendChatMessage(player, buildOutput(self.Config.Messages.List, {"{count}"}, {"["..tostring(#friendlist).."/"..tostring(self.Config.Settings.MaxFriends).."]"}))
                for i = 1, #friendlistTbl do
                    rust.SendChatMessage(player, friendlistTbl[i])
                end
                rust.SendChatMessage(player, friendlistString)
            else
                rust.SendChatMessage(player, buildOutput(self.Config.Messages.List, {"{count}"}, {"["..tostring(#friendlist).."/"..tostring(self.Config.Settings.MaxFriends).."]"})..friendlistString)
            end
            return
        end
        rust.SendChatMessage(player, self.Config.Messages.NoFriends)
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if func == "remove" then
        local removed = self:removeFriend(playerSteamID, target)
        if not removed then
            rust.SendChatMessage(player, buildOutput(self.Config.Messages.NotOnFriendlist, {"{target}"}, {target}))
        else
            if targetPlayer then
                rust.SendChatMessage(player, buildOutput(self.Config.Messages.FriendRemoved, {"{target}"}, {targetPlayer.displayName}))
            else
                rust.SendChatMessage(player, buildOutput(self.Config.Messages.FriendRemoved, {"{target}"}, {target}))
            end
        end
        return
    end
    if not targetPlayer then
        rust.SendChatMessage(player, self.Config.Messages.PlayerNotFound)
        return
    end
    local targetName = targetPlayer.displayName
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    if func == "add" then
        if player == targetPlayer then
            rust.SendChatMessage(player, self.Config.Messages.CantAddSelf)
            return
        end
        local added = self:addFriend(player, targetSteamID, targetName)
        if added == "max" then
            rust.SendChatMessage(player, self.Config.Messages.FriendlistFull)
            return
        end
        if not added then
            rust.SendChatMessage(player, buildOutput(self.Config.Messages.AlreadyOnList, {"{target}"}, {targetName}))
        else
            rust.SendChatMessage(player, buildOutput(self.Config.Messages.FriendAdded, {"{target}"}, {targetName}))
        end
        return
    end

end
-- --------------------------------
-- returns true if player was removed
-- returns false if not (not on friendlist)
-- --------------------------------
function PLUGIN:removeFriend(playerSteamID, target)
    local playerData = self:GetPlayerData(playerSteamID)
    if not playerData then return false end
    for key, _ in pairs(playerData.Friends) do
        if playerData.Friends[key].steamID == target or playerData.Friends[key].name == target then
            table.remove(playerData.Friends, key)
            if #playerData.Friends == 0 then
                Data[playerSteamID] = nil
            end
            self:SaveDataFile()
            return true
        end
    end
    return false
end
-- --------------------------------
-- returns true if friend was added
-- returns false if not (is already on friendlist)
-- --------------------------------
function PLUGIN:addFriend(player, targetSteamID, targetName)
    local playerSteamID = rust.UserIDFromPlayer(player)
    local playerName = player.displayName
    local playerData = self:GetPlayerData(playerSteamID, playerName, true)
    if #playerData.Friends >= self.Config.Settings.MaxFriends then
        return "max"
    end
    for key, _ in pairs(playerData.Friends) do
        if playerData.Friends[key].steamID == targetSteamID then
            return false
        end
    end
    local newFriend = {["name"] = targetName, ["steamID"] = targetSteamID}
    table.insert(playerData.Friends, newFriend)
    self:SaveDataFile()
    return true
end
-- --------------------------------
-- returns true when player has target on friendlist
-- returns false if not
-- --------------------------------
function PLUGIN:HasFriend(playerSteamID, target)
    local playerData = self:GetPlayerData(playerSteamID)
    if not playerData then return false end
    for key, _ in pairs(playerData.Friends) do
        if playerData.Friends[key].steamID == target or playerData.Friends[key].name == target then
            return true
        end
    end
    return false
end
-- --------------------------------
-- returns true when player is on targets friendlist
-- returns false if hes not
-- --------------------------------
function PLUGIN:IsFriendFrom(player, targetSteamID)
    local playerData = self:GetPlayerData(targetSteamID)
    if not playerData then return false end
    for key, _ in pairs(playerData.Friends) do
        if playerData.Friends[key].steamID == player or playerData.Friends[key].name == player then
            return true
        end
    end
    return false
end
-- --------------------------------
-- returns true when player and target are friends
-- returns false when they are not
-- --------------------------------
function PLUGIN:areFriends(playerSteamID, targetSteamID)
    local hasFriend = self:HasFriend(playerSteamID, targetSteamID)
    local isFriend = self:IsFriendFrom(playerSteamID, targetSteamID)
    if hasFriend and isFriend then
        return true
    end
    return false
end
-- --------------------------------
-- returns a players friendlist as table
-- if known, the table will return the names, if not it returns steamID
-- returns false if player has no friends
-- --------------------------------
function PLUGIN:GetFriendlist(playerSteamID)
    local playerData = self:GetPlayerData(playerSteamID)
    if not playerData then return false end
    local friends = {}
    for key, _ in pairs(playerData.Friends) do
        friends[key] = playerData.Friends[key].name
    end
    return friends
end
-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end
-- --------------------------------
-- returns table with player data
-- --------------------------------
function PLUGIN:GetPlayerData(playerSteamID, playerName, addNewEntry)
    local playerData = Data[playerSteamID]
    if not playerData and addNewEntry then
        playerData = {}
        playerData.SteamID = playerSteamID
        playerData.Name = playerName
        playerData.Friends = {}
        Data[playerSteamID] = playerData
        self:SaveDataFile()
    end
    return playerData
end
-- --------------------------------
-- sends the helptext
-- --------------------------------
function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, self.Config.Messages.HelpText)
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\admin-door-unlocker.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--[[
 Admin door unlocker
 
 Copyright (c) 2015 Nexus <talk@juliocesar.me>, <http://steamcommunity.com/profiles/76561197983103320>
 
 -------------------------------------------------------------------------------------------------------------------
 This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US.
 -----------------------------------------------------------------------------------------------------------------
 
 $Id$
 Version 0.1.2 by Nexus on 2015-04-11 06:05 PM (UTC -03:00)
]]--

PLUGIN.Name = "admin-door-unlocker"
PLUGIN.Title = "Admin door Unlocker"
PLUGIN.Description = "Unlock any door/box for Admins"
PLUGIN.Version = V(0, 1, 2)
PLUGIN.Author = "Nexus"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 756

-- Define A.D.U class
local ADU = {}

-- Define Config version
ADU.ConfigVersion = "0.0.4"

-- Get a Copy of PLUGIN Class
ADU.ox = PLUGIN

-- Define Settings
ADU.Settings = {}
-- Define Messages
ADU.Messages = {}

-- General Settings:
ADU.DefaultSettings = {
  ChatName = "A.D.U",
  Enabled = true,
  RequiredAuthLevel = 2,
  ConfigVersion = "0.0.4"
}

-- Plugin Messages:
ADU.DefaultMessages = {
  Enabled = "Enabled!",
  Disabled = "Disabled!",
  AuthLevelChanged = "You changed the required Auth Level to %d!",
  InvalidAuthLevel = "You need pass a valid auth level like: admin, owner, mod, moderator, user, player, 0 or 1 or 2!",
  NotAllowed = "You cannot use that command because you don't have the required Auth Level %d!",
  AuthLog = " %s by %s (%s)",

  Help = {
    "/adu.toggle - Toggle (Enable/Disable) A.D.U!",
    "/adu.authlevel <n/s> - Change the required auth level to open locked doors."
  }
}

-- -----------------------------------------------------------------------------------
-- ADU:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- It check if the config version is outdated
-- -----------------------------------------------------------------------------------
function ADU:UpdateConfig()
  -- Check if the current config version differs from the saved
  if self.ox.Config.Settings.ConfigVersion ~= self.ConfigVersion then
    -- Reset the whole table
    self.ox.Config.Settings = {}
    self.ox.Config.Messages = {}
    
    -- Load the default
    self.ox:LoadDefaultConfig()
    -- Save config
    self.ox:SaveConfig()
  end
  
  -- Copy Tables
  self.Settings = self.ox.Config.Settings
  self.Messages = self.ox.Config.Messages
end

-- -----------------------------------------------------------------------------
-- ADU:SendMessage(param, message)
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player/console
-- -----------------------------------------------------------------------------
function ADU:SendMessage(param, message)
  -- Check if the message is a table with multiple messages.
  if type(message) == "table" then
    -- Loop by table of messages and send them one by one
    for i, message in pairs(message) do
      -- Loop back
      self:SendMessage(param, message)
    end
  else
    -- Check if param is not null
    if param ~= nil then
      -- Check if call came from user's chat or console
      if type(param.net) == 'userdata' then
          -- Send the message to the targetted player.
         rust.SendChatMessage(param, self.Settings.ChatName, message, rust.UserIDFromPlayer(param))
      elseif type(param.net) == 'string' then    
        -- Check if was passed by client's console 
        if param.connection then
          -- Reply back to player's console
          param:ReplyWith(self.Settings.ChatName..": "..message) 
          -- Send message with authLog to console
          self:SendMessage(nil, self.Messages.AuthLog:format(message, param.connection.player.displayName, rust.UserIDFromPlayer(param.connection.player)))
        else
          -- Send message to console
          self:SendMessage(nil, message)
        end
      end
    else
      -- Log
      self:Log(self.Settings.ChatName..": "..message) 
    end
  end
end

-- -----------------------------------------------------------------------------------
-- ADU:Toggle(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Admin Door Unlocker
-- -----------------------------------------------------------------------------------
function ADU:Toggle(player)
  -- Check if Admin Door Unlocker is enabled
  if self.Settings.Enabled then
    -- Disable Admin Door Unlocker
    self.Settings.Enabled = false
    -- Send Message to Player
    self:SendMessage(player, self.Messages.Disabled)
  else
    -- Enable Admin Door Unlocker
    self.Settings.Enabled = true
    -- Send Message to Player
    self:SendMessage(player, self.Messages.Enabled)
  end

  -- Save the config.
  self.ox:SaveConfig()
end

-- -----------------------------------------------------------------------------------
-- ADU:ChangeAuthLevel(player, authLevel)
-- -----------------------------------------------------------------------------------
-- Change Auth Level required to use Admin Door Unlocker
-- -----------------------------------------------------------------------------------
function ADU:ChangeAuthLevel(player, authLevel)
  -- Check if Admin Door Unlocker is enabled
  if self.Settings.Enabled then
    -- Check for Admin
    if authLevel == "admin" or authLevel == "owner" or authLevel == "2" then
      -- Set required auth level to admin
      self.Settings.RequiredAuthLevel = 2
      -- Send message to player
      self:SendMessage(player, self.Messages.AuthLevelChanged:format(2))
      -- Check for Mod
    elseif authLevel == "mod" or authLevel == "moderator" or authLevel == "1" then
      -- Set required auth level to moderator
      self.Settings.RequiredAuthLevel = 1
      -- Send message to player
      self:SendMessage(player, self.Messages.AuthLevelChanged:format(1))
      -- Check for Mod
    elseif authLevel == "user" or authLevel == "player" or authLevel == "0" then
      -- Set required auth level to moderator
      self.Settings.RequiredAuthLevel = 0
      -- Send message to player
      self:SendMessage(player, self.Messages.AuthLevelChanged:format(0))
    else
      -- Send message to player
      self:SendMessage(player, self.Messages.InvalidAuthLevel)
    end

    -- Save the config.
    self.ox:SaveConfig()
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:IsAllowed(player)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run an admin (or moderator or user) only command.
-- -----------------------------------------------------------------------------------
function ADU:IsAllowed(player)
  -- Check if player is valid
  if player ~= nil then
    -- Check if is connected
    if player:GetComponent("BaseNetworkable").net.connection ~= nil then
      -- Compare the Player's AuthLevel with the required AuthLevel, if it's higher or equal
      return player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Settings.RequiredAuthLevel
    end
  end

  return false
end

-- -----------------------------------------------------------------------------------
-- ADU:Log(message)
-- -----------------------------------------------------------------------------------
-- Log normal
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function ADU:Log(message)
  UnityEngine.Debug.Log.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- ADU:LogWarning(message)
-- -----------------------------------------------------------------------------------
-- Log Warning
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function ADU:LogWarning(message)
  UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- ADU:LogError(message)
-- -----------------------------------------------------------------------------------
-- Log Error
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function ADU:LogError(message)
  UnityEngine.Debug.LogError.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat commands are registered and data
-- from the DataTable file is loaded.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init ()
  -- Add chat commands
  command.AddChatCommand("adu.authlevel", self.Plugin, "cmdChangeAuthLevel")
  command.AddChatCommand("adu.toggle", self.Plugin, "cmdToggleADU")
  
  -- Add console commands
  command.AddConsoleCommand("adu.authlevel", self.Plugin, "ccmdChangeAuthLevel")
  command.AddConsoleCommand("adu.toggle", self.Plugin, "ccmdToggleADU")
  
  -- Update config version
  ADU:UpdateConfig()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the players. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig ()
  self.Config.Settings = ADU.DefaultSettings
  self.Config.Messages = ADU.DefaultMessages
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Count(tbl)
-- -----------------------------------------------------------------------------
-- Counts the elements of a table.
-- -----------------------------------------------------------------------------
-- Credit: m-Teleportation
function PLUGIN:Count(tbl)
  local count = 0

  if type(tbl) == "table" then
    for _ in pairs(tbl) do
      count = count + 1
    end
  end

  return count
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SendHelpText(player)
-- -----------------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- -----------------------------------------------------------------------------------
function PLUGIN:SendHelpText(player)
  -- Check if user is admin
  if ADU:IsAllowed(player) then
    -- Send message to player
    ADU:SendMessage(player, self.Config.Messages.Help)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdChangeAuthLevel(player, _, args)
-- -----------------------------------------------------------------------------------
-- Change required Auth Level
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdChangeAuthLevel(player, _, args)
  -- Check if Admin Door Unlocker is enabled
  if ADU:IsAllowed(player) and self.Config.Settings.Enabled then
    -- Check for passed args
    if args.Length == 1 then
      -- Change required Auth level
      ADU:ChangeAuthLevel(player, args[0])
    elseif args.Length == 0 then
      -- Send message to player
      ADU:SendMessage(player, self.Config.Messages.InvalidAuthLevel)
    end
  -- Check if player is not allowed and A.D.U is enabled
  elseif not ADU:IsAllowed(player) and self.Config.Settings.Enabled then
    -- Send message to player
    ADU:SendMessage(player, self.Config.Messages.NotAllowed:format(self.Config.Settings.RequiredAuthLevel))  
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToggleADU(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Inventory Guardian
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToggleADU(player)
  -- Check if Inventory Guardian is enabled and If player is allowed
  if ADU:IsAllowed(player) then
    -- Restore Player inventory
    ADU:Toggle(player)
  else
    -- Send message to player
    ADU:SendMessage(player, self.Config.Messages.NotAllowed:format(self.Config.Settings.RequiredAuthLevel))
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:CanUseDoor()
-- -----------------------------------------------------------------------------------
-- When any player try to open any door this function is trigged
-- -----------------------------------------------------------------------------------
function PLUGIN:CanUseDoor(player, door)
  -- Check if player is admin
  if ADU:IsAllowed(player) and self.Config.Settings.Enabled then
    -- Unlock the door
    door:SetFlag(global["BaseEntity+Flags"].Locked, false)
    -- Lock the door
    timer.Once(0.1, function() door:SetFlag(global["BaseEntity+Flags"].Locked, true) end)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdChangeAuthLevel(arg)
-- -----------------------------------------------------------------------------------
-- Change required Auth Level
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdChangeAuthLevel(arg)
  -- Check for passed args
  if arg:HasArgs(1) then
    -- Change required Auth level
    ADU:ChangeAuthLevel(arg, arg.Args[0])
  else
    -- Send message to player
    ADU:SendMessage(arg, self.Config.Messages.InvalidAuthLevel)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdToggleInventoryGuardian(arg)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Inventory Guardian
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdToggleADU(arg)
  -- Restore Player inventory
  ADU:Toggle(arg)
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\afk.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "AFK Kick"
PLUGIN.Version = V(0, 1, 3)
PLUGIN.Description = "Kicks players that are AFK (away from keyboard) for set amount of seconds."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/765/"
PLUGIN.ResourceId = 765
PLUGIN.HasConfig = true

local debug = false

local afkTimer = {}
function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:PositionCheck(player)
    local steamId = rust.UserIDFromPlayer(player)
    local junk = player.transform.position; local start = player.transform.position
    afkTimer[steamId] = timer.Repeat(self.Config.Settings.AfkLimit, 0, function()
        local current = player.transform.position
        if debug then
            print("[" .. self.Title .. "] Start position of " .. steamId .. ": " .. tostring(start))
            print("[" .. self.Title .. "] Current position of " .. steamId .. ": " .. tostring(current))
        end
        if start.x == current.x and start.y == current.y and start.z == current.z then
            local message = self.Config.Messages.YouKicked:gsub("{afklimit}", self.Config.Settings.AfkLimit)
            Network.Net.sv:Kick(player.net.connection, message)
            if self.Config.Settings.Broadcast ~= "false" then
                local message = self.Config.Messages.PlayerKicked:gsub("{player}", player.displayName)
                rust.BroadcastChat(self.Config.Settings.ChatName, message)
            end
        end
        start = current
    end)
end

function PLUGIN:OnPlayerInit(player)
    if not player then return end
    if self.Config.Settings.AdminExcluded ~= "false" and self:PermissionsCheck(player.net.connection) then return end
    self:PositionCheck(player)
end

function PLUGIN:OnPlayerDisconnected(player)
    local steamId = rust.UserIDFromPlayer(player)
    if afkTimer[steamId] then afkTimer[steamId]:Destroy(); afkTimer[steamId] = nil end
end

function PLUGIN:Unload()
    if next(afkTimer) ~= nil then afkTimer:Destroy(); afkTimer = nil end
end

function PLUGIN:PermissionsCheck(connection)
    local authLevel; if connection then authLevel = connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(connection.username .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AdminExcluded = self.Config.Settings.AdminExcluded or "true"
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.AfkLimit = tonumber(self.Config.Settings.AfkLimit) or 300 -- 5 minutes
    self.Config.Settings.Broadcast = self.Config.Settings.Broadcast or "true"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "ADMIN"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.PlayerKicked = self.Config.Messages.PlayerKicked or "{player} was kicked for being AFK!"
    self.Config.Messages.YouKicked = self.Config.Messages.YouKicked or "You were kicked for being AFK for {afklimit} seconds!"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\afksystem.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "AFK System"
PLUGIN.Description  = "Basic AFK System"
PLUGIN.Author       = "Merka"
PLUGIN.Version      = V(2, 0, 0)
PLUGIN.HasConfig    = true

function PLUGIN:Init()
  command.AddChatCommand("afk", self.Plugin, "cmdAfk")
    afkData = datafile.GetDataTable("afksystem")
    self:LoadDefaultConfig()
 end
 function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
	self.Config.Settings.PluginPrefix = self.Config.Settings.PluginPrefix or "<color=cyan>**AFK**</color>"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.IsAfk = self.Config.Messages.IsAfk or "{player} went AFK"
    self.Config.Messages.IsNotAfk = self.Config.Messages.IsNotAfk or "{player} is no longer AFK"
    self:SaveConfig()
end

 function PLUGIN:cmdAfk(player,  command, arg)
    local userId = rust.UserIDFromPlayer(player)
	local prefixandname = self.Config.Settings.PluginPrefix.." "..player.displayName
    if afkData[userId] then
        afkData[userId] = nil
        local message = string.gsub(self.Config.Messages.IsNotAfk, "{player}", prefixandname)
        rust.BroadcastChat(message)
        player:EndSleeping()
    else
	    afkData[userId] = true
        local message = string.gsub(self.Config.Messages.IsAfk, "{player}", prefixandname)
        rust.BroadcastChat(message)
        player:StartSleeping()
    end
    datafile.SaveDataTable("afksystem")

end
 function PLUGIN:OnPlayerSleepEnded(player)
    local userID = rust.UserIDFromPlayer(player)
	local message = string.gsub(self.Config.Messages.IsNotAfk, "{player}", self.Config.Settings.PluginPrefix.." "..player.displayName)
	if afkData[userID] then
	rust.BroadcastChat(message)
	afkData[userID] = nil
	end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\airdrops.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Airdrops"
PLUGIN.Description  = "Custom Airdrop Commands"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,0,2)
PLUGIN.HasConfig    = false
PLUGIN.ResourceId 	= 860

local debug = false
function PLUGIN:Init()
    self:LoadDefaultConfig()
	command.AddChatCommand("massdrop", self.Object, "cmdMassdrop")
    command.AddChatCommand("airdrop", self.Object, "cmdAirdrop")
end

--								WILL MAYBE IMPLEMENT THIS
function PLUGIN:LoadDefaultConfig()
	self.Config.AIRDROP_CMD = self.Config.AIRDROP_CMD or {"massdrop"}
	self.Config.MASSDROP_CMD = self.Config.MASSDROP_CMD or {"massdrop"}
	self.Config.CONSOLECMD_AIRDROP_TOPLAYER =  self.Config.CONSOLECMD_AIRDROP_TOPLAYER or {"airdrop.toplayer"}
	self.Config.CONSOLECMD_AIRDROP_TOPOS = self.Config.CONSOLECMD_AIRDROP_TOPOS or {"airdrop.topos"}
	self.Config.CONSOLECMD_AIRDROP_MASSDROP = self.Config.CONSOLECMD_AIRDROP_MASSDROP or {"airdrop.massdrop"}
end

--				MASSDROP
function PLUGIN:cmdMassdrop(player, cmd, args)
	if player.net.connection.authLevel == 0 then return end
	if args.Length == 1 then
		local dropAmount = tonumber(args[0])
		if dropAmount < 2 then return end
		rust.BroadcastChat("AIRDROP", "" .. dropAmount .. " Airdrops summoned by " .. player.displayName)
		rust.RunServerCommand("airdrop.massdrop " .. dropAmount)
	else
		rust.SendChatMessage(player, "AIRDROP", "Syntax: /massdrop [AMOUNT]")
	end
end

--			AIRDROP / TOPLAYER
function PLUGIN:cmdAirdrop(player, cmd, args)
    if player.net.connection.authLevel == 0 then return end
	if args.Length == 1 then
        local targetPlayer = global.BasePlayer.Find(args[0])
        rust.BroadcastChat("AIRDROP", "Airdrop for a specific player summoned by "  .. player.displayName)
        rust.RunServerCommand("airdrop.toplayer " .. targetPlayer.displayName)
    else
        rust.BroadcastChat("AIRDROP", "Airdrop summoned by " .. player.displayName)
		rust.RunServerCommand("event.run")
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\airdrop_settings.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name 		= "Airdrop Settings"
PLUGIN.Title 		= "Airdrop Settings"
PLUGIN.Description 	= "Allows to change the airdrop settings"
PLUGIN.Url 			= "http://amx-x.ru"
PLUGIN.Version 		= V(1, 0, 0)
PLUGIN.Author 		= "t0pdevice"
PLUGIN.HasConfig 	= true
PLUGIN.ResourceID 	= 785

local CanDrop = false
local Timer
local VectorZero
local Looting = {}
local AirdropLoot = {}

function PLUGIN:Init()
	command.AddChatCommand("airdrop_min", self.Plugin, "CmdMinimumPlayers")
	command.AddChatCommand("airdrop_freq", self.Plugin, "CmdDropFrequency")
	command.AddChatCommand("airdrop_stay", self.Plugin, "CmdSupplyStayTime")
	command.AddChatCommand("airdrop_reset", self.Plugin, "CmdLootReset")
	command.AddConsoleCommand("airdrop.run", self.Plugin, "CmdAirdropRun")
	command.AddConsoleCommand("airdrop.min", self.Plugin, "CmdMinimumPlayersConsole")	
	command.AddConsoleCommand("airdrop.freq", self.Plugin, "CmdDropFrequencyConsole")
	command.AddConsoleCommand("airdrop.stay", self.Plugin, "CmdSupplyStayTimeConsole")
	command.AddConsoleCommand("airdrop.reset", self.Plugin, "CmdLootResetConsole")
	
	self:CheckConfig()
	
	if (self.Config.AirdropSettings.DropFrequency > 0) then
		Timer = timer.Repeat(self.Config.AirdropSettings.DropFrequency * 60, 0, function() self:SpawnPlane() end)
	end
	
	VectorZero = new(UnityEngine.Vector3._type, nil)
	VectorZero.x = 0
	VectorZero.y = 0
	VectorZero.z = 0
	
	Looting.Container = {}
	self:LoadAirdropLoot()
end

function PLUGIN:FormatString(Text, Parameter, Value)
	return string.gsub(Text, Parameter, Value)
end

function PLUGIN:AllowDrop()
	if (self.Config.AirdropSettings.ManualRunDrop) then
		CanDrop = true
	end
end

function PLUGIN:LoadAirdropLoot()
    AirdropLoot = datafile.GetDataTable("airdrop_settings") or {}
	
	if (not AirdropLoot.Settings) then
		self:CreateDefaultLoot()
		self:SaveAirdropLoot()
	end
end

function PLUGIN:SaveAirdropLoot()
    datafile.SaveDataTable("airdrop_settings")
end

function PLUGIN:CmdAirdropRun(Args)
	if (self.Config.AirdropSettings.ManualRunDrop) then
		self:SpawnPlane()
	end
end

function PLUGIN:CmdLootResetConsole(Args)
	local Player
	
	if (not Args.connection) then
		Player = nil
	else
		Player = Args.connection.player
	end
	
	self:CmdLootReset(Player, Args.cmd, Args.Args)
end

function PLUGIN:CmdLootReset(Player, Cmd, Args)
    if (Player and Player.net.connection.authLevel < 2) then
		self:MessageToPlayer(Player, self.Config.Messages.DontHaveAccess)
        return
    end

	self:CreateDefaultLoot()
	self:SaveAirdropLoot()
	AirdropLoot = datafile.GetDataTable("airdrop_settings") or {}
	
	if (Player) then
		self:MessageToPlayer(Player, self.Config.Messages.LootReset)
	else
		self:MessageToServer(self.Config.Messages.LootReset)
	end
end

function PLUGIN:CmdMinimumPlayersConsole(Args)
	local Player
	
	if (not Args.connection) then
		Player = nil
	else
		Player = Args.connection.player
	end
	
	self:CmdMinimumPlayers(Player, Args.cmd, Args.Args)
end

function PLUGIN:CmdMinimumPlayers(Player, Cmd, Args)
    if (Player and Player.net.connection.authLevel == 0) then
		self:MessageToPlayer(Player, self.Config.Messages.DontHaveAccess)
        return
    end

    if (not Args or Args.Length == 0) then
		if (Player) then
			self:MessageToPlayer(Player, self.Config.Messages.MinNumberExplain)
		else
			self:MessageToServer(self.Config.Messages.MinNumberExplain)
		end
        return
	end
	
    local MinPlayers = tonumber(Args[0])
	
	if (not MinPlayers) then
		return
	end

    self.Config.AirdropSettings.MinimumPlayers = MinPlayers
    self:SaveConfig()
	
	if (Player) then
		self:MessageToPlayer(Player, self:FormatString(self.Config.Messages.MinNumberChanged, "{number}", MinPlayers))
	else
		self:MessageToServer(self:FormatString(self.Config.Messages.MinNumberChanged, "{number}", MinPlayers))
	end
end

function PLUGIN:CmdSupplyStayTimeConsole(Args)
	local Player
	
	if (not Args.connection) then
		Player = nil
	else
		Player = Args.connection.player
	end
	
	self:CmdSupplyStayTime(Player, Args.cmd, Args.Args)
end

function PLUGIN:CmdSupplyStayTime(Player, Cmd, Args)
    if (Player and Player.net.connection.authLevel == 0) then
		self:MessageToPlayer(Player, self.Config.Messages.DontHaveAccess)
        return
    end

    if (not Args or Args.Length == 0) then
		if (Player) then
			self:MessageToPlayer(Player, self.Config.Messages.SupplyRemoveExplain)
		else
			self:MessageToServer(self.Config.Messages.SupplyRemoveExplain)
		end
        return
	end
	
    local Time = tonumber(Args[0])
	
	if (not Time) then
		return
	end

    self.Config.AirdropSettings.SupplyStayTime = Time
    self:SaveConfig()
	
	if (Player) then
		self:MessageToPlayer(Player, self:FormatString(self.Config.Messages.SupplyRemoveChanged, "{number}", Time))
	else
		self:MessageToServer(self:FormatString(self.Config.Messages.SupplyRemoveChanged, "{number}", Time))
	end
end

function PLUGIN:CmdDropFrequencyConsole(Args)
	local Player
	
	if (not Args.connection) then
		Player = nil
	else
		Player = Args.connection.player
	end
	
	self:CmdDropFrequency(Player, Args.cmd, Args.Args)
end

function PLUGIN:CmdDropFrequency(Player, Cmd, Args)
    if (Player and Player.net.connection.authLevel == 0) then
		self:MessageToPlayer(Player, self.Config.Messages.DontHaveAccess)
       return
    end
	
    if (not Args or Args.Length == 0) then
		if (Player) then
			self:MessageToPlayer(Player, self.Config.Messages.DropFrequencyExplain)
		else
			self:MessageToServer(self.Config.Messages.DropFrequencyExplain)
		end
        return
	end
	
    local Frequency = tonumber(Args[0])

	if (not Frequency) then
		return
	end
	
    self.Config.AirdropSettings.DropFrequency = Frequency
    self:SaveConfig()
	
	if (Player) then
		self:MessageToPlayer(Player, self:FormatString(self.Config.Messages.DropFrequencyChanged, "{number}", Frequency))
	else
		self:MessageToServer(self:FormatString(self.Config.Messages.DropFrequencyChanged, "{number}", Frequency))
	end
end

function PLUGIN:MessageToPlayer(Player, Message)
	rust.SendChatMessage(Player, self.Config.PluginSettings.Title, tostring(Message))
end

function PLUGIN:MessageToAll(Message)
	rust.BroadcastChat(self.Config.PluginSettings.Title, tostring(Message))
end

function PLUGIN:MessageToServer(Message)
	print("[" .. self.Config.PluginSettings.Title .. "] " .. tostring(Message))
end

function PLUGIN:SpawnPlane()
	CanDrop = true
	
	local Entity = global.GameManager.server:CreateEntity("events/cargo_plane", new(UnityEngine.Vector3._type, nil), new(UnityEngine.Quaternion._type, nil))
	
	if (Entity) then
		self:MessageToServer(self.Config.Messages.PlaneSpawned)
		Entity:Spawn(true)
	end
end

function PLUGIN:OnPlayerLoot(Inventory, Entity)	
	if (not Entity) then
		return
	end
	
	if (not string.find(tostring(Entity.name), "supply_drop")) then
		return
	end
	
	local Container = Entity:GetComponent("StorageContainer").inventory
	
	if (not Container) then
		return
	end

	local Player = Inventory:GetComponent("BasePlayer")
	
	if (not Player) then
		return
	end
	
	local UserID = rust.UserIDFromPlayer(Player)
	Looting[UserID] = Entity
	
	if (self.Config.AirdropSettings.CustomSupplyLoot) then
	
		if (Looting.Container) then
			for i, Loot in pairs(Looting.Container) do
				if (Loot[1] == Entity) then
					Entity:GetComponent("StorageContainer").inventory = Looting.Container[i][2]
					return
				end
			end
		end
		
		self:BuildLoot(Entity, Container)
	end
end

function PLUGIN:BuildLoot(Entity, Container)
	Container.itemList:Clear()
	Container.capacity = AirdropLoot.Settings.Capacity
	
	self:AddRandomItem(AirdropLoot.Blueprint, AirdropLoot.Count.Blueprint, Container, true)
	self:AddRandomItem(AirdropLoot.Weapon, AirdropLoot.Count.Weapon, Container, false)
	self:AddRandomItem(AirdropLoot.Item, AirdropLoot.Count.Item, Container, false)
	self:AddRandomItem(AirdropLoot.Outerwear, AirdropLoot.Count.Outerwear, Container, false)
	self:AddRandomItem(AirdropLoot.Underwear, AirdropLoot.Count.Underwear, Container, false)
	self:AddRandomItem(AirdropLoot.Gloves, AirdropLoot.Count.Gloves, Container, false)
	self:AddRandomItem(AirdropLoot.Boots, AirdropLoot.Count.Boots, Container, false)
	self:AddRandomItem(AirdropLoot.Helmet, AirdropLoot.Count.Helmet, Container, false)
	self:AddRandomItem(AirdropLoot.Tool, AirdropLoot.Count.Tool, Container, false)
	self:AddRandomItem(AirdropLoot.Medical, AirdropLoot.Count.Medical, Container, false)
	self:AddRandomItem(AirdropLoot.Food, AirdropLoot.Count.Food, Container, false)
	self:AddRandomItem(AirdropLoot.Ammo, AirdropLoot.Count.Ammo, Container, false)
	self:AddRandomItem(AirdropLoot.Resource, AirdropLoot.Count.Resource, Container, false)
	
	local Info = { Entity, Container }
	table.insert(Looting.Container, Info)	
end

function PLUGIN:AddRandomItem(Loot, MaxCount, Container, IsBlueprint)
	local Name, MinAmount, MaxAmount, Chance, Amount, Random, Item, IsStacked, IsFinded, i
	local Count = 0
	
	if (not Loot) then
		return
	end
	
	if (MaxCount == 0) then
		return
	end
	
	repeat
		if (Container.capacity == Container.itemList.Count) then
			return
		end
			
		i = math.random(1, #Loot)	
		
		Name = Loot[i]["name"]
		MinAmount = Loot[i]["min_amount"]
		MaxAmount = Loot[i]["max_amount"]
		Chance = Loot[i]["chance"]
		
		if (Chance > 0) then				
			if (MinAmount and MaxAmount) then
				Amount = math.random(MinAmount, MaxAmount)
				IsStacked = true
			else
				Amount = 1
				IsStacked = false
			end
			
			if (Amount == 0) then
				Amount = 1
			end
			
			Random = math.random(1, 100)
			
			if (Random <= Chance) then
				Item = global.ItemManager.CreateByName(Name, Amount)
				
				if Item then
					if (IsBlueprint) then
						Item.isBlueprint = true
					end
					
					if (IsStacked) then
						IsFinded = Container:FindItemByItemID(Item.info.itemid)
					end
					
					if (not IsFinded) then
						Count = Count + 1	
						Item:MoveToContainer(Container, -1, IsStacked)
					end
				end
			else
				if (not AirdropLoot.Settings.FillCount) then
					Count = Count + 1
				end
			end
		end
	until (Count == MaxCount)
end

function PLUGIN:OnEntitySpawn(Entity)
	if (not Entity) then
		return
	end
	
	if (Entity:GetComponentInParent(global.SupplyDrop._type)) then
		timer.Once(1, function() self:CheckSupplyLanded(Entity) end)
	end
	
	if (not Entity:GetComponentInParent(global.CargoPlane._type)) then
		return
	end
	
	if (global.BasePlayer.activePlayerList.Count < self.Config.AirdropSettings.MinimumPlayers) then
		self:MessageToServer(self:FormatString(self.Config.Messages.PlaneRemovedMin, "{number}", self.Config.AirdropSettings.MinimumPlayers ))
		self:RemoveEntity(Entity)
		return
	end
	
	if (not CanDrop) then
		self:MessageToServer(self.Config.Messages.PlaneRemovedTrigger)
		self:RemoveEntity(Entity)
		return	
	end
	
	if (self.Config.AirdropSettings.NotifyAirdropStart) then
		self:MessageToAll(self.Config.Messages.PlaneLaunched)
	end	
	
	CanDrop = false
end

function PLUGIN:CheckSupplyLanded(SupplyDrop)
	if (SupplyDrop) then
		local ParachuteField = global.SupplyDrop._type:GetField("parachute", rust.PrivateBindingFlag()) 
		
		if (ParachuteField) then
			local Parachute = ParachuteField:GetValue(SupplyDrop)
			
			if (Parachute) then
				timer.Once(1, function() self:CheckSupplyLanded(SupplyDrop) end)
			else
				if (self.Config.AirdropSettings.SupplyStayTime > 0) then
					timer.Once(self.Config.AirdropSettings.SupplyStayTime * 60, function() self:RemoveEntity(SupplyDrop) end)
				end
				
				if (self.Config.AirdropSettings.NotifySupplyLanded) then
					local Message
					local x = string.format("%.2f", SupplyDrop.transform.position.x)
					local y = string.format("%.2f", SupplyDrop.transform.position.y)
					local z = string.format("%.2f", SupplyDrop.transform.position.z)
					
					Message = self:FormatString(self.Config.Messages.SupplyLanded, "{x}", x)
					Message = self:FormatString(Message, "{y}", y)
					Message = self:FormatString(Message, "{z}", z)

					self:MessageToAll(Message)
				end

				if (self.Config.AirdropSettings.ArrowEnabled) then
					local StartPos = new(UnityEngine.Vector3._type, nil)
					StartPos.x = SupplyDrop.transform.position.x
					StartPos.y = SupplyDrop.transform.position.y + 5 + self.Config.AirdropSettings.ArrowLength
					StartPos.z = SupplyDrop.transform.position.z
					
					local EndPos = new(UnityEngine.Vector3._type, nil)
					EndPos.x = SupplyDrop.transform.position.x
					EndPos.y = SupplyDrop.transform.position.y + 5
					EndPos.z = SupplyDrop.transform.position.z
	
					local ArrowParams = util.TableToArray({ self.Config.AirdropSettings.ArrowTime, System.ConsoleColor.White, StartPos, EndPos, self.Config.AirdropSettings.ArrowSize })
					global.ConsoleSystem.Broadcast("ddraw.arrow", ArrowParams)
				end				
			end
		end
	end
end

function PLUGIN:RemoveEntity(Entity)
	if (Entity) then
		if (Looting.Container) then
			for i, Loot in pairs(Looting.Container) do
				if (Loot[1] == Entity) then
					Looting.Container[i] = {}
				end
			end
		end
	
		Entity:KillMessage()
	end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.PluginSettings =
	{
        Title = "Airdrop Settings",
        Version = "1.0.0"
    }

	self.Config.AirdropSettings =
	{
		MinimumPlayers = 3,
		DropFrequency = 60,
		SupplyStayTime = 60,
		ManualRunDrop = true,
		CustomSupplyLoot = true,
		NotifyAirdropStart = true,
		NotifySupplyLanded = true,
		ArrowEnabled = true,
		ArrowLength = 15,
		ArrowSize = 4,
		ArrowTime = 60
	}
	
	self.Config.Messages =
	{
		DontHaveAccess = "You don't have access!",
		LootReset = "Custom loot successfully reset to the default settings.",
		MinNumberExplain = "Specify the minimum number of players. Example: /airdrop_min 3",
		MinNumberChanged = "Minimum number of players successfully changed to {number}.",
		SupplyRemoveExplain = "Time in minutes after which the supply is removed. Example: /airdrop_stay 30",
		SupplyRemoveChanged = "Time after which the supply is removed changed to {number}.",
		DropFrequencyExplain = "Specify the frequency drop supplies in minutes. Example: /airdrop_freq 60",
		DropFrequencyChanged = "Frequency drop supplies successfully changed to {number}.",
		PlaneSpawned = "Cargo Plane has spawned.",
		PlaneRemovedMin = "Cargo Plane has removed. Minimum number of players: {number}.",
		PlaneRemovedTrigger = "Cargo Plane has removed. The event was triggered not by timer.",
		PlaneLaunched = "Cargo Plane has launched!",
		SupplyLanded = "Supply has landed at coordinates X: {x} Y: {y} Z: {z}"
	}
end

function PLUGIN:CheckConfig() 
    if self.Config.PluginSettings.Version ~= "1.0.0" then
        self:UpdateConfig()
    end
end

function PLUGIN:UpdateConfig()
    self:LoadDefaultConfig()
    self:SaveConfig()
end

function PLUGIN:Unload()
	if (Timer) then
		Timer:Destroy()
	end
end

function PLUGIN:CreateDefaultLoot()	
	AirdropLoot.Settings =
	{
		Capacity = 24,
		FillCount = true
	}
	
	AirdropLoot.Count = 
	{
		Blueprint = 2,
		Weapon = 2,
		Item = 1,
		Outerwear = 1,
		Underwear = 1,
		Gloves = 1,
		Boots = 1,
		Helmet = 1,
		Tool = 2,
		Medical = 3,
		Food = 3,
		Ammo = 2,
		Resource = 4
	}
	
	AirdropLoot.Blueprint =
	{
		{
			["name"] = "bow_hunting",
			["chance"] = 80
		},
		{
			["name"] = "knife_bone",
			["chance"] = 0
		},
		{
			["name"] = "pistol_eoka",
			["chance"] = 70
		},
		{
			["name"] = "pistol_revolver",
			["chance"] = 60
		},
		{
			["name"] = "rifle_ak",
			["chance"] = 20
		},
		{
			["name"] = "rifle_bolt",
			["chance"] = 30
		},
		{
			["name"] = "shotgun_waterpipe",
			["chance"] = 40
		},
		{
			["name"] = "smg_thompson",
			["chance"] = 40
		},
		{
			["name"] = "spear_stone",
			["chance"] = 80
		},
		{
			["name"] = "spear_wooden",
			["chance"] = 0
		},
		{
			["name"] = "building_planner",
			["chance"] = 0
		},
		{
			["name"] = "cupboard.tool",
			["chance"] = 0
		},
		{
			["name"] = "lock.code",
			["chance"] = 50
		},
		{
			["name"] = "lock.key",
			["chance"] = 0
		},
		{
			["name"] = "box_wooden",
			["chance"] = 0
		},
		{
			["name"] = "box_wooden_large",
			["chance"] = 70
		},
		{
			["name"] = "campfire",
			["chance"] = 0
		},
		{
			["name"] = "furnace",
			["chance"] = 0
		},
		{
			["name"] = "lantern",
			["chance"] = 80
		},
		{
			["name"] = "sleepingbag",
			["chance"] = 0
		},
		{
			["name"] = "gunpowder",
			["chance"] = 50
		},
		{
			["name"] = "lowgradefuel",
			["chance"] = 0
		},
		{
			["name"] = "paper",
			["chance"] = 0
		},
		{
			["name"] = "bucket_helmet",
			["chance"] = 40
		},
		{
			["name"] = "burlap_gloves",
			["chance"] = 50
		},
		{
			["name"] = "burlap_shirt",
			["chance"] = 0
		},
		{
			["name"] = "burlap_shoes",
			["chance"] = 0
		},
		{
			["name"] = "burlap_trousers",
			["chance"] = 0
		},
		{
			["name"] = "coffeecan_helmet",
			["chance"] = 40
		},
		{
			["name"] = "hazmat_boots",
			["chance"] = 50
		},
		{
			["name"] = "hazmat_gloves",
			["chance"] = 50
		},
		{
			["name"] = "hazmat_helmet",
			["chance"] = 40
		},
		{
			["name"] = "hazmat_jacket",
			["chance"] = 40
		},
		{
			["name"] = "hazmat_pants",
			["chance"] = 40
		},
		{
			["name"] = "jacket_snow",
			["chance"] = 30
		},
		{
			["name"] = "jacket_snow2",
			["chance"] = 30
		},
		{
			["name"] = "jacket_snow3",
			["chance"] = 30
		},
		{
			["name"] = "metal_facemask",
			["chance"] = 30
		},
		{
			["name"] = "metal_plate_torso",
			["chance"] = 20
		},
		{
			["name"] = "urban_boots",
			["chance"] = 0
		},
		{
			["name"] = "urban_jacket",
			["chance"] = 50
		},
		{
			["name"] = "urban_pants",
			["chance"] = 0
		},
		{
			["name"] = "urban_shirt",
			["chance"] = 50
		},
		{
			["name"] = "vagabond_jacket",
			["chance"] = 30
		},
		{
			["name"] = "axe_salvaged",
			["chance"] = 30
		},
		{
			["name"] = "hammer",
			["chance"] = 0
		},
		{
			["name"] = "hammer_salvaged",
			["chance"] = 30
		},
		{
			["name"] = "hatchet",
			["chance"] = 60
		},
		{
			["name"] = "icepick_salvaged",
			["chance"] = 30
		},
		{
			["name"] = "pickaxe",
			["chance"] = 50
		},
		{
			["name"] = "stonehatchet",
			["chance"] = 0
		},
		{
			["name"] = "torch",
			["chance"] = 0
		},
		{
			["name"] = "bandage",
			["chance"] = 0
		},
		{
			["name"] = "largemedkit",
			["chance"] = 30
		},
		{
			["name"] = "syringe_medical",
			["chance"] = 40
		},
		{
			["name"] = "ammo_pistol",
			["chance"] = 40
		},
		{
			["name"] = "ammo_rifle",
			["chance"] = 20
		},
		{
			["name"] = "ammo_shotgun",
			["chance"] = 30
		},
		{
			["name"] = "arrow_wooden",
			["chance"] = 80
		},
		{
			["name"] = "trap_bear",
			["chance"] = 70
		},
		{
			["name"] = "door_key",
			["chance"] = 70
		},
		{
			["name"] = "longsleeve_tshirt_blue",
			["chance"] = 40
		},
		{
			["name"] = "explosives",
			["chance"] = 30
		},
		{
			["name"] = "explosive.timed",
			["chance"] = 10
		},
		{
			["name"] = "shotgun_pump",
			["chance"] = 40
		}
	}
	
	AirdropLoot.Weapon =
	{
		{
			["name"] = "bow_hunting",
			["chance"] = 90
		},
		{
			["name"] = "knife_bone",
			["chance"] = 80
		},
		{
			["name"] = "pistol_eoka",
			["chance"] = 70
		},
		{
			["name"] = "pistol_revolver",
			["chance"] = 60
		},
		{
			["name"] = "rifle_ak",
			["chance"] = 30
		},
		{
			["name"] = "rifle_bolt",
			["chance"] = 50
		},
		{
			["name"] = "shotgun_waterpipe",
			["chance"] = 60
		},
		{
			["name"] = "smg_thompson",
			["chance"] = 50
		},
		{
			["name"] = "spear_stone",
			["chance"] = 80
		},
		{
			["name"] = "spear_wooden",
			["chance"] = 80
		},
		{
			["name"] = "trap_bear",
			["chance"] = 90
		},
		{
			["name"] = "explosive.timed",
			["chance"] = 30
		},
		{
			["name"] = "shotgun_pump",
			["chance"] = 50
		}
	}
	
	AirdropLoot.Item =
	{
		{
			["name"] = "bed",
			["chance"] = 0
		},
		{
			["name"] = "box_wooden",
			["chance"] = 90
		},
		{
			["name"] = "box_wooden_large",
			["chance"] = 80
		},
		{
			["name"] = "campfire",
			["chance"] = 0
		},
		{
			["name"] = "furnace",
			["chance"] = 50
		},
		{
			["name"] = "lantern",
			["chance"] = 60
		},
		{
			["name"] = "sleepingbag",
			["chance"] = 0
		},
		{
			["name"] = "flare",
			["chance"] = 0
		}
	}
	
	AirdropLoot.Outerwear =
	{
		{
			["name"] = "burlap_shirt",
			["chance"] = 80
		},
		{
			["name"] = "hazmat_jacket",
			["chance"] = 70
		},
		{
			["name"] = "jacket_snow",
			["chance"] = 60
		},
		{
			["name"] = "jacket_snow2",
			["chance"] = 60
		},
		{
			["name"] = "jacket_snow3",
			["chance"] = 60
		},
		{
			["name"] = "urban_jacket",
			["chance"] = 80
		},
		{
			["name"] = "urban_shirt",
			["chance"] = 80
		},
		{
			["name"] = "vagabond_jacket",
			["chance"] = 40
		},
		{
			["name"] = "metal_plate_torso",
			["chance"] = 40
		},
		{
			["name"] = "longsleeve_tshirt_blue",
			["chance"] = 30
		}
	}
	
	AirdropLoot.Underwear =
	{
		{
			["name"] = "burlap_trousers",
			["chance"] = 80
		},
		{
			["name"] = "hazmat_pants",
			["chance"] = 60
		},
		{
			["name"] = "urban_pants",
			["chance"] = 80
		}
	}
	
	AirdropLoot.Gloves =
	{
		{
			["name"] = "burlap_gloves",
			["chance"] = 70
		},
		{
			["name"] = "hazmat_gloves",
			["chance"] = 60
		}
	}
	
	AirdropLoot.Boots =
	{
		{
			["name"] = "burlap_shoes",
			["chance"] = 80
		},
		{
			["name"] = "hazmat_boots",
			["chance"] = 60
		},
		{
			["name"] = "urban_boots",
			["chance"] = 80
		}
	}
	
	AirdropLoot.Helmet =
	{
		{
			["name"] = "bucket_helmet",
			["chance"] = 70
		},
		{
			["name"] = "coffeecan_helmet",
			["chance"] = 60
		},
		{
			["name"] = "hazmat_helmet",
			["chance"] = 60
		},
		{
			["name"] = "metal_facemask",
			["chance"] = 50
		}
	}
	
	AirdropLoot.Tool =
	{
		{
			["name"] = "axe_salvaged",
			["chance"] = 40
		},
		{
			["name"] = "hammer",
			["chance"] = 80
		},
		{
			["name"] = "hammer_salvaged",
			["chance"] = 40
		},
		{
			["name"] = "hatchet",
			["chance"] = 80
		},
		{
			["name"] = "icepick_salvaged",
			["chance"] = 40
		},
		{
			["name"] = "pickaxe",
			["chance"] = 50
		},
		{
			["name"] = "rock",
			["chance"] = 0
		},
		{
			["name"] = "stonehatchet",
			["chance"] = 90
		},
		{
			["name"] = "torch",
			["chance"] = 0
		}
	}
	
	AirdropLoot.Medical =
	{
		{
			["name"] = "antiradpills",
			["chance"] = 70
		},
		{
			["name"] = "bandage",
			["chance"] = 90
		},
		{
			["name"] = "blood",
			["chance"] = 60
		},
		{
			["name"] = "largemedkit",
			["chance"] = 40
		},
		{
			["name"] = "syringe_medical",
			["chance"] = 60
		}
	}
	
	AirdropLoot.Food =
	{
		{
			["name"] = "apple",
			["chance"] = 90
		},
		{
			["name"] = "apple_spoiled",
			["chance"] = 0
		},
		{
			["name"] = "bearmeat",
			["chance"] = 0
		},
		{
			["name"] = "black",
			["chance"] = 0
		},
		{
			["name"] = "blueberries",
			["chance"] = 80
		},
		{
			["name"] = "can_beans",
			["chance"] = 70
		},
		{
			["name"] = "can_tuna",
			["chance"] = 70
		},
		{
			["name"] = "chicken_burned",
			["chance"] = 0
		},
		{
			["name"] = "chicken_cooked",
			["chance"] = 0
		},
		{
			["name"] = "chicken_raw",
			["chance"] = 0
		},
		{
			["name"] = "chicken_spoiled",
			["chance"] = 0
		},
		{
			["name"] = "chocholate",
			["chance"] = 70
		},
		{
			["name"] = "granolabar",
			["chance"] = 60
		},
		{
			["name"] = "humanmeat_burned",
			["chance"] = 0
		},
		{
			["name"] = "humanmeat_cooked",
			["chance"] = 0
		},
		{
			["name"] = "humanmeat_raw",
			["chance"] = 0
		},
		{
			["name"] = "humanmeat_spoiled",
			["chance"] = 0
		},
		{
			["name"] = "smallwaterbottle",
			["chance"] = 50
		},
		{
			["name"] = "wolfmeat_burned",
			["chance"] = 0
		},
		{
			["name"] = "wolfmeat_cooked",
			["chance"] = 0
		},
		{
			["name"] = "wolfmeat_raw",
			["chance"] = 0
		},
		{
			["name"] = "wolfmeat_spoiled",
			["chance"] = 0
		},
		{
			["name"] = "black raspberries",
			["chance"] = 50
		}
	}
	
	AirdropLoot.Ammo =
	{
		{
			["name"] = "ammo_pistol",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 60
		},
		{
			["name"] = "ammo_rifle",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 50
		},
		{
			["name"] = "ammo_shotgun",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 70
		},
		{
			["name"] = "arrow_wooden",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 90
		}
	}
	
	AirdropLoot.Resource =
	{
		{
			["name"] = "battery_small",
			["chance"] = 0
		},
		{
			["name"] = "bone_fragments",
			["min_amount"] = 100,
			["max_amount"] = 200,
			["chance"] = 80
		},
		{
			["name"] = "charcoal",
			["min_amount"] = 200,
			["max_amount"] = 800,
			["chance"] = 70
		},
		{
			["name"] = "cloth",
			["min_amount"] = 100,
			["max_amount"] = 200,
			["chance"] = 50
		},
		{
			["name"] = "fat_animal",
			["min_amount"] = 100,
			["max_amount"] = 200,
			["chance"] = 50
		},
		{
			["name"] = "gunpowder",
			["min_amount"] = 100,
			["max_amount"] = 300,
			["chance"] = 50
		},
		{
			["name"] = "lowgradefuel",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 50
		},
		{
			["name"] = "metal_fragments",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 40
		},
		{
			["name"] = "metal_ore",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 60
		},
		{
			["name"] = "metal_refined",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 60
		},
		{
			["name"] = "paper",
			["chance"] = 80
		},
		{
			["name"] = "skull_human",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 80
		},
		{
			["name"] = "skull_wolf",
			["min_amount"] = 50,
			["max_amount"] = 100,
			["chance"] = 80
		},
		{
			["name"] = "stones",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 90
		},
		{
			["name"] = "sulfur",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 70
		},
		{
			["name"] = "sulfur_ore",
			["min_amount"] = 500,
			["max_amount"] = 1000,
			["chance"] = 70
		},
		{
			["name"] = "wood",
			["min_amount"] = 1000,
			["max_amount"] = 5000,
			["chance"] = 90
		},
		{
			["name"] = "explosives",
			["min_amount"] = 10,
			["max_amount"] = 100,
			["chance"] = 30
		}
	}
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\analytics.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Analytics"
PLUGIN.Version = V(0, 2, 1)
PLUGIN.Description = "Real-time collection and reporting of player locations on connect to Google Analytics."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/679/"
PLUGIN.ResourceId = 679
PLUGIN.HasConfig = true

local debug = false

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:OnPlayerConnected(packet)
    if not packet then return end
    if not packet.connection then return end
    self:CollectAnalytics(packet.connection, "start")
end

function PLUGIN:OnPlayerDisconnected(player)
    if not player then return end
    if not player.net.connection then return end
    self:CollectAnalytics(player.net.connection, "end")
end

function PLUGIN:CollectAnalytics(connection, session)
    local url = "https://ssl.google-analytics.com/collect?v=1"
    local data = "&tid=" .. self.Config.TrackingID
    .. "&sc=" .. session
    .. "&cid=" .. rust.UserIDFromConnection(connection)
    .. "&uip=" .. connection.ipaddress:match("([^:]*):")
    .. "&ua=" .. Oxide.Core.OxideMod.Version:ToString()
    .. "&dp=" .. global.server.hostname
    .. "&t=pageview"
    webrequests.EnqueueGet(url .. data, function(code, response)
        if debug then
            print("[" .. self.Title .. "] Request URL: " .. url)
            print("[" .. self.Title .. "] Request data: " .. data)
            print("[" .. self.Title .. "] Response: " .. response)
            print("[" .. self.Title .. "] HTTP code: " .. code)
        end
    end, self.Plugin)
end

function PLUGIN:LoadDefaultConfig()
    self.Config.TrackingID = self.Config.TrackingID or "UA-XXXXXXXX-Y"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\Anti-Dupe.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Anti-Dupe"
PLUGIN.Title = "Anti-Dupe"
PLUGIN.Description = "Anti Item Stack Duping"
PLUGIN.Version = V(1, 0, 2)
PLUGIN.Author = "SPooCK"
PLUGIN.HasConfig = true

function PLUGIN:Init()	
	self.Dupe = {}
	self.DupeTimer = {}
end

function PLUGIN:OnItemAddedToContainer(container, item)
if (not container or not container.playerOwner) then return end
local player = container.playerOwner
local PlyID = rust.UserIDFromPlayer(player)
local name, amm = item.info.shortname, item.amount
if (amm < 2) then return end
if (self.DupeTimer[PlyID]) then self.DupeTimer[PlyID]:Destroy() self.DupeTimer[PlyID] = nil end
	self.Dupe[PlyID] = {} self.Dupe[PlyID].iname = {} self.Dupe[PlyID].iamm = {}
	self.Dupe[PlyID].iname = name self.Dupe[PlyID].iamm = amm
	self.DupeTimer[PlyID] = timer.Once(1.5, function() self.Dupe[PlyID] = nil end)
end

function PLUGIN:OnItemRemovedFromContainer(container, item)
if (not container or not container.playerOwner) then return end
local player = container.playerOwner
local PlyID = rust.UserIDFromPlayer(player)
local name, amm = item.info.shortname, item.amount
if (amm < 2) then return end
local ilist = container.itemList:GetEnumerator()
	while ilist:MoveNext() do
	local ilname = ilist.Current.info.shortname
	local ilamm1 = ilist.Current.amount local ilamm2 = ilist.Current.amount-1
		if (ilist.Current ~= item and self.Dupe[PlyID] and self.Dupe[PlyID].iname == ilname) then
			if (self.Dupe[PlyID].iamm == amm) then
				if (ilamm1 == amm or ilamm2 == amm) then
				item:Remove(0)
				rust.BroadcastChat("Anti-Dupe", player.displayName.. " is trying to DUPE " ..item.info.displayname)
				break
				end
			end
		end
	end
end

function PLUGIN:OnPlayerSpawn(player)
local PlyID = rust.UserIDFromPlayer(player)
if (self.Dupe[PlyID]) then self.Dupe[PlyID] = nil end
if (self.DupeTimer[PlyID]) then self.DupeTimer[PlyID]:Destroy() self.DupeTimer[PlyID] = nil end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\AntiBlockJumpStack.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


PLUGIN.Title       = "AntiBlockJumpStack"
PLUGIN.Description = "Stop players from building while jumping and placing objects on their own location."
PLUGIN.Version     = V( 1, 1, 3 )
PLUGIN.HasConfig   = false
PLUGIN.Author      = "Mughisi"

local BasePlayerModelState = global.BasePlayer._type:GetField("modelState", rust.PrivateBindingFlag())

function PLUGIN:OnEntityBuilt(planner, gameObject)
	if not planner then return end
	local player = planner.ownerPlayer
	local buildingBlock = gameObject:GetComponent("BuildingBlock")
	local position = player.transform.position
	local buildingCost = nil

	if player.net.connection.authLevel > 0 then return end

	if buildingBlock then
		local modelState = BasePlayerModelState:GetValue(player)
		if not modelState.onground then
			self:SendMessage(player, "You aren't allowed to build while jumping or falling.")
			if buildingCost then
				local it = buildingCost:GetEnumerator()
				while it:MoveNext() do
					player.inventory:GiveItem(it.Current.itemid, it.Current.amount, true)
				end
			end
			buildingBlock:KillMessage()
			return
		end
		
		local playerCollider = player.gameObject:GetComponentInChildren( UnityEngine.Collider._type )
		local blockCollider = buildingBlock.gameObject:GetComponentInChildren( UnityEngine.Collider._type )
		if playerCollider and blockCollider then
			local blockBounds = blockCollider.bounds
			local playerBounds = playerCollider.bounds

			if playerBounds:Intersects(blockBounds) then
				self:SendMessage(player, "You aren't allowed to build this close to yourself, take a step back.")
				if buildingCost then
					local it = buildingCost:GetEnumerator()
					while it:MoveNext() do
						player.inventory:GiveItem(it.Current.itemid, it.Current.amount, true)
					end
				end
				buildingBlock:KillMessage()
				return
			end
		end
	end
end

function PLUGIN:SendMessage( target, message )
    if not target then return end
    if not target:IsConnected() then return end

    message = UnityEngine.StringExtensions.QuoteSafe( message )

    target:SendConsoleCommand( "chat.add \"0\""  .. message );
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\arena.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Arena"
PLUGIN.Version = V(1, 1, 3)
PLUGIN.Description = "Arena converted from Oxide 1"
PLUGIN.Author = "Reneb - Oxide 1 version by eDeloa"
PLUGIN.HasConfig = true

local DataFile = "arena"
local Data = {}
local MessageClient   = UnityEngine.NetworkNetworkable._type:GetMethod( "MessageClient")

function PLUGIN:Init()
  arena_loaded = false
  self:LoadDataFile()
  
  self.ArenaData = {}
  self.ArenaData.Games = {}
  self.ArenaData.CurrentGame = nil
  self.ArenaData.SavedInventories = {}
  self.ArenaData.Users = {}
  self.ArenaData.UserCount = 0
  self.ArenaData.IsOpen = false
  self.ArenaData.HasStarted = false
  self.ArenaData.HasEnded = false
  self.ArenaData.AutoArena = false
  self.ArenaTimers = {}
  command.AddChatCommand( "arena", self.Plugin, "cmdArena")
end

function PLUGIN:OnServerInitialized()
	spawns_plugin = plugins.Find("spawns")

    
    if(not spawns_plugin) then
   	 print("You must have the Spawns Database @ http://forum.rustoxide.com/plugins/spawns-database.720/")
   	 return false
   	end
   	arena_loaded = true
   	
   	command.AddChatCommand( "arena_game", self.Plugin, "cmdArenaGame")
	command.AddChatCommand( "arena_open", self.Plugin, "cmdArenaOpen")
	command.AddChatCommand( "arena_close", self.Plugin, "cmdArenaClose")
	command.AddChatCommand( "arena_start", self.Plugin, "cmdArenaStart")
	command.AddChatCommand( "arena_end", self.Plugin, "cmdArenaEnd")
	command.AddChatCommand( "arena_spawnfile", self.Plugin, "cmdArenaSpawnFile")

	command.AddChatCommand( "arena_list", self.Plugin, "cmdArenaList")
	command.AddChatCommand( "arena_join", self.Plugin, "cmdArenaJoin")
	command.AddChatCommand( "arena_leave", self.Plugin, "cmdArenaLeave")
	
	command.AddChatCommand( "arena_launch", self.Plugin, "cmdArenaLaunch")
	command.AddChatCommand( "arena_stop", self.Plugin, "cmdArenaStop")
	
	command.AddChatCommand( "arena_reward", self.Plugin, "cmdArenaReward")
	command.AddChatCommand( "arena_givereward", self.Plugin, "cmdArenaGiveReward")
	
	timer.Once(0.1, function()
		if(self.Config.Default.SpawnFileName  ~= "") then	
			self:LoadArenaSpawnFile(self.Config.Default.SpawnFileName)
		end
		if(self.Config.Default.GameName ~= "") then	
			for i=1, #self.ArenaData.Games do
				if(self.ArenaData.Games[i].GameName == self.Config.Default.GameName) then
					success, err = self:SelectArenaGame(i)
					if(not success) then
						print(tostring(err))
					end
					break
				end
			end
		end
	end)
end

-- *******************************************
-- PLUGIN:Unload()
-- Called when the plugin is reloaded
-- *******************************************
function PLUGIN:Unload()
	self:resetTimers()
end

function PLUGIN:resetTimers()
	for k,v in pairs (self.ArenaTimers) do
		self.ArenaTimers[k]:Destroy()
	end
end

-- *******************************************
-- PLUGIN:LoadDataFile()
-- Load data files from oxide/data/DATAFILE.json
-- *******************************************
function PLUGIN:LoadDataFile()
    local data = datafile.GetDataTable(DataFile)
    Data = data or {}
    Data.Rewards = Data.Rewards or {}
end
function PLUGIN:SaveData()
    datafile.SaveDataTable(DataFile)
end

-- *******************************************
-- CHAT COMMANDS
-- *******************************************

function PLUGIN:cmdArena(player, cmd, args)
	if(not arena_loaded) then
		rust.SendChatMessage(player, self.Config.ChatName, "The Arena plugin was not successfully loaded, you probably forgot the Spawns Plugin")
		return
	end
	if(self.ArenaData.HasStarted) then
		if(self.ArenaData.IsOpen) then
			rust.SendChatMessage(player, self.Config.ChatName, "The Arena has already started but may still join. (/arena_join)" )
			rust.SendChatMessage(player, self.Config.ChatName, "Players ingame: " .. self.ArenaData.UserCount )
		else
			rust.SendChatMessage(player, self.Config.ChatName, "The Arena has already started and you may not join anymore." )
			rust.SendChatMessage(player, self.Config.ChatName, "Players ingame: " .. self.ArenaData.UserCount )
		end
		return
	else
		if(self.ArenaData.IsOpen) then
			rust.SendChatMessage(player, self.Config.ChatName, "The Arena is Opened, say /arena_join to join" )
			rust.SendChatMessage(player, self.Config.ChatName, "Currently " .. self.ArenaData.UserCount .. " players listed")
			return
		else
			if(self.ArenaData.AutoArena and self.ArenaTimers["NextArena"]) then
				rust.SendChatMessage(player, self.Config.ChatName, "Next Arena is in: " .. self.ArenaTimers["NextArena"].Delay)
			else
				rust.SendChatMessage(player, self.Config.ChatName, "There is no Arenas at the moment" )
			end
			return
		end
	end
	return
end

function PLUGIN:cmdArenaList(player, cmd, args)
	rust.SendChatMessage(player, self.Config.ChatName, "Game#         Arena Game")
	rust.SendChatMessage(player, self.Config.ChatName, "---------------------------")
	for i = 1, #self.ArenaData.Games do
		rust.SendChatMessage(player, self.Config.ChatName, "#" .. i .. "                  " .. self.ArenaData.Games[i].GameName)
	end
end

function PLUGIN:cmdArenaGame(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	if (args.Length == 0) then
		rust.SendChatMessage(player, self.Config.ChatName, "Syntax: /arena_game {gameID}")
		return
	end
	if (tonumber(args[0])==nil) then
		rust.SendChatMessage(player, self.Config.ChatName, "Syntax: /arena_game {gameID}")
		return
	end

	local success, err = self:SelectArenaGame(tonumber(args[0]))
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
	rust.SendChatMessage(player, self.Config.ChatName, self.ArenaData.Games[self.ArenaData.CurrentGame].GameName .. " is now the next Arena game.")
end

function PLUGIN:cmdArenaOpen(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	local success, err = self:OpenArena()
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
end

function PLUGIN:cmdArenaClose(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	local success, err = self:CloseArena()
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
end

function PLUGIN:cmdArenaStart(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	local success, err = self:StartArena()
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
end

function PLUGIN:cmdArenaEnd(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	local success, err = self:EndArena()
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
end

function PLUGIN:cmdArenaSpawnFile(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	if (args.Length == 0) then
		rust.SendChatMessage(player, self.Config.ChatName, "Syntax: /arena_spawnfile {filename}")
		return
	end

	local success, err = self:LoadArenaSpawnFile(args[0])
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end

	rust.SendChatMessage(player, self.Config.ChatName, "Successfully loaded the spawn file.")
end

function PLUGIN:cmdArenaJoin(player, cmd, args)
	local success, err = self:JoinArena(player)
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end

	rust.SendChatMessage(player, self.Config.ChatName, "Successfully joined the Arena.")
end

function PLUGIN:cmdArenaLeave(player, cmd, args)
	local success, err = self:LeaveArena(player)
	if (not success) then
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end

	rust.SendChatMessage(player, self.Config.ChatName, "Successfully left the Arena.")
end
function PLUGIN:cmdArenaLaunch(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	if (not self.ArenaData.CurrentGame) then
		rust.SendChatMessage(player, self.Config.ChatName, "An Arena game must first be chosen.")
		return
	end
	allowed = true
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"MinimumPlayers"})) == nil) then allowed = false end
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"MaximumPlayers"})) == nil) then allowed = false end
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"CancelArenaTime"})) == nil) then allowed = false end
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"WaitToStartTime"})) == nil) then allowed = false end
	if(tostring(self:pluginsCall("AutoArenaConfig",{"CloseOnStart"})) == "nil") then allowed = false end
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"ArenasInterval"})) == nil) then allowed = false end
	if(tonumber(self:pluginsCall("AutoArenaConfig",{"ArenaLimitTime"})) == nil) then allowed = false end
	if(not allowed) then
		rust.SendChatMessage(player, self.Config.ChatName, "The Mod that you tried to start was not properly made as an Auto Arena, configs are missing.")
		return
	end
	self.ArenaData.AutoArena = true
	success, err = self:OpenArena()
	if (not success) then
		self.ArenaData.AutoArena = false
		rust.SendChatMessage(player, self.Config.ChatName, err)
		return
	end
	rust.SendChatMessage(player, self.Config.ChatName, "The Arena was successfully launched, and will work on its own.")
end
function PLUGIN:cmdArenaStop(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
		rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
		return
	end
	if(not self.ArenaData.AutoArena) then
		rust.SendChatMessage(player, self.Config.ChatName, "The AutoArena wasn't launched.")
		return
	end
	self.ArenaData.AutoArena = false
	self:resetTimers()
	rust.SendChatMessage(player, self.Config.ChatName, "The AutoArena was deactivated.")
end
function PLUGIN:cmdArenaReward(player,cmd,args)
	cuserid = rust.UserIDFromPlayer(player)
	if(not Data.Rewards[cuserid]) then 
		rust.SendChatMessage(player, self.Config.ChatName, "You have 0 rewards waiting")
		return
	end
	count = 0
	for i=1, #Data.Rewards[cuserid] do
		count = count + 1
	end
	rust.SendChatMessage(player, self.Config.ChatName, "You have " .. count .. " rewards waiting")
	todel = {}
	for i=1, #Data.Rewards[cuserid] do
		if(self:pluginsCall("isRewardRandom",{ Data.Rewards[cuserid][i] })) then
			self:pluginsCall("giveRandomReward",{ player, Data.Rewards[cuserid][i] })
			table.insert(todel,i)
			rust.SendChatMessage(player, self.Config.ChatName, "You've received a random reward from the \"" .. Data.Rewards[cuserid][i] .. "\" game.")
		else
			if(args.Length == 0) then
				rust.SendChatMessage(player, self.Config.ChatName, Data.Rewards[cuserid][i] .. ": Choose a Reward between: " .. tostring(self:pluginsCall("OnRewardGetList",{ Data.Rewards[cuserid][i] })))
			else
				trygiveReward = self:pluginsCall("giveSpecificReward",{ player, Data.Rewards[cuserid][i], args[0] })
				if(trygiveReward == "true") then
					rust.SendChatMessage(player, self.Config.ChatName, "You've received your reward from the \"" .. Data.Rewards[cuserid][i] .. "\" game.")
					table.insert(todel,i)
					break
				end
			end
		end
	end
	for o = #todel,1, -1 do
		table.remove(Data.Rewards[cuserid],todel[o])
	end
	self:SaveData()
end
function PLUGIN:cmdArenaGiveReward(player,cmd,args)
  if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
  	rust.SendChatMessage(player, self.Config.ChatName, "You are not allowed to use this command")
  	return
  end
  if(args.Length == 0) then
  	rust.SendChatMessage(player, self.Config.ChatName, "/arena_givereward \"PLAYER\" \"ARENAGAME\"")
  	return
  end
  if(args.Length == 1) then
	rust.SendChatMessage(player, self.Config.ChatName, "/arena_givereward \"PLAYER\" \"ARENAGAME\"")
	for i = 1, #self.ArenaData.Games do
      rust.SendChatMessage(player, self.Config.ChatName, "/arena_givereward \"PLAYER\" \"" .. self.ArenaData.Games[i].GameName .. "\"")
  	end
	return
  end
  targetPlayer, err = self:FindPlayer(args[0])
  if(not targetPlayer) then rust.SendChatMessage(player,self.Config.ChatName,err) return end
  targetGame = false
  for i = 1, #self.ArenaData.Games do
  	if(self.ArenaData.Games[i].GameName == args[1]) then
  	  targetGame = true
  	  break
  	end
  end
  if(not targetGame) then rust.SendChatMessage(player,self.Config.ChatName,"This GameName doesn't exist") return end
  self:GiveReward(targetPlayer,args[1])
  rust.SendChatMessage(player,self.Config.ChatName,"Reward from " .. args[1] .. " was successfully given to " .. targetPlayer.displayName)
end

-- *******************************************
-- API COMMANDS
-- *******************************************
function PLUGIN:RegisterArenaGame(gamename)
  table.insert(self.ArenaData.Games, {GameName = gamename})
  return #(self.ArenaData.Games)
end

-- *******************************************
-- HOOK FUNCTIONS
-- *******************************************

function PLUGIN:pluginsCall(hookCall,args)
	local arr = util.TableToArray( args )
	for i,k in pairs(args) do
		util.ConvertAndSetOnArray(arr, i, k, UnityEngine.Object._type)
	end
	return plugins.CallHook(hookCall, arr )
end

function PLUGIN:OnPlayerSpawn( baseplayer )
	if(not arena_loaded) then return end
	if (self.ArenaData.HasStarted and self:IsPlaying(baseplayer)) then
		timer.Once(0.2, function()
			self:TeleportPlayerToArena(baseplayer) 
			self:pluginsCall("OnArenaSpawnPost",{ baseplayer })
		end)
    end
end

function PLUGIN:OnPlayerDisconnected(player,connection)
  if (not arena_loaded) then
    return
  end
  if (self:IsPlaying(player)) then
    player:Die()
    self:LeaveArena(player)
  end
end

function PLUGIN:SendHelpText(player)
  if (not arena_loaded) then
    return
  end
  rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_list to list all Arena games.")
  rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_join to join the Arena when it is open.")
  rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_leave to leave the Arena.")
  if (player:GetComponent("BaseNetworkable").net.connection.authLevel > 0) then
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_spawnfile {filename} to load a spawnfile.")
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_game {gameID} to select an Arena game.")
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_open to open the Arena.")
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_close to close the Arena entrance.")
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_start to start the Arena game.")
    rust.SendChatMessage(player, self.Config.ChatName, "Use /arena_end to end the Arena game.")
  end
end
-- *******************************************
-- MAIN FUNCTIONS
-- *******************************************
function PLUGIN:LoadArenaSpawnFile(filename)
  local spawnsCount, err = spawns_plugin:CallHook("GetSpawnsCount",filename)
  if (not spawnsCount) then
    return false, err
  end

  self.ArenaData.SpawnsFile = filename
  self.ArenaData.SpawnCount = spawnsCount
  return true
end

function PLUGIN:SelectArenaGame(gameid)
  if (gameid < 1 or gameid > #(self.ArenaData.Games)) then
    return false, "Invalid gameID."
  end

  if (self.ArenaData.IsOpen or self.ArenaData.HasStarted) then
    return false, "The Arena needs to be closed and ended before selecting a new game."
  end

  local success = self:pluginsCall("CanSelectArenaGame",{ gameid })
  if (success ~= "true" and success ~= nil) then
    return false, success
  end
  self.ArenaData.CurrentGame = gameid
  self:pluginsCall("OnSelectArenaGamePost",{ gameid })
  return true
end
function PLUGIN:OpenArena()
  if (not self.ArenaData.CurrentGame) then
    return false, "An Arena game must first be chosen."
  elseif (not self.ArenaData.SpawnsFile) then
    return false, "A spawn file must first be loaded."
  elseif (self.ArenaData.IsOpen) then
    return false, "The Arena is already open."
  end
  local success = self:pluginsCall("CanArenaOpen", { } )
  if (success ~= "true" and success ~= nil) then
    return false, success
  end
  self.ArenaData.IsOpen = true
  rust.BroadcastChat(self.Config.ChatName,"The Arena is now open for: " .. self.ArenaData.Games[self.ArenaData.CurrentGame].GameName .. "!  Type /arena_join to join!")
  self:pluginsCall("OnArenaOpenPost", { } )
  
  if(self.ArenaData.AutoArena) then
  	self:resetTimers()
  	self.ArenaTimers["CancelArena"] = timer.Once(tonumber(self:pluginsCall("AutoArenaConfig",{"CancelArenaTime"})), function() self:CloseArena() end)
  end
  return true
end

function PLUGIN:CloseArena()
  if (not self.ArenaData.IsOpen) then
    return false, "The Arena is already closed."
  end

  local success = self:pluginsCall("CanArenaClose", { } )
  if (success ~= "true" and success ~= nil) then
    return false, success
  end

  self.ArenaData.IsOpen = false
  self:pluginsCall("OnArenaClosePost", { } )
  if(self.ArenaData.HasStarted) then
 	 rust.BroadcastChat(self.Config.ChatName,"The Arena entrance is now closed!")
  else
     rust.BroadcastChat(self.Config.ChatName,"The Arena was cancelled!")
     if(self.ArenaData.AutoArena) then
     	self:resetTimers()
     	self.ArenaTimers["NextArena"] = timer.Once(tonumber(self:pluginsCall("AutoArenaConfig",{"ArenasInterval"})), function() self:OpenArena() end)
     	rust.BroadcastChat(self.Config.ChatName,"Next Arena will be in " .. tonumber(self:pluginsCall("AutoArenaConfig",{"ArenasInterval"})) .. " seconds")
     end
  end
  
  return true
end

function PLUGIN:StartArena()
  if (not self.ArenaData.CurrentGame) then
    return false, "An Arena game must first be chosen."
  elseif (not self.ArenaData.SpawnsFile) then
    return false, "A spawn file must first be loaded."
  elseif (self.ArenaData.HasStarted) then
    return false, "An Arena game has already started."
  end

  local success = self:pluginsCall("CanArenaStart", { } )
  if (success ~= "true" and success ~= nil) then
    return false, success
  end
  
  self:pluginsCall("OnArenaStartPre", { } )

  rust.BroadcastChat(self.Config.ChatName,"Arena: " .. self.ArenaData.Games[self.ArenaData.CurrentGame].GameName .. " is about to begin!")
  self.ArenaData.HasStarted = true
  self.ArenaData.HasEnded = false
	
  timer.Once(5, function() self:SaveAllInventories() self:SaveAllHomeLocations() self:TeleportAllPlayersToArena() self:pluginsCall("OnArenaStartPost", { } ) end)
  return true
end

function PLUGIN:EndArena()
  if (self.ArenaData.HasEnded or ((not self.ArenaData.HasStarted) and (not self.ArenaData.IsOpen))) then
    return false, "An Arena game is not underway."
  end

  local success, err = self:pluginsCall("CanArenaEnd", { } )
  if (success ~= "true" and success ~= nil) then
    return false, success
  end

  self.ArenaData.IsOpen = false
  self.ArenaData.HasEnded = true

  self:pluginsCall("OnArenaEndPre", { } )

  local netusers = self:GetAllPlayers()
  for k,player in pairs(netusers) do
    if (self:IsPlaying(player)) then
      self:LeaveArena(player)
    end
  end

  rust.BroadcastChat(self.Config.ChatName,"Arena: " .. self.ArenaData.Games[self.ArenaData.CurrentGame].GameName .. " is now over!")
  self.ArenaData.HasStarted = false
  self:pluginsCall("OnArenaEndPost", { } )
  return true
end

function PLUGIN:JoinArena(player)
  if (not self.ArenaData.IsOpen) then
    return false, "The Arena is currently closed."
  elseif (self:IsPlaying(player)) then
    return false, "You are already in the Arena."
  end

  local success = self:pluginsCall("CanArenaJoin", { player } )
  if (success ~= "true" and success ~= nil) then
    return false, success
  end
  self.ArenaData.Users[rust.UserIDFromPlayer( player )] = {}
  self.ArenaData.Users[rust.UserIDFromPlayer( player )].HasJoined = true
  self.ArenaData.UserCount = self.ArenaData.UserCount + 1

  if (self.ArenaData.HasStarted) then
    self:SaveHomeLocation(player)
    self:SaveInventory(player)
  end
  
  rust.BroadcastChat(self.Config.ChatName,player.displayName .. " has joined the Arena!  (Total Players: " .. self.ArenaData.UserCount .. ")")
  self:pluginsCall("OnArenaJoinPost", { player } )
  return true
end

function PLUGIN:LeaveArena(player)
  if (not self:IsPlaying(player)) then
    return false, "You are not currently in the Arena."
  end

  self.ArenaData.UserCount = self.ArenaData.UserCount - 1

  if (not self.ArenaData.HasEnded) then
    rust.BroadcastChat(self.Config.ChatName,player.displayName .. " has left the Arena!  (Total Players: " .. self.ArenaData.UserCount .. ")")
  end

  if (self.ArenaData.HasStarted) then
  	self:RedeemInventory(player)
    self:TeleportPlayerHome(player)
    self.ArenaData.Users[rust.UserIDFromPlayer( player )] = nil
    self:pluginsCall("OnArenaLeavePost", { player } )
  else
    self.ArenaData.Users[rust.UserIDFromPlayer( player )] = nil
  end

  return true
end

function PLUGIN:CanArenaJoin(player)
	if(self.ArenaData.AutoArena) then
		if(self.ArenaData.UserCount >= tonumber(self:pluginsCall("AutoArenaConfig",{"MaximumPlayers"}))) then
			return "Max players reached"
		end
	end
end
function PLUGIN:OnArenaJoinPost(player)
	if(self.ArenaData.AutoArena) then
		if(self.ArenaData.UserCount >= tonumber(self:pluginsCall("AutoArenaConfig",{"MinimumPlayers"}))) then
			self:resetTimers()
			self.ArenaTimers["StartArena"] = timer.Once(tonumber(self:pluginsCall("AutoArenaConfig",{"WaitToStartTime"})), function()
				success, err = self:StartArena() 
				if(not success) then
					rust.BroadcastChat(self.Config.ChatName,err)
				end
			end)
		end
	end
end
function PLUGIN:OnArenaStartPost()
	if(self.ArenaData.AutoArena) then
		self:resetTimers()
		self.ArenaTimers["EndArena"] = timer.Once(tonumber(self:pluginsCall("AutoArenaConfig",{"ArenaLimitTime"})), function() self:EndArena() end)
	end
end
function PLUGIN:OnArenaEndPost()
	if(self.ArenaData.AutoArena) then
		self:resetTimers()
		self.ArenaTimers["NextArena"] = timer.Once(tonumber(self:pluginsCall("AutoArenaConfig",{"ArenasInterval"})), function() self:OpenArena() end)
	end
end

function PLUGIN:GiveReward(player,cgame)
	cuserid = rust.UserIDFromPlayer(player)
	if(not Data.Rewards[cuserid]) then Data.Rewards[cuserid] = {} end
	table.insert(Data.Rewards[cuserid],cgame)
	rust.SendChatMessage(player,self.Config.ChatName,"You have won a reward, say /arena_reward to get more informations")
end
-- *******************************************
-- HELPER FUNCTIONS
-- *******************************************
function PLUGIN:GetAllPlayers()
    itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    playerList = {}
    while itPlayerList:MoveNext() do
        table.insert(playerList,itPlayerList.Current)
    end
    return playerList
end


function PLUGIN:LoadDefaultConfig()
  -- Set default configuration settings
  self.Config.ChatName = "Arena"
  self.Config.Default = {}
  self.Config.Default.SpawnFileName = ""
  self.Config.Default.GameName = "Deathmatch"
  self.Config.authLevel = 1
  self.Config.AutoArena_Settings = {}
  self.Config.AutoArena_Settings.IntervalTime = 1800
  self.Config.AutoArena_Settings.WaitTimeBeforeStart = 60
  self.Config.AutoArena_Settings.AutoDisable = 300
end

function PLUGIN:IsPlaying(player)
  local userID = rust.UserIDFromPlayer( player )
  return (self.ArenaData.Users[userID] and self.ArenaData.Users[userID].HasJoined)
end

function PLUGIN:SaveAllHomeLocations()
  local netusers =  self:GetAllPlayers()
  for k,player in pairs(netusers) do
    if (self:IsPlaying(player)) then
      self:SaveHomeLocation(player)
    end 
  end
end

function PLUGIN:SaveHomeLocation(player)
  local userID = rust.UserIDFromPlayer( player )
  local homePos = player.transform.position
  self.ArenaData.Users[userID].HomeCoords = {}
  self.ArenaData.Users[userID].HomeCoords.x = homePos.x
  self.ArenaData.Users[userID].HomeCoords.y = homePos.y
  self.ArenaData.Users[userID].HomeCoords.z = homePos.z
end

function PLUGIN:KillAllPlayers()
  local netusers = self:GetAllPlayers()
  for k,player in pairs(netusers) do
    if (self:IsPlaying(player)) then
      self:KillPlayer(player)
    end
  end
end

function PLUGIN:KillPlayer(player)
  player:Die()
end

function PLUGIN:TeleportAllPlayersToArena()
  local netusers = self:GetAllPlayers()
  for k,player in pairs(netusers) do
    if (self:IsPlaying(player)) then
      self:TeleportPlayerToArena(player)
    end
  end
end


local function makeTeleportVectors()
	if (TeleportVectors == nil or (TeleportVectors and #TeleportVectors == 0)) then
		TeleportVectors = {}
        local coordsArray = util.TableToArray( { 0, 0, 0 } )
        local tempValues = { 
            { x = 2000, y = 0, z = 2000 },
            { x = 2000, y = 0, z = -2000 },
            { x = -2000, y = 0, z = -2000 },
            { x = -2000, y = 0, z = 2000 }
        }
        for k, v in pairs( tempValues ) do
        	util.ConvertAndSetOnArray( coordsArray, 0, v.x, System.Single._type )
        	util.ConvertAndSetOnArray( coordsArray, 1, v.y, System.Single._type )
        	util.ConvertAndSetOnArray( coordsArray, 2, v.z, System.Single._type )
            vector3 = new( UnityEngine.Vector3._type, coordsArray )
            table.insert( TeleportVectors, vector3 )
        end
    end
end
function PLUGIN:TeleportPlayerToArena(player)
  if(not newVector3) then newVector3 = new( UnityEngine.Vector3._type , nil ) end
  
  local spawnPoint, err = spawns_plugin:CallHook("GetRandomSpawn", self.ArenaData.SpawnsFile, self.ArenaData.SpawnCount )
  if(not spawnPoint) then rust.BroadcastChat(self.Config.ChatName,err) end
  newVector3.x = spawnPoint.x
  newVector3.y = spawnPoint.y
  newVector3.z = spawnPoint.z
  self:TeleportPlayer(player, newVector3)
end
function PLUGIN:cmdArenatest(player,cmd,args)
	self:loadScreen(player)
end
function PLUGIN:loadScreen(player)
	
	--[[local Data    = new( global.NetworkData._type, nil )
    Data:WriteUInt( global.StringPool.Get.methodarray[1]:Invoke( nil, util.TableToArray( { "startloading" } ) ) )
    Data:WriteUInt64( player.net.connection.ownerid )
    MessageClient:Invoke( nil , util.TableToArray( { player.net, player.net.connection, UnityEngine.MSG.RPC_MESSAGE, Data:ToBytes() } ) )
	]]
	player:SetPlayerFlag( global["BasePlayer+PlayerFlags"].ReceivingSnapshot, true )
	player:UpdateNetworkGroup()
	player:SendFullSnapshot()
end
function PLUGIN:TeleportPlayerHome(player)
	if(not newVector3) then newVector3 = new( UnityEngine.Vector3._type , nil ) end
	
    local userID = rust.UserIDFromPlayer(player)
    if (self.ArenaData.Users[userID] and self.ArenaData.Users[userID].HomeCoords) then
    newVector3.x = self.ArenaData.Users[userID].HomeCoords.x
    newVector3.y = self.ArenaData.Users[userID].HomeCoords.y
    newVector3.z = self.ArenaData.Users[userID].HomeCoords.z
    self:TeleportPlayer(player, newVector3)
    
  end
end

function PLUGIN:TeleportPlayer( player, destination )
	player:StartSleeping()
	player.transform.position = destination
	newobj = util.TableToArray( { destination } )
	util.ConvertAndSetOnArray( newobj, 0, destination, UnityEngine.Object._type )
	player:ClientRPC(nil,player,"ForcePositionTo",newobj)
	player:TransformChanged()
	self:loadScreen(player)
end


function PLUGIN:BroadcastToPlayers(message)
  netusers = self:GetAllPlayers()
  if (netusers) then
    for k,player in pairs(netusers) do
      if (self:IsPlaying(player)) then
        rust.SendChatMessage(player, self.Config.ChatName, message)
      end
    end
  end
end
function PLUGIN:RedeemInventory(player)
	inv = player.inventory
	inv:Strip()
	container = {}
	container["Main"] = inv.containerMain
	container["Belt"] = inv.containerBelt
	container["Wear"] = inv.containerWear
	for n,cont in pairs(container) do
		for i,data in pairs( self.ArenaData.SavedInventories[cont] ) do
			inv:GiveItem(self.ArenaData.SavedInventories[cont][i],cont)
		end
		self.ArenaData.SavedInventories[cont] = {}
	end
end
function PLUGIN:SaveAllInventories()
  local netusers =  self:GetAllPlayers()
  for k,player in pairs(netusers) do
    if (self:IsPlaying(player)) then
      self:SaveInventory(player)
    end
  end
end
function PLUGIN:SaveInventory(player)
	inv = player.inventory
	container = {}
	container["Main"] = inv.containerMain
	container["Belt"] = inv.containerBelt
	container["Wear"] = inv.containerWear
	for n,cont in pairs(container) do
		ilist = cont.itemList
		self.ArenaData.SavedInventories[cont] = {}
		for i=0, ilist.Count-1 do
			table.insert(self.ArenaData.SavedInventories[cont],ilist[i])
		end
		for i,data in pairs( self.ArenaData.SavedInventories[cont] ) do
			ilist:Remove(self.ArenaData.SavedInventories[cont][i])
			self.ArenaData.SavedInventories[cont][i].parent = nil
		end
		cont:MarkDirty()
	end
end
function PLUGIN:FindPlayer( target )
	local steamid = false
	if(tonumber(target) ~= nil and string.len(target) == 17) then
		steamid = target
	end
	local targetplayer = false
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		local currentplayer = allBasePlayer[ i ];
		if(steamid) then
			if(steamid == rust.UserIDFromPlayer(currentplayer)) then
				return currentplayer
			end
		else
			if(currentplayer.displayName == target) then
				return currentplayer
			elseif(string.find(currentplayer.displayName,target)) then
				if(targetplayer) then
					return false, "Multiple Players Found"
				end
				targetplayer = currentplayer
			end
		end
	end
	if(not targetplayer) then return false, "No players found" end
	return targetplayer
end



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\arena_deathmatch.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Arena: Deathmatch"
PLUGIN.Title = "Arena: Deathmatch"
PLUGIN.Version = V(1, 1, 3)
PLUGIN.Description = "Arena Deathmatch converted from Oxide 1"
PLUGIN.Author = "Reneb - Oxide 1 version by eDeloa"
PLUGIN.HasConfig = true
 
function PLUGIN:Init()
	arena_loaded = false
end

function PLUGIN:OnServerInitialized()

spawns_plugin = plugins.Find("spawns")
	arena_plugin = plugins.Find("arena")

    self.DeathmatchData = {}
	self.DeathmatchData.Users = {}
	self.DeathmatchData.IsChosen = false
	self.DeathmatchData.HasStarted = false
	self.DeathmatchData.CustomPack = 0
	   
    if(not spawns_plugin or not arena_plugin) then
   	  print("You must have the Spawns Database @ http://forum.rustoxide.com/plugins/spawns-database.720/")
   	  print("You must have the Arena Plugin")
	  
	  return
   	end
   	arena_loaded = true
   	self:InitializeTable()
   	command.AddChatCommand( "deathmatch_pack", self.Plugin, "cmdDeathmatchPack")
   	self.DeathmatchData.GameID = arena_plugin:CallHook("RegisterArenaGame",self.Config.ArenaGame)
end

function PLUGIN:BroadcastChat(msg)
  local netusers = arena_plugin:CallHook("GetAllPlayers", nil)
  for k,player in pairs(netusers) do
  	rust.SendChatMessage(player,msg)
  end
end  
-- *******************************************
-- CHAT FUNCTIONS
-- *******************************************
function PLUGIN:cmdDeathmatchPack(player, cmd, args)
  if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel) then
  	rust.SendChatMessage(player, self.Config.ChatName, "This command is restricted")
  	return
  end
  if(args.Length == 0 or ( args.Length > 0 and tonumber(args[0])==nil) ) then
  	rust.SendChatMessage(player, self.Config.ArenaGame, "Syntax: /deathmatch_pack {packNumber (0 = default)}")
    return
  end
  pack = tonumber(args[0])

  if (pack == 0) then
    self.DeathmatchData.CustomPack = 0
    rust.SendChatMessage(player, self.Config.ArenaGame, "Default pack settings loaded.")
  elseif (pack > 0 and pack <= #self.Config.Packs) then
    self.DeathmatchData.CustomPack = pack
    rust.SendChatMessage(player, self.Config.ArenaGame, "Custom Deathmatch pack selected.")
  else
    rust.SendChatMessage(player, self.Config.ArenaGame, "Specified pack number out of bounds.")
  end
end

-- *******************************************
-- ARENA HOOK FUNCTIONS
-- *******************************************
function PLUGIN:CanSelectArenaGame(gameid)
  if (gameid == self.DeathmatchData.GameID) then
    return "true"
  end
end

function PLUGIN:OnSelectArenaGamePost(gameid)
  if (gameid == self.DeathmatchData.GameID) then
    self.DeathmatchData.IsChosen = true
  else
    self.DeathmatchData.IsChosen = false
  end
end

function PLUGIN:CanArenaOpen()
  if (self.DeathmatchData.IsChosen) then
    return "true"
  end
end
  
function PLUGIN:OnArenaOpenPost()
  if (self.DeathmatchData.IsChosen) then
    arena_plugin:CallHook("BroadcastToPlayers","In Deathmatch, your inventory WILL be lost!  Do not join until you have put away your items!")
  end
end

function PLUGIN:CanArenaClose()
  if (self.DeathmatchData.IsChosen) then
    return "true"
  end
end

function PLUGIN:OnArenaClosePost()
end
 
function PLUGIN:CanArenaStart()
  if (self.DeathmatchData.IsChosen) then
    return "true"
  end
end

function PLUGIN:ArenaHasMinimum(currentNumber)
  if (self.DeathmatchData.IsChosen) then
  	if(currentNumber >= self.Config.AutoArena_Settings.MinimumPlayers) then
    	return "true"
    end
  end
end

function PLUGIN:ArenaHasMaximum(currentNumber)
  if (self.DeathmatchData.IsChosen) then
  	if(currentNumber >= self.Config.AutoArena_Settings.MaximumPlayers) then
    	return "true"
    end
  end
end

-- *******************************************
-- Called after everyone has been teleported into the Arena
-- *******************************************
function PLUGIN:OnArenaStartPost()
  if (self.DeathmatchData.IsChosen) then
    self.DeathmatchData.HasStarted = true
    self:EquipAllPlayers()
  end
end

function PLUGIN:CanArenaEnd()
  if (self.DeathmatchData.IsChosen) then
    return "true"
  end
end

-- *******************************************
-- Called after everyone has already been kicked out of the Arena.
-- OnArenaLeavePost() is called for each user before OnArenaEndPost() is called
-- *******************************************
function PLUGIN:OnArenaEndPost()
  if (self.DeathmatchData.IsChosen) then
    self.DeathmatchData.HasStarted = false
  end
end

function PLUGIN:CanArenaJoin(player)
  if (self.DeathmatchData.IsChosen) then
    return "true"
  end
end

function PLUGIN:OnArenaJoinPost(player)
  if (self.DeathmatchData.IsChosen) then
    if (self.DeathmatchData.HasStarted) then
      arena_plugin:CallHook("TeleportPlayerToArena",player)
      self:EquipPlayer(player)
    end

    local userID = rust.UserIDFromPlayer(player)
    self.DeathmatchData.Users[userID] = {}
    self.DeathmatchData.Users[userID].kills = 0
    self.DeathmatchData.Users[userID].spawnTime = -1
  end
end
-- *******************************************
-- Called when someone asks for a reward
-- *******************************************
function PLUGIN:isRewardRandom(arenagame)
	if(arenagame == self.Config.ArenaGame) then
		if(self.Config.Rewards.Random) then
			return true
		end
		return false
	end
end
function PLUGIN:OnRewardGetList(arenagame)
	if(arenagame == self.Config.ArenaGame) then
		msg = ""
		for k,v in pairs(self.Config.Rewards.Packs) do
			msg = msg .. "\"" .. k .. "\" "
		end
		return msg
	end
end

function PLUGIN:giveRandomReward(player,arenagame)
	if(arenagame == self.Config.ArenaGame) then
		count = 0
		for k,v in pairs(self.Config.Rewards.Packs) do
			count = count + 1
		end
		crand = math.random(1,count)
		count = 0
		for k,v in pairs(self.Config.Rewards.Packs) do
			count = count + 1
			if(crand  == count) then
				self:giveReward(player,v)
				break
			end
		end
	end
end
function PLUGIN:giveSpecificReward(player,arenagame,name)
	if(arenagame == self.Config.ArenaGame) then
		for k,v in pairs(self.Config.Rewards.Packs) do
			if(name == k) then
				self:giveReward(player,v)
				return "true"
			end
		end
		return false
	end
end
-- *******************************************
-- Called after a player has left the Arena.
-- *******************************************
function PLUGIN:OnArenaLeavePost(player)
  if (self.DeathmatchData.IsChosen) then
    self.DeathmatchData.Users[rust.UserIDFromPlayer(player)] = nil
  end
end

function PLUGIN:OnArenaSpawnPost(player)
  if (self.DeathmatchData.IsChosen) then
    self:EquipPlayer(player)
    self:GivePlayerImmunity(player)
  end
end

-- *******************************************
-- HOOK FUNCTIONS
-- *******************************************
function PLUGIN:AutoArenaConfig(cfgName)
  if (self.DeathmatchData.IsChosen) then
    return self.Config.AutoArena_Settings[cfgName]
  end
end
function PLUGIN:OnEntityAttacked(entity,hitinfo)
  if (not arena_loaded) then
    return
  end
  if (self.DeathmatchData.IsChosen and self.DeathmatchData.HasStarted) then
    if (hitinfo and hitinfo.Initiator and hitinfo.Initiator:ToPlayer()) then
      if (entity and entity:ToPlayer()) then
          if (entity:ToPlayer() ~= hitinfo.Initiator:ToPlayer()) then
              -- If the victim is protected, deal no damage
              if (arena_plugin:CallHook("IsPlaying",entity:ToPlayer()) and self:IsImmune(entity:ToPlayer())) then
                rust.SendChatMessage(hitinfo.Initiator:ToPlayer(), self.Config.ArenaGame, "New spawns have immunity!")
                return false
              end
          end
        end
    end
  end
end

function PLUGIN:OnEntityDeath(entity, hitinfo)
  if (not arena_loaded) then
    return
  end
  if (self.DeathmatchData.IsChosen and self.DeathmatchData.HasStarted) then
    if (entity:ToPlayer()) then
      if (hitinfo and hitinfo.Initiator and hitinfo.Initiator:ToPlayer()) then
        local attacker = hitinfo.Initiator:ToPlayer()
        local victim = entity:ToPlayer()

        if (attacker and victim and arena_plugin:CallHook("IsPlaying",victim)) then
          if (attacker == victim) then
            -- Process suicide
          elseif (not arena_plugin:CallHook("IsPlaying",attacker)) then
            -- Handle this
          else
            self:AwardKill(attacker)
          end
        end
      end
    end
  end
end

function PLUGIN:SendHelpText(player)
  if (not arena_loaded) then
    return
  end
  if (player:GetComponent("BaseNetworkable").net.connection.authLevel > 0) then
    rust.SendChatMessage(player, self.Config.ArenaGame, "Use /deathmatch_pack {packNumber} to select a custom pack for Deathamtch.")
  end
end

-- *******************************************
-- MAIN FUNCTIONS
-- *******************************************
function PLUGIN:InitializeTable()
	Table = {}
	local itemlist = global.ItemManager.GetItemDefinitions();
	local it = itemlist:GetEnumerator()
	while (it:MoveNext()) do
		local correctname = string.lower(it.Current.displayname)
		Table[correctname] = tostring(it.Current.shortname)
	end
end 
  
function PLUGIN:EquipAllPlayers()
  local netusers = arena_plugin:CallHook("GetAllPlayers",nil)
  for k,player in pairs(netusers) do
    if (arena_plugin:CallHook("IsPlaying",player)) then
      self:EquipPlayer(player)
    end
  end
end
function PLUGIN:GiveItem(inv,name,amount,type)
	local itemname = false
	name = string.lower(name)
	if(Table[name]) then
		itemname = Table[name]
	else
		itemname = name
	end
	if(tonumber(amount) == nil) then
		return false, "amount is not valid"
	end
	local container
	if(type == "belt") then
		container = inv.containerBelt
	elseif(type == "main") then
		container = inv.containerMain
	elseif(type == "wear") then
		container = inv.containerWear
	else
		return false, "wrong type: belt, main or wear"
	end
	local giveitem = global.ItemManager.CreateByName(itemname,amount)
	if(not giveitem) then
		return false, itemname .. " is not a valid item name"
	end
	inv:GiveItem(giveitem,container);
	return giveitem
end

function PLUGIN:EquipPlayer(player)
  if(not Table) then self:InitializeTable() end
  self:ClearInventory(player)

  local packNum = self.Config.DefaultPack
  if (self.DeathmatchData.CustomPack > 0) then
    packNum = self.DeathmatchData.CustomPack
  elseif (self.Config.RandomPack) then
    packNum = math.random(#self.Config.Packs)
  end

  local packData = self.Config.Packs[packNum]
  
  -- Equip player with armor
  if (packData.armor) then
    for i = 1, #packData.armor do
      str = packData.armor[i]
      giveitem, err = self:GiveItem(player.inventory,str,1,"wear")
	  if(not giveitem) then print("Deathmatch: Error while giving " .. str .. ": " .. err) end
    end
  end

  -- Equip player with items in their backpack
  if (packData.backpack) then
    for i = 1, #packData.backpack do
      if (packData.backpack[i][2]) then
        giveitem, err = self:GiveItem(player.inventory,packData.backpack[i][1],packData.backpack[i][2],"main")
	    if(not giveitem) then print("Deathmatch: Error while giving " .. packData.backpack[i][1] .. ": " .. err) end
      else
        giveitem, err = self:GiveItem(player.inventory,packData.backpack[i][1],1,"main")
	    if(not giveitem) then print("Deathmatch: Error while giving " .. packData.backpack[i][1] .. ": " .. err) end
      end
    end
  end

  -- Equip player with items on their belt
  if (packData.belt) then
    for i = 1, #packData.belt do
      if (packData.belt[i][2]) then
        giveitem, err = self:GiveItem(player.inventory,packData.belt[i][1],packData.belt[i][2],"belt")
	    if(not giveitem) then print("Deathmatch: Error while giving " .. packData.belt[i][1] .. ": " .. err) end
      else
        giveitem, err = self:GiveItem(player.inventory,packData.belt[i][1],1,"belt")
	    if(not giveitem) then print("Deathmatch: Error while giving " .. packData.belt[i][1] .. ": " .. err) end
      end
    end
  end
end

function PLUGIN:AwardKill(player)
  local userData = self:GetUserData(player)
  userData.kills = userData.kills + 1
  self:DisplayKillMessage(player)
  self:ShowPlayerScore(player)

  if (self.Config.KillLimit > 0 and userData.kills >= self.Config.KillLimit) then
    self:GiveWin(player)
  end
end

function PLUGIN:GiveWin(player)
  -- Announce win
  local str = "DEATHMATCH IS OVER!  " .. string.upper(player.displayName) .. " WINS!"
  if(self.Config.Rewards.activated) then
  	arena_plugin:CallHook("GiveReward",player,self.Config.ArenaGame)
  end
  for i = 1, 10 do
    arena_plugin:CallHook("BroadcastToPlayers",str)
  end

  -- Trigger the end of the arena
  timer.Once(5, function() arena_plugin:CallHook("EndArena",nil) end)
end

function PLUGIN:giveReward(player,rewards)
	for i,v in pairs(rewards) do
		if (rewards[i][2]) then
			giveitem, err = self:GiveItem(player.inventory,rewards[i][1],rewards[i][2],"main")
			if(not giveitem) then print("Deathmatch: Error while giving reward " .. rewards[i][1] .. ": " .. err) end
		else
			giveitem, err = self:GiveItem(player.inventory,rewards[i][1],1,"main")
			if(not giveitem) then print("Deathmatch: Error while giving reward " .. rewards[i][1] .. ": " .. err) end
		end
    end
end

-- *******************************************
-- HELPER FUNCTIONS
-- *******************************************
function PLUGIN:ClearInventory(player)
  player.inventory:Strip()
end

-- *******************************************
-- PLUGIN:LoadDefaultConfig()
-- Loads the default configuration into the config table
-- *******************************************
function PLUGIN:LoadDefaultConfig()
  -- Set default configuration settings
  self.Config.ArenaGame = "Deathmatch"
  
  self.Config.Rewards = {}
  self.Config.Rewards.activated = true
  self.Config.Rewards.Random = false
  self.Config.Rewards.Packs = {
  	["wood"] = {
  		{"Wood", 10000},
  		{"Hazmat Gloves", 1}
  	},
  	["lanterns"] = {
  		{"Lantern", 1},
  		{"Lantern", 1},
  		{"Lantern", 1}
  	}
  }
  
  
  self.Config.AutoArena_Settings = {}
  self.Config.AutoArena_Settings["MinimumPlayers"] = 2
  self.Config.AutoArena_Settings["MaximumPlayers"] = 10
  self.Config.AutoArena_Settings["CancelArenaTime"] = 360
  self.Config.AutoArena_Settings["WaitToStartTime"] = 30
  self.Config.AutoArena_Settings["ArenaLimitTime"] = 1800
  self.Config.AutoArena_Settings["ArenasInterval"] = 1800
  self.Config.AutoArena_Settings["CloseOnStart"] = true
  
  self.Config.authLevel = 1
  self.Config.SpawnImmunity = 4
  self.Config.RandomPack = true
  self.Config.DefaultPack = 1
  self.Config.KillLimit = 5000
  
  self.Config.Packs =
  {
    {belt = {{"Thompson"},{"Medical Syringe", 1}}, armor = {"Hazmat Boots", "Hazmat Jacket", "Hazmat Gloves", "Hazmat Pants"}, backpack = {{"Pistol Bullet", 250}}},
    {belt = {{"Thompson"},{"Medical Syringe", 1}}, armor = {"Hazmat Boots", "Hazmat Jacket", "Hazmat Gloves", "Hazmat Pants"}, backpack = {{"Pistol Bullet", 250}}}
  }
  self.Config.KillMessages =
  {
    "Sweet Kill!",
    "+1 Kill!",
    "Nice Shot!",
    "Destruction!",
    "Like a boss!",
    "You Mex'd him!",
    "Boom!",
    "Ultrakill!",
    "Y0u 4R3 s0 1337!"
  }
end

function PLUGIN:GivePlayerImmunity(player)
  self.DeathmatchData.Users[rust.UserIDFromPlayer(player)].spawnTime = time.GetUnixTimestamp()
end

function PLUGIN:IsImmune(player)
  return (not ((time.GetUnixTimestamp() - self.DeathmatchData.Users[rust.UserIDFromPlayer(player)].spawnTime) > self.Config.SpawnImmunity))
end

local msgNumber = 1
function PLUGIN:DisplayKillMessage(player)
  rust.SendChatMessage(player, self.Config.ArenaGame, self.Config.KillMessages[msgNumber])
  msgNumber = (msgNumber % #self.Config.KillMessages) + 1
end

function PLUGIN:ShowPlayerScore(player)
  local userData = self:GetUserData(player)
  arena_plugin:CallHook("BroadcastToPlayers",player.displayName .. " has a total of " .. userData.kills .. " kills!")
end

function PLUGIN:GetUserData(player)
  return self.DeathmatchData.Users[rust.UserIDFromPlayer(player)]
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\authenticator.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Authenticator"
PLUGIN.Description = "Allow users to register their name on your server"
PLUGIN.Author = "#Domestos"
PLUGIN.Version = V(1, 1, 0)
PLUGIN.HasConfig = true
PLUGIN.ResourceID = 701

local DataFile = "authenticator"
local needIdentify = {}
local kickTimer = {}
local dataTable = {}


function PLUGIN:Init()
    command.AddChatCommand("auth", self.Object, "cmdAuth")
    command.AddChatCommand("authhelp", self.Object, "cmdAuthHelp")
    self:LoadDataFile()
    self:LoadDefaultConfig()
end

function PLUGIN:LoadDefaultConfig()
    -- Settings
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.LogToConsole = self.Config.Settings.LogToConsole or "false"
    self.Config.Settings.NotifyOnConnect = self.Config.Settings.NotifyOnConnect or "true"
    self.Config.Settings.TimeToIdentify = self.Config.Settings.TimeToIdentify or 40
    -- Messages
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.NotRegistered = self.Config.Messages.NotRegistered or "You dont have registered a name yet"
    self.Config.Messages.NotifyOnConnect = self.Config.Messages.NotifyOnConnect or "You can register your name on this server by using {command} so nobody can pretend to be you"
    self.Config.Messages.SuccessfullRegistered = self.Config.Messages.SuccessfullRegistered or "Your name is now registered to your steam account"
    self.Config.Messages.SuccessfullUnregistered = self.Config.Messages.SuccessfullUnregistered or "You have successfully unregistered your name"
    self.Config.Messages.SuccessfullIdentified = self.Config.Messages.SuccessfullIdentified or "Successfully identified"
    self.Config.Messages.NoIdentifyNeeded = self.Config.Messages.NoIdentifyNeeded or "You dont need to identify on this account"
    self.Config.Messages.WrongPassword = self.Config.Messages.WrongPassword or "Wrong password!"
    self.Config.Messages.KickMessage = self.Config.Messages.KickMessage or "You didnt identify your name. Please choose a different one"
    self.Config.Messages.NameAlreadyRegistered = self.Config.Messages.NameAlreadyRegistered or "The name you're using is registered to another steam account. Please identify by using {command}. You have {time} seconds before getting kicked"
    self.Config.Messages.RegisteredAnotherNameAlready = self.Config.Messages.RegisteredAnotherNameAlready or "Your steam account has already registered the name {name}. Use {command} to unregister"
    -- Save
    self:SaveConfig()
end

function PLUGIN:LoadDataFile()
    dataTable = datafile.GetDataTable(DataFile) or {}
end
function PLUGIN:SaveDataFile()
    datafile.SaveDataTable(DataFile)
end

local function QuoteSafe(string)
    return UnityEngine.StringExtensions.QuoteSafe(string)
end

function PLUGIN:ChatMessage(targetPlayer, chatName, msg)
    if msg then
        targetPlayer:SendConsoleCommand("chat.add "..QuoteSafe(chatName).." "..QuoteSafe(msg))
    else
        msg = chatName
        targetPlayer:SendConsoleCommand("chat.add SERVER "..QuoteSafe(msg))
    end
end

-- --------------------------------
-- handles chat command /auth
-- --------------------------------
function PLUGIN:cmdAuth(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local func, password = args[1], args[2]
    local playerSteamID = rust.UserIDFromPlayer(player)
    local playerName = player.displayName
    if not password or func ~= "register" and func ~= "unregister" and func ~= "identify" then
        self:ChatMessage(player, "Syntax: \"/auth <register/unregister/identify> <password>\"")
        return
    end
    if func == "register" then
        if needIdentify[playerSteamID] then
            local msg = string.gsub(self.Config.Messages.NameAlreadyRegistered, "{time}", self.Config.Settings.TimeToIdentify)
            msg = string.gsub(msg, "{command}", "\"/auth identify <password>\"")
            self:ChatMessage(player, msg)
            return
        end
        if not dataTable[playerSteamID] then
            dataTable[playerSteamID] = {}
            dataTable[playerSteamID].steamid = playerSteamID
            dataTable[playerSteamID].name = playerName
            dataTable[playerSteamID].password = password
            self:SaveDataFile()
            self:ChatMessage(player, self.Config.Messages.SuccessfullRegistered)
            if self.Config.Settings.LogToConsole == "true" then
                print("SteamID: "..tostring(playerSteamID).." registered the name "..playerName)
            end
            return
        end
        local msg = string.gsub(self.Config.Messages.RegisteredAnotherNameAlready, "{name}", dataTable[playerSteamID].name)
        msg = string.gsub(msg, "{command}", "\"/auth unregister <password>\"")
        self:ChatMessage(player, msg)
        return
    end
    if func == "unregister" then
        if not dataTable[playerSteamID] then
            self:ChatMessage(player, self.Config.Messages.NotRegistered)
            return
        end
        if password == dataTable[playerSteamID].password then
            dataTable[playerSteamID] = nil
            self:SaveDataFile()
            self:ChatMessage(player, self.Config.Messages.SuccessfullUnregistered)
            if self.Config.Settings.LogToConsole == "true" then
                print("SteamID: "..tostring(playerSteamID).." unregistered the name "..playerName)
            end
            return
        end
        self:ChatMessage(player, self.Config.Messages.WrongPassword)
        return
    end
    if func == "identify" then
        if not needIdentify[playerSteamID] then
            self:ChatMessage(player, self.Config.Messages.NoIdentifyNeeded)
            return
        end
        for key, _ in pairs(dataTable) do
            if dataTable[key].name == playerName then
                if dataTable[key].password == tostring(password) then
                    needIdentify[playerSteamID] = nil
                    kickTimer[playerSteamID] = nil
                    self:ChatMessage(player, self.Config.Messages.SuccessfullIdentified)
                    if self.Config.Settings.LogToConsole == "true" then
                        print("SteamID: "..tostring(playerSteamID).." identified as "..playerName.." (original account: "..dataTable[key].steamID..")")
                    end
                    return
                end
                self:ChatMessage(player, self.Config.Messages.WrongPassword)
                return
            end
        end
    end
end

-- --------------------------------
-- checks if player needs to identify
-- --------------------------------
function PLUGIN:OnPlayerInit(player)
    local playerSteamID = rust.UserIDFromPlayer(player)
    local playerName = player.displayName
    for key, _ in pairs(dataTable) do
        if dataTable[key].name == playerName then
            if dataTable[key].steamid ~= playerSteamID then
                local msg = string.gsub(self.Config.Messages.NameAlreadyRegistered, "{time}", self.Config.Settings.TimeToIdentify)
                msg = string.gsub(msg, "{command}", "\"/auth identify <password>\"")
                self:ChatMessage(player, msg)
                needIdentify[playerSteamID] = true
                kickTimer[playerSteamID] = timer.Once(self.Config.Settings.TimeToIdentify, function() self:CheckIdentify(player) end)
                if self.Config.Settings.LogToConsole == "true" then
                    print("SteamID: "..tostring(playerSteamID).." is forced to identify his name "..playerName)
                end
                return
            end
            return
        end
    end
    if not dataTable[playerSteamID] then
        if self.Config.Settings.NotifyOnConnect == "true" then
            local msg = string.gsub(self.Config.Messages.NotifyOnConnect, "{command}", "\"/auth register <password>\"")
            self:ChatMessage(player, msg)
        end
    end
end

-- --------------------------------
-- kicks player if not identified in time
-- --------------------------------
function PLUGIN:CheckIdentify(player)
    local playerSteamID = rust.UserIDFromPlayer(player)
    local playerName = player.displayName
    if not needIdentify[playerSteamID] then return end
    needIdentify[playerSteamID] = nil
    kickTimer[playerSteamID] = nil
    if self.Config.Settings.LogToConsole == "true" then
        print("SteamID: "..tostring(playerSteamID).." kicked for not identifying his name ("..playerName..")")
    end
    Network.Net.sv:Kick(player.net.connection, self.Config.Messages.KickMessage)
end

-- --------------------------------
-- remove data when disconnected before identified
-- --------------------------------
function PLUGIN:OnPlayerDisconnected(player)
    local playerSteamID = rust.UserIDFromPlayer(player)
    if needIdentify[playerSteamID] then
        needIdentify[playerSteamID] = nil
    end
end

-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end

function PLUGIN:SendHelpText(player)
    self:ChatMessage(player, "Use \"/authhelp\" to get infos about the name authentication")
end
function PLUGIN:cmdAuthHelp(player)
    self:ChatMessage(player, "This server allows you to register your name so nobody can pretend to be you")
    self:ChatMessage(player, "Use \"/auth register <password>\" to register")
    self:ChatMessage(player, "If someone connects with your name from another steam account now he will be kicked")
end

function PLUGIN:Unload()
    if kickTimer then kickTimer = nil end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\authlevel.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Auth Level"
PLUGIN.Version = V(0, 1, 8)
PLUGIN.Description = "Add or remove players as owner/moderator/player via command."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/resources/702/"
PLUGIN.ResourceId = 702
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Figure out a method to set player auth level instantly without having to restart client

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdAuthLevel")
    command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdAuthLevel")
end

function PLUGIN:cmdAuthLevel(player, cmd, args)
    if player and not self:PermissionsCheck(player) then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission)
        return
    end
    if args.Length ~= 2 then
        local message = self.Config.Messages.ChatHelp:gsub("{command}", self.Config.Settings.ChatCommand)
        rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, message)
        return
    end
    local targetPlayer = global.BasePlayer.Find(args[0])
    if not targetPlayer then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.InvalidTarget)
        return
    end
    local authLevel = string.lower(args[1])
    if authLevel ~= "2" and authLevel ~= "1" and authLevel ~= "0" and authLevel ~= "admin" and authLevel ~= "owner"
            and authLevel ~= "mod" and authLevel ~= "moderator" and authLevel ~= "guest" and authLevel ~= "player" then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.InvalidAuthLevel)
        return
    end
    local steamId = rust.UserIDFromPlayer(targetPlayer)
    if authLevel == "2" or authLevel == "admin" or authLevel == "owner" then
        rust.RunServerCommand("ownerid", steamId, targetPlayer.displayName)
    end
    if authLevel == "1" or authLevel == "mod" or authLevel == "moderator" then
        rust.RunServerCommand("moderatorid", steamId, targetPlayer.displayName)
    end
    if authLevel == "0" or authLevel == "guest" or authLevel == "player" then
        rust.RunServerCommand("removeowner", steamId)
        rust.RunServerCommand("removemoderator", steamId)
    end
    rust.RunServerCommand("server.writecfg")
    local message = self.Config.Messages.AuthLevelSet:gsub("{level}", authLevel):gsub("{player}", targetPlayer.displayName)
    rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
end

function PLUGIN:ccmdAuthLevel(args)
    local player = nil
    if args.connection then player = args.connection.player end
    if player and not self:PermissionsCheck(player) then args:ReplyWith(self.Config.Messages.NoPermission); return end
    if not args:HasArgs(2) then
        local message = self.Config.Messages.ConsoleHelp:gsub("{command}", self.Config.Settings.ConsoleCommand)
        if player then args:ReplyWith(message) else print(message) end
        return
    end
    local targetPlayer = global.BasePlayer.Find(args:GetString(0))
    if not targetPlayer then args:ReplyWith(self.Config.Messages.InvalidTarget); return end
    local authLevel = args:GetString(1)
    if authLevel ~= "2" and authLevel ~= "1" and authLevel ~= "0" and authLevel ~= "admin" and authLevel ~= "owner"
            and authLevel ~= "mod" and authLevel ~= "moderator" and authLevel ~= "guest" and authLevel ~= "player" then
        if player then args:ReplyWith(self.Config.Messages.InvalidAuthLevel) else print(self.Config.Messages.InvalidAuthLevel) end
        return
    end
    local steamId = rust.UserIDFromPlayer(targetPlayer)
    if authLevel == "2" or authLevel == "admin" or authLevel == "owner" then
        rust.RunServerCommand("ownerid", steamId, targetPlayer.displayName)
    end
    if authLevel == "1" or authLevel == "mod" or authLevel == "moderator" then
        rust.RunServerCommand("moderatorid", steamId, targetPlayer.displayName)
    end
    if authLevel == "0" or authLevel == "guest" or authLevel == "player" then
        rust.RunServerCommand("removeowner", steamId)
        rust.RunServerCommand("removemoderator", steamId)
     end
    rust.RunServerCommand("server.writecfg")
    local message = self.Config.Messages.AuthLevelSet:gsub("{level}", authLevel):gsub("{player}", targetPlayer.displayName)
    if player then args:ReplyWith(message) else print(message) end
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp) end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "authlevel"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "ADMIN"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or "HELP"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "global.authlevel"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.AuthLevelSet = self.Config.Messages.AuthLevelSet or "Auth level set to {level} for {player}!"
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or "Use /authlevel player authlevel to set the auth level for player"
    self.Config.Messages.ConsoleHelp = self.Config.Messages.ConsoleHelp or "Use authlevel player authlevel to set the auth level for player"
    self.Config.Messages.InvalidAuthLevel = self.Config.Messages.InvalidAuthLevel or "Invalid auth level! Valid levels are 0 (player), 1 (moderator), and 2 (owner)"
    self.Config.Messages.InvalidTarget = self.Config.Messages.InvalidTarget or "Invalid player name! Please try again"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\autobroadcast.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Auto Broadcast"
PLUGIN.Title = "Auto Broadcast"
PLUGIN.Version = V(0, 1, 1)
PLUGIN.Description = "Sending global broadcasts on a timer"
PLUGIN.Author = "Taffy"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 684

--** Load default configuration
function PLUGIN:LoadDefaultConfig()
	self.Config.ChatName 			= self.Config.ChatName or "Info"
	self.Config.BroadCastInterval	= self.Config.BroadCastInterval or 600
	-- Messages to send - Add or remove as required
    self.Config.Messages = {
        Message1			= "Please do not grief other players",
        Message2		    = "New plugins are added all the time. type /help for info",
        Message3			= "This is an example global broadcast"
    }
end

--**Initialisation routine
function PLUGIN:Init()
	--define some variables for counters
	x = 0
	y = 1
	-- work out how many messages have been created
	for k , v in pairs(self.Config.Messages) do
			x = x + 1
	end
	local BroadCastTimer = tonumber(self.Config.BroadCastInterval)
	local BroadCastEnabled = self.Config.TimedBroadCastEnabled
	--initiating the timer
	self.BCTimer = {}
	self.BCTimer = timer.Repeat (BroadCastTimer , 0 , function() self:BroadCastMessageNow( ) end )
end

--** Process sending of broadcast
function PLUGIN:BroadCastMessageNow( )
	--working out which message to send
	local MessageSent = 0
	if y + 1 > x then
		MessageString="Message" ..(y)
		y = 1
	else
		MessageString="Message" ..(y)
		y = y + 1
	end
	print (MessageString)
	global.ConsoleSystem.Broadcast("chat.add \"" .. self.Config.ChatName .. "\" \"" .. self.Config.Messages[MessageString] .. "\"")
end

--when unloading the plugin the timer will be destroyed
function PLUGIN:Unload()
	if self.BCTimer then self.BCTimer:Destroy() end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\autocommands.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Auto Commands"
PLUGIN.Version = V(0, 2, 4)
PLUGIN.Description = "Automatically executes configured commands on server startup."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/resources/774/"
PLUGIN.ResourceId = 774
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Add timed config option for each command entry
---- Allow for partial matching with commands

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdAutoCommand")
    command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdAutoCommand")
end

function PLUGIN:OnServerInitialized()
    for i = 1, #self.Config.Settings.Commands do
        rust.RunServerCommand(self.Config.Settings.Commands[i])
        print("[" .. self.Title .. "] ran command " .. self.Config.Settings.Commands[i])
    end
end

function PLUGIN:cmdAutoCommand(player, cmd, args)
    if player and not self:PermissionsCheck(player.net.connection) then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission)
        return
    end
    local command = string.lower(args[1])
    local action = args[0]
    local list = self.Config.Settings.Commands
    if action == nil or action ~= "add" and action ~= "remove" and action ~= "list" then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.UnknownAction)
        return
    end
    if args.Length ~= 2 then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.ChatHelp)
        return
    end
    --[[if args.Length ~= 1 and action == "list" then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.ChatHelp); return end]]
    if action == "add" then
        local listed
        for key, value in pairs(list) do if command == value then listed = true; break end end
        if not listed then
            table.insert(list, command)
            self:SaveConfig()
            local message = self.Config.Messages.CommandAdded:gsub("{command}", command)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = self.Config.Messages.AlreadyAdded:gsub("{command}", command)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
        return
    end
    if action == "remove" then
        local listed
        for key, value in pairs(list) do if command == value then listed = true; break end end
        if listed then
            table.remove(list, key)
            self:SaveConfig()
            local message = self.Config.Messages.CommandRemoved:gsub("{command}", command)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = self.Config.Messages.NotListed:gsub("{command}", command)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
        return
    end
    --[[if action == "list" then
        local commands
        for i = 1, #list do commands = commands .. ", " .. list[i] end
        rust.SendChatMessage(player, self.Config.Settings.ChatName, commands)
        return
    end]]
end

function PLUGIN:ccmdAutoCommand(args)
    local player = nil
    if args.connection then player = args.connection.player end
    if player and not self:PermissionsCheck(player) then args:ReplyWith(self.Config.Messages.NoPermission); return end
    --if not args:HasArgs(2) then args:ReplyWith(self.Config.Messages.ConsoleHelp); return end
    local action = args:GetString(1)
    local message = "This command is not yet usable."
    if player then args:ReplyWith(message) else print(message) end
end

function PLUGIN:PermissionsCheck(connection)
    local authLevel; if connection then authLevel = connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(connection.username .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player.net.connection) then rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp) end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "autocmd"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "SERVER"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or "HELP"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "auto.command"
    self.Config.Settings.Commands = self.Config.Settings.Commands or { "server.globalchat true", "server.stability false" }
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.AlreadyAdded = self.Config.Messages.AlreadyAdded or "{command} is already on the auto command list!"
    self.Config.Messages.ChatHelp = self.Config.Messages.Chathelp or "Use /autocmd add|remove command to add or remove an auto command"
    self.Config.Messages.ConsoleHelp = self.Config.Messages.ConsoleHelp or "Use auto.command add|remove command to add or remove an auto command"
    self.Config.Messages.CommandAdded = self.Config.Messages.CommandAdded or "{command} has been added to the auto command list!"
    self.Config.Messages.CommandRemoved = self.Config.Messages.CommandRemoved or "{command} has been removed from the auto command list!"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.NotListed = self.Config.Messages.NotListed or "{command} is not on the auto command list!"
    self.Config.Messages.UnknownAction = self.Config.Messages.UnknownAction or "Unknown command action! Use add or remove"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\AutoDoorCloser.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "AutoDoorCloser"
PLUGIN.Description  = "Automaticly close the doors"
PLUGIN.Author       = "Bombardir"
PLUGIN.Version      = V(1, 3, 1)
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 800

local Timers, Data, msgs, UpdateLayerMethod, settings = {}

local function SendChatMessage(player, msg)
	player:SendConsoleCommand("chat.add", (msgs.ChatPlayerIcon and rust.UserIDFromPlayer(player)) or 0, msgs.ChatFormat:format(msg))
end
  
function PLUGIN:Init()
	settings = self.Config.Settings or {} 
	settings.DataFile = settings.DataFile or "AutoDoorCloserData"
	settings.DefaultTime = settings.DefaultTime or 3
	settings.MinTime = settings.MinTime or 1
	if settings.MinTime <= 0 then settings.MinTime = 0.1 end
	settings.MaxTime = settings.MaxTime or 10
	if settings.MaxTime < settings.MinTime then settings.MaxTime = settings.MinTime + 0.1 end
	settings.Command = settings.Command or "ad"
	self.Config.Settings = settings
	   
	msgs = self.Config.Message or {}
	msgs.ChatFormat = msgs.ChatFormat or "<color=#af5>[AutoDoor]</color> %s" 
	if msgs.ChatPlayerIcon == nil then msgs.ChatPlayerIcon = true end
	msgs.SuccesOn = msgs.SuccesOn or "Your doors will close automatically after %s sec."
	msgs.SuccesOff = msgs.SuccesOff or "You turn off the automatic closing doors!"
	msgs.ErrorMin = (msgs.ErrorMin or "The minimum value of time: %s"):format(settings.MinTime)
	msgs.ErrorMax = (msgs.ErrorMax or "The maximum value of time: %s"):format(settings.MaxTime)
	msgs.Syntax = (msgs.Syntax or "/%s [off/<time>]"):format(settings.Command)
	msgs.Help = (msgs.Help or "/%s [off/<time>] -- set/del time for automatic closing doors"):format(settings.Command)
	self.Config.Message = msgs
	
	Data = datafile.GetDataTable( settings.DataFile )
	
	if settings.Command ~= "" then command.AddChatCommand(settings.Command, self.Plugin, "C_AD") end
	self:SaveConfig()
	
	UpdateLayerMethod = global.BuildingBlock._type:GetMethod("UpdateLayer", rust.PrivateBindingFlag() )
end

function PLUGIN:SendHelpText(player)
	SendChatMessage(player, msgs.Help)
end   

function PLUGIN:CanOpenDoor( player, lock )
	local door = lock:GetParentEntity()
	door = door and door:GetComponent("Door")
	if door and not door:IsOpen() then 
		if Timers[door] then Timers[door]:Destroy() Timers[door] = nil end
		local ADtime = Data[rust.UserIDFromPlayer(player)]
		if ADtime == nil then ADtime = settings.DefaultTime end
		if ADtime then
			Timers[door] = timer.Once(ADtime, function() 
				if door and door:IsOpen() then
					door:SetFlag(global.BaseEntity.Flags.Open, false) 
					UpdateLayerMethod:Invoke(door, nil)
					door:SendNetworkUpdateImmediate(false)
				end
				Timers[door] = nil
			end) 
		end 
	end
end

function PLUGIN:C_AD(player, _, args)
	if args.Length > 0 then
		local ADtime = tonumber(args[0])
		local steam = rust.UserIDFromPlayer(player)
		if ADtime then
			if ADtime >= settings.MinTime then
				if ADtime <= settings.MaxTime then
					Data[steam] = ADtime
					SendChatMessage(player, msgs.SuccesOn:format(ADtime))
				else
					SendChatMessage(player, msgs.ErrorMax)
				end
			else
				SendChatMessage(player, msgs.ErrorMin)
			end
		else
			Data[steam] = false
			SendChatMessage(player, msgs.SuccesOff)
		end
		datafile.SaveDataTable( settings.DataFile )
	else
		SendChatMessage(player, msgs.Syntax)
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\broadcaster.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Broadcaster"
PLUGIN.Description  = "Easy Broadcasting"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,0,1)
PLUGIN.HasConfig    = true
PLUGIN.ResourceId 	= 863

function PLUGIN:Init()
command.AddChatCommand("bcast", self.Object, "cmdBroadcast")
self:LoadDefaultConfig()
end

function PLUGIN:LoadDefaultConfig()
	self.Config.NoPermissionMsg = self.Config.NoPermissionMsg or "You have no permission to use this command!"
	self:SaveConfig()
end

function PLUGIN:cmdBroadcast(player, cmd, args)
	if player.net.connection.authLevel > 0 then
		if args.Length >= 1 then
			local BroadcastText = tostring(args[0])
			rust.BroadcastChat("BROADCAST", BroadcastText)
		else
			rust.SendChatMessage(player, "BROADCAST", "Syntax: /bcast ''TEXT''")
		end
	else
		rust.SendChatMessage(player, "BROADCAST", self.Config.NoPermissionMsg)
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\chathandler.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Chat Handler"
PLUGIN.Description  = "Many features to help moderate the chat"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(2, 5, 4)
PLUGIN.ResourceId   = 707

local debugMode = false

-- --------------------------------
-- declare some plugin wide vars
-- --------------------------------
local muteData, spamData, langData = {}, {}, {}
local MuteList = "chathandler-mutelist"
local SpamList = "chathandler-spamlist"
local LangFile = "chathandler-localization"
local LogFile = "Log.ChatHandler.txt"
local AntiSpam, ChatHistory, AdminMode = {}, {}, {}
local GlobalMute = false
local langString
-- external plugin references
local exRanksAndTitles
-- --------------------------------
-- initialise all settings and data
-- --------------------------------
function PLUGIN:Init()
    self:LoadDefaultConfig()
    self:LoadChatCommands()
    self:LoadDataFiles()
    self:LoadLocalization()
    self:RegisterPermissions()
end
function PLUGIN:OnServerInitialized()
    exRanksAndTitles = plugins.Find("RanksAndTitles") or false
end
-- --------------------------------
-- error and debug reporting
-- --------------------------------
local pluginTitle = PLUGIN.Title
local pluginVersion = string.match(tostring(PLUGIN.Version), "(%d+.%d+.%d+)")
local function error(msg)
    local message = "[Error] "..pluginTitle.."(v"..pluginVersion.."): "..msg
    local array = util.TableToArray({message})
    UnityEngine.Debug.LogError.methodarray[0]:Invoke(nil, array)
    print(message)
end
local function debug(msg)
    if not debugMode then return end
    local message = "[Debug] "..pluginTitle.."(v"..pluginVersion.."): "..msg
    local array = util.TableToArray({message})
    UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, array)
end
-- --------------------------------
-- permission check
-- --------------------------------
local function HasPermission(player, perm)
    local steamID = rust.UserIDFromPlayer(player)
    if player:GetComponent("BaseNetworkable").net.connection.authLevel == 2 then
        return true
    end
    if permission.UserHasPermission(steamID, perm) then
        return true
    end
    return false
end
-- --------------------------------
-- builds output messages by replacing wildcards
-- --------------------------------
local function buildOutput(str, tags, replacements)
    for i = 1, #tags do
        str = string.gsub(str, tags[i], replacements[i])
    end
    return str
end
-- --------------------------------
-- prints to server console
-- --------------------------------
local function printToConsole(msg)
    global.ServerConsole.PrintColoured(System.ConsoleColor.Cyan, msg)
end
-- --------------------------------
-- prints to log file
-- --------------------------------
local function printToFile(msg)
    global.server.Log(LogFile, msg.."\n")
end
-- --------------------------------
-- splits chat messages longer than 80 characters into multilines
-- --------------------------------
local function splitLongMessages(msg, maxCharsPerLine)
    local length = string.len(msg)
    local msgTbl = {}
    if length > 128 then
        msg = string.sub(msg, 1, 128)
    end
    if length > maxCharsPerLine then
        while length > maxCharsPerLine do
            local subStr = string.sub(msg, 1, maxCharsPerLine)
            local first, last = string.find(string.reverse(subStr), " ")
            if first then
                subStr = string.sub(subStr, 1, -first)
            end
            table.insert(msgTbl, subStr)
            msg = string.sub(msg, string.len(subStr) + 1)
            length = string.len(msg)
        end
        table.insert(msgTbl, msg)
    else
        table.insert(msgTbl, msg)
    end
    return msgTbl
end
-- --------------------------------
-- generates default config
-- --------------------------------
function PLUGIN:LoadDefaultConfig() 
    self.Config.Settings                                = self.Config.Settings or {}
    -- General Settings
    self.Config.Settings.General                        = self.Config.Settings.General or {}
    self.Config.Settings.General.Language               = self.Config.Settings.General.Language or "en"
    self.Config.Settings.General.MaxCharsPerLine        = self.Config.Settings.General.MaxCharsPerLine or 64
    self.Config.Settings.General.BroadcastMutes         = self.Config.Settings.General.BroadcastMutes or self.Config.Settings.BroadcastMutes or "true"
    self.Config.Settings.General.BlockServerAds         = self.Config.Settings.General.BlockServerAds or self.Config.Settings.BlockServerAds or "true"
    self.Config.Settings.General.AllowedIPsToPost       = self.Config.Settings.General.AllowedIPsToPost or self.Config.AllowedIPsToPost or {}
    self.Config.Settings.General.EnableChatHistory      = self.Config.Settings.General.EnableChatHistory or self.Config.Settings.EnableChatHistory or "true"
    self.Config.Settings.General.ChatHistoryMaxLines    = self.Config.Settings.General.ChatHistoryMaxLines or self.Config.Settings.ChatHistoryMaxLines or 10
    -- Wordfilter settings
    self.Config.Settings.Wordfilter                     = self.Config.Settings.Wordfilter or {}
    self.Config.Settings.Wordfilter.EnableWordfilter    = self.Config.Settings.Wordfilter.EnableWordfilter or "false"
    self.Config.Settings.Wordfilter.ReplaceFullWord     = self.Config.Settings.Wordfilter.ReplaceFullWord or "true"
    -- Chat commands
    self.Config.Settings.ChatCommands                   = self.Config.Settings.ChatCommands or {}
    self.Config.Settings.ChatCommands.AdminMode         = self.Config.Settings.ChatCommands.AdminMode or {"admin"}
    self.Config.Settings.ChatCommands.ChatHistory       = self.Config.Settings.ChatCommands.ChatHistory or {"history", "h"}
    self.Config.Settings.ChatCommands.Mute              = self.Config.Settings.ChatCommands.Mute or {"mute"}
    self.Config.Settings.ChatCommands.Unmute            = self.Config.Settings.ChatCommands.Unmute or {"unmute"}
    self.Config.Settings.ChatCommands.GlobalMute        = self.Config.Settings.ChatCommands.GlobalMute or {"globalmute"}
    self.Config.Settings.ChatCommands.Wordfilter        = self.Config.Settings.ChatCommands.Wordfilter or {"wordfilter" }
    -- command permissions
    self.Config.Settings.Permissions                    = self.Config.Settings.Permissions or {}
    self.Config.Settings.Permissions.AdminMode          = self.Config.Settings.Permissions.AdminMode or "canadminmode"
    self.Config.Settings.Permissions.Mute               = self.Config.Settings.Permissions.Mute or "canmute"
    self.Config.Settings.Permissions.GlobalMute         = self.Config.Settings.Permissions.GlobalMute or "canglobalmute"
    self.Config.Settings.Permissions.AntiGlobalMute     = self.Config.Settings.Permissions.AntiGlobalMute or "notglobalmuted"
    self.Config.Settings.Permissions.EditWordFilter     = self.Config.Settings.Permissions.EditWordFilter or "caneditwordfilter"
    -- Name colors
    self.Config.Settings.NameColor                      = self.Config.Settings.NameColor or {}
    self.Config.Settings.NameColor.NormalUser           = self.Config.Settings.NameColor.NormalUser or "#5af"
    self.Config.Settings.NameColor.AdminMode            = self.Config.Settings.NameColor.AdminMode or "#ff8000"
    -- Logging settings
    self.Config.Settings.Logging                        = self.Config.Settings.Logging or {}
    self.Config.Settings.Logging.LogToConsole           = self.Config.Settings.Logging.LogToConsole or "true"
    self.Config.Settings.Logging.LogBlockedMessages     = self.Config.Settings.Logging.LogBlockedMessages or "true"
    self.Config.Settings.Logging.LogToFile              = self.Config.Settings.Logging.LogToFile or "false"
    -- Admin mode settings
    self.Config.Settings.AdminMode                      = self.Config.Settings.AdminMode or {}
    self.Config.Settings.AdminMode.ReplaceChatName      = self.Config.Settings.AdminMode.ReplaceChatName or "true"
    self.Config.Settings.AdminMode.AdminChatName        = self.Config.Settings.AdminMode.AdminChatName or "[Server Admin]"
    -- Antispam settings
    self.Config.Settings.AntiSpam                       = self.Config.Settings.AntiSpam or {}
    self.Config.Settings.AntiSpam.EnableAntiSpam        = self.Config.Settings.AntiSpam.EnableAntiSpam or "true"
    self.Config.Settings.AntiSpam.MaxLines              = self.Config.Settings.AntiSpam.MaxLines or 4
    self.Config.Settings.AntiSpam.TimeFrame             = self.Config.Settings.AntiSpam.TimeFrame or 6
    -- Group settings
    self.Config.Settings.Groups                         = self.Config.Settings.Groups or {}
    self.Config.Settings.Groups.EnableGroups            = self.Config.Settings.Groups.EnableGroups or "false"
    self.Config.Settings.Groups.PrefixPosition          = self.Config.Settings.Groups.PrefixPosition or "left"
    self.Config.Settings.Groups.ColorNamesOnly          = self.Config.Settings.Groups.ColorNamesOnly or "true"
    -- Check if PrefixPosition setting is valid
    if self.Config.Settings.Groups.PrefixPosition ~= "left" and self.Config.Settings.Groups.PrefixPosition ~= "right" then
        self.Config.Settings.Groups.PrefixPosition = "left"
    end
    -- Chatgroups
    self.Config.ChatGroups = self.Config.ChatGroups or {
        ["Donator"] = {
            ["Permission"] = "donator",
            ["Prefix"] = "[$$$]",
            ["Color"] = "#06DCFB",
            ["ShowPrefix"] = true,
            ["ShowColor"] = true
        },
        ["VIP"] = {
            ["Permission"] = "vip",
            ["Prefix"] = "[VIP]",
            ["Color"] = "#59ff4a",
            ["ShowPrefix"] = true,
            ["ShowColor"] = true
        },
        ["Admin"] = {
            ["Permission"] = "admin",
            ["Prefix"] = "[Admin]",
            ["Color"] = "#FFA04A",
            ["ShowPrefix"] = true,
            ["ShowColor"] = true
        }
    }
    -- Wordfilter
    self.Config.WordFilter = self.Config.WordFilter or {
        ["bitch"] = "sweety",
        ["fucking hell"] = "lovely heaven",
        ["cunt"] = "****"
    }
    -- Check wordfilter for conflicts
    if self.Config.Settings.Wordfilter.EnableWordfilter== "true" then
        for key, value in pairs(self.Config.WordFilter) do
            local first, _ = string.find(string.lower(value), string.lower(key))
            if first then
                self.Config.WordFilter[key] = nil
                error("Config error in wordfilter: [\""..key.."\":\""..value.."\"] both contain the same word")
                error("[\""..key.."\":\""..value.."\"] was removed from word filter")
            end
        end
    end
    -- removed config entries
        -- removed in v2.3.4
    self.Config.Settings.Logging.LogChatToOxide = nil
        -- removed in v2.4
    self.Config.AllowedIPsToPost = nil
    self.Config.Settings.BroadcastMutes = nil
    self.Config.Settings.BlockServerAds = nil
    self.Config.Settings.EnableWordFilter = nil
    self.Config.Settings.EnableChatHistory = nil
    self.Config.Settings.ChatHistoryMaxLines = nil
    self.Config.Settings.AdminMode.ChatCommand = nil
    self.Config.Settings.HelpText = nil
        -- removed in v2.5
    self.Config.Settings.NameColor.Admin = nil
    --
    self:SaveConfig()
end
-- --------------------------------
-- load all chat commands, depending on settings
-- --------------------------------
function PLUGIN:LoadChatCommands()
    for _, cmd in pairs(self.Config.Settings.ChatCommands.Mute) do
        command.AddChatCommand(cmd, self.Object, "cmdMute")
    end
    for _, cmd in pairs(self.Config.Settings.ChatCommands.Unmute) do
        command.AddChatCommand(cmd, self.Object, "cmdUnMute")
    end
    for _, cmd in pairs(self.Config.Settings.ChatCommands.AdminMode) do
        command.AddChatCommand(cmd, self.Object, "cmdAdminMode")
    end
    if self.Config.Settings.General.EnableChatHistory == "true" then
        for _, cmd in pairs(self.Config.Settings.ChatCommands.ChatHistory) do
            command.AddChatCommand(cmd, self.Object, "cmdHistory")
        end
    end
    if self.Config.Settings.Wordfilter.EnableWordfilter== "true" then
        for _, cmd in pairs(self.Config.Settings.ChatCommands.Wordfilter) do
            command.AddChatCommand(cmd, self.Object, "cmdEditWordFilter")
        end
    end
    for _, cmd in pairs(self.Config.Settings.ChatCommands.GlobalMute) do
        command.AddChatCommand(cmd, self.Object, "cmdGlobalMute")
    end
    -- Console commands
    command.AddConsoleCommand("player.mute", self.Object, "ccmdMute")
    command.AddConsoleCommand("player.unmute", self.Object, "ccmdUnMute")
end
-- --------------------------------
-- handles all data files
-- --------------------------------
function PLUGIN:LoadDataFiles()
    muteData = datafile.GetDataTable(MuteList) or {}
    spamData = datafile.GetDataTable(SpamList) or {}
end
-- --------------------------------
-- handles localization file
-- --------------------------------
function PLUGIN:LoadLocalization()
    local configPath = self.Plugin.Manager.ConfigPath
    local fileName = configPath .. "/"..LangFile..".json"
    local langData = new(self.Plugin.Config:GetType(), nil)
    langData:Load(fileName)
    if not langData.Localization then
        error("Your ChatHandler localization file is corrupt. ChatHandler wont work properly")
        return
    end
    langString = langData.Localization[self.Config.Settings.General.Language]
end
-- --------------------------------
-- register all permissions for group system
-- --------------------------------
function PLUGIN:RegisterPermissions()
    -- command permissions
    for _, perm in pairs(self.Config.Settings.Permissions) do
        if not permission.PermissionExists(perm) then
            permission.RegisterPermission(perm, self.Object)
        end
    end
    -- group permissions
    if self.Config.Settings.Groups.EnableGroups == "true" then
        for key, _ in pairs(self.Config.ChatGroups) do
            permission.RegisterPermission(self.Config.ChatGroups[key].Permission, self.Object)
        end
    end
end
-- --------------------------------
-- removes expired mutes from the mutelist
-- --------------------------------
function PLUGIN:CleanUpMuteList()
    local now = time.GetUnixTimestamp()
    for key, _ in pairs(muteData) do
        if muteData[key].expiration < now and muteData[key].expiration ~= 0 then
            table.remove(muteData, key)
            datafile.SaveDataTable(MuteList)
        end
    end
end
-- --------------------------------
-- broadcasts chat messages
-- --------------------------------
function PLUGIN:BroadcastChat(player, name, msg)
    local steamID = rust.UserIDFromPlayer(player)
    if AdminMode[steamID] then
        global.ConsoleSystem.Broadcast("chat.add", 0, name..": "..msg)
    else
        global.ConsoleSystem.Broadcast("chat.add", steamID, name..": "..msg)
    end
end
-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end
-- --------------------------------
-- returns (bool)IsMuted, (string)timeMuted
-- --------------------------------
function PLUGIN:CheckMute(targetSteamID)
    local now = time.GetUnixTimestamp()
    if not muteData[targetSteamID] then return false, false end
    if muteData[targetSteamID].expiration < now and muteData[targetSteamID].expiration ~= 0 then
        muteData[targetSteamID] = nil
        datafile.SaveDataTable(MuteList)
        return false, false
    end
    if muteData[targetSteamID].expiration == 0 then
        return true, false
    else
        local expiration = muteData[targetSteamID].expiration
        local muteTime = expiration - now
        local hours = string.format("%02.f", math.floor(muteTime / 3600))
        local minutes = string.format("%02.f", math.floor(muteTime / 60 - (hours * 60)))
        local seconds = string.format("%02.f", math.floor(muteTime - (hours * 3600) - (minutes * 60)))
        local expirationString = tostring(hours.."h "..minutes.."m "..seconds.."s")
        return true, expirationString
    end
    return false, false
end
-- --------------------------------
-- handles chat command /admin
-- --------------------------------
function PLUGIN:cmdAdminMode(player)
    if not HasPermission(player, self.Config.Settings.Permissions.AdminMode) then
        rust.SendChatMessage(player, langString.AdminNotifications["NoPermission"])
        return
    end
    local steamID = rust.UserIDFromPlayer(player)
    if AdminMode[steamID] then
        AdminMode[steamID] = nil
        rust.SendChatMessage(player, langString.AdminNotifications["AdminModeDisabled"])
    else
        AdminMode[steamID] = true
        rust.SendChatMessage(player, langString.AdminNotifications["AdminModeEnabled"])
    end
end
-- --------------------------------
-- handles chat command /globalmute
-- --------------------------------
function PLUGIN:cmdGlobalMute(player)
    if not HasPermission(player, self.Config.Settings.Permissions.GlobalMute) then
        rust.SendChatMessage(player, langString.AdminNotifications["NoPermission"])
        return
    end
    if not GlobalMute then
        GlobalMute = true
        rust.BroadcastChat(langString.PlayerNotifications["GlobalMuteEnabled"])
    else
        GlobalMute = false
        rust.BroadcastChat(langString.PlayerNotifications["GlobalMuteDisabled"])
    end
end
-- --------------------------------
-- handles chat command /mute
-- --------------------------------
function PLUGIN:cmdMute(player, cmd, args)
    if not HasPermission(player, self.Config.Settings.Permissions.Mute) then
        rust.SendChatMessage(player, langString.AdminNotifications["NoPermission"])
        return
    end
    local args = self:ArgsToTable(args, "chat")
    local target, duration = args[1], args[2]
    if not target then
        rust.SendChatMessage(player, "Syntax: /mute <name/steamID> <time[m/h] (optional)>")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        rust.SendChatMessage(player, langString.AdminNotifications["PlayerNotFound"])
        return
    end
    self:Mute(player, targetPlayer, duration, nil)
end
-- --------------------------------
-- handles console command player.mute
-- --------------------------------
function PLUGIN:ccmdMute(arg)
    local player, F1Console
    if arg.connection then
        player = arg.connection.player
    end
    if player then F1Console = true end
    if player and not HasPermission(player, self.Config.Settings.Permissions.Mute) then
        arg:ReplyWith(langString.AdminNotifications["NoPermission"])
        return true
    end
    local args = self:ArgsToTable(arg, "console")
    local target, duration = args[1], args[2]
    if not target then
        if F1Console then
            arg:ReplyWith("Syntax: player.mute <name/steamID> <time[m/h] (optional)>")
        else
            printToConsole("Syntax: player.mute <name/steamID> <time[m/h] (optional)>")
        end
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        if F1Console then
            arg:ReplyWith(langString.AdminNotifications["PlayerNotFound"])
        else
            printToConsole(langString.AdminNotifications["PlayerNotFound"])
        end
        return
    end
    self:Mute(player, targetPlayer, duration, arg)
end
-- --------------------------------
-- mute target
-- --------------------------------
function PLUGIN:Mute(player, targetPlayer, duration, arg)
    local targetName = targetPlayer.displayName
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    -- define source of command trigger
    local F1Console, srvConsole, chatCmd
    if player and arg then F1Console = true end
    if not player then srvConsole = true end
    if player and not arg then chatCmd = true end
    -- Check if target is already muted
    local isMuted, _ = self:CheckMute(targetSteamID)
    if isMuted then
        if F1Console then
            arg:ReplyWith(buildOutput(langString.AdminNotifications["AlreadyMuted"], {"{name}"}, {targetName}))
        end
        if srvConsole then
            printToConsole(buildOutput(langString.AdminNotifications["AlreadyMuted"], {"{name}"}, {targetName}))
        end
        if chatCmd then
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["AlreadyMuted"], {"{name}"}, {targetName}))
        end
        return
    end
    if not duration then
    -- No time is given, mute permanently
        muteData[targetSteamID] = {}
        muteData[targetSteamID].steamID = targetSteamID
        muteData[targetSteamID].expiration = 0
        table.insert(muteData, muteData[targetSteamID])
        datafile.SaveDataTable(MuteList)
        -- Send mute notice
        if self.Config.Settings.General.BroadcastMutes == "true" then
            rust.BroadcastChat(buildOutput(langString.PlayerNotifications["BroadcastMutes"], {"{name}"}, {targetName}))
            if F1Console then
                arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerMuted"], {"{name}"}, {targetName}))
            end
            if srvConsole then
                printToConsole(buildOutput(langString.AdminNotifications["PlayerMuted"], {"{name}"}, {targetName}))
            end
        else
            if F1Console then
                arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerMuted"], {"{name}"}, {targetName}))
            end
            if srvConsole then
                printToConsole(buildOutput(langString.AdminNotifications["PlayerMuted"], {"{name}"}, {targetName}))
            end
            if chatCmd then
                rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["PlayerMuted"], {"{name}"}, {targetName}))
            end
            rust.SendChatMessage(targetPlayer, langString.PlayerNotifications["Muted"])
        end
        -- Send console log
        if self.Config.Settings.Logging.LogToConsole == "true" then
            if not player then
                printToConsole("[ChatHandler] An admin muted "..targetName)
            else
                printToConsole("[ChatHandler] "..player.displayName.." muted "..targetName)
            end
        end
        -- log to file
        if self.Config.Settings.Logging.LogToFile == "true" then
            if not player then
                printToFile("An admin muted "..targetName)
            else
                printToFile(player.displayName.." muted "..targetName)
            end
        end
        return
    end
    -- Time is given, mute only for this timeframe
    -- Check for valid time format
    local c = string.match(duration, "^%d*[mh]$")
    if string.len(duration) < 2 or not c then
        if F1Console then
            arg:ReplyWith(langString.AdminNotifications["InvalidTimeFormat"])
        end
        if srvConsole then
            printToConsole(langString.AdminNotifications["InvalidTimeFormat"])
        end
        if chatCmd then
            rust.SendChatMessage(player, langString.AdminNotifications["InvalidTimeFormat"])
        end
        return
    end
    -- Build expiration time
    local now = time.GetUnixTimestamp()
    local muteTime = tonumber(string.sub(duration, 1, -2))
    local timeUnit = string.sub(duration, -1)
    local timeMult, timeUnitLong
    if timeUnit == "m" then
        timeMult = 60
        timeUnitLong = "minutes"
    end
    if timeUnit == "h" then
        timeMult = 3600
        timeUnitLong = "hours"
    end
    local expiration = (now + (muteTime * timeMult))
    local time = muteTime.." "..timeUnitLong
    -- Mute player for given duration
    muteData[targetSteamID] = {}
    muteData[targetSteamID].steamID = targetSteamID
    muteData[targetSteamID].expiration = expiration
    table.insert(muteData, muteData[targetSteamID])
    datafile.SaveDataTable(MuteList)
    -- Send mute notice
    if self.Config.Settings.General.BroadcastMutes == "true" then
        rust.BroadcastChat(buildOutput(langString.PlayerNotifications["BroadcastMutesTimed"], {"{name}", "{time}"}, {targetName, time}))
        if F1Console then
            arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerMutedTimed"], {"{name}", "{time}"}, {targetName, time}))
        end
        if srvConsole then
            printToConsole(buildOutput(langString.AdminNotifications["PlayerMutedTimed"], {"{name}", "{time}"}, {targetName, time}))
        end
    else
        rust.SendChatMessage(targetPlayer, buildOutput(langString.PlayerNotifications["MutedTimed"], {"{time}"}, {time}))
        if F1Console then
            arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerMutedTimed"], {"{name}", "{time}"}, {targetName, time}))
        end
        if srvConsole then
            printToConsole(buildOutput(langString.AdminNotifications["PlayerMutedTimed"], {"{name}", "{time}"}, {targetName, time}))
        end
        if chatCmd then
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["PlayerMutedTimed"], {"{name}", "{time}"}, {targetName, time}))
        end
    end
    -- Send console log
    if self.Config.Settings.Logging.LogToConsole == "true" then
        if not player then
            printToConsole("[ChatHandler] An admin muted "..targetName.." for "..muteTime.." "..timeUnitLong)
        else
            printToConsole("[ChatHandler] "..player.displayName.." muted "..targetName.." for "..muteTime.." "..timeUnitLong)
        end
    end
    -- log to file
    if self.Config.Settings.Logging.LogToFile == "true" then
        if not player then
            printToFile("An admin muted "..targetName.." for "..muteTime.." "..timeUnitLong)
        else
            printToFile(player.displayName.." muted "..targetName.." for "..muteTime.." "..timeUnitLong)
        end
    end
end
-- --------------------------------
-- handles chat command /unmute
-- --------------------------------
function PLUGIN:cmdUnMute(player, cmd, args)
    if not HasPermission(player, self.Config.Settings.Permissions.Mute) then
        rust.SendChatMessage(player, langString.AdminNotifications["NoPermission"])
        return
    end
    local args = self:ArgsToTable(args, "chat")
    local target = args[1]
    -- Check for valid syntax
    if not target then
        rust.SendChatMessage(player, "Syntax: /unmute <name|steamID> or /unmute all to clear mutelist")
        return
    end
    -- Check if "all" is used to clear the whole mutelist
    if target == "all" then
        local mutecount = #muteData
        muteData = {}
        datafile.SaveDataTable(MuteList)
        rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["MutelistCleared"], {"{count}"}, {tostring(mutecount)}))
        return
    end
    -- Try to get target netuser
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        rust.SendChatMessage(player, langString.AdminNotifications["PlayerNotFound"])
        return
    end
    self:Unmute(player, targetPlayer, nil)
end
-- --------------------------------
-- handles console command player.unmute
-- --------------------------------
function PLUGIN:ccmdUnMute(arg)
    local player, F1Console
    if arg.connection then
        player = arg.connection.player
    end
    if player then F1Console = true end
    if player and not HasPermission(player, self.Config.Settings.Permissions.Mute) then
        arg:ReplyWith(langString.AdminNotifications["NoPermission"])
        return true
    end
    local args = self:ArgsToTable(arg, "console")
    local target = args[1]
    if not target then
        if F1Console then
            arg:ReplyWith("Syntax: player.unmute <name/steamID> or player.unmute all to clear mutelist")
        else
            printToConsole("Syntax: player.unmute <name/steamID> or player.unmute all to clear mutelist")
        end
        return
    end
    -- Check if "all" is used to clear the whole mutelist
    if target == "all" then
        local mutecount = #muteData
        muteData = {}
        datafile.SaveDataTable(MuteList)
        if F1Console then
            arg:ReplyWith(buildOutput(langString.AdminNotifications["MutelistCleared"], {"{count}"}, {tostring(mutecount)}))
        else
            printToConsole(buildOutput(langString.AdminNotifications["MutelistCleared"], {"{count}"}, {tostring(mutecount)}))
        end
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        if F1Console then
            arg:ReplyWith(langString.AdminNotifications["PlayerNotFound"])
        else
            printToConsole(langString.AdminNotifications["PlayerNotFound"])
        end
        return
    end
    self:Unmute(player, targetPlayer, arg)
end
-- --------------------------------
-- unmute target
-- --------------------------------
function PLUGIN:Unmute(player, targetPlayer, arg)
    local targetName = targetPlayer.displayName
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    -- define source of command trigger
    local F1Console, srvConsole, chatCmd
    if player and arg then F1Console = true end
    if not player then srvConsole = true end
    if player and not arg then chatCmd = true end
    -- Unmute player
    if muteData[targetSteamID] then
        muteData[targetSteamID] = nil
        datafile.SaveDataTable(MuteList)
        -- Send unmute notice
        if self.Config.Settings.General.BroadcastMutes == "true" then
            rust.BroadcastChat(buildOutput(langString.PlayerNotifications["BroadcastUnmutes"], {"{name}"}, {targetName}))
            if F1Console then
                arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerUnmuted"], {"{name}"}, {targetName}))
            end
            if srvConsole then
                printToConsole(buildOutput(langString.AdminNotifications["PlayerUnmuted"], {"{name}"}, {targetName}))
            end
        else
            rust.SendChatMessage(targetPlayer, langString.PlayerNotifications["Unmuted"])
            if F1Console then
                arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerUnmuted"], {"{name}"}, {targetName}))
            end
            if srvConsole then
                printToConsole(buildOutput(langString.AdminNotifications["PlayerUnmuted"], {"{name}"}, {targetName}))
            end
            if chatCmd then
                rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["PlayerUnmuted"], {"{name}"}, {targetName}))
            end
        end
        -- Send console log
        if self.Config.Settings.Logging.LogToConsole == "true" then
            if player then
                printToConsole("[ChatHandler] "..player.displayName.." unmuted "..targetName)
            else
                printToConsole("[ChatHandler] An admin unmuted "..targetName)
            end
        end
        -- log to file
        if self.Config.Settings.Logging.LogToFile == "true" then
            if player then
                printToFile(player.displayName.." unmuted "..targetName)
            else
                printToFile("An admin unmuted "..targetName)
            end
        end
        return
    end
    -- player is not muted
    if F1Console then
        arg:ReplyWith(buildOutput(langString.AdminNotifications["PlayerNotMuted"], {"{name}"}, {targetName}))
    end
    if srvConsole then
        printToConsole(buildOutput(langString.AdminNotifications["PlayerNotMuted"], {"{name}"}, {targetName}))
    end
    if chatCmd then
        rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["PlayerNotMuted"], {"{name}"}, {targetName}))
    end
end
-- --------------------------------
-- handles chat messages
-- --------------------------------
function PLUGIN:OnPlayerChat(arg)
    local msg = arg:GetString(0, "text")
    local player = arg.connection.player
    if string.sub(msg, 1, 1) == "/" or msg == "" then return end
    local steamID = rust.UserIDFromPlayer(player)
    -- Spam prevention
    if self.Config.Settings.AntiSpam.EnableAntiSpam == "true" then
        local isSpam, punishTime = self:AntiSpamCheck(player)
        if isSpam then
            rust.SendChatMessage(player, buildOutput(langString.PlayerNotifications["AutoMuted"], {"{punishTime}"}, {punishTime}))
            timer.Once(4, function() rust.SendChatMessage(player, langString.PlayerNotifications["SpamWarning"]) end)
            if self.Config.Settings.General.BroadcastMutes == "true" then
                rust.BroadcastChat(buildOutput(langString.PlayerNotifications["BroadcastAutoMutes"], {"{name}", "{punishTime}"}, {player.displayName, punishTime}))
            end
            if self.Config.Settings.Logging.LogToConsole == "true" then
                printToConsole("[ChatHandler] "..player.displayName.." got a "..punishTime.." auto mute for spam")
            end
            if self.Config.Settings.Logging.LogToFile == "true" then
                printToFile(player.displayName.." got a "..punishTime.." auto mute for spam")
            end
            return false
        end
    end
    -- Parse message to filter stuff and check if message should be blocked
    local canChat, msg, errorMsg, errorPrefix = self:ParseChat(player, msg)
    -- Chat is blocked
    if not canChat then
        if self.Config.Settings.Logging.LogBlockedMessages == "true" then
            if self.Config.Settings.Logging.LogToConsole == "true" then
                global.ServerConsole.PrintColoured(System.ConsoleColor.Cyan, errorPrefix, System.ConsoleColor.DarkYellow, " "..player.displayName..": ", System.ConsoleColor.DarkGreen, msg)
            end
            if self.Config.Settings.Logging.LogToFile == "true" then
                global.server.Log("Log.Chat.txt", errorPrefix.." "..steamID.."/"..player.displayName..": "..msg.."\n")
            end
        end
        rust.SendChatMessage(player, errorMsg)
        return false
    end
    -- Chat is ok and not blocked
    local maxCharsPerLine = tonumber(self.Config.Settings.General.MaxCharsPerLine)
    msg = splitLongMessages(msg, maxCharsPerLine) -- msg is a table now
    local i = 1
    while msg[i] do
        local username, message, logUsername, logMessage = self:BuildNameMessage(player, msg[i])
        self:SendChat(player, username, message, logUsername, logMessage)
        i = i + 1
    end
    return false
end
-- --------------------------------
-- checks for chat spam
-- returns (bool)IsSpam, (string)punishTime
-- --------------------------------
function PLUGIN:AntiSpamCheck(player)
    local steamID = rust.UserIDFromPlayer(player)
    local now = time.GetUnixTimestamp()
    if muteData[steamID] then return false, false end
    if AdminMode[steamID] then return false, false end
    if AntiSpam[steamID] then
        local firstMsg = AntiSpam[steamID].timestamp
        local msgCount = AntiSpam[steamID].msgcount
        if msgCount < self.Config.Settings.AntiSpam.MaxLines then
            AntiSpam[steamID].msgcount = AntiSpam[steamID].msgcount + 1
            return false, false
        else
            if now - firstMsg <= self.Config.Settings.AntiSpam.TimeFrame then
                -- punish
                local punishCount = 1
                local expiration, punishTime, newEntry
                if spamData[steamID] then
                    newEntry = false
                    punishCount = spamData[steamID].punishcount + 1
                    spamData[steamID].punishcount = punishCount
                    datafile.SaveDataTable(SpamList)
                end
                if punishCount == 1 then
                    expiration =  now + 300
                    punishTime = "5 minutes"
                elseif punishCount == 2 then
                    expiration = now + 3600
                    punishTime = "1 hour"
                else
                    expiration = 0
                    punishTime = "permanent"
                end
                if newEntry ~= false then
                    spamData[steamID] = {}
                    spamData[steamID].steamID = steamID
                    spamData[steamID].punishcount = punishCount
                    table.insert(spamData, spamData[steamID])
                    datafile.SaveDataTable(SpamList)
                end
                muteData[steamID] = {}
                muteData[steamID].steamID = steamID
                muteData[steamID].expiration = expiration
                table.insert(muteData, muteData[steamID])
                datafile.SaveDataTable(MuteList)
                AntiSpam[steamID] = nil
                return true, punishTime
            else
                AntiSpam[steamID].timestamp = now
                AntiSpam[steamID].msgcount = 1
                return false, false
            end
        end
    else
        AntiSpam[steamID] = {}
        AntiSpam[steamID].timestamp = now
        AntiSpam[steamID].msgcount = 1
        return false, false
    end
end
-- --------------------------------
-- parses the chat
-- returns (bool)canChat, (string)msg, (string)errorMsg, (string)errorPrefix
-- --------------------------------
function PLUGIN:ParseChat(player, msg)
    local msg = tostring(msg)
    local steamID = rust.UserIDFromPlayer(player)
    if AdminMode[steamID] then return true, msg, false, false end
    -- Check player specific mute
    local isMuted, timeMuted = self:CheckMute(steamID)
    if isMuted then
        if not timeMuted then
            return false, msg, langString.PlayerNotifications["IsMuted"], "[MUTED]"
        else
            return false, msg, buildOutput(langString.PlayerNotifications["IsTimeMuted"], {"{timeMuted}"}, {timeMuted}), "[MUTED]"
        end
    end
    -- Check global mute
    if GlobalMute and not HasPermission(player, self.Config.Settings.Permissions.AntiGlobalMute) then
        return false, msg, langString.PlayerNotifications["GlobalMuted"], "[MUTED]"
    end
    -- Check for server advertisements
    if self.Config.Settings.General.BlockServerAds == "true" then
        local ipCheck
        local ipString = ""
        local chunks = {string.match(msg, "(%d+)%.(%d+)%.(%d+)%.(%d+)") }
        if #chunks == 4 then
            for _,v in pairs(chunks) do
                if tonumber(v) < 0 or tonumber(v) > 255 then
                    ipCheck = false
                    break
                end
                ipString = ipString..v.."."
                ipCheck = true
            end
            -- remove the last dot
            if string.sub(ipString, -1) == "." then
                ipString = string.sub(ipString, 1, -2)
            end
        else
            ipCheck = false
        end
        if ipCheck then
            local allowedIP = false
            for key, value in pairs(self.Config.Settings.General.AllowedIPsToPost) do
                if string.match(self.Config.Settings.General.AllowedIPsToPost[key], ipString) then
                    allowedIP = true
                end
            end
            if not allowedIP then
                return false, msg, langString.PlayerNotifications["AdWarning"], "[BLOCKED]"
            end
        end
    end
    -- Check for blacklisted words
    if self.Config.Settings.Wordfilter.EnableWordfilter== "true" then
        for key, value in pairs(self.Config.WordFilter) do
            local first, last = string.find(string.lower(msg), string.lower(key), nil, true)
            if first then
                while first do
                    local before = string.sub(msg, 1, first - 1)
                    local after = string.sub(msg, last + 1)
                    -- replace whole word if parts are blacklisted
                    if self.Config.Settings.Wordfilter.ReplaceFullWord == "true" then
                        if string.sub(before, -1) ~= " " and string.len(before) > 0 then
                            local spaceStart, spaceEnd = string.find(string.reverse(before), " ")
                            if spaceStart then
                                before = string.reverse(string.sub(before, spaceStart + 1))
                            else
                                before = ""
                            end
                        end
                        if string.sub(after, 1, 1) ~= " " and string.len(after) > 0 then
                            local spaceStart, spaceEnd = string.find(after, " ")
                            if spaceStart then
                                after = string.sub(after, spaceStart)
                            else
                                after = ""
                            end
                        end
                    end
                    msg = before..value..after
                    first, last = string.find(string.lower(msg), string.lower(key), nil, true)
                end
            end
        end
    end
    -- show dem sneaky color tags
    msg = string.gsub(string.lower(msg), "<color", "<\\color\\")
    msg = string.gsub(string.lower(msg), "color>", "\\color\\>")
    return true, msg, false, false
end
-- --------------------------------
-- builds username and chatmessage
-- returns (string)username, (string)message
-- --------------------------------
function PLUGIN:BuildNameMessage(player, msg)
    local username, logUsername = player.displayName, player.displayName
    local message, logMessage = msg, msg
    local steamID = rust.UserIDFromPlayer(player)
    local foundPerm = false
    if AdminMode[steamID] then
        if self.Config.Settings.AdminMode.ReplaceChatName == "true" then
            username = "<color="..self.Config.Settings.NameColor.AdminMode..">"..self.Config.Settings.AdminMode.AdminChatName.."</color>"
            message = "<color="..self.Config.Settings.NameColor.AdminMode..">"..message.."</color>"
            logUsername = self.Config.Settings.AdminMode.AdminChatName
            logMessage = msg
            return username, message, logUsername, logMessage
        else
            username = "<color="..self.Config.Settings.NameColor.AdminMode..">"..username.."</color>"
            message = "<color="..self.Config.Settings.NameColor.AdminMode..">"..message.."</color>"
            logUsername = self.Config.Settings.AdminMode.AdminChatName
            logMessage = msg
            return username, message, logUsername, logMessage
        end
    end
    if self.Config.Settings.Groups.EnableGroups == "true" then
        for key, value in pairs(self.Config.ChatGroups) do
            if permission.UserHasPermission(steamID, self.Config.ChatGroups[key].Permission) then
                if self.Config.ChatGroups[key].ShowPrefix == true then
                    if self.Config.Settings.Groups.PrefixPosition == "left" then
                        username = self.Config.ChatGroups[key].Prefix.." "..username
                        logUsername = self.Config.ChatGroups[key].Prefix.." "..logUsername
                    else
                        username = username.." "..self.Config.ChatGroups[key].Prefix
                        logUsername = logUsername.." "..self.Config.ChatGroups[key].Prefix
                    end
                end
                if self.Config.ChatGroups[key].ShowColor then
                    if self.Config.Settings.Groups.ColorNamesOnly == "true" then
                        username = "<color="..self.Config.ChatGroups[key].Color..">"..username.."</color>"
                    else
                        username = "<color="..self.Config.ChatGroups[key].Color..">"..username.."</color>"
                        message = "<color="..self.Config.ChatGroups[key].Color..">"..message.."</color>"
                    end
                else
                    username = "<color="..self.Config.Settings.NameColor.NormalUser..">"..username.."</color>"
                end
                foundPerm = true
            end
        end
    end
    if not foundPerm then
        username = "<color="..self.Config.Settings.NameColor.NormalUser..">"..username.."</color>"
    end
    -- Add title if plugin RanksAndTitles is installed
    if exRanksAndTitles then
        local title = exRanksAndTitles:Call("grabPlayerData", steamID, "Title")
        local hideTitle = exRanksAndTitles:Call("grabPlayerData", steamID, "hidden")
        local colorOn = exRanksAndTitles.Config.Settings.colorSupport
        local color = exRanksAndTitles:Call("getColor", steamID)
        if not hideTitle and title ~= "" and colorOn then
            username = username.."<color="..color.."> ["..title.."]</color>"
            logUsername = logUsername.." ["..title.."]"
        end
        if not hideTitle and title ~= "" and not colorOn then
            if string.sub(username, -8) == "</color>" then
                username = string.sub(username, 1, -9).." ["..title.."]</color>"
                logUsername = logUsername.." ["..title.."]"
            else
                username = username.." ["..title.."]"
                logUsername = logUsername.." ["..title.."]"
            end
        end
    end
    return username, message, logUsername, logMessage
end
-- --------------------------------
-- sends and logs chat messages
-- --------------------------------
function PLUGIN:SendChat(player, name, msg, logName, logMsg)
    local steamID = rust.UserIDFromPlayer(player)
    -- Broadcast chat ingame
    self:BroadcastChat(player, name, msg)
    -- Log chat to console
    global.ServerConsole.PrintColoured(System.ConsoleColor.DarkYellow, logName..": ", System.ConsoleColor.DarkGreen, logMsg)
    -- Log chat to Rusty chat stream
    UnityEngine.Debug.Log.methodarray[0]:Invoke(nil, util.TableToArray({"[CHAT] "..logName..": "..logMsg}))
    -- Log chat to log file
    global.server.Log("Log.Chat.txt", steamID.."/"..logName..": "..logMsg.."\n")
    -- Log chat history
    if self.Config.Settings.General.EnableChatHistory == "true" then
        self:InsertHistory(name, steamID, msg)
    end
end
-- --------------------------------
-- remove data on disconnect
-- --------------------------------
function PLUGIN:OnPlayerDisconnected(player)
    local steamID = rust.UserIDFromPlayer(player)
    AntiSpam[steamID] = nil
    AdminMode[steamID] = nil
end
-- --------------------------------
-- handles chat command for chat history
-- --------------------------------
function PLUGIN:cmdHistory(player)
    if #ChatHistory > 0 then
        rust.SendChatMessage(player, "ChatHistory", "----------")
        local i = 1
        while ChatHistory[i] do
            rust.SendChatMessage(player, ChatHistory[i].name, ChatHistory[i].msg, ChatHistory[i].steamID)
            i = i + 1
        end
        rust.SendChatMessage(player, "ChatHistory", "----------")
    else
        rust.SendChatMessage(player, "ChatHistory", langString.PlayerNotifications["NoChatHistory"])
    end
end
-- --------------------------------
-- inserts chat messages into history
-- --------------------------------
function PLUGIN:InsertHistory(name, steamID, msg)
    if #ChatHistory == self.Config.Settings.General.ChatHistoryMaxLines then
        table.remove(ChatHistory, 1)
    end
    table.insert(ChatHistory, {["name"] = name, ["steamID"] = steamID, ["msg"] = msg})
end
-- --------------------------------
-- handles chat command /wordfilter
-- --------------------------------
function PLUGIN:cmdEditWordFilter(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local func, word, replacement = args[1], args[2], args[3]
    if not func or func ~= "add" and func ~= "remove" and func ~= "list" then
        if not HasPermission(player, self.Config.Settings.Permissions.EditWordFilter) then
            rust.SendChatMessage(player, "Syntax /wordfilter list")
        else
            rust.SendChatMessage(player, "Syntax: /wordfilter add <word> <replacement> or /wordfilter remove <word>")
        end
        return
    end
    if func ~= "list" and not HasPermission(player, self.Config.Settings.Permissions.EditWordFilter) then
        rust.SendChatMessage(player, langString.AdminNotifications["NoPermission"])
        return
    end
    if func == "add" then
        if not replacement then
            rust.SendChatMessage(player, "Syntax: /wordfilter add <word> <replacement>")
            return
        end
        local first, last = string.find(string.lower(replacement), string.lower(word))
        if first then
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["WordfilterError"], {"{replacement}", "{word}"}, {replacement, word}))
            return
        else
            self.Config.WordFilter[word] = replacement
            self:SaveConfig()
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["WordfilterAdded"], {"{word}", "{replacement}"}, {word, replacement}))
        end
        return
    end
    if func == "remove" then
        if not word then
            rust.SendChatMessage(player, "Syntax: /wordfilter remove <word>")
            return
        end
        if self.Config.WordFilter[word] then
            self.Config.WordFilter[word] = nil
            self:SaveConfig()
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["WordfilterRemoved"], {"{word}"}, {word}))
        else
            rust.SendChatMessage(player, buildOutput(langString.AdminNotifications["WordfilterNotFound"], {"{word}"}, {word}))
        end
        return
    end
    if func == "list" then
        local wordFilterList = ""
        for key, _ in pairs(self.Config.WordFilter) do
            wordFilterList = wordFilterList..key..", "
        end
        rust.SendChatMessage(player, buildOutput(langString.PlayerNotifications["WordfilterList"], {"{wordFilterList}"}, {wordFilterList}))
    end
end
-- --------------------------------
-- handles chat command /help
-- --------------------------------
function PLUGIN:SendHelpText(player)
    if self.Config.Settings.General.EnableChatHistory == "true" then
        rust.SendChatMessage(player, langString.HelpText["ChatHistory"])
    end
    if self.Config.Settings.Wordfilter.EnableWordfilter== "true" then
        rust.SendChatMessage(player, langString.HelpText["Wordfilter"])
    end
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\cleanup.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "cleanup"
PLUGIN.Title = "Clean Up"
PLUGIN.Version = V(1, 3, 2)
PLUGIN.Description = "Clean up your server"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true

function PLUGIN:Init()
	command.AddChatCommand( "clean", self.Plugin, "cmdClean" )
	command.AddChatCommand( "count", self.Plugin, "cmdCount" )
	timer.Once(0.1, function() 
		nulVector3 = new(UnityEngine.Vector3._type,nil) 
	end )
end
function PLUGIN:LoadDefaultConfig()
	self.Config.authLevel = 1
end
local function ChatMessage(player,msg)
	player:SendConsoleCommand( "chat.add \"SERVER\" \"" .. msg .. "\"" );
end
local function FindBuilding(entity)
	buildingradius = 3
	local arr = util.TableToArray( { entity.transform.position , buildingradius } )
	util.ConvertAndSetOnArray(arr, 1, buildingradius, System.Single._type)
	local hits = UnityEngine.Physics.OverlapSphere["methodarray"][1]:Invoke(nil,arr)
	local it = hits:GetEnumerator()
	local buildingblock = false
	while (it:MoveNext()) do
		if(it.Current:GetComponentInParent(global.BuildingBlock._type)) then
			buildingblock =  true
			break
		end
	end
	return buildingblock
end
function PLUGIN:cmdCount( player, com, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(args.Length == 0) then
			ChatMessage(player,"/count bags => Gets the number of bags")
			ChatMessage(player,"/count trees => Gets the number of trees")
			ChatMessage(player,"/count resources => Gets the number of resources")
			ChatMessage(player,"/count players => Gets the number of online players")
			ChatMessage(player,"/count sleepers => Gets the number of sleepers")
			ChatMessage(player,"/count buildingblocks => Gets the number of buildingblocks")
			ChatMessage(player,"/count worlditems => Gets the number of worlditems")
			ChatMessage(player,"/count animals => Gets the number of animals")
			ChatMessage(player,"/count cupboards => Gets the number of cupboards")
			return
		end
		if(args.Length >= 1) then
			if(args[0] == "trees") then
				
				local alltrees = UnityEngine.Object.FindObjectsOfTypeAll(global.TreeEntity._type)
				local max = 0
				for i=0, alltrees.Length-1 do
					if(tostring(alltrees[i].hideFlags) == tostring(UnityEngine.HideFlags.HideInHierarchy)) then
						max = max + 1
					end
				end
				ChatMessage(player,"Trees Count: " .. max)
			elseif(args[0] == "bags") then
				ChatMessage(player,"Bags Count: " .. (UnityEngine.Object.FindObjectsOfTypeAll(global.FakePhysics._type).Length-1))
			elseif(args[0] == "resources") then
				ChatMessage(player,"Resources Count: " .. (UnityEngine.Object.FindObjectsOfTypeAll(global.BaseResource._type).Length))
			elseif(args[0] == "players") then
				local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
				local online = 0
				for i=0, players.Length - 1 do
					if(players[i]:IsConnected()) then
						online = online + 1
					end
				end
				ChatMessage(player,"Online Players Count: " .. online)
			elseif(args[0] == "sleepers") then
				local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
				local sleepers = 0
				for i=0, players.Length - 1 do
					if(not players[i]:IsConnected()) then
						sleepers = sleepers + 1
					end
				end
				ChatMessage(player,"Sleepers Players Count: " .. sleepers)
			elseif(args[0] == "buildingblocks") then
				ChatMessage(player,"Building Blocks count: " .. UnityEngine.Object.FindObjectsOfTypeAll(global.BuildingBlock._type).Length)
			elseif(args[0] == "worlditems") then
				ChatMessage(player,"World Items count: " .. UnityEngine.Object.FindObjectsOfTypeAll(global.WorldItem._type).Length)
			elseif(args[0] == "animals") then
				ChatMessage(player,"Animals count: " .. UnityEngine.Object.FindObjectsOfTypeAll(global.BaseNPC._type).Length)
 			elseif(args[0] == "cupboards") then
				ChatMessage(player,"Tool Cupboards count: " .. UnityEngine.Object.FindObjectsOfTypeAll(global.BuildPrivilegeTrigger._type).Length-1)
			end
		end
	end
end
function PLUGIN:cmdClean( player, com, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(args.Length == 0) then
			ChatMessage(player,"Clean Tool")
			ChatMessage(player,"/clean bags => clean all world bags that are not connected to a building")
			ChatMessage(player,"/clean bags all => clean all world bags")
			ChatMessage(player,"/clean cupboards => clean all Tool Cupboards that are not connected to a building")
			ChatMessage(player,"/clean cupboards all => clean all Tool Cupboards bags")
			ChatMessage(player,"/clean trees => cleans 50% of the trees")
			ChatMessage(player,"/clean trees all => clean 100% of the trees")
			ChatMessage(player,"/clean trees 0-1 => cleans 0% to 100% of the trees")
			ChatMessage(player,"/clean animals => cleans 50% of the animals")
			ChatMessage(player,"/clean animals all => clean 100% of the animals")
			ChatMessage(player,"/clean animals 0-1 => cleans 0% to 100% of the animals")
			return
		end
		local ttype = 0
		if(args.Length >= 2 and args[1] and args[1] == "all") then
			ttype = 1
		end
		-------- Get all items that are outside boxes, laying in the open world --------
		if(args.Length >= 1 and args[0] == "bags") then
			local fakephysics = UnityEngine.Object.FindObjectsOfTypeAll(global.FakePhysics._type)
			local max = 0
			local removed = 0
			for i=(fakephysics.Length-1), 0, -1 do
				local worlditem = fakephysics[i]:GetComponent("WorldItem")
				if(worlditem) then
					max = max + 1
					if(ttype == 1) then
						if(worlditem:GetItem()) then -- this is used to check that you are not removing the world_generic
							worlditem:GetItem():SetWorldEntity(nil)
							worlditem:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
							removed = removed + 1
						end
					else
						if(worlditem:GetItem()) then -- this is used to check that you are not removing the world_generic
							if(not FindBuilding(worlditem)) then -- check if the item in on a building or not
								worlditem:GetItem():SetWorldEntity(nil)
								worlditem:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
								removed = removed + 1
							end
						end
					end
				end
			end
			if(ttype == 1) then
				ChatMessage(player,"Cleaned up " .. removed .. " bags")
			else
				ChatMessage(player,"Cleaned up " .. removed .. " bags out of " .. max .. " total bags")
			end
		elseif(args.Length >= 1 and args[0] == "cupboards") then
			local allTriggerBase = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
			local max = 0
			local removed = 0
			for i=(allTriggerBase.Length-1), 0, -1 do
				if(allTriggerBase[i]:GetComponent("BuildPrivilegeTrigger")) then
					if(allTriggerBase[i].privlidgeEntity and allTriggerBase[i].privlidgeEntity:GetComponentInChildren(UnityEngine.Rigidbody._type) ~= nil) then -- check if not going to destroy the source tool cupboard that would make everything bug if deleted 
						max = max + 1
						if(ttype == 1) then
							allTriggerBase[i].privlidgeEntity:GetComponent("BaseEntity"):Kill(ProtoBuf.Mode.None,0,0,nulVector3)
							removed = removed + 1
						else
							if(not FindBuilding(allTriggerBase[i].privlidgeEntity:GetComponent("BaseEntity"))) then -- check if the item in on a building or not
								allTriggerBase[i].privlidgeEntity:GetComponent("BaseEntity"):Kill(ProtoBuf.Mode.None,0,0,nulVector3)
								removed = removed + 1
							end
						end
					end
				end
			end
			if(ttype == 1) then
				ChatMessage(player,"Cleaned up " .. removed .. " Tool Cupboards")
			else
				ChatMessage(player,"Cleaned up " .. removed .. " Tool Cupboards out of " .. max .. " total cupboards")
			end
		elseif(args.Length >= 1 and args[0] == "trees") then
			local percent = 50
			if(args.Length >= 2 and args[1] and tonumber(args[1]) ~= nil) then
				if(tonumber(args[1]) > 1) then
					ChatMessage(player,"Invalid range: 0 to 1 (0.5 = 50%)")
					return
				end
				ttype = 0
				percent = tonumber(args[1]) * 100
			end
			local trees = UnityEngine.Object.FindObjectsOfTypeAll(global.TreeEntity._type)
			local max = 0
			local removed = 0
			for i=(trees.Length-1), 0, -1 do
				if(trees[i]:GetComponentInChildren(global.Spawnable._type)) then
					max = max + 1
					if(ttype == 1) then
						trees[i]:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
						removed = removed + 1
					else
						if(math.random(0,100) <= percent) then
							trees[i]:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
							removed = removed + 1
						end
					end
				end
			end
			ChatMessage(player,"Cleaned up " .. removed .. " trees (" .. (removed/max)*100 .. "%)" )
		elseif(args.Length >= 1 and args[0] == "animals") then
			local percent = 50
			if(args.Length >= 2 and args[1] and tonumber(args[1]) ~= nil) then
				if(tonumber(args[1]) > 1) then
					ChatMessage(player,"Invalid range: 0 to 1 (0.5 = 50%)")
					return
				end
				ttype = 0
				percent = tonumber(args[1]) * 100
			end
			local animals = UnityEngine.Object.FindObjectsOfTypeAll(global.BaseNPC._type)
			local max = 0
			local removed = 0
			for i=(animals.Length-1), 0, -1 do
				if(animals[i]:GetComponentInChildren(global.Spawnable._type)) then
					max = max + 1
					if(ttype == 1) then
						animals[i]:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
						removed = removed + 1
					else
						if(math.random(0,100) <= percent) then
								animals[i]:Kill(ProtoBuf.Mode.None,0,0,nulVector3)
								removed = removed + 1
						end
					end
				end
			end
			ChatMessage(player,"Cleaned up " .. removed .. " Animals (" .. (removed/max)*100 .. "%)" )
		end
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\commandblock.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Command Block"
PLUGIN.Version = V(0, 2, 3)
PLUGIN.Description = "Blocks configured commands sent by a client to the server."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/resources/647/"
PLUGIN.ResourceId = 647
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Add chat and console commands to add/remove from the block list

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:OnRunCommand(arg)
    if not arg then return end
    if not arg.connection then return end
    if not arg.connection.player then return end
    if not arg.cmd then return end
    if not arg.cmd.name then return end
    local player = arg.connection.player
    local command = arg.cmd.namefull
    local blocked = false
    for key, setting in pairs(self.Config.Settings.Commands) do
        if setting:match("^(" .. command .. ")$") then blocked = true end
        if blocked then
            if player then
                rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.Blocked)
                player:SendConsoleCommand("echo " .. self.Config.Messages.Blocked)
            end
            if debug then print("[" .. self.Title .. "] Player tried to run console command \"" .. arg.cmd.name .. "\" but was blocked by configuration") end
            return false 
        end
    end
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "SERVER"
    self.Config.Settings.Commands = self.Config.Settings.Commands or { "kill", "server.seed" }
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.Blocked = self.Config.Messages.Blocked or "Sorry, that command is blocked!"
    self.Config.Messages.CommandBlocked = nil -- Removed n 0.2.3
    self.Config.Messages.ChatCommand = nil -- Removed n 0.2.3, temporarily
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\countryblock.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Country Block"
PLUGIN.Version = V(0, 1, 7)
PLUGIN.Description = "Allows or blocks players from specific countries via a whitelist or blacklist of country codes."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/698/"
PLUGIN.ResourceId = 698
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Fix chat help for chat command
---- Fix "Array index is out of range" when using invalid single arg or no arg
---- Add console command function
---- Add command action to list the countries on the blacklist/whitelist

local blacklisted, whitelisted = false, false
function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdCountryBlock")
    --command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdCountryBlock")
end

function PLUGIN:CanClientLogin(connection)
    if not debug then if self.Config.Settings.AdminExcluded ~= "false" and self:PermissionsCheck(connection) then return end end
    local country = "undefined"
    local playerIp = connection.ipaddress:match("([^:]*):")
    local listType = self.Config.Settings.ListType
    if debug then playerIp = "8.8.8.8"; print("[" .. self.Title .. "] Player's IP: " .. playerIp) end
    if playerIp ~= "127.0.0.1" then
        local url = "http://ipinfo.io/" .. playerIp .. "/country"
        webrequests.EnqueueGet(url, function(code, response)
            country = response:gsub("\n", "")
            if country == "undefined" or code ~= 200 then
                print("[" .. self.Title .. "] Checking country for " .. connection.username .. " failed!")
                self:Deport(connection, country)
                return
            end
            print("[" .. self.Title .. "] " .. connection.username .. " connected from " .. country)
            if string.lower(listType) == "blacklist" and self:ListCheck(country) then self:Deport(connection, country) end
            if string.lower(listType) == "whitelist" and not self:ListCheck(country) then self:Deport(connection, country) end
        end, self.Plugin)
    end
end

function PLUGIN:ListCheck(arg)
    local list = self.Config.Settings.CountryList
    for _, entry in pairs(list) do if arg == entry then return true end end
end

function PLUGIN:Deport(connection, country)
    Network.Net.sv:Kick(connection, self.Config.Messages.Rejected)
    local kicked = self.Config.Messages.PlayerKicked:gsub("{player}", connection.username):gsub("{country}", country)
    print("[" .. self.Title .. "] " .. kicked)
    if self.Config.Settings.Broadcast ~= "false" then rust.BroadcastChat(self.Config.Settings.ChatName, kicked) end
end

function PLUGIN:cmdCountryBlock(player, cmd, args)
    if player and not self:PermissionsCheck(player.net.connection) then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission)
        return
    end
    local argument = string.upper(args[1])
    --[[if string.len(country) > 2 or string.len(country) < 2 then -- args.Length ~= 2, bring this back but support 1 for list action?
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.ChatHelp) -- Can't do this with an array :/
        return
    end]]
    local action = args[0]
    local list = self.Config.Settings.CountryList
    if action == nil or action ~= "add" and action ~= "remove" and action ~= "type" then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.UnknownAction)
        return
    end
    if action == "add" then
        local listed
        for key, value in pairs(list) do if argument == value then listed = true; break end end
        if not listed then
            table.insert(list, argument)
            self:SaveConfig()
            local message = self.Config.Messages.CountryAdded:gsub("{country}", argument)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = self.Config.Messages.AlreadyAdded:gsub("{country}", argument)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
        return
    end
    if action == "remove" then
        local listed
        for key, value in pairs(list) do if argument == value then listed = true; break end end
        if listed then
            table.remove(list, key)
            self:SaveConfig()
            local message = self.Config.Messages.CountryRemoved:gsub("{country}", argument)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = self.Config.Messages.NotListed:gsub("{country}", argument)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
        return
    end
    if action == "type" then
        if string.lower(argument) == "blacklist" or string.lower(argument) == "whitelist" then
            self.Config.Settings.ListType = string.lower(argument)
            self:SaveConfig()
            local message = self.Config.Messages.ListTypeChanged:gsub("{listtype}", argument)
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
            return
        else
            rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.UnknownListType)
        end
        return
    end
    --[[if action == "list" then
        local countries = ""
        --for i = 1, #list do print(list[i]); countries = countries .. ", " .. list[i] end
        rust.SendChatMessage(player, self.Config.Settings.ChatName, countries)
    end]]
end

function PLUGIN:ccmdCountryBlock(args)
    -- TODO
end

function PLUGIN:PermissionsCheck(connection)
    local authLevel; if connection then authLevel = connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(connection.username .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player.net.connection) then
        for i = 1, #self.Config.Messages.ChatHelp do
            rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp[i])
        end
    end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AdminExcluded = self.Config.Settings.AdminExcluded or "true"
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.Broadcast = self.Config.Settings.Broadcast or "true"
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "country"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "SERVER"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or "HELP"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "country.block"
    self.Config.Settings.CountryList = self.Config.Settings.CountryList or { "UK", "US" }
    self.Config.Settings.ListType = self.Config.Settings.ListType or "whitelist"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.AlreadyAdded = self.Config.Messages.AlreadyAdded or "{country} is already on the country list!"
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or {
        "Use /country add countrycode to add a country to the list",
        "Use /country remove countrycode to remove a country from the list",
        "Use /country list to list all the countries on the list"
    }
    self.Config.Messages.CountryAdded = self.Config.Messages.CountryAdded or "{country} has been added to the country list!"
    self.Config.Messages.CountryRemoved = self.Config.Messages.CountryRemoved or "{country} has been removed from the country list!"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.NotListed = self.Config.Messages.NotListed or "{country} is not on the country list!"
    self.Config.Messages.ListTypeChanged = self.Config.Messages.ListTypeChanged or "Country list type changed to {listtype}"
    self.Config.Messages.PlayerKicked = self.Config.Messages.PlayerKicked or "{player} was kicked as their country ({country}) is blocked!"
    self.Config.Messages.Rejected = self.Config.Messages.Rejected or "Sorry, this server doesn't allow players from your country!"
    self.Config.Messages.UnknownAction = self.Config.Messages.UnknownAction or "Unknown command action! Use add, remove, list, or type"
    self.Config.Messages.UnknownListType = self.Config.Messages.UnknownListType or "Unknown list type! Use blacklist or whitelist"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\CustomChatCommands.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Custom Chat Commands"
PLUGIN.Description  = "Set completely custom chat commands"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(2, 3, 1)
PLUGIN.ResourceID   = 649

-- --------------------------------
-- init
-- --------------------------------
function PLUGIN:Init()
    for cmd, _ in pairs(self.Config.ChatCommands) do
        command.AddChatCommand(cmd, self.Object, "cmdChatCmd")
    end
    self:LoadDefaultConfig()
    self:RegisterPermissions()
end
-- --------------------------------
-- permission check
-- --------------------------------
local function HasPermission(player, perm)
    local steamID = rust.UserIDFromPlayer(player)
    if player:GetComponent("BaseNetworkable").net.connection.authLevel > 0 then
        return true
    end
    if permission.UserHasPermission(steamID, perm) then
        return true
    end
    return false
end
-- --------------------------------
-- load config
-- --------------------------------
function PLUGIN:LoadDefaultConfig()
    -- general settings
    self.Config.Settings                = self.Config.Settings or {}
    self.Config.Settings.ChatName       = self.Config.Settings.ChatName or "SERVER"
    -- messages
    self.Config.Messages                = self.Config.Messages or {}
    self.Config.Messages.NoPermission   = self.Config.Messages.NoPermission or "You dont have permission to use this command!"
    -- chat commands
    self.Config.ChatCommands            = self.Config.ChatCommands or {
        ["command1"] = {
            ["text"] = {"This is an example text"},
            ["helptext"] = "This is the helptext for this command",
            ["permission"] = false
        },
        ["command2"] = {
            ["text"] = {"This is an example text for admins only", "You can also use multiline messages"},
            ["helptext"] = "This is the helptext for this command, also admin only",
            ["permission"] = "admin"
        }
    }
    -- update old admin entries to new permission entries added in v2.3.0
    for key, _ in pairs(self.Config.ChatCommands) do
        if self.Config.ChatCommands[key].admin then
            self.Config.ChatCommands[key].admin = nil
            self.Config.ChatCommands[key].permission = "admin"
        elseif self.Config.ChatCommands[key].admin ~= nil then
            self.Config.ChatCommands[key].admin = nil
            self.Config.ChatCommands[key].permission = false
        end
    end
    self:SaveConfig()
end
-- --------------------------------
-- register permissions
-- --------------------------------
function PLUGIN:RegisterPermissions()
    for key, _ in pairs(self.Config.ChatCommands) do
        local perm = self.Config.ChatCommands[key].permission or false
        if perm then
            if not permission.PermissionExists(perm) then
                permission.RegisterPermission(perm, self.Object)
            end
        end
    end
end
-- --------------------------------
-- handles the chat commands
-- --------------------------------
function PLUGIN:cmdChatCmd(player, chatcmd)
    local chatName = self.Config.Settings.ChatName
    for key, _ in pairs(self.Config.ChatCommands) do
        if chatcmd == key then
            local cmd = self.Config.ChatCommands[key]
            if cmd.permission then
                if HasPermission(player, cmd.permission) then
                    for k, _ in pairs(cmd.text) do
                        rust.SendChatMessage(player, chatName, cmd.text[k])
                    end
                else
                    rust.SendChatMessage(player, chatName, self.Config.Messages.NoPermission)
                end
            else
                for k, _ in pairs(cmd.text) do
                    rust.SendChatMessage(player, chatName, cmd.text[k])
                end
            end
        end
    end
end
-- --------------------------------
-- send helptext
-- --------------------------------
function PLUGIN:SendHelpText(player)
    local chatName = self.Config.Settings.ChatName
    for key, _ in pairs(self.Config.ChatCommands) do
        local cmd = self.Config.ChatCommands[key]
        if cmd.helptext and cmd ~= "" then
            if cmd.permission then
                if HasPermission(player, cmd.permission) then
                    rust.SendChatMessage(player, chatName, cmd.helptext)
                end
            else
                rust.SendChatMessage(player, chatName, cmd.helptext)
            end
        end
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\dice.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Dice"
PLUGIN.Version = V(0, 2, 5)
PLUGIN.Description = "Feeling lucky? Roll one or multiple dice to get a random number."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/655/"
PLUGIN.ResourceId = 655
PLUGIN.HasConfig = true

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdRollDice")
end

function PLUGIN:cmdRollDice(player, cmd, arg)
    local dice = tonumber(arg[0]) or 1
    local count, total = 0, 0
    if dice > 1000 then dice = 1 end
    while count < dice do
        local roll = math.random(6);
        total = total + roll; count = count + 1
    end
    local number = tostring(total)
    local message = self.Config.Messages.Rolled:gsub("{player}", player.displayName):gsub("{number}", number)
    rust.BroadcastChat(self.Config.Settings.ChatName, message)
end

function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp)
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "dice"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "DICE"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or "HELP"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or "Use /dice # to roll dice (# being optional number of dice to roll)"
    self.Config.Messages.Rolled = self.Config.Messages.Rolled or "{player} rolled {number}"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\email.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Email API"
PLUGIN.Version = V(0, 1, 3)
PLUGIN.Description = "API for sending email messages via supported transactional email services."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/712/"
PLUGIN.ResourceId = 712
PLUGIN.HasConfig = true

local debug = false

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:EmailMessage(subject, message)
    if subject == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SubjectRequired) return end
    if message == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.MessageRequired) return end
    if string.lower(self.Config.Settings.Provider) == "elastic" or string.lower(self.Config.Settings.Provider) == "elasticemail" then
        if self.Config.Settings.ApiKeyPrivate == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetApiKey) return end
        self.url = "https://api.elasticemail.com/mailer/send"
        self.data = "api_key=" .. self.Config.Settings.ApiKeyPrivate
        .. "&username=" .. self.Config.Settings.Username
        .. "&from=" .. self.Config.Settings.EmailFrom
        .. "&from_name=" .. self.Config.Settings.NameFrom
        .. "&to=" .. self.Config.Settings.EmailTo
        .. "&toname=" .. self.Config.Settings.NameTo
        .. "&subject=" .. subject
        .. "&body_text=" .. message
    elseif string.lower(self.Config.Settings.Provider) == "mandrill" then
        if self.Config.Settings.ApiKeyPrivate == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetApiKey) return end
        self.url = "https://mandrillapp.com/api/1.0/messages/send.json"
        self.data = '{\"key\": \"' .. self.Config.Settings.ApiKeyPrivate .. '\",'
        .. '\"message\": {'
            .. '\"from_email\": \"' .. self.Config.Settings.EmailFrom .. '\",'
            .. '\"from_name\": \"' .. self.Config.Settings.NameFrom .. '\",'
            .. '\"to\": [{'
                .. '\"email\": \"' .. self.Config.Settings.EmailTo .. '\",'
                .. '\"name\": \"' .. self.Config.Settings.NameTo .. '\"}],'
        .. '\"subject\": \"' .. subject .. '\",'
        .. '\"html\": \"' .. message .. '\"}}'
    elseif string.lower(self.Config.Settings.Provider) == "sendgrid" then
        if self.Config.Settings.ApiKeyPrivate == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetApiKey) return end
        self.url = "https://api.sendgrid.com/api/mail.send.json"
        self.data = "api_key=" .. self.Config.Settings.ApiKeyPrivate
        .. "&api_user=" .. self.Config.Settings.Username
        .. "&from=" .. self.Config.Settings.EmailFrom
        .. "&fromname=" .. self.Config.Settings.NameFrom
        .. "&to=" .. self.Config.Settings.EmailTo
        .. "&toname=" .. self.Config.Settings.NameTo
        .. "&subject=" .. subject
        .. "&html=" .. message
    else
        print("[" .. self.Title .. "] " .. self.Config.Messages.InvalidProvider)
        return
    end
    webrequests.EnqueuePost(self.url, self.data, function(code, response)
        if debug then self:DebugMessages(self.url, self.data, code) end
        if code ~= 200 and code ~= 250 then
            print("[" .. self.Title .. "] " .. self.Config.Messages.SendFailed)
        else
            print("[" .. self.Title .. "] " .. self.Config.Messages.SendSuccess)
        end
    end, self.Plugin)
end

function PLUGIN:DebugMessages(url, data, code)
    if debug then
        print("[" .. self.Title .. "] POST URL: " .. tostring(url))
        print("[" .. self.Title .. "] POST data: " .. tostring(data))
        print("[" .. self.Title .. "] HTTP code: " .. code)
    end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.ApiKeyPrivate = self.Config.Settings.ApiKeyPrivate or ""
    self.Config.Settings.ApiKeyPublic = self.Config.Settings.ApiKeyPublic or ""
    self.Config.Settings.EmailFrom = self.Config.Settings.EmailFrom or "me@me.tld"
    self.Config.Settings.EmailTo = self.Config.Settings.EmailTo or "you@you.tld"
    self.Config.Settings.NameFrom = self.Config.Settings.NameFrom or "Bob Barker"
    self.Config.Settings.NameTo = self.Config.Settings.NameTo or "Drew Carey"
    self.Config.Settings.Provider = self.Config.Settings.Provider or "mandrill"
    self.Config.Settings.Username = self.Config.Settings.Username or ""
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.InvalidProvider = self.Config.Messages.InvalidProvider or "Configured email provider is not valid!"
    self.Config.Messages.MessageRequired = self.Config.Messages.MessageRequired or "Message not given! Please enter one and try again"
    self.Config.Messages.SendFailed = self.Config.Messages.SendFailed or "Email failed to send!"
    self.Config.Messages.SendSuccess = self.Config.Messages.SendSuccess or "Email successfully sent!"
    self.Config.Messages.SetApiKey = self.Config.Messages.SetApiKey or "API key not set! Please set it and try again."
    self.Config.Messages.SubjectRequired = self.Config.Messages.SubjectRequired or "Subject not given! Please enter one and try again"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\EnhancedBanSystem.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Enhanced Ban System"
PLUGIN.Description  = "Ban system with advanced features"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(2, 2, 3)
PLUGIN.HasConfig    = true
PLUGIN.ResourceID   = 693

local debugMode = false

function PLUGIN:Init()
    command.AddChatCommand("ban", self.Object, "cmdBan")
    command.AddChatCommand("unban", self.Object, "cmdUnban")
    command.AddChatCommand("kick", self.Object, "cmdKick")
    command.AddChatCommand("bancheck", self.Object, "cmdBanCheck")
    command.AddConsoleCommand("player.ban", self.Object, "ccmdBan")
    command.AddConsoleCommand("player.unban", self.Object, "ccmdUnban")
    command.AddConsoleCommand("player.kick", self.Object, "ccmdKick")
    self:LoadDataFile()
    self:LoadDefaultConfig()
end
local plugin_RustDB
function PLUGIN:OnServerInitialized()
    plugin_RustDB = plugins.Find("RustDB") or false
end

local DataFile = "ebsbanlist"
local BanData = {}
function PLUGIN:LoadDataFile()
    BanData = datafile.GetDataTable(DataFile) or {}
end
function PLUGIN:SaveDataFile()
    datafile.SaveDataTable(DataFile)
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.BroadcastBans = self.Config.Settings.BroadcastBans or "false"
    self.Config.Settings.LogToConsole = self.Config.Settings.LogToConsole or "true"
    self.Config.Settings.CheckUsableByEveryone = self.Config.Settings.CheckUsableByEveryone or "false"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "SERVER"
    -- Messages
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.KickMessage = self.Config.Messages.KickMessage or "An admin kicked you for {reason}"
    self.Config.Messages.BanMessage = self.Config.Messages.BanMessage or "An admin banned you for {reason}"
    self.Config.Messages.DenyConnection = self.Config.Messages.DenyConnection or "You are banned on this server"
    self.Config.Messages.HelpText = self.Config.Messages.HelpText or "Use /bancheck to check if and for how long someone is abnned"
    self:SaveConfig()
end
-- --------------------------------
-- admin permission check
-- --------------------------------
local function IsAdmin(player)
    return player:GetComponent("BaseNetworkable").net.connection.authLevel > 0
end
-- --------------------------------
-- error and debug reporting
-- --------------------------------
local pluginTitle = PLUGIN.Title
local pluginVersion = string.match(tostring(PLUGIN.Version), "(%d+.%d+.%d+)")
local function error(msg)
    local message = "[Error] "..pluginTitle.."(v"..pluginVersion.."): "..msg
    local array = util.TableToArray({message})
    UnityEngine.Debug.LogError.methodarray[0]:Invoke(nil, array)
    print(message)
end
local function debug(msg)
    if not debugMode then return end
    local message = "[Debug] "..pluginTitle.."(v"..pluginVersion.."): "..msg
    local array = util.TableToArray({message})
    UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, array)
end
-- --------------------------------
-- removes expired bans
-- --------------------------------
function PLUGIN:CleanUpBanList()
    local now = time.GetUnixTimestamp()
    for key, value in pairs(BanData) do
        if BanData[key].expiration < now and BanData[key].expiration ~= 0 then
            BanData[key] = nil
            self:SaveDataFile()
        end
    end
end
-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end
-- --------------------------------
-- handles chat command /ban
-- --------------------------------
function PLUGIN:cmdBan(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local target, reason, duration = args[1], args[2], args[3]
    if not IsAdmin(player) then
        rust.SendChatMessage(player, "You dont have permission to use this command")
        return
    end
    if not reason then
        rust.SendChatMessage(player, "Syntax: \"/ban <name|steamID|ip> <reason> <time[m|h|d] (optional)>\"")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        rust.SendChatMessage(player, "Player not found")
        return
    end
    self:Ban(player, targetPlayer, reason, duration)
end
-- --------------------------------
-- handles console command player.ban
-- --------------------------------
function PLUGIN:ccmdBan(arg)
    local player
    if arg.connection then
        player = arg.connection.player
    end
    if player and not IsAdmin(player) then
        arg:ReplyWith("You dont have permission to use this command")
        return true
    end
    local args = self:ArgsToTable(arg, "console")
    local target, reason, duration = args[1], args[2], args[3]
    if player and not IsAdmin(player) then
        rust.SendChatMessage(player, "You dont have permission to use this command")
        return
    end
    if not reason then
        print("Syntax: \"player.ban <name|steamID|ip> <reason> <time[m|h|d] (optional)>\"")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        print("Player not found")
        return
    end
    self:Ban(player, targetPlayer, reason, duration)
end
-- --------------------------------
-- handles chat command /unban
-- --------------------------------
function PLUGIN:cmdUnban(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local target = args[1]
    if not IsAdmin(player) then
        rust.SendChatMessage(player, "You dont have permission to use this command")
        return
    end
    if not target then
        rust.SendChatMessage(player, "Syntax: \"/unban <name|steamID|ip>\"")
        return
    end
    self:UnBan(player, target)
end
-- --------------------------------
-- handles console command player.unban
-- --------------------------------
function PLUGIN:ccmdUnban(arg)
    local player
    if arg.connection then
        player = arg.connection.player
    end
    if player and not IsAdmin(player) then
        arg:ReplyWith("You dont have permission to use this command")
        return true
    end
    local args = self:ArgsToTable(arg, "console")
    local target = args[1]
    if not target then
        print("Syntax: \"player.unban <name|steamID|ip>\"")
        return
    end
    self:UnBan(player, target)
end
-- --------------------------------
-- handles chat command /kick
-- --------------------------------
function PLUGIN:cmdKick(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local target, reason = args[1], args[2]
    if not IsAdmin(player) then
        rust.SendChatMessage(player, "You dont have permission to use this command")
        return
    end
    if not reason then
        rust.SendChatMessage(player, "Syntax: \"/kick <name|steamID|ip> <reason>\"")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        rust.SendChatMessage(player, "Player not found")
        return
    end
    self:Kick(player, targetPlayer, reason)
end
-- --------------------------------
-- handles console command player.kick
-- --------------------------------
function PLUGIN:ccmdKick(arg)
    local player
    if arg.connection then
        player = arg.connection.player
    end
    if player and not IsAdmin(player) then
        arg:ReplyWith("You dont have permission to use this command")
        return true
    end
    local args = self:ArgsToTable(arg, "console")
    local target, reason = args[1], args[2]
    if not reason then
        print("Syntax: \"player.kick <name|steamID|ip> <reason>\"")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        print("Player not found")
        return
    end
    self:Kick(player, targetPlayer, reason)
end
-- --------------------------------
-- handles chat command /bancheck
-- --------------------------------
function PLUGIN:cmdBanCheck(player, cmd, args)
    local args = self:ArgsToTable(args, "chat")
    local target = args[1]
    if not IsAdmin(player) and self.Config.Settings.CheckUsableByEveryone == "false" then
        rust.SendChatMessage(player, "You dont have permission to use this command")
        return
    end
    if not target then
        rust.SendChatMessage(player, "Syntax: \"/bancheck <name|steamID|ip>\"")
        return
    end
    local now = time.GetUnixTimestamp()
    for key, value in pairs(BanData) do
        if BanData[key].name == target or BanData[key].steamID == target or BanData[key].IP == target then
            if BanData[key].expiration > now or BanData[key].expiration == 0 then
                if BanData[key].expiration == 0 then
                    rust.SendChatMessage(player, target.." is permanently banned")
                    return
                else
                    local expiration = BanData[key].expiration
                    local bantime = expiration - now
                    local days = string.format("%02.f", math.floor(bantime / 86400))
                    local hours = string.format("%02.f", math.floor(bantime / 3600 - (days * 24)))
                    local minutes = string.format("%02.f", math.floor(bantime / 60 - (days * 1440) - (hours * 60)))
                    local seconds = string.format("%02.f", math.floor(bantime - (days * 86400) - (hours * 3600) - (minutes * 60)))
                    rust.SendChatMessage(player, target.." is banned for "..tostring(days).." days "..tostring(hours).." hours "..tostring(minutes).." minutes "..tostring(seconds).." seconds")
                    return
                end
            end
        end
    end
    rust.SendChatMessage(player, target.." is not banned")
end
-- --------------------------------
-- kick player
-- --------------------------------
function PLUGIN:Kick(player, targetPlayer, reason)
    local targetName = targetPlayer.displayName
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    local targetInfo = targetName.." ("..targetSteamID..")"
    -- Kick player
    local kickMsg = string.gsub(self.Config.Messages.KickMessage, "{reason}", reason)
    Network.Net.sv:Kick(targetPlayer.net.connection, kickMsg)
    -- Output the bans
    if self.Config.Settings.BroadcastBans == "true" then
        rust.BroadcastChat(self.Config.Settings.ChatName, targetName.." has been kicked for "..reason)
    else
        if player then
            rust.SendChatMessage(player, targetName.." has been kicked for "..reason)
        else
            print(targetName.." has been kicked for "..reason)
        end
    end
    if self.Config.Settings.LogToConsole == "true" then
        if player then
            print(self.Title..": "..player.displayName.." kicked "..targetInfo)
        else
            print(self.Title..": Admin kicked "..targetInfo)
        end
    end
end
-- --------------------------------
-- unban player
-- --------------------------------
function PLUGIN:UnBan(player, target)
    debug("unban target: "..target)
    for key, _ in pairs(BanData) do
        if BanData[key].name == target or BanData[key].steamID == target or BanData[key].IP == target then
            debug("ban found")
            -- Send unban request to RustDB
            if plugin_RustDB then
                plugin_RustDB:RustDBUnban(BanData[key].steamID)
            end
            -- remove from banlist
            BanData[key].name = nil
            BanData[key].steamID = nil
            BanData[key].IP = nil
            BanData[key].expiration = nil
            BanData[key].reason = nil
            BanData[key] = nil
            debug("bandata nil: "..tostring(BanData[key] == nil))
            self:SaveDataFile()
            -- Output the bans
            if self.Config.Settings.BroadcastBans == "true" then
                rust.BroadcastChat(self.Config.Settings.ChatName, target.." has been unbanned")
            else
                if player then
                    rust.SendChatMessage(player, target.." has been unbanned")
                else
                    print(target.." has been unbanned")
                end
            end
            if self.Config.Settings.LogToConsole == "true" then
                if player then
                    print(self.Title..": "..player.displayName.." unbanned "..target)
                else
                    print(self.Title..": Admin unbanned "..target)
                end
            end
            return
        end
    end
    if player then
        rust.SendChatMessage(player, target.." not found in banlist")
    else
        print(target.." not found in banlist")
    end
end
-- --------------------------------
-- ban player
-- --------------------------------
function PLUGIN:Ban(player, targetPlayer, reason, duration)
    local targetName = targetPlayer.displayName
    local targetIP = targetPlayer.net.connection.ipaddress:match("([^:]*):")
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    -- Check if player is already banned
    local now = time.GetUnixTimestamp()
    for key, value in pairs(BanData) do
        if BanData[key].steamID == targetSteamID then
            if BanData[key].expiration > now or BanData[key].expiration == 0 then
                if player then
                    rust.SendChatMessage(player, targetName.." is already banned!")
                else
                    print(targetName.." is already banned!")
                end
                return
            else
                self:CleanUpBanList()
            end
        end
    end
    if not duration then -- If no time is given ban permanently
        local expiration = 0
        -- Insert data into the banlist
        BanData[targetSteamID] = {}
        BanData[targetSteamID].steamID = targetSteamID
        BanData[targetSteamID].name = targetName
        BanData[targetSteamID].expiration = expiration
        BanData[targetSteamID].IP = targetIP
        BanData[targetSteamID].reason = reason
        table.insert(BanData, BanData[targetSteamID])
        self:SaveDataFile()
        -- Send ban to RustDB
        if plugin_RustDB then
            plugin_RustDB:RustDBBan(player, targetName, targetSteamID, reason)
        end
        -- Kick target from server
        debug("kicked: "..targetName)
        local BanMsg = string.gsub(self.Config.Messages.BanMessage, "{reason}", reason)
        Network.Net.sv:Kick(targetPlayer.net.connection, BanMsg)
        -- Output bans
        if self.Config.Settings.BroadcastBans == "true" then
            rust.BroadcastChat(self.Config.Settings.ChatName, targetName.." has been permanently banned")
        else
            if player then
                rust.SendChatMessage(player, targetName.." has been permanently banned")
            else
                print(targetName.." has been permanently banned")
            end
        end
        if self.Config.Settings.LogToConsole == "true" then
            if player then
                print(self.Title..": "..player.displayName.." permanently banned "..targetName.." for "..reason)
            else
                print(self.Title..": Admin permanently banned "..targetName.." for "..reason)
            end
        end
    else -- if time is given, ban for time
        -- Check if time input is a valid format
        if string.len(duration) < 2 or not string.match(duration, "^%d*[mhd]$") then
            if player then
                rust.SendChatMessage(player, "Invalid time format")
            else
                print("Invalid time format")
            end
            return
        end
        -- Build time format
        local now = time.GetUnixTimestamp()
        local banTime = tonumber(string.sub(duration, 1, -2))
        local timeUnit = string.sub(duration, -1)
        local timeMult, timeUnitLong
        if timeUnit == "m" then
            timeMult = 60
            timeUnitLong = "minutes"
        elseif timeUnit == "h" then
            timeMult = 3600
            timeUnitLong = "hours"
        elseif timeUnit == "d" then
            timeMult = 86400
            timeUnitLong = "days"
        end
        local expiration = now + (banTime * timeMult)
        -- Insert data into the banlist
        BanData[targetSteamID] = {}
        BanData[targetSteamID].steamID = targetSteamID
        BanData[targetSteamID].name = targetName
        BanData[targetSteamID].expiration = expiration
        BanData[targetSteamID].IP = targetIP
        BanData[targetSteamID].reason = reason
        table.insert(BanData, BanData[targetSteamID])
        self:SaveDataFile()
        -- Kick target from server
        debug("kicked: "..targetName)
        local BanMsg = string.gsub(self.Config.Messages.BanMessage, "{reason}", reason)
        Network.Net.sv:Kick(targetPlayer.net.connection, BanMsg)
        -- Output bans
        if self.Config.Settings.BroadcastBans == "true" then
            rust.BroadcastChat(self.Config.Settings.ChatName, targetName.." has been banned for "..banTime.." "..timeUnitLong)
        else
            if player then
                rust.SendChatMessage(player, targetName.." has been banned for "..banTime.." "..timeUnitLong)
            else
                print(targetName.." has been banned for "..banTime.." "..timeUnitLong)
            end
        end
        if self.Config.Settings.LogToConsole == "true" then
            if player then
                print(self.Title..": "..player.displayName.." banned "..targetName.." for "..banTime.." "..timeUnitLong.." for "..reason)
            else
                print(self.Title..": Admin banned "..targetName.." for "..banTime.." "..timeUnitLong.." for "..reason)
            end
        end
    end
end
-- --------------------------------
-- checks for ban on player connects
-- --------------------------------
function PLUGIN:CanClientLogin(connection)
    local steamID = rust.UserIDFromConnection(connection)
    local ip = connection.ipaddress:match("([^:]*):")
    local name = connection.username
    local userInfo = name.." ("..steamID..")"
    local now = time.GetUnixTimestamp()
    for key, value in pairs(BanData) do
        if BanData[key].steamID == steamID or BanData[key].IP == ip then
            if BanData[key].expiration < now and BanData[key].expiration ~= 0 then
                self:CleanUpBanList()
                return
            else
                debug(userInfo.." connection denied")
                if self.Config.Settings.LogToConsole == "true" then
                    print(self.Title..": "..userInfo.." connection denied")
                end
                return self.Config.Messages.DenyConnection
            end
        else
            if BanData[key].name == name then
                print(self.Title..": Warning! the name from "..userInfo.." has been banned but is using another steam account now!")
                print(self.Title..": It might be the same person with another account or just someone else with the same name. Judge it by yourself")
            end
        end
    end
end
-- --------------------------------
-- sends helptext when /help is used
-- --------------------------------
function PLUGIN:SendHelpText(player)
    if self.Config.Settings.CheckUsableByEveryone == "true" then
        rust.SendChatMessage(player, self.Config.Messages.HelpText)
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\event.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Running"
PLUGIN.Title = "Running"
PLUGIN.Version = V(1, 0, 0)
PLUGIN.Description = " "
PLUGIN.Author = "Mizantop"
PLUGIN.ResourceId = 777
PLUGIN.HasConfig = true

local runningman = nil
local eventstart = nil
local eventpause = nil
local time1 = nil
local time2 = nil
local API = nil

function PLUGIN:Init()
    self:LoadDefaultConfig()
	command.AddChatCommand( "eventon", self.Plugin, "cmdEvent" )
	command.AddChatCommand( "eventoff", self.Plugin, "cmdEventOff" )
	command.AddChatCommand( "run", self.Plugin, "cmdRun" )
	command.AddConsoleCommand("serv.eventon", self.Plugin, "ccmdEvent")
	command.AddConsoleCommand("serv.eventoff", self.Plugin, "cmdEventOf")
	if GetEconomyAPI then
		API = GetEconomyAPI() -- Global Function!
	else
		print("Economics not found!")
	end
	if (self.Config.Default.On == "true") then
		eventpause = timer.Once( 60 * self.Config.Default.PauseeventTime, function() self:Startevent() end )
		time1 = time.GetUnixTimestamp()
	end
end

function PLUGIN:LoadDefaultConfig()
  self.Config.Default = {}
  self.Config.Default.ChatName = "EVENT"
  self.Config.Default.authLevel = 1
  self.Config.Default.On = "true"
  self.Config.Default.Count = 5
  self.Config.Default.StarteventTime = 30
  self.Config.Default.PauseeventTime = 30
  self.Config.Reward = {}
  self.Config.Reward.Random = "true"
  self.Config.Reward.RewardFixing = "wood"
  self.Config.Reward.RewardFixingAmount = 10000
  self.Config.Reward.Reward1 = "wood"
  self.Config.Reward.Reward1Amount = 50000
  self.Config.Reward.Reward2 = "stones"
  self.Config.Reward.Reward2Amount = 50000
  self.Config.Reward.Reward3 = "metal_ore"
  self.Config.Reward.Reward3Amount = 15000
  self.Config.Reward.Reward4 = "sulfur_ore"
  self.Config.Reward.Reward4Amount = 15000
  self.Config.Reward.Reward5 = "smg_thompson"
  self.Config.Reward.Reward5Amount = 1
  self.Config.Reward.Reward5_2 = "ammo_pistol"
  self.Config.Reward.Reward5_2Amount = 150
  self.Config.Reward.RewardMoney = 50000
  self.Config.Reward.Reward6 = "wood"
  self.Config.Reward.Reward6Amount = 50000
end

function PLUGIN:Startevent()
	if (eventpause ~= nil) then
		eventpause:Destroy()
		runningman = nil
		eventpause = nil
		Runlog("timer eventpause stoped")
	end
	if (eventstart ~= nil) then
		eventstart:Destroy()
		runningman = nil
		eventstart = nil
		Runlog("timer eventstart stoped")
	end
	print(self.Config.Default.Count.." iz "..global.BasePlayer.activePlayerList.Count)
	if (global.BasePlayer.activePlayerList.Count >= self.Config.Default.Count) then
		enum = global.BasePlayer.activePlayerList:GetEnumerator()
		local i = 0
		local ArrayPlayers = {}
			while enum:MoveNext() do
		i = i+1;
			ArrayPlayers[i] = enum.Current;
		end
		local rand_i = math.random(1,global.BasePlayer.activePlayerList.Count);
		runningman = ArrayPlayers[rand_i]
		Runlog("Running man: "..runningman.displayName.."")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Running man: "..runningman.displayName..",\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \" : "..runningman.displayName..",\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"    !\"")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Kill him and get the reward!\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \": /run -     \"")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Command: /run - to know the distance to the target\"")
		eventstart = timer.Once( 60 * self.Config.Default.StarteventTime, function() self:Runningstop() end )
		time1 = time.GetUnixTimestamp()
	else
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"There aren't enough players to start the event\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"    \"")
		eventpause = timer.Once( 60 * self.Config.Default.PauseeventTime, function() self:Startevent() end )
		time1 = time.GetUnixTimestamp()
	end
end

function PLUGIN:cmdEventOff(player, cmd, args)
	if (player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Config.Default.authLevel) then
		if (eventpause ~= nil) then
			eventpause:Destroy()
			eventpause = nil
			runningman = nil
			Runlog("timer eventpause stoped")
		end
		if (eventstart ~= nil) then
			eventstart:Destroy()
			eventstart = nil
			runningman = nil
			Runlog("timer eventstart stoped")
		end
		Runlog("Running Man has stoped")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, " !")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "Event has stoped!")
	else
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "     !")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "You have no rights to do this!")
	end
end

function PLUGIN:cmdEventOf()
	if (eventpause ~= nil) then
		eventpause:Destroy()
		eventpause = nil
		runningman = nil
		Runlog("timer eventpause stoped")
	end
	if (eventstart ~= nil) then
		eventstart:Destroy()
		eventstart = nil
		runningman = nil
		Runlog("timer eventstart stoped")
	end
	Runlog("Running Man has stoped") 
end

function PLUGIN:ccmdEvent(args)
	if (eventpause ~= nil) then
		eventpause:Destroy()
		eventpause = nil
		runningman = nil
		Runlog("timer eventpause stoped")
	end
	if (eventstart ~= nil) then
		eventstart:Destroy()
		eventstart = nil
		runningman = nil
		Runlog("timer eventstart stoped")
	end
	local enum = global.BasePlayer.activePlayerList:GetEnumerator()
	local i = 0
	local ArrayPlayers = {}
		while enum:MoveNext() do
	i = i+1;
		ArrayPlayers[i] = enum.Current;
	end
	local rand_i = math.random(1,global.BasePlayer.activePlayerList.Count);
	runningman = ArrayPlayers[rand_i]
	Runlog("Running man: "..runningman.displayName.."")
	global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Running man: "..runningman.displayName..",\"")
	--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \" : "..runningman.displayName..",\"")
	--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"    !\"")
	global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Kill him and get the reward!\"")
	--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \": /run -     \"")
	global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Command: /run - to know the distance to the target\"")
	eventstart = timer.Once( 60 * self.Config.Default.StarteventTime, function() self:Runningstop() end )
	time1 = time.GetUnixTimestamp()
end

function PLUGIN:cmdEvent(player, cmd, args)
	if (player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Config.Default.authLevel) then
		if (eventpause ~= nil) then
			eventpause:Destroy()
			eventpause = nil
			runningman = nil
			Runlog("timer eventpause stoped")
		end
		if (eventstart ~= nil) then
			eventstart:Destroy()
			eventstart = nil
			runningman = nil
			Runlog("timer eventstart stoped")
		end
		local enum = global.BasePlayer.activePlayerList:GetEnumerator()
		local i = 0
		local ArrayPlayers = {}
			while enum:MoveNext() do
		i = i+1;
			ArrayPlayers[i] = enum.Current;
		end
		local rand_i = math.random(1,global.BasePlayer.activePlayerList.Count);
		runningman = ArrayPlayers[rand_i]
		Runlog("Running man: "..runningman.displayName.."")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Running man: "..runningman.displayName..",\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \" : "..runningman.displayName..",\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"    !\"")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Kill him and get the reward!\"")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \": /run -     \"")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Command: /run - to know the distance to the target\"")
		eventstart = timer.Once( 60 * self.Config.Default.StarteventTime, function() self:Runningstop() end )
		time1 = time.GetUnixTimestamp()
	else
		rust.SendChatMessage(player, self.Config.Default.ChatName, "     !")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "You have no rights to do this!")
	end
end

function PLUGIN:SendHelpText(player)
    --player:ChatMessage(" \"/run\"      ")
	player:ChatMessage("Use \"/run\" to find out information about the running man")
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(authlevel >= self.Config.Default.authLevel) then
		--player:ChatMessage(" \"/eventon\"    ")
		--player:ChatMessage(" \"/eventon\"    ")
		player:ChatMessage("Use \"/eventon\" for start event Running Man")
		player:ChatMessage("Use \"/eventoff\" for stop event Running Man")
	end
end

function PLUGIN:cmdRun(player, cmd, args)
	--eventstart:Destroy()
	if (not player) then return end
	if (runningman ~= nil) then
		local xr = string.format("%.0f", runningman.transform.position.x)
		local zr = string.format("%.0f", runningman.transform.position.z)
		local xk = string.format("%.0f", player.transform.position.x)
		local zk = string.format("%.0f", player.transform.position.z)
		local dist = math.floor(math.sqrt(math.pow(xr - xk,2) + math.pow(zr - zk,2)))
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "  "..runningman.displayName..",")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "Running man "..runningman.displayName..",")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "  "..dist.."")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "is at a distance of "..dist.."")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "    !")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "Kill him and get the reward!")
		time2 = time.GetUnixTimestamp()
		local time3 = time2 - time1
		time3 = eventstart.Delay - time3
		time3 = math.floor(time3 / 60)
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "   : "..time3.." ")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "Until the end of event left: "..time3.." minutes")
	else
		time2 = time.GetUnixTimestamp()
		local time3 = time2 - time1
		time3 = eventpause.Delay - time3
		time3 = math.floor(time3 / 60)
		rust.SendChatMessage(player, self.Config.Default.ChatName, "At the moment the event is not running")
		rust.SendChatMessage(player, self.Config.Default.ChatName, "Before the start of the event remained: "..time3.." minutes")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "     ")
		--rust.SendChatMessage(player, self.Config.Default.ChatName, "    : "..time3.." ")
	end
end

	function Runlog(text)
		print('[EVENT] +--------------- RUNNING MAN -----------------');
		print('[EVENT] | '..text); --       .
		print('[EVENT] +---------------------------------------------');
	end

function PLUGIN:OnEntityDeath(entity, hitinfo)
	if(entity:ToPlayer()) then
		self:PlayerKilled(entity,hitinfo)
	end
end	
	
function PLUGIN:PlayerKilled(victim,hitinfo)
	if (hitinfo.Initiator:ToPlayer()) then
		local attacker = hitinfo.Initiator:ToPlayer()
		if(attacker ~= victim) then
			if (victim == runningman) then
				Runlog("Running man - "..attacker.displayName.." kill "..runningman.displayName.." and received as a reward!")
				--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \" - "..attacker.displayName.."  "..runningman.displayName.."   !\"")
				global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Player - "..attacker.displayName.." kill "..runningman.displayName.." and received as a reward!\"")
				local inv = attacker.inventory
				if (self.Config.Reward.Random == "true") then
					Runlog("random")
					local rand = math.random(1,6)
					Runlog(rand)
					if (rand == 1) then
						Runlog("wood")
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward1, self.Config.Reward.Reward1Amount), inv.containerMain)
					end
					if (rand == 2) then
						Runlog("stones")
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward2, self.Config.Reward.Reward2Amount), inv.containerMain)
					end
					if (rand == 3) then
						Runlog("metal_ore")
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward3, self.Config.Reward.Reward3Amount), inv.containerMain)
					end
					if (rand == 4) then
						Runlog("sulfur_ore")
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward4, self.Config.Reward.Reward4Amount), inv.containerMain)
					end
					if (rand == 5) then
						Runlog("smg_thompson")
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward5, self.Config.Reward.Reward5Amount), inv.containerMain)
						inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward5_2, self.Config.Reward.Reward5_2Amount), inv.containerMain)
					end
					if (rand == 6) then
						if (API ~= nil) then
							Runlog("money")
							local userdata = API:GetUserDataFromPlayer(attacker)
							userdata:Deposit(self.Config.Reward.RewardMoney)
							Runlog(userdata[1])
							API.SaveData()
						else
							Runlog("Economics not found!")
							inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward6, self.Config.Reward.Reward6Amount), inv.containerMain)
						end
					end
				else
					Runlog("reward")
					inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.RewardFixing, self.Config.Reward.RewardFixingAmount), inv.containerMain)
				end
				eventstart:Destroy()
				eventstart = nil
				runningman = nil
				Runlog("timer eventstart stoped")
				eventpause = timer.Once( 60 * self.Config.Default.PauseeventTime, function() self:Startevent() end )
				time1 = time.GetUnixTimestamp()
			end
		end
	end
end

function PLUGIN:OnPlayerDisconnected(player)
	if (player == runningman) then
		Runlog("Player "..runningman.displayName.." got scared and ran away!")
		--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \" "..runningman.displayName.."   !\"")
		global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Player "..runningman.displayName.." got scared and ran away!\"")
		eventstart:Destroy()
		runningman = nil
		eventstart = nil
		Runlog("timer eventstart stoped")
		eventpause = timer.Once( 60 * self.Config.Default.PauseeventTime, function() self:Startevent() end )
		time1 = time.GetUnixTimestamp()
	end
end

function PLUGIN:Runningstop()
	Runlog("Running man - "..runningman.displayName.." ran away from the chase and received as a reward!")
	--global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"  - "..runningman.displayName.."      !\"")
	global.ConsoleSystem.Broadcast("chat.add \""..self.Config.Default.ChatName.."\" \"Running man - "..runningman.displayName.." ran away from the chase and received as a reward!\"")
	local inv = runningman.inventory
	if (self.Config.Reward.Random == "true") then
		Runlog("random")
		local rand = math.random(1,6)
		if (rand == 1) then
			Runlog("wood")
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward1, self.Config.Reward.Reward1Amount), inv.containerMain)
		end
		if (rand == 2) then
			Runlog("stones")
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward2, self.Config.Reward.Reward2Amount), inv.containerMain)
		end
		if (rand == 3) then
			Runlog("metal_ore")
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward3, self.Config.Reward.Reward3Amount), inv.containerMain)
		end
		if (rand == 4) then
			Runlog("sulfur_ore")
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward4, self.Config.Reward.Reward4Amount), inv.containerMain)
		end
		if (rand == 5) then
			Runlog("smg_thompson")
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward5, self.Config.Reward.Reward5Amount), inv.containerMain)
			inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward5_2, self.Config.Reward.Reward5_2Amount), inv.containerMain)
		end
		if (rand == 6) then
			if (API ~= nil) then
				Runlog("money")
				local userdata = API:GetUserDataFromPlayer(runningman)
				userdata:Deposit(self.Config.Reward.RewardMoney)
				Runlog(userdata[1])
				API.SaveData()
			else
				Runlog("Economics not found!")
				inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.Reward6, self.Config.Reward.Reward6Amount), inv.containerMain)
			end
		end
	else
		Runlog("reward")
		inv:GiveItem(global.ItemManager.CreateByName(self.Config.Reward.RewardFixing, self.Config.Reward.RewardFixingAmount), inv.containerMain)
	end
	eventstart:Destroy()
	eventstart = nil
	runningman = nil
	Runlog("timer eventstart stoped")
	eventpause = timer.Once( 60 * self.Config.Default.PauseeventTime, function() self:Startevent() end )
	time1 = time.GetUnixTimestamp()
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\finder.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "finder"
PLUGIN.Title = "Finder"
PLUGIN.Version = V(1, 4, 2)
PLUGIN.Description = "Find objects that belongs to players. sleepingbags, players, sleepers, doors for the moment."
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 692
local deadPlayerList = false
function PLUGIN:Init()
	self.Find = {}
	command.AddChatCommand( "findsleepingbags", self.Plugin, "cmdFindSleepingBag" )
	command.AddChatCommand( "findsleepingbag", self.Plugin, "cmdFindSleepingBag" )
	command.AddChatCommand( "findplayers", self.Plugin, "cmdFindPlayer" )
	command.AddChatCommand( "findplayer", self.Plugin, "cmdFindPlayer" )
	command.AddChatCommand( "finddoor", self.Plugin, "cmdFindDoor" )
	command.AddChatCommand( "finddoors", self.Plugin, "cmdFindDoor" )
	command.AddChatCommand( "findtp", self.Plugin, "cmdFindTp" )
	command.AddChatCommand( "finditem", self.Plugin, "cmdFindItem" )
	command.AddChatCommand( "findprivilege", self.Plugin, "cmdFindBuildingPrivilege" )
	command.AddChatCommand( "findprivileges", self.Plugin, "cmdFindBuildingPrivilege" )
	deadPlayerList = plugins.Find("deadPlayerList")
	buildingOwners = plugins.Find("BuildingOwners")
	if(not deadPlayerList) then
		print("To increase your chance in finding players, use the deadPlayerList plugin")
	end
end
local function ChatMessage(player,msg)
	player:SendConsoleCommand( "chat.add \"SERVER\" \"" .. msg .. "\"" );
end
function PLUGIN:LoadDefaultConfig()
	self.Config.authLevel = 1
end
function PLUGIN:cmdFindBuildingPrivilege(player,cmd,args)
	if(player.net.connection.authLevel >= self.Config.authLevel ) then
		if(args.Length >= 1) then
			local targetplayer, err = self:FindPlayer(args[0])
			if(not targetplayer) then
				ChatMessage(player,err)
				return
			end
			ChatMessage(player,"Looking for building privileges of " .. targetplayer.displayName)
			local buildpriv, err = self:FindBuildingPrivilegeByPlayer(targetplayer)
			if(not buildpriv) then
				ChatMessage(player,err)
				return
			end
			self.Find[player] = buildpriv
			ChatMessage(player,"Found " .. #buildpriv .. " Building privileges for " .. targetplayer.displayName .. " use \"/findtp ID\" to teleport to it/them")
			for i = 1, #buildpriv do
				local pos = buildpriv[i].transform.position
				ChatMessage(player,i .. " - " .. math.ceil(pos.x) .. " " .. math.ceil(pos.y) .. " " .. math.ceil(pos.z))
			end
		end
	end
end
function PLUGIN:FindBuildingPrivilegeByPlayer(player)
	local userID = player.userID
	if(type(userID) ~= "string") then
		userID = rust.UserIDFromPlayer(player)
	end
	local buildingPriviliges = {}
	local allTriggerBase = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
	if(allTriggerBase.Length == 0) then return false, "No Tool Cupboard were found on your server" end
	for i = 0, allTriggerBase.Length - 1 do
		if(allTriggerBase[i]:GetComponent("BuildPrivilegeTrigger")) then
			local bpriv = rust.UserIDsFromBuildingPrivilege( allTriggerBase[i].privlidgeEntity )
			for o = 0, bpriv.Length - 1 do
				if(bpriv[o] == userID) then
					buildingPriviliges[#buildingPriviliges + 1] = allTriggerBase[i].privlidgeEntity:GetComponent("BaseEntity")
				end
			end
		end
	end
	if(#buildingPriviliges == 0) then return false, "No Building Privileges Found for " .. player.displayName end
	return buildingPriviliges
end
function PLUGIN:cmdFindItem(player,com,args)
	self.Find[player] = {}
	local authlevel = player.net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(args.Length >= 1) then
			local itemdefinition, err = self:GetItemDefinition(string.lower(args[0]))
			if(not itemdefinition) then
				ChatMessage(player,err)
				return
			end
			local containers,err = self:FindItemContainers()
			if(not containers) then
				ChatMessage(player,err)
				return
			end
			local minamount = 1
			if(args.Length >= 2) then
				if(tonumber(args[1]) ~= nil) then
					minamount = tonumber(args[1])
				end
			end
			local founditems, err = self:FindItemInContainers(containers,itemdefinition,minamount)
		 	if(not founditems) then
				ChatMessage(player,err)
				return
			end
			self.Find[player] = founditems
			ChatMessage(player,"Found " .. #founditems .. " Containers that have at least " .. tostring(minamount) .. " of ".. tostring(itemdefinition.displayname))
			for i = 1, #founditems do
				local pos = founditems[i].transform.position
				ChatMessage(player,i .. " - " .. tostring(err[i].type) .. " - " .. tostring(err[i].num) .. " " .. tostring(itemdefinition.displayname) .. " - " .. math.ceil(pos.x) .. " " .. math.ceil(pos.y) .. " " .. math.ceil(pos.z))
			end
		end
	end
end
function PLUGIN:FindItemInContainers(containers,itemdef,min)
	local found = {}
	local description = {}
	for i=1, #containers do
		local content = containers[i].item.contents
		local amount = content:GetAmount(itemdef.itemid,false)
		if(amount >= min) then
			found[#found + 1] = containers[i]
			description[#description+1] = {type=containers[i].item.info.displayname,num=amount}
		end
	end
	
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		if(allBasePlayer[ i ].inventory) then
			local amount = allBasePlayer[ i ].inventory:GetAmount(itemdef.itemid)
			if(amount >= min) then
				found[#found + 1] = allBasePlayer[ i ]
				description[#description+1] = {type=allBasePlayer[ i ].displayName .. "(Player)",num=amount}
			end
		end
	end
	if(#found == 0) then
		return false, "No items found with those criterias"
	end
	return found, description
end
function PLUGIN:GetItemDefinition(itemname)
	local itemlist = global.ItemManager.GetItemDefinitions();
	local it = itemlist:GetEnumerator()
	local itemdefinition = false
	while (it:MoveNext()) do
		if(itemname == string.lower(it.Current.displayname)) then
			itemdefinition = it.Current
			break
		elseif(itemname == it.Current.shortname) then
			itemdefinition = it.Current
			break
		end
	end
	if(not itemdefinition) then
		return false, "Wrong item name"
	end
	return itemdefinition
end
function PLUGIN:cmdFindPlayer(player,com,args)
	self.Find[player] = {}
	local authlevel = player.net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(args.Length >= 1) then
			local targetplayers, err = self:FindPlayers(args[0])
			if(not targetplayers) then
				ChatMessage(player,err)
				return
			end
			self.Find[player] = targetplayers
			ChatMessage(player,"Found " .. #targetplayers .. " players that match " .. args[0] .. " use \"/findtp ID\" to teleport")
			for i = 1, #targetplayers do
				if(targetplayers[i].transform) then
					local pos = targetplayers[i].transform.position
					local state = "Alive"
					if(targetplayers[i]:IsDead()) then state = "Dead" end
					if(targetplayers[i]:IsSleeping()) then state = "Sleeping" end
					if(targetplayers[i]:IsSpectating()) then state = "Spectating" end
					local status = "Disconnected"
					if(targetplayers[i]:IsConnected()) then status = "Connected" end
					ChatMessage(player,i .. " - " ..  targetplayers[i].displayName .. " - ".. rust.UserIDFromPlayer(targetplayers[i]) .. " - " .. status .. " - " .. state .. " - " .. math.ceil(pos.x) .. " " .. math.ceil(pos.y) .. " " .. math.ceil(pos.z))
				else
					ChatMessage(player,i .. " - " ..  targetplayers[i].displayName .. " - ".. targetplayers[i].userID .. " - " .. "Disconnected" .. " - " .. "Dead" .. " - " .. math.ceil(targetplayers[i].pos.x) .. " " .. math.ceil(targetplayers[i].pos.y) .. " " .. math.ceil(targetplayers[i].pos.z))
				end
			end
		end
	end
end
function PLUGIN:cmdFindDoor(player,com,args)
	self.Find[player] = {}
	local authlevel = player.net.connection.authLevel
	local neededlevel = 1
	if(authlevel >= neededlevel) then
		if(not buildingOwners) then
			ChatMessage(player,"This command is not activated. You must have Building Owners plugin installed.")
			return
		end
		if(args.Length >= 1) then
			local targetplayer, err = self:FindPlayer(args[0])
			if(not targetplayer) then
				ChatMessage(player,err)
				return
			end
			ChatMessage(player,"Looking for Doors owned by " .. targetplayer.displayName)
			local doors, err = self:FindDoorsByPlayer(targetplayer)
			if(not doors) then
				ChatMessage(player,err)
				return
			end
			self.Find[player] = doors
			ChatMessage(player,"Found " .. #doors .. " Doors owned by " .. targetplayer.displayName .. " use \"/findtp ID\" to teleport to it/them")
			for i = 1, #doors do
				local pos = doors[i].transform.position
				ChatMessage(player,i .. " - Level " .. tostring(doors[i]:GetComponent("BuildingBlock").grade) .. " - " .. math.ceil(pos.x) .. " " .. math.ceil(pos.y) .. " " .. math.ceil(pos.z))
			end
		end
	end
end
function PLUGIN:cmdFindTp( player, com, args )
	local authlevel = player.net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(not self.Find[player]) then
			ChatMessage(player,"You need to find stuff first. Use /findhelp to get the full list of what you can find")
			return
		end
		
		if(args.Length >= 1) then
			local target = false
			if(tonumber(args[0]) == nil) then
				ChatMessage(player,"Wrong argument 1: needs to be a number")
				return
			end
			target = tonumber(args[0])
			if(not self.Find[player][target]) then
				ChatMessage(player,"Wrong argument 1: This ID doesn't exist.")
				return
			end
			if(self.Find[player][target].transform) then
				self:Teleport( player, self.Find[player][target].transform.position )
			else
				local newpos = player.transform.position
				newpos.x = self.Find[player][target].pos.x
				newpos.y = self.Find[player][target].pos.y
				newpos.z = self.Find[player][target].pos.z
				self:Teleport( player, newpos )
			end
		else
			ChatMessage(player,"You must specify an ID of which you want to teleport to.")
		end
	end
end
function PLUGIN:cmdFindSleepingBag( player, com, args )
	self.Find[player] = {}
	local authlevel = player.net.connection.authLevel
	local neededlevel = self.Config.authLevel 
	if(authlevel >= neededlevel) then
		if(args.Length >= 1) then
			local targetplayer, err = self:FindPlayer(args[0])
			if(not targetplayer) then
				ChatMessage(player,err)
				return
			end
			ChatMessage(player,"Looking for sleeping bags owned by " .. targetplayer.displayName)
			local bags, err = self:FindSleepingBagByPlayer(targetplayer)
			if(not bags) then
				ChatMessage(player,err)
				return
			end
			self.Find[player] = bags
			ChatMessage(player,"Found " .. #bags .. " Sleeping Bag for " .. targetplayer.displayName .. " use \"/findtp ID\" to teleport to it/them")
			for i = 1, #bags do
				local pos = bags[i].transform.position
				ChatMessage(player,i .. " - " .. math.ceil(pos.x) .. " " .. math.ceil(pos.y) .. " " .. math.ceil(pos.z))
			end
		end
	end
end

function PLUGIN:FindDoorsByPlayer(player)
	local userID = player.userID
	if(type(userID) ~= "string") then
		userID = rust.UserIDFromPlayer(player)
	end
	local doors = {}
	local allDoors = UnityEngine.Object.FindObjectsOfTypeAll(global.Door._type)
	if(allDoors.Length == 0) then return false, "No Doors were found on your server" end
	for i = 0, tonumber(allDoors.Length - 1) do
		local currdoor = allDoors[i];
		local steamid = buildingOwners.CallHook("FindBlockData", currdoor:GetComponent("BuildingBlock"))
		if(steamid and userID == steamid) then
			doors[#doors + 1] = currdoor:GetComponent("BuildingBlock")
		end
	end
	if(#doors == 0) then return false, "No Doors Found for " .. player.displayName end
	return doors
end
function PLUGIN:FindItemContainers()
	local containers = {}
	local allItems = UnityEngine.Object.FindObjectsOfTypeAll(global.WorldItem._type)
	if(allItems.Length == 0) then return false, "No Items were found on your server" end
	for i = 0, tonumber(allItems.Length - 1) do
		local curritem = allItems[i];
		if(curritem.item and curritem.item.contents and curritem.item.contents.capacity) then
			containers[#containers + 1] = curritem
		end
	end
	if(#containers == 0) then return false, "No Item containers were found" end
	return containers
end
function PLUGIN:FindSleepingBagByPlayer(player)
	local userID = player.userID
	local bags = {}
	local sleepingbags = UnityEngine.Object.FindObjectsOfTypeAll(global.SleepingBag._type)
	if(sleepingbags.Length == 0) then return false, "No Sleeping Bags Found on the server" end
	for i = 0, tonumber(sleepingbags.Length - 1) do
		local sleepingbag = sleepingbags[i];
		if(sleepingbag.deployerUserID and sleepingbag.deployerUserID == tonumber(userID)) then
			bags[#bags + 1] = sleepingbag
		end
	end
	if(#bags == 0) then return false, "No Sleeping Bags Found for " .. player.displayName end
	return bags
end
function PLUGIN:FindPlayers(target)
	local found = {}
	local steamid = false
	if(tonumber(target) ~= nil and string.len(target) == 17) then
		steamid = target
	end
	local targetplayer = false
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		local currentplayer = allBasePlayer[ i ];
		if(steamid) then
			if(steamid == rust.UserIDFromPlayer(currentplayer)) then
				found[1] = currentplayer
				return found
			end
		else
			if(string.find(currentplayer.displayName,target)) then
				found[#found + 1] = currentplayer
			elseif(string.find(rust.UserIDFromPlayer(currentplayer),target)) then
				found[#found + 1] = currentplayer
			end
		end
	end
	if(#found == 0) then 
		if deadPlayerList then
			local deadplayers, err = deadPlayerList.CallHook("FindDeadPlayers", target)
			if(not deadplayers) then return false, err end
			for k,v in pairs(deadplayers) do
				v.userID = k
				found[# found +1 ] = v
			end
			return found
		end
		return false, "No players found" 
	end
	return found
end
function PLUGIN:FindPlayer( target )
	local steamid = false
	if(tonumber(target) ~= nil and string.len(target) == 17) then
		steamid = target
	end
	local targetplayer = false
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		local currentplayer = allBasePlayer[ i ];
		if(steamid) then
			if(steamid == rust.UserIDFromPlayer(currentplayer)) then
				return currentplayer
			end
		else
			if(currentplayer.displayName == target) then
				return currentplayer
			elseif(string.find(currentplayer.displayName,target)) then
				if(targetplayer) then
					return false, "Multiple Players Found"
				end
				targetplayer = currentplayer
			end
		end
	end
	if(not targetplayer) then 
		if deadPlayerList then
			targetsteamid,targetplayer = deadPlayerList.CallHook("FindDeadPlayer", target)
		end
		if(not targetsteamid) then
			return false, "No players found" 
		end
		targetplayer.userID = targetsteamid
	end
	return targetplayer
end

function PLUGIN:Teleport( player, destination )
    player:StartSleeping()
    rust.ForcePlayerPosition( player, destination.x, destination.y, destination.z )
    player:SetPlayerFlag( global["BasePlayer+PlayerFlags"].ReceivingSnapshot, true )
    player:UpdateNetworkGroup()
    player:SendFullSnapshot()
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\friendsfriendlyfire.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Friends Friendly Fire"
PLUGIN.Version = V(1, 3, 3)
PLUGIN.Description = "Enable/disable friend fire for friends server-wide."
PLUGIN.Author = "Wulfspider"
PLUGIN.ResourceId = 687
PLUGIN.HasConfig = true

local debug = false

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdFriendlyFire")
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.CmdAuthLevel = tonumber(self.Config.Settings.CmdAuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "fff"
    self.Config.Settings.FriendlyFire = self.Config.Settings.FriendlyFire or self.Config.FriendlyFire or "true"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.CantHurtFriend = self.Config.Messages.CantHurtFriend or "You can't hurt your friend!"
    self.Config.FriendlyFire = nil -- Removed in 0.3.2
    self:SaveConfig()
end

local friendsAPI
function PLUGIN:OnServerInitialized()
    friendsAPI = plugins.Find("0friendsAPI") or false
    if not friendsAPI then
        print("[" .. self.Title .. "] Friends API not found!")
        print("[" .. self.Title .. "] Get it here: http://forum.rustoxide.com/resources/686/")
        return
    end
end

function PLUGIN:OnPlayerAttack(attacker, hitinfo)
    if self.Config.FriendlyFire == "false" then
        if debug then print("[" .. self.Title .. "] HitEntity: " .. tostring(hitinfo.HitEntity)) end
        if hitinfo.HitEntity then
            if string.match(tostring(hitinfo.HitEntity), "BasePlayer") then
                local targetPlayer = hitinfo.HitEntity
                local targetSteamId = rust.UserIDFromPlayer(targetPlayer)
                local attackerSteamId = rust.UserIDFromPlayer(attacker)
                local hasFriend = friendsAPI.CallHook("HasFriend", attackerSteamId, targetSteamId)
                if debug then print("[" .. self.Title .. "] hasFriend: " .. tostring(hasFriend)) end
                if hasFriend then
                    rust.SendChatMessage(attacker, self.Config.Messages.CantHurtFriend)
                    hitinfo.damageTypes = new(Rust.DamageTypeList._type, nil)
                    hitinfo.HitMaterial = 0
                    return true
                end
            end
        end
    end
end

function PLUGIN:HasPermission(connection)
    local authLevel; if connection then authLevel = connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(connection.username .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:cmdFriendlyFire(player)
    if not self:HasPermission(player.net.connection) then return false end
    if self.Config.Settings.FriendlyFire == "false" then
        self.Config.Settings.FriendlyFire = "true"
        rust.SendChatMessage(player, "Friendly Fire on")
    else
        self.Config.Settings.FriendlyFire = "false"
        rust.SendChatMessage(player, "Friendly Fire off")
    end
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\glue.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Glue"
PLUGIN.Version = V(1, 0, 1)
PLUGIN.Description = ""
PLUGIN.Author = "Bombardir"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 733

local msgs, mode = {}, {}
local function SendMessage(player, msg)
	player:SendConsoleCommand("chat.add \"".. msgs.ChatName.."\" \"".. msg .."\"")
end 
local function GetData(player)
	local data = mode[player] or {}
	mode[player] = data
	return data
end
local function GetBone(hitinfo)
	local array = util.TableToArray( { 0 })
	util.ConvertAndSetOnArray(array, 0, hitinfo.HitBone or 0, System.UInt32._type)
	return global.StringPool.Get.methodarray[0]:Invoke(nil, array )
end 
function PLUGIN:Init()
	self.Config.Admin_Auth_LvL = self.Config.Admin_Auth_LvL or 2
	self.Config.Chat_Command   = self.Config.Chat_Command or "glue"
	
	msgs = self.Config.Messages or {}
	msgs.NoPerm = msgs.NoPerm or "No Permission!"
	msgs.ChatName = msgs.ChatName or "[Glue]"
	msgs.NoParent = msgs.NoParent or "This entity has no parent."
	msgs.Already = msgs.Already or "This entity has already been added!"
	msgs.BoneNot = msgs.BoneNot or "Bone not found."
	msgs.NoParentFound = msgs.NoParentFound or "Entities or players with this name not found!"
	msgs.SyntaxError = msgs.SyntaxError or "Syntax Error! /%s m [mode_num] (1 - disable/clear selected, 2 - entity to glue, 3 - parent entity to glue, 4 - unglue, 5 - get bone name)"
	msgs.SyntaxError2 = msgs.SyntaxError2 or "Syntax Error! /%s [entity/player] [parent entity/player]"
	msgs.mode = msgs.mode or {}
	msgs.mode[1] = msgs.mode[1] or "Glue mode disabled."
	msgs.mode[2] = msgs.mode[2] or {"Select the entities/entity to glue.", "Entity added to the glue list."}
	msgs.mode[3] = msgs.mode[3] or {"Select the parent entity to glue.", "Entities glued!" }
	msgs.mode[4] = msgs.mode[4] or {"Select the entity to unglue.", "Entities unglued!" }
	msgs.mode[5] = msgs.mode[5] or "Shoot entity to get bone name."
	self.Config.Messages = msgs
	self:SaveConfig() 
	
	command.AddChatCommand(self.Config.Chat_Command, self.Plugin, "C_Glue")
end

function PLUGIN:C_Glue(player, _, args)
	if player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Config.Admin_Auth_LvL then
		if args.Length > 0 then
			local arg_0 = args[0]
			if arg_0 == "m" then
				local arg = tonumber(args[1]) or 1
				if arg > 0 and arg < 6 then
					local data = GetData(player)
					if arg == 1 then
						data.mode = nil
						data.ents = nil
					else
						data.ents = data.ents or {}
						data.mode = arg
					end
					SendMessage(player, msgs.mode[arg][1] or msgs.mode[arg])
				else
					SendMessage(player, msgs.SyntaxError:format(self.Config.Chat_Command))
				end 
			else
				if args.Length > 1 then 
					local P_need_to_spawn = false
					local parent = global.BasePlayer.Find(args[1])
					if not parent then
						parent = global.GameManager.CreateEntity(args[1], player.transform.position, player.transform.rotation)
						P_need_to_spawn = true
					end
					if parent then
						local T_need_to_spawn = false
						local target = global.BasePlayer.Find(arg_0)
						if not target then
							target = global.GameManager.CreateEntity(arg_0, parent.transform.position, parent.transform.rotation)
							T_need_to_spawn = true
						end
						if target then
							if P_need_to_spawn then parent:Spawn(true) end
							if T_need_to_spawn then target:Spawn(true) end
							target:SetParent(parent, '')
							SendMessage(player, msgs.mode[3][2])
						else
							SendMessage(player, msgs.NoParentFound)
						end
					else
						SendMessage(player, msgs.NoParentFound)
					end
				else
					SendMessage(player, msgs.SyntaxError2:format(self.Config.Chat_Command))
				end
			end
		end
	else
		SendMessage(player, msgs.NoPerm)
	end
end

function PLUGIN:OnPlayerAttack(player, hitinfo)
	local ent = hitinfo.HitEntity
	if ent then
		local data = GetData(player)
		if data.mode then
			if data.mode == 5 then
				local bone = GetBone(hitinfo)
				if bone == "" then bone = msgs.BoneNot end
				SendMessage(player, bone)
			else
				if data.mode == 2 then
					for i=1, #data.ents do
						if data.ents[i] == ent then
							SendMessage(player, msgs.Already)
							return true 
						end
					end
					table.insert(data.ents, ent)
				elseif data.mode == 3 then
					local bone = GetBone(hitinfo)
					for i=1, #data.ents do
						data.ents[i]:SetParent(ent, bone)
					end
				elseif data.mode == 4 then
					if ent:GetParentEntity() then
						ent:SetParent(nil, "")
					else
						SendMessage(player, msgs.NoParent)
						return true
					end
				end
				SendMessage(player, msgs.mode[data.mode][2])
			end
			return true
		end
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\heal.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Heal, Feed and Cure"
PLUGIN.Description = "Allows you to heal, feed and cure players"
PLUGIN.Author = "#Domestos"
PLUGIN.Version = V(1, 2, 1)
PLUGIN.HasConfig = false
PLUGIN.ResourceID = 658

function PLUGIN:Init()
    command.AddChatCommand("heal", self.Object, "ChatCmd")
    command.AddChatCommand("cure", self.Object, "ChatCmd")
    command.AddChatCommand("feed", self.Object, "ChatCmd")
    command.AddConsoleCommand("player.heal", self.Object, "ConsoleCmd")
    command.AddConsoleCommand("player.cure", self.Object, "ConsoleCmd")
    command.AddConsoleCommand("player.feed", self.Object, "ConsoleCmd")
end

local function QuoteSafe(string)
    return UnityEngine.StringExtensions.QuoteSafe(string)
end

function PLUGIN:ChatMessage(targetPlayer, chatName, msg)
    if msg then
        targetPlayer:SendConsoleCommand("chat.add "..QuoteSafe(chatName).." "..QuoteSafe(msg))
    else
        msg = chatName
        targetPlayer:SendConsoleCommand("chat.add SERVER "..QuoteSafe(msg))
    end
end
-- --------------------------------
-- admin permission check
-- --------------------------------
local function IsAdmin(player)
    if player:GetComponent("BaseNetworkable").net.connection.authLevel == 0 then
        return false
    end
    return true
end

-- --------------------------------
-- Handles console commands
-- --------------------------------
function PLUGIN:ConsoleCmd(arg)
    local command = arg.cmd.namefull
    local player
    if arg.connection then
        player = arg.connection.player
    end
    -- Check permission
    if player and not IsAdmin(player) then
        arg:ReplyWith("You dont have permission to use this command")
        return true
    end
    -- Convert args
    local args = self:ArgsToTable(arg, "console")
    local target, amount = args[1], args[2]
    -- Check for target name
    if not player and not target then
        if command == "player.cure" then
            print("Syntax: \""..command.." <name>\"")
        else
            print("Syntax: \""..command.." <name> <amount (optional)>\"")
        end
        return true
    end
    -- Get target
    local targetPlayer = self:GetTargetPlayer(player, target)
    if not targetPlayer then
        if player then
            arg:ReplyWith("Player not found")
        else
            print("Player not found")
        end
        return true
    end
    -- Check for valid heal amount
    if amount and command ~= "player.cure" then
        amount = string.match(amount, "^%d*")
        if amount == "" then
            if player then
                arg:ReplyWith("<amount> needs to be a number")
            else
                print("<amount> needs to be a number")
            end
            return true
        end
    end
    if command == "player.heal" then
        amount = tonumber(amount) or 100
    elseif command == "player.feed" then
        amount = tonumber(amount) or 1000
    end
    -- Call function
    if command == "player.heal" then
        self:Heal(player, targetPlayer, amount)
    elseif command == "player.cure" then
        self:Cure(player, targetPlayer)
    elseif command == "player.feed" then
        self:Feed(player, targetPlayer, amount)
    end
    return true
end

-- --------------------------------
-- Handles chat commands
-- --------------------------------
function PLUGIN:ChatCmd(player, cmd, args)
    -- Check permission
    if not IsAdmin(player) then
        self:ChatMessage(player, "You dont have permission to use this command")
        return
    end
    local command = cmd
    local args = self:ArgsToTable(args, "chat")
    local target, amount = args[1], args[2]
    -- Check for valid heal amount
    if amount and command ~= "cure" then
        amount = string.match(amount, "^%d*")
        if amount == "" then
            self:ChatMessage(player, "<amount> needs to be a number")
            return
        end
    end
    if command == "heal" then
        amount = tonumber(amount) or 100
    elseif command == "feed" then
        amount = tonumber(amount) or 1000
    end
    -- Get target
    local targetPlayer = self:GetTargetPlayer(player, target)
    if not targetPlayer then
        self:ChatMessage(player, "Player not found")
        return
    end
    -- Call function
    if command == "heal" then
        self:Heal(player, targetPlayer, amount)
    elseif command == "cure" then
        self:Cure(player, targetPlayer)
    elseif command == "feed" then
        self:Feed(player, targetPlayer, amount)
    end
end

-- --------------------------------
-- Heal
-- --------------------------------
function PLUGIN:Heal(player, targetPlayer, amount)
    targetPlayer.metabolism.health.value = targetPlayer.metabolism.health.value + amount
    if player then
        if player ~= targetPlayer then
            self:ChatMessage(player, "You healed "..targetPlayer.displayName.." for "..tostring(amount).." HP")
            self:ChatMessage(targetPlayer, player.displayName.." healed you for "..tostring(amount).." HP")
        else
            self:ChatMessage(player, "You healed yourself for "..tostring(amount).." HP")
        end
    else
        print("You healed "..targetPlayer.displayName.." for "..tostring(amount).." HP")
        self:ChatMessage(targetPlayer, "An admin healed you for "..tostring(amount).." HP")
    end
end

-- --------------------------------
-- Cure
-- --------------------------------
function PLUGIN:Cure(player, targetPlayer)
    targetPlayer.metabolism.poison.value = 0
    targetPlayer.metabolism.radiation.value = 0
    targetPlayer.metabolism.oxygen.value = 1
    targetPlayer.metabolism.bleeding.value = 0
    targetPlayer.metabolism.wetness.value = 0
    targetPlayer.metabolism.dirtyness.value = 0
    if player then
        if player ~= targetPlayer then
            self:ChatMessage(player, "You cured "..targetPlayer.displayName)
            self:ChatMessage(targetPlayer, player.displayName.." cured you")
        else
            self:ChatMessage(player, "You cured yourself")
        end
    else
        print("You cured "..targetPlayer.displayName)
        self:ChatMessage(targetPlayer, "An admin cured you")
    end
end

-- --------------------------------
-- Feed
-- --------------------------------
function PLUGIN:Feed(player, targetPlayer, amount)
    targetPlayer.metabolism.calories.value = targetPlayer.metabolism.calories.value + amount
    targetPlayer.metabolism.hydration.value = targetPlayer.metabolism.hydration.value + amount
    if player then
        if player ~= targetPlayer then
            self:ChatMessage(player, "You fed "..targetPlayer.displayName.." for "..tostring(amount))
            self:ChatMessage(targetPlayer, player.displayName.." fed you for "..tostring(amount))
        else
            self:ChatMessage(player, "You fed yourself for "..tostring(amount))
        end
    else
        print("You fed "..targetPlayer.displayName.." for "..tostring(amount))
        self:ChatMessage(targetPlayer, "An admin fed you for "..tostring(amount))
    end
end

-- --------------------------------
-- returns targetPlayer or false
-- --------------------------------
function PLUGIN:GetTargetPlayer(player, target)
    local targetPlayer
    if not target then
        return player
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        return false
    else
        return targetPlayer
    end
end

-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\HelloWorldLua.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "HelloWorldLua"
PLUGIN.Version = V(0, 1, 0)
PLUGIN.Author = "Bas"
function PLUGIN:Init()
    print("Hello World from Lua")   
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\helptext.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Helptext"
PLUGIN.Description  = "Hooks into plugins to send helptext"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(1, 4, 0)
PLUGIN.HasConfig    = true
PLUGIN.ResourceID   = 676

function PLUGIN:Init()
    command.AddChatCommand("help", self.Object, "cmdHelp")
    self:LoadDefaultConfig()
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.UseCustomHelpText = self.Config.Settings.UseCustomHelpText or "false"
    self.Config.Settings.AllowHelpTextFromOtherPlugins = self.Config.Settings.AllowHelpTextFromOtherPlugins or "true"
    self.Config.CustomHelpText = self.Config.CustomHelpText or {
       "custom helptext",
       "custom helptext"
    }
    self:SaveConfig()
end

function PLUGIN:cmdHelp(player)
    if not player then return end
    if self.Config.Settings.UseCustomHelpText == "true" then
        for _, helptext in pairs(self.Config.CustomHelpText) do
            rust.SendChatMessage(player, helptext)
        end
    end
    if self.Config.Settings.AllowHelpTextFromOtherPlugins == "true" then
        plugins.CallHook("SendHelpText", util.TableToArray({player}))
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\hurtme.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Hurt Me"
PLUGIN.Version = V(0, 2, 0)
PLUGIN.Description = "Hurts target player on command, with optional amount."
PLUGIN.Author = "Luke Spragg - Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/resources/657/"
PLUGIN.ResourceID = "657"
PLUGIN.HasConfig = true

-- TODO:
---- Add authLevel check and permission option for moderators

-- Plugin initialization
function PLUGIN:Init()
    -- Add default command
    command.AddChatCommand("hurt", self.Object, "cmdHurt")
end

-- Hurt chat command
function PLUGIN:cmdHurt(player, cmd, args)
    -- Check if player has permission
    if (not player:IsAdmin()) then
        -- Send no permission message to player via chat
        player:SendConsoleCommand("chat.add \"" .. self.Config.Settings.ChatName .. "\" \"" .. self.Config.Messages.NoPermission .. "\"")
        return
    else
        -- Check for proper command usage
        if (args.Length < 1) then
            -- Send correct usage message to player via chat
            player:SendConsoleCommand("chat.add \"" .. self.Config.Settings.ChatName .. "\" \"" .. self.Config.Messages.HelpText .. "\"")
            return
        else
            -- Check if target is given
            local targetplayer = global.BasePlayer.Find(args[0])

            -- Check if player name is a real boy
            if (targetplayer == nil) then
                -- We tried, but the player doesn't seem to exist!
                player:SendConsoleCommand("chat.add \"" .. self.Config.Settings.ChatName .. "\" \"" .. self.Config.Messages.InvalidTarget .. "\"")
                return
            else
                -- Damage the player by given amount
                local amount
                if (args.Length == 2) then amount = args[1] else amount = 100 end
                targetplayer:TakeDamage(amount)

                -- Send message to target player via chat
                local targethurt = string.gsub(self.Config.Messages.TargetHurt, "{amount}", tostring(amount))
                --targetplayer:SendConsoleCommand("chat.add \"" .. self.Config.Settings.ChatName .. "\" \"" .. targethurt .. "\"")

                -- Send message to command user via chat
                local playerhurt = string.gsub(self.Config.Messages.AdminHurt, "{player}", targetplayer.displayName)
                local playerhurt = string.gsub(playerhurt, "{amount}", tostring(amount))
                --player:SendConsoleCommand("chat.add \"" .. self.Config.Settings.ChatName .. "\" \"" .. playerhurt .. "\"")
            end
        end
    end
end

-- Load default configuration
function PLUGIN:LoadDefaultConfig()
    -- General settings
    self.Config.Settings = {}
    self.Config.Settings.ChatName = "HURT"
    self.Config.Settings.ChatCommand = "hurt"

    -- Message strings
    self.Config.Messages = {}
    self.Config.Messages.NoPermission = "You do not have permission to use this command!"
    self.Config.Messages.HelpText = "Use /hurt player amount (amount being optional, default is 100)"
    self.Config.Messages.InvalidTarget = "Invalid target! Please try again"
    self.Config.Messages.TargetHurt = "You have been hurt {amount} by admin"
    self.Config.Messages.AdminHurt = "{player} has been hurt {amount}"
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\Inventory-Guardian.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--[[ 
 Inventory Guardian
 
 Copyright (c) 2015 Nexus <talk@juliocesar.me>, <http://steamcommunity.com/profiles/76561197983103320/>
 
 -------------------------------------------------------------------------------------------------------------------
 This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US.
 -----------------------------------------------------------------------------------------------------------------
 
 $Id$
 Version 0.1.5 by Nexus on 2015-04-11 06:15 PM (UTC -03:00)
]]--

PLUGIN.Name = "Inventory-Guardian"
PLUGIN.Title = "Inventory Guardian"
PLUGIN.Description = "Keep players inventory after server wipes"
PLUGIN.Version = V(0, 1, 5)
PLUGIN.Author = "Nexus"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 773

-- Define Inventory Guardian class
local IG = {}

-- Define Inventory Data
IG.Data = {}

-- Define Player deaths table
IG.PlayerDeaths = {}

-- Define default save protocol
IG.SaveProtocol = 0

-- Get a Copy of PLUGIN Class
IG.ox = PLUGIN

-- Define Config version
IG.ConfigVersion = "0.0.8"

-- Define Settings
IG.Settings = {}
-- Define Messages
IG.Messages = {}

-- Define Local config values
IG.DefaultSettings = {
  ChatName = "Inventory Guardian",
  Enabled = true,
  RequiredAuthLevel = 2,
  ConfigVersion = "0.0.8",
  RestoreUponDeath = false,
  AutoRestore = true,
  KeepItemCondition = true
}

-- Define Plugin Messages:
IG.DefaultMessages = {
  Saved = "Your inventory was been saved!",
  Restored = "Your inventory has been restored!",
  RestoreUponDeathEnabled = "Restore Upon Death Enabled!",
  RestoreUponDeathDisabled = "Restore Upon Death Disabled!",
  RestoreEmpty = "You don't have any saved inventory, so cannot be restored!",
  DeletedInv = "Your saved inventory was deleted!",
  Enabled = "Enabled!",
  Disabled = "Disabled!",
  AutoRestoreDisabled = "Automatic Restoration has been disabled!",
  AutoRestoreEnabled = "Automatic Restoration has been enabled!",
  AuthLevelChanged = "You changed the required Auth Level to %d!",
  CantDoDisabled = "We are unable to run that command since the Inventory Guardian is disabled!",
  NotAllowed = "You cannot use that command because you don't have the required Auth Level %d!",
  InvalidAuthLevel = "You need pass a valid auth level like: admin, owner, mod, moderator, 1 or 2!",
  RestoredPlayerInventory = "Player \"%s\" inventory has been restored!",
  RestoreInit = "Initiating all players inventories restoration...",
  RestoreAll = "All players inventories has been restored!",
  SavedPlayerInventory = "Player \"%s\" inventory has been saved!",
  SaveInit = "Initiating all players inventories salvation...",
  SaveAll = "All players inventories has been saved!",
  PlayerNotFound = "The specified player couldn't be found please try again!",
  MultiplePlayersFound = "Found multiple players with that name!",
  DeletedPlayerInventory = "Player \"%s\" saved inventory has been deleted!",
  DeleteAll = "All players inventories has been deleted!",
  DeleteInit = "Initiating all players inventories deletion...",
  StripInit = "Initiating all players inventories strips...",
  StripAll = "All players inventories has been stripped!",
  SelfStriped = "Your current inventory has been cleaned!",
  PlayerStriped = "Your current inventory has been cleaned by \"%s\"",
  PlayerStripedBack = "Player \"%s\" inventory has been cleaned.",
  AutoRestoreDetected = "Map wipe was detected!",
  AutoRestoreNotDetected = "Forced map wipe not detected!",
  WipeRestoreOnce = "Restore once has been enabled to all players.",
  RestoreOnce = "Restore once has been enabled to %s!",
  KeepConditionEnabled = "Items condition restoration has been enabled!",
  KeepConditionDisabled = "Items condition restoration has been disabled!",
  PlayerSaved = "Your inventory has been saved by \"%s\".",
  PlayerDeleted = "Your saved inventory has been deleted by \"%s\"!",
  PlayerRestored = "Your inventory has been restored by \"%s\"!",
  PlayerRestoreEmpty = "Player \"%s\" don't have any saved inventory, so cannot be restored!",
  AuthLog = " %s by %s (%s)",

  Help = {
    "/ig.save - Save your inventory for later restoration!",
    "/ig.restore - Restore your saved inventory!",
    "/ig.delsaved - Delete your saved inventory!",
    "/ig.save <name> - Save player's inventory for later restoration!",
    "/ig.restore <name> - Restore player's saved inventory!",
    "/ig.delsaved <name> - Delete player's saved inventory!",
    "/ig.restoreupondeath - Toggles the Inventory restoration upon death for all players on the server!",
    "/ig.toggle - Toggle (Enable/Disable) Inventory Guardian!",
    "/ig.autorestore - Toggle (Enable/Disable) Automatic Restoration.",
    "/ig.authlevel <n/s> - Change Inventory Guardian required Auth Level.",
    "/ig.strip - Clear your current inventory.",
    "/ig.strip <name> - Clear player current inventory.",
    "/ig.keepcondition - Toggle (Enable/Disable) Items condition restoration."
  }
}

-- -----------------------------------------------------------------------------------
-- IG:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- It check if the config version is outdated
-- -----------------------------------------------------------------------------------
function IG:UpdateConfig()
  -- Check if the current config version differs from the saved
  if self.ox.Config.Settings.ConfigVersion ~= self.ConfigVersion then
    -- Reset the whole table
    self.ox.Config.Settings = {}
    self.ox.Config.Messages = {}
    
    -- Load the default
    self.ox:LoadDefaultConfig()
    -- Save config
    self.ox:SaveConfig()
  end
  
  -- Copy Tables
  self.Settings = self.ox.Config.Settings
  self.Messages = self.ox.Config.Messages
end

-- -----------------------------------------------------------------------------------
-- IG:ClearSavedInventory(player)
-- -----------------------------------------------------------------------------------
-- Clear player's saved inventory on Data Table
-- -----------------------------------------------------------------------------------
function IG:ClearSavedInventory(player)
  -- Grab the player SteamID.
  local playerID = rust.UserIDFromPlayer(player)
  
  -- Check if playerID is valid
  if playerID ~= "0" then
    -- Reset inventory
    self.Data.GlobalInventory[playerID] = {}
    self.Data.GlobalInventory[playerID]['belt'] = {}
    self.Data.GlobalInventory[playerID]['main'] = {}
    self.Data.GlobalInventory[playerID]['wear'] = {}
    -- Save Inventory
    self.ox:SaveData()
  end
end

-- -----------------------------------------------------------------------------------
-- IG:SaveInventory(player)
-- -----------------------------------------------------------------------------------
-- Save player inventory
-- -----------------------------------------------------------------------------------
function IG:SaveInventory(player)
  -- Grab the player SteamID.
  local playerID = rust.UserIDFromPlayer(player)

  -- Get Player inventory list
  local belt = player.inventory.containerBelt
  local main = player.inventory.containerMain
  local wear = player.inventory.containerWear

  -- Enumerate inventory list
  local beltItems = belt.itemList:GetEnumerator()
  local mainItems = main.itemList:GetEnumerator()
  local wearItems = wear.itemList:GetEnumerator()
  -- Reset counts
  local beltCount = 0
  local mainCount = 0
  local wearCount = 0

  -- Reset saved inventory
  self:ClearSavedInventory(player)

  -- Loop by the Belt Items
  while beltItems:MoveNext() do
    -- Save current item to player's inventory table
    self.Data.GlobalInventory[playerID]['belt'][tostring(beltCount)] = {name = tostring(beltItems.Current.info.shortname), amount = beltItems.Current.amount, condition = beltItems.Current.condition, bp = beltItems.Current.isBlueprint}
    -- Increment the count
    beltCount = beltCount + 1
  end

  -- Loop by the Main Items
  while mainItems:MoveNext() do
    -- Save current item to player's inventory table
    self.Data.GlobalInventory[playerID]['main'][tostring(mainCount)] = {name = tostring(mainItems.Current.info.shortname), amount = mainItems.Current.amount, condition =  mainItems.Current.condition, bp = mainItems.Current.isBlueprint}
    -- Increment the count
    mainCount = mainCount + 1
  end

  -- Loop by the Wear Items
  while wearItems:MoveNext() do
    -- Save current item to player's inventory table
    self.Data.GlobalInventory[playerID]['wear'][tostring(wearCount)] = {name = tostring(wearItems.Current.info.shortname), amount = wearItems.Current.amount, condition = wearItems.Current.condition, bp = false}
    -- Increment the count
    wearCount = wearCount + 1
  end  

  -- Save inventory data
  self.ox:SaveData()
end

-- -----------------------------------------------------------------------------------
-- IG:SavedInventoryIsEmpty(player)
-- -----------------------------------------------------------------------------------
-- Check if player's saved inventory is empty
-- -----------------------------------------------------------------------------------
function IG:SavedInventoryIsEmpty(player)
  -- Grab the player SteamID.
  local playerID = rust.UserIDFromPlayer(player)
  
  -- Check if player's inventory is null
  if self.Data.GlobalInventory[playerID] == nil then
    return true
  else
    -- Check if all inventory containers are empty too
    return self:Count(self.Data.GlobalInventory [playerID] ['belt']) == 0 and self:Count(self.Data.GlobalInventory [playerID] ['main']) == 0 and self:Count(self.Data.GlobalInventory [playerID] ['wear'] )== 0
  end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Count(tbl)
-- -----------------------------------------------------------------------------
-- Counts the elements of a table.
-- -----------------------------------------------------------------------------
-- Credit: m-Teleportation
function IG:Count(tbl)
  local count = 0

  if type(tbl) == "table" then
    for _ in pairs(tbl) do
      count = count + 1
    end
  end

  return count
end

-- -----------------------------------------------------------------------------------
-- IG:RestoreInventory(player)
-- -----------------------------------------------------------------------------------
-- Restore player inventory
-- -----------------------------------------------------------------------------------
function IG:RestoreInventory(player)
  -- Grab the player his/her SteamID.
  local playerID = rust.UserIDFromPlayer(player)
  -- Clear player Inventory
  player.inventory:Strip()

  -- This fixes the incomplete restoration process
  timer.Once (1, function ()
    -- Get Player inventory list
    local belt = player.inventory.containerBelt
    local main = player.inventory.containerMain
    local wear = player.inventory.containerWear
    local Inventory = {}

    -- Set inventory
    Inventory['belt'] = belt
    Inventory['main'] = main
    Inventory['wear'] = wear

    -- Loop by player's saved inventory slots
    for slot, items in pairs(self.Data.GlobalInventory[playerID]) do
      --Loop by slots
      for i, item in pairs(items) do

        -- Create an inventory item
        local itemEntity = global.ItemManager.CreateByName(item.name, item.amount)
        
        -- Check for Blueprint field
        if item.bp then
          -- Set Item as Blueprint
          itemEntity.isBlueprint = true
        -- Check for Health field
        elseif item.condition and self.Settings.KeepItemCondition then
          -- Define item health
          itemEntity.condition = item.condition       
        end

        -- Set that created inventory item to player
        player.inventory:GiveItem(itemEntity, Inventory[slot])
      end
    end
  end)
end

-- -----------------------------------------------------------------------------
-- IG:SendMessage(param, message)
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player/console
-- -----------------------------------------------------------------------------
function IG:SendMessage(param, message)
  -- Check if the message is a table with multiple messages.
  if type(message) == "table" then
    -- Loop by table of messages and send them one by one
    for i, message in pairs(message) do
      -- Loop back
      self:SendMessage(param, message)
    end
  else
    -- Check if param is not null
    if param ~= nil then
      -- Check if call came from user's chat or console
      if type(param.net) == 'userdata' then
          -- Send the message to the targetted player.
         rust.SendChatMessage(param, self.Settings.ChatName, message, rust.UserIDFromPlayer(param))
      elseif type(param.net) == 'string' then    
        -- Check if was passed by client's console 
        if param.connection then
          -- Reply back to player's console
          param:ReplyWith(self.Settings.ChatName..": "..message) 
          -- Send message with authLog to console
          self:SendMessage(nil, self.Messages.AuthLog:format(message, param.connection.player.displayName, rust.UserIDFromPlayer(param.connection.player)))
        else
          -- Send message to console
          self:SendMessage(nil, message)
        end
      end
    else
      -- Log
      self:Log(self.Settings.ChatName..": "..message) 
    end
  end
end

-- -----------------------------------------------------------------------------------
-- IG:RestoreUponDeath(player)
-- -----------------------------------------------------------------------------------
-- Toogle the config restore upon death
-- -----------------------------------------------------------------------------------
function IG:ToggleRestoreUponDeath(player)
  -- Check if Inventory Guardian is enabled
  if self.Settings.Enabled then
    -- Check if Restore Upon Death is enabled
    if self.Settings.RestoreUponDeath then
      -- Disable Restore Upon Death
      self.Settings.RestoreUponDeath = false
      -- Send Message to Player
      self:SendMessage(player, self.Messages.RestoreUponDeathDisabled)
    else
      -- Enable Restore Upon Death
      self.Settings.RestoreUponDeath = true
      -- Send Message to Player
      self:SendMessage(player, self.Messages.RestoreUponDeathEnabled)
    end

    -- Save the config.
    self.ox:SaveConfig()
  end
end

-- -----------------------------------------------------------------------------------
-- IG:ToogleKeepCondition()
-- -----------------------------------------------------------------------------------
-- Toogle the config KeepItemCondition
-- -----------------------------------------------------------------------------------
function IG:ToogleKeepCondition(player)
  -- Check if Inventory Guardian is enabled
  if self.Settings.Enabled then
    -- Check if Keep Items Condition is enabled
    if self.Settings.KeepItemCondition then
      -- Disable Keep Items Condition
      self.Settings.KeepItemCondition = false
      -- Send Message to Player
      self:SendMessage(player, self.Messages.KeepConditionDisabled)
    else
      -- Enable Restore Upon Death
      self.Settings.KeepItemCondition = true
      -- Send Message to Player
      self:SendMessage(player, self.Messages.KeepConditionEnabled)
    end

    -- Save the config.
    self.ox:SaveConfig()
  end
end

-- -----------------------------------------------------------------------------------
-- IG:ToggleInventoryGuardian(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Inventory Guardian
-- -----------------------------------------------------------------------------------
function IG:ToggleInventoryGuardian(player)
  -- Check if Inventory Guardian is enabled
  if self.Settings.Enabled then
    -- Disable Inventory Guardian
    self.Settings.Enabled = false
    -- Send Message to Player
    self:SendMessage(player, self.Messages.Disabled)
  else
    -- Enable Inventory Guardian
    self.Settings.Enabled = true
    -- Send Message to Player
    self:SendMessage(player, self.Messages.Enabled)
  end

  -- Save the config.
  self.ox:SaveConfig()
end

-- -----------------------------------------------------------------------------------
-- IG:ToggleAutoRestore(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Automatic restoration
-- -----------------------------------------------------------------------------------
function IG:ToggleAutoRestore(player)
  -- Check if Inventory Guardian is enabled
  if self.Settings.AutoRestore then
    -- Disable Inventory Guardian's Auto restore
    self.Settings.AutoRestore = false
    -- Send Message to Player
    self:SendMessage(player, self.Messages.AutoRestoreDisabled)
  else
    -- Enable Inventory Guardian's Auto restore
    self.Settings.AutoRestore = true
    -- Send Message to Player
    self:SendMessage(player, self.Messages.AutoRestoreEnabled)
  end

  -- Save the config.
  self.ox:SaveConfig()
end

-- -----------------------------------------------------------------------------------
-- IG:ChangeAuthLevel(player, authLevel)
-- -----------------------------------------------------------------------------------
-- Change Auth Level required to use Inventory Guardian
-- -----------------------------------------------------------------------------------
function IG:ChangeAuthLevel(player, authLevel)
  -- Check if Inventory Guardian is enabled
  if self.Settings.Enabled then
    -- Check for Admin
    if authLevel == "admin" or authLevel == "owner" or authLevel == "2" then
      -- Set required auth level to admin
      self.Settings.RequiredAuthLevel = 2
      -- Send message to player
      self:SendMessage(player, self.Messages.AuthLevelChanged:format(2))
      -- Check for Mod
    elseif authLevel == "mod" or authLevel == "moderator" or authLevel == "1" then
      -- Set required auth level to moderator
      self.Settings.RequiredAuthLevel = 1
      -- Send message to player
      self:SendMessage(player, self.Messages.AuthLevelChanged:format(1))
    else
      -- Send message to player
      self:SendMessage(player, self.Messages.InvalidAuthLevel)
    end

    -- Save the config.
    self.ox:SaveConfig()
  end
end

-- -----------------------------------------------------------------------------------
-- IG:IsAllowed(player)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run an admin (or moderator or user) only command.
-- -----------------------------------------------------------------------------------
function IG:IsAllowed(player)
  -- Check if player is valid
  if player ~= nil then
    -- Check if is connected
    if player:GetComponent("BaseNetworkable").net.connection ~= nil then
      -- Compare the Player's AuthLevel with the required AuthLevel, if it's higher or equal
      return player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Settings.RequiredAuthLevel
    end
  end

  return false
end

-- -----------------------------------------------------------------------------------
-- IG:Check(player)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and save Inventory
-- -----------------------------------------------------------------------------------
function IG:Check(player)
  -- Check if Inventory Guardian is enabled
  if not self.Settings.Enabled then
    -- Send message to player
    self:SendMessage(player, self.Messages.CantDoDisabled)

    return false
      -- Check if player is allowed and Inventory Guardian is enabled
  elseif not self:IsAllowed(player) then
    -- Send message to player
    self:SendMessage(player, self.Messages.NotAllowed:format(self.Settings.RequiredAuthLevel))

    return false
  else
    return true
  end
end

-- -----------------------------------------------------------------------------------
-- IG:PlayerIsConnected(player)
-- -----------------------------------------------------------------------------------
-- Checks if the player is connected
-- -----------------------------------------------------------------------------------
function IG:PlayerIsConnected(player)
  -- Check if player is not null
  if player ~= nil then
    return player:GetComponent("BaseNetworkable").net.connection ~= nil
  else
    return nil
  end
end

-- -----------------------------------------------------------------------------------
-- IG:RestoreAll(param)
-- -----------------------------------------------------------------------------------
-- Restore all players inventories
-- -----------------------------------------------------------------------------------
function IG:RestoreAll(param)
  -- Send message
  self:SendMessage(param, self.Messages.RestoreInit)

  -- Get all players
  local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
  local player = nil
  local playerID = 0

  -- Loop by all players
  for i = 0, (players.Length-1) do
    -- Get current player
    player = players[i]
    
    -- Get PlayerID
    playerID = rust.UserIDFromPlayer(player)
    
    -- Check if player have a valid Player ID
    if playerID ~= "0" then
      -- Check if player have a saved inventory
      if not self:SavedInventoryIsEmpty(player) then
        -- Restore Inventory
        self:RestoreInventory(player)
        -- Send message to player
        self:SendMessage(param, self.Messages.RestoredPlayerInventory:format(player.displayName))
        
        -- Check if player is connected
        if self:PlayerIsConnected(player) then
          -- Send message to Oplayer
          IG:SendMessage(player, self.Messages.PlayerSaved:format("admin"))
        end
      end
    end
    
    -- Add timer
    timer.Once(1, function ()
      -- Check if loop is done
      if (players.Length-1) == i then
        -- Send message
        self:SendMessage(param, self.Messages.RestoreAll)
      end
    end)
  end
end

-- -----------------------------------------------------------------------------------
-- IG:SaveAll(param)
-- -----------------------------------------------------------------------------------
-- Save all players inventories
-- -----------------------------------------------------------------------------------
function IG:SaveAll(param)
  -- Send message
  self:SendMessage(param, self.Messages.SaveInit)

  -- Get all players
  local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
  local player = nil
  local playerID = 0

  -- Loop by all players
  for i = 0, (players.Length-1) do
    -- Get current player
    player = players[i]
    
    -- Get PlayerID
    playerID = rust.UserIDFromPlayer(player)
    
    -- Check if player have a valid Player ID
    if playerID ~= "0" then
      -- Save Inventory
      self:SaveInventory(player)

      -- Send message to console
      self:SendMessage(param, self.Messages.SavedPlayerInventory:format(player.displayName))
      
      -- Check if player is connected
      if self:PlayerIsConnected(player) then
        -- Send message to Oplayer
        self:SendMessage(player, self.Messages.PlayerSaved:format("admin"))
      end
    end
    
    -- Add timer
    timer.Once(1, function ()
      -- Check if loop is done
      if (players.Length-1) == i then
        -- Send message
        self:SendMessage(param, self.Messages.SaveAll)
      end
    end)
  end
end

-- -----------------------------------------------------------------------------------
-- IG:DeleteAll(param)
-- -----------------------------------------------------------------------------------
-- Delete all players inventories
-- -----------------------------------------------------------------------------------
function IG:DeleteAll(param)
  -- Send message
  self:SendMessage(param, self.Messages.DeleteInit)

  -- Get all players
  local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
  local player = nil
  local playerID = 0
  local i = 0

  -- Loop by all players
  for i = 0, (players.Length-1) do
    -- Get current player
    player = players[i]

    -- Get PlayerID
    playerID = rust.UserIDFromPlayer(player)
    -- Check if player have a valid Player ID
    if playerID ~= "0" then
      -- Delete player Inventory
      self:ClearSavedInventory(player)
      -- Send message to player
      self:SendMessage(param, self.Messages.DeletedPlayerInventory:format(player.displayName))
      
      -- Check if player is connected
      if self:PlayerIsConnected(player) then
        -- Send message to Oplayer
        IG:SendMessage(player, self.Messages.PlayerDeleted:format("admin"))
      end
    end

    -- Add timer
    timer.Once(1, function ()
      -- Check if loop is done
      if (players.Length-1) == i then
        -- Send message
        self:SendMessage(param, self.Messages.DeleteAll)
      end
    end)
  end
end

-- -----------------------------------------------------------------------------------
-- IG:StripAll(param)
-- -----------------------------------------------------------------------------------
-- Strip all players inventories
-- -----------------------------------------------------------------------------------
function IG:StripAll(param)
  -- Send message
  self:SendMessage(param, self.Messages.StripInit)

  -- Get all players
  local players = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
  local player = nil
  local playerID = 0
  local i = 0

  -- Loop by all players
  for i = 0, (players.Length-1) do
    -- Get current player
    player = players[i]

    -- Get PlayerID
    playerID = rust.UserIDFromPlayer(player)
    
    -- Check if player have a valid Player ID
    if playerID ~= "0" then
      -- Clear player Inventory
      player.inventory:Strip()
      
      -- Send message to player
      self:SendMessage(param, self.Messages.PlayerStripedBack:format(player.displayName))
      
      -- Check if player is connected
      if self:PlayerIsConnected(player) then
        -- Send message to Oplayer
        IG:SendMessage(player, self.Messages.PlayerStriped:format("admin"))
      end
    end

    -- Add timer
    timer.Once(1, function ()
      -- Check if loop is done
      if (players.Length-1) == i then
        -- Send message
        self:SendMessage(param, self.Messages.StripAll)
      end
    end)
  end
end

-- -----------------------------------------------------------------------------
-- IG:FindPlayersByName(playerName)
-- -----------------------------------------------------------------------------
-- Searches the online players for a specific name.
-- -----------------------------------------------------------------------------
function IG:FindPlayersByName(playerName)
  -- Check if a player name was supplied.
  if not playerName then return end

  -- Set the player name to lowercase to be able to search case insensitive.
  playerName = string.lower(playerName)

  -- Setup some variables to save the matching BasePlayers with that partial
  -- name.
  local matches = {}
  -- Get all players (Sleeping/Online)
  local PlayerList = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
  -- Enumarate list
  PlayerList = PlayerList:GetEnumerator()

  -- Iterate through the online player list and check for a match.
  while PlayerList:MoveNext() do
    -- Get the player his/her display name and set it to lowercase.
    local displayName = string.lower(PlayerList.Current.displayName)

    -- Look for a match.
    if string.find(displayName, playerName, 1, true) then
      -- Match found, add the player to the list.
      table.insert(matches, PlayerList.Current)
    end
  end

  -- Return all the matching players.
  return matches
end

-- -----------------------------------------------------------------------------
-- IG:FindPlayerByName(oPlayer, playerName)
-- -----------------------------------------------------------------------------
-- Searches the online players for a specific name.
-- -----------------------------------------------------------------------------
function IG:FindPlayerByName(oPlayer, playerName)
  -- Get a list of matched players
  local players = self:FindPlayersByName(playerName)
  local player = nil

  -- Check if we found the targetted player.
  if self:Count(players) == 0 then
    -- The targetted player couldn't be found, send a message to the player.
    self:SendMessage(oPlayer, self.Messages.PlayerNotFound)

    return player
  end

  -- Check if we found multiple players with that partial name.
  if self:Count(players) > 1 then
    -- Multiple players were found, send a message to the player.
    self:SendMessage(oPlayer, self.Messages.MultiplePlayersFound)

    return player
  else
    -- Only one player was found, modify the targetPlayer variable value.
    player = players[1]
  end

  return player
end

-- -----------------------------------------------------------------------------------
-- IG:AutomaticRestoration()
-- -----------------------------------------------------------------------------------
-- Detect and restore inventories
-- -----------------------------------------------------------------------------------
function IG:AutomaticRestoration()
  -- Check if protocols are detected
  if self.Settings.AutoRestore then
    -- Check if the current Save Protocol is different then the last saved
    if self.SaveProtocol ~= self.Data.SaveProtocol and self.Data.SaveProtocol ~= 0 then
      -- Wipe Restore Once list
      self.Data.RestoreOnce = {}
      -- Send message to console
      self:LogWarning(self.Settings.ChatName..": "..self.Messages.AutoRestoreDetected)
    end
  end

  -- Set data save protocol
  self.Data.SaveProtocol = self.SaveProtocol
  
  -- Save SaveProtocol
  self.ox:SaveData()
end

-- -----------------------------------------------------------------------------------
-- IG:Log(message)
-- -----------------------------------------------------------------------------------
-- Log normal
-- -----------------------------------------------------------------------------------
function IG:Log(message)
  UnityEngine.Debug.Log.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- IG:LogWarning (message)
-- -----------------------------------------------------------------------------------
-- Log Warning
-- -----------------------------------------------------------------------------------
function IG:LogWarning(message)
  UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- IG:LogError(message)
-- -----------------------------------------------------------------------------------
-- Log Error
-- -----------------------------------------------------------------------------------
function IG:LogError(message)
  UnityEngine.Debug.LogError.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- IG:ClearRestoreOnce(player, param)
-- -----------------------------------------------------------------------------------
-- Clear restore once table
function IG:ClearRestoreOnce(player, param)
  -- Set original player
  local oPlayer = player
  
  -- Check if player want to clear all
  if param == "all" or param == "*" then
    -- Wipe the whole Restore Once table
    self.Data.RestoreOnce = {} 
    -- Send message to player
    self:SendMessage(player, self.Messages.WipeRestoreOnce)
  elseif param ~= "" or param ~= " " then
      -- Find player by Name
      player = self:FindPlayerByName(player, param)
      
      -- Check if a player was found
      if player ~= nil then
        -- Get player ID
        local playerID = rust.UserIDFromPlayer(player)
        -- Delete playerID from Restore Once table
        self.Data.RestoreOnce[playerID] = nil
        -- Send message to player
        self:SendMessage(player, self.Messages.RestoreOnce:format(player.displayName))
      end  
  else
    -- Get player ID
    local playerID = rust.UserIDFromPlayer(player)
    -- Delete playerID from Restore Once table
    self.Data.RestoreOnce[playerID] = nil
    -- Send message to player
    self:SendMessage(player, self.Messages.RestoreOnce:format(player.displayName))
  end
  -- Save data table
  self.ox:SaveData()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnServerInitialized()
-- -----------------------------------------------------------------------------------
-- On server initialisation finished the required in-game chat commands are registered and data
-- from the DataTable file is loaded.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnServerInitialized()
  -- Add the current save protocol
  IG.SaveProtocol = Rust.Protocol.save

  -- Add chat commands
  command.AddChatCommand("ig.save", self.Plugin, "cmdSaveInventory")
  command.AddChatCommand("ig.restore", self.Plugin, "cmdRestoreInventory")
  command.AddChatCommand("ig.restoreupondeath", self.Plugin, "cmdToggleRestoreUponDeath")
  command.AddChatCommand("ig.delsaved", self.Plugin, "cmdDeleteInventory")
  command.AddChatCommand("ig.toggle", self.Plugin, "cmdToggleInventoryGuardian")
  command.AddChatCommand("ig.autorestore", self.Plugin, "cmdToggleAutoRestore")
  command.AddChatCommand("ig.authlevel", self.Plugin, "cmdChangeAuthLevel")
  command.AddChatCommand("ig.strip", self.Plugin, "cmdStripInv")
  command.AddChatCommand("ig.restoreonce", self.Plugin, "cmdClearRestoreOnce")
  command.AddChatCommand("ig.keepcondition", self.Plugin, "cmdToogleKeepCondition")

  -- Add console commands
  command.AddConsoleCommand("ig.authlevel", self.Plugin, "ccmdChangeAuthLevel")
  command.AddConsoleCommand("ig.toggle", self.Plugin, "ccmdToggleInventoryGuardian")
  command.AddConsoleCommand("ig.restoreupondeath", self.Plugin, "ccmdToggleRestoreUponDeath")
  command.AddConsoleCommand("ig.autorestore", self.Plugin, "ccmdToggleAutoRestore")
  command.AddConsoleCommand("ig.restoreall", self.Plugin, "ccmdRestoreAll")
  command.AddConsoleCommand("ig.saveall", self.Plugin, "ccmdSaveAll")
  command.AddConsoleCommand("ig.deleteall", self.Plugin, "ccmdDeleteAll")
  command.AddConsoleCommand("ig.restoreonce", self.Plugin, "ccmdClearRestoreOnce")
  command.AddConsoleCommand("ig.keepcondition", self.Plugin, "ccmdToogleKeepCondition")
  command.AddConsoleCommand("ig.strip", self.Plugin, "ccmdStripInv")
  command.AddConsoleCommand("ig.delsaved", self.Plugin, "ccmdDeleteInventory")
  command.AddConsoleCommand("ig.save", self.Plugin, "ccmdSaveInventory")
  command.AddConsoleCommand("ig.restore", self.Plugin, "ccmdRestoreInventory")
  command.AddConsoleCommand("ig.stripall", self.Plugin, "ccmdStripAll")

  -- Load default saved data
  self:LoadSavedData()

  -- Update config version
  IG:UpdateConfig()

  -- Run automatic restoration
  IG:AutomaticRestoration()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the players. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
  self.Config.Settings = IG.DefaultSettings
  self.Config.Messages = IG.DefaultMessages
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnPlayerDisconnected(player)
-- -----------------------------------------------------------------------------------
-- Run on Player Disconnect
-- -----------------------------------------------------------------------------------
function PLUGIN:OnPlayerDisconnected(player)
  -- Save player inventory
  IG:SaveInventory(player)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnEntityDeath(entity)
-- -----------------------------------------------------------------------------------
-- When an entity dies
-- -----------------------------------------------------------------------------------
function PLUGIN:OnEntityDeath(entity)
  -- Convert entity to player
  local player = entity:ToPlayer()

  -- Check if entity is a player
  if player then
    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer(player)
    
    -- Add playerID to player death list
    IG.PlayerDeaths[playerID] = true

    -- Check if the Restore upon death is enabled
    if self.Config.Settings.RestoreUponDeath then
      -- Save player inventory
      IG:SaveInventory(player)
    else
      -- Reset saved inventory
      IG:ClearSavedInventory(player)
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnPlayerRespawned(player)
-- -----------------------------------------------------------------------------------
-- When a player respawn
-- -----------------------------------------------------------------------------------
function PLUGIN:OnPlayerRespawned(player)
  -- Grab the player his/her SteamID.
  local playerID = rust.UserIDFromPlayer(player)

  -- Check if saved inventory is empty
  if not IG:SavedInventoryIsEmpty(player) then
    -- Check if Once Restoration is enabled and if player never got once restored or if Once Restoration is disabled or if the Restore upon death is enabled and if player just died or If player never died = First spawn
    if IG.Data.RestoreOnce [playerID] == nil or (self.Config.Settings.RestoreUponDeath and IG.PlayerDeaths[playerID] == true) or IG.PlayerDeaths[playerID] == nil then
      -- Restore player inventory
      IG:RestoreInventory(player)
      -- Send message to user
      IG:SendMessage(player, self.Config.Messages.Restored)
      -- Add Player ID to Once Restorated List
      IG.Data.RestoreOnce [playerID] = true
      -- Reset saved inventory
      timer.Once(3, function() IG:ClearSavedInventory(player) end)
    end
  end

  -- Remove PlayerID from player deaths list
  IG.PlayerDeaths[playerID] = nil
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SendHelpText(player)
-- -----------------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- -----------------------------------------------------------------------------------
function PLUGIN:SendHelpText(player)
  -- Check if user is admin
  if IG:IsAllowed(player) then
    -- Send message to player
    IG:SendMessage(player, self.Config.Messages.Help)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdSaveInventory(player, _, args)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and save Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdSaveInventory(player, _, args)
  -- Make a copy of the player what ran the command
  local oPlayer = player
  local tPlayer = nil

  -- Check if Inventory Guardian is enabled and If player is allowed
  if IG:Check(player) then
    -- Check if any arg was passed
    if args.Length == 1 then
      -- Check if arg is not empty
      if args[0] ~= "" or args[0] ~= " " then
        -- Find a player by name
        tPlayer = IG:FindPlayerByName(oPlayer, args[0])

        -- Check if player is valid
        if tPlayer ~= nil then
          -- Set player as the founded player
          player = tPlayer
        else
          return nil
        end
      end
    end

    -- Save player inventory
    IG:SaveInventory(player)

    -- Check if oPlayer is the same then player
    if player ~= oPlayer then
      -- Send message to oPlayer
      IG:SendMessage(oPlayer, self.Config.Messages.SavedPlayerInventory:format(player.displayName))
      -- Send message to player
      IG:SendMessage(player, self.Config.Messages.PlayerSaved:format(oPlayer.displayName))
    else
      -- Send message to user
      IG:SendMessage(player, self.Config.Messages.Saved)
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdRestoreInventory(player, _, args)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and restore Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdRestoreInventory(player, _, args)
  -- Make a copy of the player what ran the command
  local oPlayer = player
  local tPlayer = nil

  -- Check if Inventory Guardian is enabled and If player is allowed
  if IG:Check(player) then
    -- Check if any arg was passed
    if args.Length == 1 then
      -- Check if arg is not empty
      if args[0] ~= "" or args[0] ~= " " then
        -- Find a player by name
        tPlayer = IG:FindPlayerByName(oPlayer, args[0])

        -- Check if player is valid
        if tPlayer ~= nil then
          -- Set player as the founded player
          player = tPlayer
        else
          return nil
        end
      end
    end

    -- Check if saved inventory is empty
    if IG:SavedInventoryIsEmpty (player) then
      -- Send message
      IG:SendMessage(oPlayer, self.Config.Messages.RestoreEmpty)
    else
      -- Restore Inventory
      IG:RestoreInventory(player)
      -- Check if oPlayer is the same then player
      if player ~= oPlayer then
        -- Send message to oPlayer
        IG:SendMessage(oPlayer, self.Config.Messages.RestoredPlayerInventory:format(player.displayName))
        -- Send message to player
        IG:SendMessage(player, self.Config.Messages.PlayerRestored:format(oPlayer.displayName))
      else      
        -- Send message to user
        IG:SendMessage(player, self.Config.Messages.Restored)
      end
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdDeleteInventory(player, _, args)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and delete Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdDeleteInventory(player, _, args)
  -- Make a copy of the player what ran the command
  local oPlayer = player
  local tPlayer = nil

  -- Check if Inventory Guardian is enabled and If player is allowed
  if IG:Check(player) then
    -- Check if any arg was passed
    if args.Length == 1 then
      -- Check if arg is not empty
      if args[0] ~= "" or args[0] ~= " " then
        -- Find a player by name
        tPlayer = IG:FindPlayerByName(oPlayer, args[0])

        -- Check if player is valid
        if tPlayer ~= nil then
          -- Set player as the founded player
          player = tPlayer
        else
          return nil
        end
      end
    end

    -- Restore player Inventory
    IG:ClearSavedInventory(player)

    -- Check if oPlayer is the same then player
    if player ~= oPlayer then
      -- Send message to oPlayer
      IG:SendMessage(oPlayer, self.Config.Messages.DeletedPlayerInventory:format(player.displayName))
      -- Send message to player
      IG:SendMessage(player, self.Config.Messages.PlayerDeleted:format(oPlayer.displayName))
    else
      -- Send message to user
      IG:SendMessage(player, self.Config.Messages.DeletedInv)
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToggleInventoryGuardian(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Inventory Guardian
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToggleInventoryGuardian(player)
  -- Check if Inventory Guardian is enabled and If player is allowed
  if IG:IsAllowed(player) then
    -- Restore Player inventory
    IG:ToggleInventoryGuardian(player)
  else
    -- Send message to player
    IG:SendMessage(player, self.Config.Messages.NotAllowed:format(self.Config.Settings.RequiredAuthLevel))
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToggleRestoreOnce(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Automatic restoration
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToggleAutoRestore(player)
  -- Check if Inventory Guardian is enabled and If player is allowed
  if IG:Check(player) then
    -- Toggle Automatic Restoration
    IG:ToggleAutoRestore(player)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdChangeAuthLevel(player, _, args)
-- -----------------------------------------------------------------------------------
-- Change required Auth Level
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdChangeAuthLevel(player, _, args)
  -- Check if Inventory Guardian is enabled
  if IG:Check(player) then
    -- Check for passed args
    if args.Length == 1 then
      -- Change required Auth level
      IG:ChangeAuthLevel(player, args[0])
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToggleRestoreUponDeath(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Restoration upon death
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToggleRestoreUponDeath(player)
  -- Check if Inventory Guardian is enabled
  if IG:Check(player) then
    -- Toggle restore upon death
    IG:ToggleRestoreUponDeath(player)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToogleKeepCondition(player)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Keep Items Condition
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToogleKeepCondition(player)
  -- Check if Inventory Guardian is enabled
  if IG:Check(player) then
    -- Toggle keep items condition
    IG:ToogleKeepCondition(player)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdChangeAuthLevel(arg)
-- -----------------------------------------------------------------------------------
-- Change required Auth Level
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdChangeAuthLevel(arg)
  -- Check for passed args
  if arg:HasArgs(1) then
    -- Change required Auth level
    IG:ChangeAuthLevel(arg, arg.Args[0])
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdToggleInventoryGuardian()
-- -----------------------------------------------------------------------------------
-- Enable/Disable Inventory Guardian
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdToggleInventoryGuardian(arg)
  -- Restore Player inventory
  IG:ToggleInventoryGuardian(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdToogleKeepCondition(arg)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Keep Items Condition
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdToogleKeepCondition(arg)
  -- Toggle keep items condition
  IG:ToogleKeepCondition(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdToggleRestoreOnce(arg)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Automatic restoration
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdToggleAutoRestore(arg)
  -- Toggle automatic restoration
  IG:ToggleAutoRestore(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdToggleRestoreUponDeath(arg)
-- -----------------------------------------------------------------------------------
-- Enable/Disable Restoration upon death
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdToggleRestoreUponDeath(arg)
  -- Toggle restore upon death
  IG:ToggleRestoreUponDeath(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdRestoreAll()
-- -----------------------------------------------------------------------------------
-- Restore All players inventories
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdRestoreAll(arg)
  -- Restore all players inventories
  IG:RestoreAll(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdSaveAll()
-- -----------------------------------------------------------------------------------
-- Save All players inventories
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdSaveAll(arg)
  -- Save all players inventories
  IG:SaveAll(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdDeleteAll()
-- -----------------------------------------------------------------------------------
-- Delete All players inventories
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdDeleteAll(arg)
  -- Delete all players inventories
  IG:DeleteAll(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdStripAll()
-- -----------------------------------------------------------------------------------
-- Delete All players inventories
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdStripAll(arg)
  -- Strip all players inventories
  IG:StripAll(arg)
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdStripInv(player, _, args)
-- -----------------------------------------------------------------------------------
-- Strip player inventory
-- ----------------------------------------------------------------------------------
function PLUGIN:cmdStripInv(player, _, args)
  -- Copy origin player
  local oPlayer = player
  local tPlayer = nil

    -- Check if any arg was passed
    if args.Length == 1 then
      -- Check if arg is not empty
      if args[0] ~= "" or args[0] ~= " " then
        -- Find a player by name
        tPlayer = IG:FindPlayerByName(oPlayer, args[0])
    
        -- Check if player is valid
        if tPlayer ~= nil then
          -- Set player as the founded player
          player = tPlayer
        else
          return nil
        end
    end
  end

  -- Check if player is valid
  if player ~= nil then
    -- Clear player Inventory
    player.inventory:Strip()
  end

  -- Check if player is not oPlayer
  if player ~= oPlayer then
    -- Send message to target player
    IG:SendMessage(tPlayer, self.Config.Messages.PlayerStriped:format(oPlayer.displayName))
    -- Send message back to oPlayer
    IG:SendMessage(oPlayer, self.Config.Messages.PlayerStripedBack:format(player.displayName))
  else
    -- Send message to oPlayer
    IG:SendMessage(oPlayer, self.Config.Messages.SelfStriped)
  end
  
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdStripInv(arg)
-- -----------------------------------------------------------------------------------
-- Strip player inventory
-- ----------------------------------------------------------------------------------
function PLUGIN:ccmdStripInv(arg)
    -- Define player
    local player = nil
    -- Check if any arg was passed
    if arg:HasArgs(1) then
      -- Check if arg is not empty
      if arg.Args[0] ~= "" or arg.Args[0] ~= " " then
        -- Find a player by name
        player = IG:FindPlayerByName(arg, arg.Args[0])
    end
  end

  -- Check if player is valid
  if player ~= nil then
    -- Clear player Inventory
    player.inventory:Strip()
          
    -- Send message back to console
    IG:SendMessage(arg, self.Config.Messages.PlayerStripedBack:format(player.displayName))    
    -- Send message 
    IG:SendMessage(player, self.Config.Messages.PlayerStriped:format("admin"))
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdDeleteInventory(arg)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and delete Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdDeleteInventory(arg)
  -- Define player
  local player = nil
  
  -- Check if any arg was passed
  if arg:HasArgs(1) then
    -- Find a player by name
    player = IG:FindPlayerByName(arg, arg.Args[0])
  end

  -- Check if is valid
  if player ~= nil then
    -- Restore player Inventory
    IG:ClearSavedInventory(player)
    
    -- Send message back to player
    IG:SendMessage(arg, self.Config.Messages.DeletedPlayerInventory:format(player.displayName))
    -- Send message
    IG:SendMessage(player, self.Config.Messages.PlayerDeleted:format("admin"))
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdSaveInventory(arg)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and save Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdSaveInventory(arg)
  -- Make a copy of the player what ran the command
  local player = nil

  -- Check if any arg was passed
  if arg:HasArgs(1) then
    -- Find a player by name
    player = IG:FindPlayerByName(arg, arg.Args[0])
  end

  -- Check if player is valid
  if player ~= nil then
    -- Save player inventory
    IG:SaveInventory(player)
    
    -- Send message to oPlayer
    IG:SendMessage(arg, self.Config.Messages.SavedPlayerInventory:format(player.displayName))
    -- Send message to player
    IG:SendMessage(player, self.Config.Messages.PlayerSaved:format("admin"))
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdRestoreInventory(arg)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run and restore Inventory
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdRestoreInventory(arg)
  -- Define player
  local player = nil
  -- Check if any arg was passed
  if arg:HasArgs(1) then
    -- Find a player by name
    player = IG:FindPlayerByName(arg, arg.Args[0])
  end

  -- Check if is valid
  if player ~= nil then
    -- Check if saved inventory is empty
    if IG:SavedInventoryIsEmpty (player) then
      -- Send message
      IG:SendMessage(arg, self.Config.Messages.PlayerRestoreEmpty:format(player.displayName))
    else    
      -- Restore Inventory
      IG:RestoreInventory(player)
  
      -- Send message to oPlayer
      IG:SendMessage(arg, self.Config.Messages.RestoredPlayerInventory:format(player.displayName))
      -- Send message to player
      IG:SendMessage(player, self.Config.Messages.PlayerRestored:format("admin"))
    end  
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SaveData()
-- -----------------------------------------------------------------------------------
-- Saves the table with all the warpdata to a DataTable file.
-- -----------------------------------------------------------------------------------
function PLUGIN:SaveData()
  -- Save the DataTable
  datafile.SaveDataTable("Inventory-Guardian")
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadSavedData()
-- -----------------------------------------------------------------------------------
-- Load the DataTable file into a table or create a new table when the file doesn't
-- exist yet.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadSavedData()
  IG.Data = datafile.GetDataTable("Inventory-Guardian")
  IG.Data = IG.Data or {}
  IG.Data.GlobalInventory = IG.Data.GlobalInventory or {}
  IG.Data.RestoreOnce = IG.Data.RestoreOnce or {}
  IG.Data.SaveProtocol = IG.Data.SaveProtocol or IG.SaveProtocol
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\item_manager.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "item_manager"
PLUGIN.Title = "Item Manager Plugin"
PLUGIN.Version = V(0, 1, 10)
PLUGIN.Description = "This will allow you to easily manage players inventories (use as plugin call or copy the code)"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = false
	
function PLUGIN:Init()
end
function PLUGIN:InitializeTable()
	self.Table = {}
	local itemlist = global.ItemManager.GetItemDefinitions();
	local it = itemlist:GetEnumerator()
	while (it:MoveNext()) do
		local correctname = string.lower(it.Current.displayname)
		self.Table[correctname] = tostring(it.Current.shortname)
	end
end
function PLUGIN:FindItemWear( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local wearlist = inv.containerWear.itemList
	local it = wearlist:GetEnumerator()
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			return it.Current
		end
	end
	return false
end
function PLUGIN:FindItemMain( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local mainlist = inv.containerMain.itemList
	local it = mainlist:GetEnumerator()
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			return it.Current
		end
	end
	return false
end
function PLUGIN:FindItemBelt( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local mainlist = inv.containerBelt.itemList
	local it = beltlist:GetEnumerator()
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			return it.Current
		end
	end
	return false
end
function PLUGIN:GetItemBySlot( inv, slot, type )
	if(not self.Table) then self:InitializeTable() end
	type = string.lower(type)
	local container
	if(type == "belt") then
		container = inv.containerBelt
	elseif(type == "main") then
		container = inv.containerMain
	elseif(type == "wear") then
		container = inv.containerWear
	else
		return false, "wrong type: belt, main or wear"
	end
	if(slot+1 > container.capacity) then
		return false, "slot out of range"
	end
	return container:GetSlot(slot)
end
function PLUGIN:FindItemAllByName( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local beltlist = inv.containerBelt.itemList
	local itbelt = beltlist:GetEnumerator()
	while (itbelt:MoveNext()) do
		if(string.lower(tostring(itbelt.Current.info.displayname)) == name) then
			return itbelt.Current
		end
	end
	local mainlist = inv.containerMain.itemList
	local itmain = mainlist:GetEnumerator()
	while (itmain:MoveNext()) do
		if(string.lower(tostring(itmain.Current.info.displayname)) == name) then
			return itmain.Current
		end
	end
	local wearlist = inv.containerWear.itemList
	local itwear = wearlist:GetEnumerator()
	while (itwear:MoveNext()) do
		if(string.lower(tostring(itwear.Current.info.displayname)) == name) then
			return itwear.Current
		end
	end
	return false
end
function PLUGIN:FindItemsAllByName( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local beltlist = inv.containerBelt.itemList
	local mainlist = inv.containerMain.itemList
	local wearlist = inv.containerWear.itemList
	local itbelt = beltlist:GetEnumerator()
	local itmain = mainlist:GetEnumerator()
	local itwear = wearlist:GetEnumerator()
	local tbl = {}
	local count = 0
	while (itbelt:MoveNext()) do
		if(string.lower(tostring(itbelt.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = itbelt.Current
			count = count + itbelt.Current.amount
		end
	end
	while (itmain:MoveNext()) do
		if(string.lower(tostring(itmain.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = itmain.Current
			count = count + itmain.Current.amount
		end
	end
	while (itwear:MoveNext()) do
		if(string.lower(tostring(itwear.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = itwear.Current
			count = count + itwear.Current.amount
		end
	end
	return tbl, count
end
function PLUGIN:FindItemsMainByName( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local mainlist = inv.containerMain.itemList
	local it = mainlist:GetEnumerator()
	local tbl = {}
	local count = 0
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = it.Current
			count = count + it.Current.amount
		end
	end
	return tbl, count
end
function PLUGIN:FindItemsWearByName( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local wearlist = inv.containerWear.itemList
	local it = wearlist:GetEnumerator()
	local tbl = {}
	local count = 0
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = it.Current
			count = count + it.Current.amount
		end
	end
	return tbl, count
end
function PLUGIN:FindItemsBeltByName( inv, name )
	if(not self.Table) then self:InitializeTable() end
	name = string.lower(name)
	local beltlist = inv.containerBelt.itemList
	local it = beltlist:GetEnumerator()
	local tbl = {}
	local count = 0
	while (it:MoveNext()) do
		if(string.lower(tostring(it.Current.info.displayname)) == name) then
			tbl[ #tbl + 1] = it.Current
			count = count + it.Current.amount
		end
	end
	return tbl, count
end
function PLUGIN:Clear( inv, type )
	if(not self.Table) then self:InitializeTable() end
	if(not type) then
		inv:Strip()
	else
		local container
		if(type == "belt") then
			container = inv.containerBelt
		elseif(type == "main") then
			container = inv.containerMain
		elseif(type == "wear") then
			container = inv.containerWear
		else
			return false, "wrong type: belt, main or wear"
		end
		container:Kill()
	end
end
function PLUGIN:GetItems( inv, type )
	if(not self.Table) then self:InitializeTable() end
	local tbl = {}
	local count = 0
	if(not type) then
		local beltlist = inv.containerBelt.itemList
		local mainlist = inv.containerMain.itemList
		local wearlist = inv.containerWear.itemList
		local itbelt = beltlist:GetEnumerator()
		local itmain = mainlist:GetEnumerator()
		local itwear = wearlist:GetEnumerator()
		while (itbelt:MoveNext()) do
			tbl[ #tbl + 1] = itbelt.Current
		end
		while (itmain:MoveNext()) do
			tbl[ #tbl + 1] = itmain.Current
		end
		while (itwear:MoveNext()) do
			tbl[ #tbl + 1] = itwear.Current
		end
	else
		local container
		if(type == "belt") then
			container = inv.containerBelt
		elseif(type == "main") then
			container = inv.containerMain
		elseif(type == "wear") then
			container = inv.containerWear
		else
			return false, "wrong type: belt, main or wear"
		end
		local list = container.itemList
		local it = list:GetEnumerator()
		while (it:MoveNext()) do
			tbl[ #tbl + 1] = it.Current
		end
	end	
	return tbl
end
function PLUGIN:GiveItem(inv,name,amount,type)
	if(not self.Table) then self:InitializeTable() end
	local itemname = false
	name = string.lower(name)
	if(self.Table[name]) then
		itemname = self.Table[name]
	else
		itemname = name
	end
	if(tonumber(amount) == nil) then
		return false, "amount is not valid"
	end
	local container
	if(type == "belt") then
		container = inv.containerBelt
	elseif(type == "main") then
		container = inv.containerMain
	elseif(type == "wear") then
		container = inv.containerWear
	else
		return false, "wrong type: belt, main or wear"
	end
	local giveitem = global.ItemManager.CreateByName(itemname,amount)
	if(not giveitem) then
		return false, itemname .. " is not a valid item name"
	end
	inv:GiveItem(giveitem,container);
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\lock-unlock.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "lock-unlock"
PLUGIN.Title = "Door Unlocker"
PLUGIN.Version = V(1, 1, 0)
PLUGIN.Description = "Manually unlock doors"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true


function PLUGIN:Init()
	command.AddChatCommand( "unlock", self.Object, "cmdUnlock" )
	command.AddChatCommand( "lock", self.Object, "cmdLock" )
	local pluginList = plugins.GetAll()
    for i = 0, pluginList.Length - 1 do
        local pluginTitle = pluginList[i].Object.Title
        if pluginTitle == "FriendsAPI" then
            friendsAPI = pluginList[i].Object
            break
        end
    end
	local pluginList = plugins.GetAll()
    for i = 0, pluginList.Length - 1 do
        local pluginTitle = pluginList[i].Object.Title
        if pluginTitle == "Building Owners" then
            buildingowners = pluginList[i].Object
            break
        end
    end
end
function PLUGIN:Unload()
end
function PLUGIN:LoadDefaultConfig()
	self.Config.authLevelToUsePlugin = 0
	self.Config.authLevelToForceAccess = 1
end

function PLUGIN:cmdUnlock( player, com, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = self.Config.authLevelToUsePlugin
	if(authlevel and neededlevel and authlevel >= neededlevel) then
		local arr = util.TableToArray( { player.eyes:Ray()  } )
		local hits = UnityEngine.Physics.RaycastAll["methodarray"][1]:Invoke(nil,arr)
		local it = hits:GetEnumerator()
		while (it:MoveNext()) do
            if(it.Current.collider:GetComponentInParent(global.Door._type)) then
				local door = it.Current.collider:GetComponentInParent(global.BuildingBlock._type)
				if(self:CanLock(authlevel,door,player)) then
					local lock = door:GetComponent("BaseEntity"):GetSlot(global.Slot.Lock)
					if(lock) then
						lock:SetFlag(global.Flags.Locked,false)
						lock:SendNetworkUpdate()
					end
				else
					player:ChatMessage("You dont have any access to this door")
					return
				end
			end
		end
		player:ChatMessage("You have successfully unlocked the door")
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end
function PLUGIN:cmdLock( player, com, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = self.Config.authLevelToUsePlugin
	if(authlevel and neededlevel and authlevel >= neededlevel) then
		local arr = util.TableToArray( { player.eyes:Ray()  } )
		local hits = UnityEngine.Physics.RaycastAll["methodarray"][1]:Invoke(nil,arr)
		local it = hits:GetEnumerator()
		while (it:MoveNext()) do
            if(it.Current.collider:GetComponentInParent(global.Door._type)) then
				local door = it.Current.collider:GetComponentInParent(global.BuildingBlock._type)
				if(self:CanLock(authlevel,door,player)) then
					local lock = door:GetComponent("BaseEntity"):GetSlot(global.Slot.Lock)
					if(lock) then
						lock:SetFlag(global.Flags.Locked,true)
						lock:SendNetworkUpdate()
					end
				else
					player:ChatMessage("You dont have any access to this door")
					return
				end
			end
		end
		player:ChatMessage("You have successfully locked the door")
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end
function PLUGIN:CanLock(authlevel,blockbuilding,baseplayer)
	if(authlevel >= self.Config.authLevelToForceAccess) then
		return true
	end
	if(buildingowners) then
		local ownerid = buildingowners:FindBlockData(blockbuilding)
		if(ownerid and ownerid == rust.UserIDFromPlayer(baseplayer)) then
			return true
		end
		if(friendsAPI and friendsAPI:HasFriend(ownerid,rust.UserIDFromPlayer(baseplayer))) then
			return true
		end
	end
	return false
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-AntiParachutes.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Anti-Airdrop                                                          Version 1.0.0
-- -----------------------------------------------------------------------------------
-- Filename:          m-AntiParachutes.lua
-- Last Modification: 01-22-2015
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will
-- allow a server admin to remove active parachutes from the world.
--
-- This is just a simple snippet and not an actual plugin.
-- -----------------------------------------------------------------------------------
 
PLUGIN.Title       = "Remove Parachutes"
PLUGIN.Description = "Removes parachutes that are stuck in place."
PLUGIN.Version     = V( 1, 0, 0 )
PLUGIN.HasConfig   = false
PLUGIN.Author      = "Mughisi"
 
-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat command is registered.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Add the chat command:
    command.AddChatCommand( "remparachutes", self.Object, "cmdRemoveParachutes" )
end
 
-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdRemoveParachutes( player, cmd, args )                       Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/remparachutes' command that allows the server admins to remove all 
-- parachutes from the world.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdRemoveParachutes( player, cmd, args )
    -- Check if the player is an admin, if this is not the case exit the function.
    if player.net.connection.authLevel == 0 then
        return
    end
 
    parachutes = UnityEngine.Object.FindObjectsOfTypeAll( global.BaseEntity._type )
    for i = 0, parachutes.Length - 1 do
        if parachutes[i].model then
            if tostring( parachutes[i] ):find("parachute") then
                parachutes[i]:KillMessage()
            end
        end
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-Compass.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Simple In-Game Compass                                                Version 1.0.0
-- -----------------------------------------------------------------------------------
-- Filename:          m-Compass.lua
-- Last Modification: 11-02-2014
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will offer
-- players to check in which direction they're running.
-- -----------------------------------------------------------------------------------


PLUGIN.Title = "Compass"
PLUGIN.Description = "Allows a player to check his/her direction."
PLUGIN.Version = V( 1, 0, 0 )
PLUGIN.HasConfig = true
PLUGIN.Author = "Mughisi"


-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat command is registered and the
-- configuration file is checked.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Set the chat command.
    command.AddChatCommand("compass", self.Object, "cmdCompass")
end


-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the admins. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Setting:
    self.Config.Settings = {
        ChatName = "Compass",
        Version = "1.0.0"
    }

    -- Plugin Messages:
    self.Config.Messages = {
        OnUse = "You are facing {direction}"
    }

    self.Config.Directions = {
        N = "North",
        NE = "Northeast",
        E = "East",
        SE = "Southeast",
        S = "South",
        SW = "Southwest",
        W = "West",
        NW = "Northwest"
    }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdCompass( player, cmd, args )
-- -----------------------------------------------------------------------------------
-- In-game '/compass' command for players to check the direction they're heading in.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdCompass(player, cmd, args)
    -- Grab the look rotation of the player, do this twice to prevent issues with the 
    -- rotation.
    local lookRotation = player.eyes.rotation
    lookRotation = player.eyes.rotation.eulerAngles.y
    local direction = nil

    -- Translate the angle into a position.
    if lookRotation > 337.5 or lookRotation < 22.5 then 
        direction = self.Config.Directions.N 
    elseif lookRotation > 22.5 and lookRotation < 67.5 then
        direction = self.Config.Directions.NE 
    elseif lookRotation > 67.5 and lookRotation < 112.5 then
        direction = self.Config.Directions.E 
    elseif lookRotation > 112.5 and lookRotation < 157.5 then
        direction = self.Config.Directions.SE 
    elseif lookRotation > 157.5 and lookRotation < 202.5 then
        direction = self.Config.Directions.S 
    elseif lookRotation > 202.5 and lookRotation < 247.5 then
        direction = self.Config.Directions.SW
    elseif lookRotation > 247.5 and lookRotation < 292.5 then
        direction = self.Config.Directions.W
    elseif lookRotation > 292.5 and lookRotation < 337.5 then
        direction = self.Config.Directions.NW 
    end

    self:SendMessage( player, self:Parse( self.Config.Messages.OnUse, { direction = direction } ) )
end

-- -----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- -----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- -----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- -----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    for k, v in pairs( values ) do
        -- Replace the variable in the message with the specified value.
        tostring(v):gsub("(%%)", "%%%%") 
        message = message:gsub( "{" .. k .. "}", v)
    end

    return message
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-DisappearingCorpses.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Disappearing Corpses                                                  Version 1.0.3
-- -----------------------------------------------------------------------------------
-- Filename:          m-DisappearingCorpses.lua
-- Last Modification: 01-21-2015
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will
-- allow server administrators modify the time that a player's corpse remains active
-- in the world.
-- -----------------------------------------------------------------------------------

PLUGIN.Title       = "Disappearing Corpses"
PLUGIN.Description = "Modify the duration of which a player's corpse remains active."
PLUGIN.Version     = V( 1, 0, 3 )
PLUGIN.HasConfig   = true
PLUGIN.Author      = "Mughisi"
PLUGIN.ResourceId  = 778

-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat command is registered.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Add the chat commands:
    command.AddChatCommand( "corpsetime", self.Object, "cmdCorpseDuration" )

    -- Check the config.
    self:CheckConfig()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the admins. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Settings:
    self.Config.Settings = {
        ChatName           = "Corpses",
        Duration           = 120,
        Version            = "1.0"
    }

    -- Plugin Messages:
    self.Config.Messages = {
        -- Messages involving /settime and env.time
        CorpseTimeSuccess       = "Modified the length of which a player's corpse remains active in the world to {length} minutes.",
        SyntaxCommandCorpseTime = {
            "A Syntax Error Occurred!",
            "You can only use the /corpsetime command as follows:",
            "/corpsetime <minutes> - Keeps the player's corpse active in the world for <minutes>.",
            "The time in minutes must be atleast 1 and should not exceed 60."
        }
    }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:CheckConfig()
-- -----------------------------------------------------------------------------------
-- This function checks if the configuration file is up to date and starts an update
-- if this is not the case.
-- -----------------------------------------------------------------------------------
function PLUGIN:CheckConfig() 
    -- Check if the current plugin version is the latest.
    if self.Config.Settings.Version ~= "1.0" then
        -- Different configuration version, update it now.
        self:UpdateConfig()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- This function updates the configuration file.
-- -----------------------------------------------------------------------------------
function PLUGIN:UpdateConfig()
    self:LoadDefaultConfig()
    self:SaveConfig()
    print( "m-DisappearingCorpses.lua : Default Config Loaded" )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdCorpseDuration( player, cmd, args )                         Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/corpsetime' command that allows the server admins to modify the length of
-- which the corpse of a player remains active in the world.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdCorpseDuration( player, cmd, args )
    -- Check if the player is an admin, if this is not the case exit the function.
    if player.net.connection.authLevel == 0 then
        return
    end
    
    -- Check if the player specified an argument.
    if args.Length == 1 then
        -- The player specified an argument, checking if this is a number.
        local newDuration = tonumber( args[0] )

        -- Checking if the new duration is valid.
        if newDuration >= 1 and newDuration <= 60 then
            -- The new hour is valid, modify the duration and inform the player.
            self.Config.Settings.Duration = newDuration * 60
            self:SaveConfig()

            self:SendMessage( player, self:Parse( self.Config.Messages.CorpseTimeSuccess, { length = newDuration } ) )

            return
        end
    end

    -- Something went wrong, show a syntax error to the player.
    self:SendMessage( player, self.Config.Messages.SyntaxCommandCorpseTime )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnEntitySpawn( entity )
-- -----------------------------------------------------------------------------------
-- OnEntitySpawn Oxide Hook. This hook is triggered when an entity is spawned into the
-- world. This hook is used to modify the length of which the corpse of a player
-- remains active in the world when the corpse is first spawned.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnEntitySpawn( entity )
    -- Check if a corpse is spawned in the world.
    if entity:GetComponent( "BaseCorpse" ) then
        -- Check if a valid parent entity is available.
        if not entity:GetComponent( "BaseCorpse" ).parentEnt then return end

        -- Check if the corpse is from a player and not an animal.
        if entity.parentEnt:ToPlayer() then
            -- A corpse is spawned in the world, modify the duration that it remains
            -- active.
            entity:ResetRemovalTime( self.Config.Settings.Duration )
        end
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnGather( dispenser, entity, item )
-- -----------------------------------------------------------------------------------
-- OnGather Oxide Hook. This hook is triggered when an entity gathers a 
-- ResourceDispenser. This hook is used to reset the timer that a player's corpse 
-- remains alive otherwise it would reset it to the standard duration of 2 minutes.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnGather( dispenser, entity, item )
    if dispenser:GetComponent( "BaseCorpse" ) then
        local corpse = dispenser:GetComponent( "BaseCorpse" )
        
        -- Check if a valid parent entity is available.
        if not corpse.parentEnt then return end
        if not corpse.parentEnt:ToString():find("player/player", 1, true) then return end

        -- Check if the corpse is from a player and not an animal.
        if a then
            -- A corpse is spawned in the world, modify the duration that it remains active.
           corpse:ResetRemovalTime( self.Config.Settings.Duration )
        end
    end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- -----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- -----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- -----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    for k, v in pairs( values ) do
        -- Replace the variable in the message with the specified value.
        tostring(v):gsub("(%%)", "%%%%") 
        message = message:gsub( "{" .. k .. "}", v)
    end

    return message
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-GatherRate.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Increased Gather Rate                                                 Version 1.1.2
-- -----------------------------------------------------------------------------------
-- Filename:          m-GatherRate.lua
-- Last Modification: 02-10-2014
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will offer
-- server admins the option to increase the amount of items gained from gathering.
-- -----------------------------------------------------------------------------------


PLUGIN.Title = "Increased Gathering Rate"
PLUGIN.Description = "Increase the amount of resources from gathering per attack."
PLUGIN.Version = V( 1, 1, 2 )
PLUGIN.HasConfig = true
PLUGIN.Author = "Mughisi"
PLUGIN.ResourceId = 675


-- -----------------------------------------------------------------------------------
-- Globals
-- -----------------------------------------------------------------------------------
-- Some globals that are used in multiple functions.
-- -----------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat command is registered and the
-- configuration file is checked.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Add the chat command.
    command.AddChatCommand("gather", self.Plugin, "cmdGatherRate")

    -- Check the configuration file.
    self:CheckConfig()
    
    -- Show a message in the server console with the current values.
    print( "Resources from gathering is set to: x" .. self.Config.Settings.GatherMultiplier .. "." )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the admins. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Settings:
    self.Config.Settings = {
        Version                   = "1.2",
        ChatName                  = "Gatherer",
        GatherMultiplier          = 1
    }

    -- Plugin Messages:
    self.Config.Messages = {
        SetGatherRate = "Resources from gathering has been modified, it is now set to: x{multiplier}!",
        GatherRate = "Resources from gathering is set to: x{multiplier}!",
        Error = "The new multiplier must be a positive number!",
        HelpTextPlayer = "Use /gather to check the gathering rate!",
        HelpTextAdmin = {
                "Use '/gather' to check the gathering rate!",
                "Use '/gather <multiplier>' to increase the amount of resources gathered by <multiplier>!",
            },
        GatherResourceError = {
                "To increase the gather rate of a certain resource you need a valid resource name.",
                "These are the resources you can modify:"
            }
    }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:CheckConfig()
-- -----------------------------------------------------------------------------------
-- This function checks if the configuration file is up to date and starts an update
-- if this is not the case.
-- -----------------------------------------------------------------------------------
function PLUGIN:CheckConfig() 
    -- Check if the current plugin version is the latest.
    if self.Config.Settings.Version ~= "1.2" then
        -- Different configuration version, update it now.
        self:UpdateConfig()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- This function updates the configuration file.
-- -----------------------------------------------------------------------------------
function PLUGIN:UpdateConfig()
    self:LoadDefaultConfig()
    self:SaveConfig()
    print( "m-GatherRate.lua : Default Config Loaded" )
end

-- -----------------------------------------------------------------------------------
-- function PLUGIN:cmdGatherRate( player, cmd, args) 
-- -----------------------------------------------------------------------------------
-- In-game '/craft' command for server admins to be able to modify the crafting speed
-- and for players to check the crafting speed.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdGatherRate(player, cmd, args)
    -- Check if the player is an admin, if this is not the case the player will only
    -- be able to see the current rates.
    if player.net.connection.authLevel == 0 then
        -- The player is not an admin, show a message with the current multiplier and
        -- exit the function.
        self:SendMessage( player, self:Parse( self.Config.Messages["GatherRate"], { multiplier = self.Config.Settings.GatherMultiplier } ) )
        
        return 
    end
    
    -- The player is an admin, check how many arguments were supplied with the
    -- command and respond correctly.
    if args.Length == 1 then
        -- Multiple arguments were supplied, assuming the player is attempting to
        -- modify the gathering rate and perhaps the amount of resources in
        -- resource dispensers (trees, corpses, stone/ore deposits, ...)

        -- Initialise some required variables
        local newGatherMultiplier = tonumber( args[0] )

        -- Check if we have a valid value for both the new gathering multiplier and
        -- resource amount multiplier.
        if newGatherMultiplier then
            -- Check if both values are positive.
            if tonumber( newGatherMultiplier ) > 0 then
                -- Update the configuration file with the new values and save it.
                self.Config.Settings.GatherMultiplier = newGatherMultiplier
                self:SaveConfig()

                -- Send a message to the player.
                self:SendMessage( player, self:Parse( self.Config.Messages["SetGatherRate"], { multiplier = self.Config.Settings.GatherMultiplier } ) )

                return
            end
        end

        -- Something went wrong, show an error message.
        self:SendMessage( player, self.Config.Messages["Error"] )
    else
        -- Show the values to the player.
        self:SendMessage( player, self:Parse( self.Config.Messages["GatherRate"], { multiplier = self.Config.Settings.GatherMultiplier } ) )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnPlayerAttack( player, hitinfo )
-- -----------------------------------------------------------------------------------
-- OnPlayerAttack Oxide Hook. This hook is triggered when a BasePlayer attacks another
-- entity. This hook is used to capture resource gathering.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnGather( dispenser, entity, item )
    -- Increase the amount of the item gained with the modifier, this needs to be
    -- extended in the future to allow for on playerbase modifications, different
    -- modifiers per resource and different resources per dispenser.
    if entity:ToPlayer() then
        if tonumber( item.amount ) then
            item.amount = item.amount * self.Config.Settings.GatherMultiplier
        end
    end
end
-- -----------------------------------------------------------------------------------
-- PLUGIN:SendHelpText( player )
-- -----------------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- -----------------------------------------------------------------------------------
function PLUGIN:SendHelpText( player )
    if player.net.connection.authLevel > 0 then
        self:SendMessage( player, self.Config.Messages.HelpTextAdmin )
    else
        self:SendMessage( player, self.Config.Messages.HelpTextPlayer )
    end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- -----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- -----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- -----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    if type( message ) == "table" then
        local returnTable = {}

        for _, msg in pairs( message ) do
            for k, v in pairs( values ) do
                -- Replace the variable in the message with the specified value.
                tostring(v):gsub("(%%)", "%%%%") 
                msg = msg:gsub( "{" .. k .. "}", v)
                table.insert( returnTable, msg )
            end
        end

        return returnTable
    else
        for k, v in pairs( values ) do
            -- Replace the variable in the message with the specified value.
            tostring(v):gsub("(%%)", "%%%%") 
            message = message:gsub( "{" .. k .. "}", v)
        end

        return message
    end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-Godmode.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Admin Godmode                                                         Version 1.4.3
-- -----------------------------------------------------------------------------------
-- Filename:          m-Godmode.lua
-- Last Modification: 02-27-2015
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will offer
-- server admins the option to disable all damage taken.
-- -----------------------------------------------------------------------------------


PLUGIN.Title       = "Godmode"
PLUGIN.Description = "Allows an admin to toggle Godmode."
PLUGIN.Version     = V( 1, 4, 3 )
PLUGIN.HasConfig   = true
PLUGIN.Author      = "Mughisi"
PLUGIN.ResourceId  = 673


-- -----------------------------------------------------------------------------------
-- Globals
-- -----------------------------------------------------------------------------------
-- Some globals that are used in multiple functions/hooks.
-- -----------------------------------------------------------------------------------
local AntiNoDamageSpam = {}

-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat command is registered and the
-- configuration file is checked.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Set the chat command.
    command.AddChatCommand("god", self.Object, "cmdToggleGod")

    -- Check if the config file is up to date.
    self:CheckConfig()

    -- Load the Godmode datatable file.
    self:LoadSavedData()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the admins. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Setting:
    self.Config.Settings = {
        ChatName = "God",
        Version = "1.4.3"
    }

    -- Plugin Messages:
    self.Config.Messages = {
        Enabled             = "You have enabled godmode!",
        Disabled            = "You have disabled godmode!",
        HelpMessage         = "/god - This command will toggle godmode on or off.",
        NoGodDamageAttacker = "{player} is currently in godmode and can't take any damage.",
        NoGodDamagePlayer   = "{player} just tried to deal damage to you."
    }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:CheckConfig()
-- -----------------------------------------------------------------------------------
-- This function checks if the configuration file is up to date and starts an update
-- if this is not the case.
-- -----------------------------------------------------------------------------------
function PLUGIN:CheckConfig() 
    -- Check if the current plugin version is the latest.
    if self.Config.Settings.Version ~= "1.4.3" then
        -- Different configuration version, update it now.
        self:UpdateConfig()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- This function updates the configuration file.
-- -----------------------------------------------------------------------------------
function PLUGIN:UpdateConfig()
    -- Check and update the global plugin settings.
    self.Config.Settings.ChatName         = self.Config.Settings.ChatName or "God"
    self.Config.Settings.ShowHitIndicator = nil
    self.Config.Settings.Version          = "1.4.3"

    -- Check and update the plugin messages.
    self.Config.Messages.Enabled             = self.Config.Messages.Enabled or "You have enabled godmode!"
    self.Config.Messages.Disabled            = self.Config.Messages.Disabled or "You have disabled godmode!"
    self.Config.Messages.HelpMessage         = self.Config.Messages.HelpMessage or "/god - This command will toggle godmode on or off."
    self.Config.Messages.NoGodDamageAttacker = self.Config.Messages.NoGodDamageAttacker or "{player} is currently in godmode and can't take any damage."
    self.Config.Messages.NoGodDamagePlayer   = self.Config.Messages.NoGodDamagePlayer or "{player} just tried to deal damage to you."

    -- Save the updated configuration file.
    self:SaveConfig()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadSavedData()
-- -----------------------------------------------------------------------------------
-- Load the DataTable file into a table or create a new table when the file doesn't
-- exist yet.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadSavedData()
    -- Open the datafile if it exists, otherwise we'll create a new one.
    Gods = datafile.GetDataTable( "m-Godmode" )
    Gods = Gods or {}
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SaveData()
-- -----------------------------------------------------------------------------------
-- Saves the table with all the teleportdata to a DataTable file.
-- -----------------------------------------------------------------------------------
function PLUGIN:SaveData()  
    -- Save the DataTable
    datafile.SaveDataTable( "m-Godmode" )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdToggleGod( player, cmd, args )                              Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/god' command for server admins to be able to toggle Godmode on and off.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdToggleGod(player, cmd, args)
    -- Check if the player is an admin.
    if player.net.connection.authLevel == 0 then return end

    -- Grab the player is Steam ID.
    local userID = rust.UserIDFromPlayer(player)

    -- Check if the player is turning Godmode on or off.
    if Gods[userID] then
        -- Godmode is currently enabled, disable it and send the player a message.
        Gods[userID] = nil
        self:SendMessage(player, self.Config.Messages["Disabled"])
    else
        -- Godmode is currently disabled, enable it and send the player a message.
        Gods[userID] = true
        self:SendMessage(player, self.Config.Messages["Enabled"])
    end

    self:SaveData()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnEntityAttacked( entity, hitinfo )
-- -----------------------------------------------------------------------------------
-- OnEntityAttacked Oxide Hook. This hook is triggered when an entity (BasePlayer or 
-- BaseAnimals) is attacked. This hook is used to check if an admin is taking damage
-- and if he/she is, it will prevent the damage from being dealt.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnEntityAttacked( entity, hitinfo )
    -- Check if a player is taking the damage.
    if entity:ToPlayer() then
        -- Grab the Steam ID of the player.
        local userID = rust.UserIDFromPlayer(entity)

        -- Check if the player has Godmode enabled.
        if Gods[userID] then
            -- The player has Godmode enabled, set the damage dealt to 0 for every
            -- damage type as some weapons deal multiple types of damage.
            while hitinfo.damageTypes:Total() > 0 do
                hitinfo.damageTypes:Set( hitinfo.damageTypes:GetMajorityDamageType(), 0 )
            end

            -- Set the material getting hit to 0 to prevent warning messages to 
            -- be shown in console regarding missing hit effects.
            hitinfo.HitMaterial = 0

            -- Check if the damage is dealt by a player, if it's from a player then
            -- inform him that he's hitting an admin with godmode enabled.

            if hitinfo.Initiator:ToPlayer() and hitinfo.Initiator ~= entity then
                -- Get the BasePlayer of the attacker.
                local attacker   = hitinfo.Initiator
                local attackerID = rust.UserIDFromPlayer( attacker )

                -- Get the current timestamp
                local timestamp = time.GetUnixTimestamp()

                -- Check the anti-spam value for the attacker, we don't want to send
                -- multiple messages if he'd empty an entire SMG clip on the admin.
                AntiNoDamageSpam[attackerID] = AntiNoDamageSpam[attackerID] or 0

                -- Check if it has been more than 30 seconds that we've send a message to
                -- the attacking player.
                if ( timestamp - AntiNoDamageSpam[attackerID] ) > 30 then
                    -- It has been more than 30 seconds after the last message, send the
                    -- player a new message.
                    self:SendMessage( attacker, self:Parse( self.Config.Messages.NoGodDamageAttacker, { player = entity.displayName } ) )
                    self:SendMessage( entity, self:Parse( self.Config.Messages.NoGodDamagePlayer, { player = attacker.displayName } ) )
 
                    -- Update the timestamp
                    AntiNoDamageSpam[attackerID] = timestamp
                end
            end
        end
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnRunPlayerMetabolism( metabolism )
-- -----------------------------------------------------------------------------------
-- OnEntityAttack Oxide Hook. This hook is triggered when the metabolism is updated. 
-- This hook is used to disable damage taken from drowning and radiation when Godmode
-- is enabled for the player.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnRunPlayerMetabolism( metabolism )
    -- Grab the Steam ID of the player.
    local player = metabolism:GetComponent("BasePlayer")
    local userID = rust.UserIDFromPlayer( player )

    -- Check if the player has Godmode enable.
    if Gods[userID] then
        -- The player has Godmode enabled, change the metabolism values.
        player:InitializeHealth( 100, 100 )
        metabolism.oxygen:Add( metabolism.oxygen.max )
        metabolism.wetness:Add( -metabolism.wetness.max )
        metabolism.radiation_level:Add( -metabolism.radiation_level.max )
        metabolism.radiation_poison:Add( -metabolism.radiation_poison.max )
        metabolism.temperature:Reset()
        metabolism.hydration:Add( metabolism.hydration.max )
        metabolism.calories:Add( metabolism.calories.max )
        metabolism.bleeding:Reset()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SendHelpText( player )
-- -----------------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- -----------------------------------------------------------------------------------
function PLUGIN:SendHelpText( player )
    if player.net.connection.authLevel > 0 then
        self:SendMessage( player, self.Config.Messages.HelpMessage )
    end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- -----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- -----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- -----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    if type( message ) == "table" then
        local returnTable = {}

        for _, msg in pairs( message ) do
            for k, v in pairs( values ) do
                -- Replace the variable in the message with the specified value.
                tostring(v):gsub("(%%)", "%%%%") 
                msg = msg:gsub( "{" .. k .. "}", v)
                table.insert( returnTable, msg )
            end
        end

        return returnTable
    else
        for k, v in pairs( values ) do
            -- Replace the variable in the message with the specified value.
            tostring(v):gsub("(%%)", "%%%%") 
            message = message:gsub( "{" .. k .. "}", v)
        end

        return message
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-RustBanSaver.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- --------------------------------------------------------------------------------------
-- m-RustBanSaver.lua
-- --------------------------------------------------------------------------------------
-- This plugin will save your bans to the bans.cfg server file.
-- --------------------------------------------------------------------------------------

PLUGIN.Title       = "Rust Ban Saver"
PLUGIN.Description = "Saves the bans of players banned with the command banid."
PLUGIN.Version     = V( 1, 0, 1 )
PLUGIN.HasConfig   = false
PLUGIN.Author      = "Mughisi"

-- --------------------------------------------------------------------------------------
-- PLUGIN:Init()
-- --------------------------------------------------------------------------------------
-- This will set the ingame chat command.
-- --------------------------------------------------------------------------------------
function PLUGIN:Init()
    command.AddChatCommand( "savebans", self.Object, "cmdSaveBans" )
end

-- --------------------------------------------------------------------------------------
-- PLUGIN:cmdSaveBans( player, cmd, args )
-- --------------------------------------------------------------------------------------
-- In-game '/savebans' command that allows an admin to save the executed bans.
-- --------------------------------------------------------------------------------------
function PLUGIN:cmdSaveBans( player, cmd, args )
    if not player:IsAdmin() then return end

    global.ServerUsers.Save()
end

function PLUGIN:OnRunCommand( arg )
    -- Check if the command is being send from an in-game player.
    if ( not arg ) then return end
    if ( not arg.cmd ) then return end
    if ( not arg.cmd.name ) then return end
    
    -- Check if the wakeup command was used.
    if arg.cmd.name == "banid" then
        if arg.connection then
            player = arg.connection.player
        end

        if player and not player:IsAdmin() then
            return true
        end

        timer.Once(1, function() global.ServerUsers.Save() end )

        arg:ReplyWith("Executed command banid!")
    end	
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-Teleportation.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- Teleportation System                                          Version 1.4.13
-- ----------------------------------------------------------------------------
-- Filename:          m-Teleportation.lua
-- Last Modification: 04-17-2015
-- ----------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and 
-- offers the following teleportation methods: Admin Teleports, Homes and TPR.
-- ----------------------------------------------------------------------------


PLUGIN.Title       = "Teleportation System"
PLUGIN.Description = "Multiple teleportation systems for admins and players."
PLUGIN.Version     = V( 1, 4, 13)
PLUGIN.HasConfig   = true
PLUGIN.Author      = "Mughisi"
PLUGIN.ResourceId  = 660

-- ----------------------------------------------------------------------------
-- Globals
-- ----------------------------------------------------------------------------
-- Some globals that are used in multiple functions.
-- ----------------------------------------------------------------------------
local PendingRequests = {}
local PlayersRequests = {}
local TeleportTimers  = {}

local TeleportData    = {}

local FriendsAPI      = nil

local OverlapSphere   = UnityEngine.Physics.OverlapSphere.methodarray[1]
local RaycastAll      = UnityEngine.Physics.RaycastAll["methodarray"][5]

-- ----------------------------------------------------------------------------
-- PLUGIN:Init()
-- ----------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat commands are registered
-- and data from the DataTable file is loaded. Also running a temporary player
-- check to prevent bugs with `player.transform.position` after reloading the
-- plugin.
-- ----------------------------------------------------------------------------
function PLUGIN:Init()
    -- Add the chat commands for the Admin TP System:
    command.AddChatCommand( "tp",       self.Plugin, "cmdTeleport" )
    command.AddChatCommand( "tpl",      self.Plugin, "cmdTeleportLocation" )
    command.AddChatCommand( "tpsave",   self.Plugin, "cmdSaveTeleportLocation" )
    command.AddChatCommand( "tpremove", self.Plugin, "cmdRemoveTeleportLocation" )
    command.AddChatCommand( "tpb",      self.Plugin, "cmdTeleportBack" )
    command.AddChatCommand( "tpn",      self.Plugin, "cmdTeleportNear" )

    -- Add the chat commands for the Homes System:
    command.AddChatCommand( "sethome",    self.Plugin, "cmdSetHome" )
    command.AddChatCommand( "removehome", self.Plugin, "cmdRemoveHome" )
    command.AddChatCommand( "home",       self.Plugin, "cmdTeleportHome" )
    command.AddChatCommand( "listhomes",  self.Plugin, "cmdListHomes" )

    -- Add the chat commands for the TPR System:
    command.AddChatCommand( "tpr", self.Plugin, "cmdTeleportRequest" )
    command.AddChatCommand( "tpa", self.Plugin, "cmdTeleportAccept" )

    -- Add the Help commands:
    command.AddChatCommand( "tphelp",   self.Plugin, "cmdTeleportHelp" )
    command.AddChatCommand( "tplimits", self.Plugin, "cmdTeleportLimits" )

    -- Add the admin wipe command to remove all saved homes.
    command.AddChatCommand( "wipehomes", self.Plugin, "cmdWipeHomes" )

    -- Add the Console commands:
    command.AddConsoleCommand("teleport.toplayer", self.Plugin, "ccmdTeleport")
    command.AddConsoleCommand("teleport.topos", self.Plugin, "ccmdTeleport")

    -- Load the teleport datatable file.
    self:LoadSavedData()

    -- Check if the configuration file is up to date.
    if self.Config.Settings.ConfigVersion ~= "1.4.13" then
        -- The configuration file needs an update.
        self:UpdateConfig()
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:OnServerInitialized()
-- ----------------------------------------------------------------------------
-- When the server has finished the startup process we will check if the 
-- required API plugins are available and get a few variables.
-- ----------------------------------------------------------------------------
function PLUGIN:OnServerInitialized()
    -- Check if the CheckFoundationForOwner configuration value is set to true.
    -- If it is true we need the plugin `Building Owners`.
    if self.Config.Homes.CheckFoundationForOwner then
        -- The setting CheckFoundationForOwner is true, check if
        -- `Building Owners` is installed.
        if not plugins.Exists( "BuildingOwners" ) then
            -- The plugin isn't installed, print a message in the console and
            -- disable the owner check.
            print( "m-Teleportation: To limit Homes to only be set on foundations owned by the player the plugin `Building Owners` is required!" )
            print( "                 This plugin can be downloaded at http://forum.rustoxide.com/plugins/building-owners.682/" )
            print( "                 The owner check has temporarily been disabled to prevent problems." )
            self.Config.Homes.CheckFoundationForOwner = false
        end
    end
    
    -- Check if the UseFriendsAPI configuration value is set to true. If it  is
    -- true we need the plugin `FriendsAPI`.
    if self.Config.Homes.UseFriendsAPI then
        -- The setting CheckFoundationForOwner is true, check if `Friends API`
        -- is installed.
        if not plugins.Exists( "0friendsAPI" ) then
            -- The plugin isn't installed, print a message in the console and
            -- disable the owner check.
            print( "m-Teleportation: To allow Homes to be set on foundations owned by friends of the player the plugin `Friends API` is required!" )
            print( "                 This plugin can be downloaded at http://forum.rustoxide.com/plugins/friends-api.686/" )
            print( "                 The friends check has temporarily been disabled to prevent problems." )
            self.Config.Homes.UseFriendsAPI = false
        else
            -- Grab the plugin.
            FriendsAPI = plugins.Find( "0friendsAPI" )
        end
    end
    
    -- "Fix" for the GetCurrentTime() problem that is causing it to throw an 
    -- "AmibiguousMatchException: Ambiguous matching in method resolution"
    -- error when called for the first time.
    status, err = pcall( time.GetCurrentTime )
    date = time.GetCurrentTime():ToString( "d" )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- ----------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it
-- for localized messages that are send in-game to the players. When this file
-- doesn't exist a new one will be created with these default values.
-- ----------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Settings:
    self.Config.Settings = {
        ChatName          = "Teleportation",
        ConfigVersion     = "1.4.13",
        HomesEnabled      = true,
        TPREnabled        = true,
        InterruptTPOnHurt = true
    }

    -- Admin TP System Settings:
    self.Config.AdminTP = {
        AnnounceTeleportToTarget    = false,
        UseableByModerators         = true,
        LocationRadius              = 25,
        TeleportNearDefaultDistance = 30
    }
    
    -- Homes System Settings:
    self.Config.Homes = {
        HomesLimit              = 2,
        Cooldown                = 600,
        Countdown               = 15,
        DailyLimit              = 5,
        LocationRadius          = 25,
        ForceOnTopOfFoundation  = true,
        CheckFoundationForOwner = true,
        UseFriendsAPI           = true
    }

    -- TPR System Settings: 
    self.Config.TPR = {
        Cooldown          = 600,
        Countdown         = 15,
        DailyLimit        = 5,
        RequestDuration   = 30,
        BlockTPAOnCeiling = true
    }

    -- Plugin Messages:
    self.Config.Messages = {
        -- Admin TP System:
        AdminTP                        = "You teleported to {player}!",
        AdminTPTarget                  = "{player} teleported to you!",
        AdminTPPlayers                 = "You teleported {player} to {target}!",
        AdminTPPlayer                  = "{admin} teleported you to {player}!",
        AdminTPPlayerTarget            = "{admin} teleported {player} to you!",
        AdminTPCoordinates             = "You teleported to {coordinates}!",
        AdminTPTargetCoordinates       = "You teleported {player} to {coordinates}!",
        AdminTPOutOfBounds             = "You tried to teleport to a set of coordinates outside the map boundaries!",
        AdminTPBoundaries              = "X and Z values need to be between -{boundary} and {boundary} while the Y value needs to be between -100 and 2000!",
        AdminTPLocation                = "You teleported to {location}!",
        AdminTPLocationSave            = "You have saved the current location!",
        AdminTPLocationRemove          = "You have removed the location {location}!",
        AdminLocationList              = "The following locations are available:",
        AdminLocationListEmpty         = "You haven't saved any locations!",
        AdminTPBack                    = "You've teleported back to your previous location!",
        AdminTPBackSave                = "Your previous location has been saved, use /tpb to teleport back!",
        AdminTPTargetCoordinatesTarget = "{admin} teleported you to {coordinates}!",
        AdminTPConsoleTP               = "You were teleported to {destination}",
        AdminTPConsoleTPPlayer         = "You were teleported to {player}",

        -- Homes System:
        HomeTP                        = "You teleported to your home '{home}'!",
        HomeSave                      = "You have saved the current location as your home!",
        HomeSaveFoundationOnly        = "You can only save a home location on a foundation!",
        HomeFoundationNotOwned        = "You can't set your home on someone else's house.",
        HomeFoundationNotFriendsOwned = "You need to be in your own or in a friend's house to set your home!",
        HomeRemove                    = "You have removed your home {home}!",
        HomeList                      = "The following homes are available:",
        HomeListEmpty                 = "You haven't saved any homes!",
        HomeMaxLocations              = "Unable to set your home here, you have reached the maximum of {amount} homes!",
        HomeTPStarted                 = "Teleporting to your home {home} in {countdown} seconds!",
        HomeTPCooldown                = "Your teleport is currently on cooldown. You'll have to wait {time} for your next teleport.",
        HomeTPLimitReached            = "You have reached the daily limit of {limit} teleports today!",
        HomesListWiped                = "You have wiped all the saved home locations!",

        -- TPR System:
        Request              = "You've requested a teleport to {player}!",
        RequestTarget        = "{player} requested to be teleported to you! Use '/tpa' to accept!",
        PendingRequest       = "You already have a request pending, cancel that request or wait until it gets accepted or times out!",
        PendingRequestTarget = "The player you wish to teleport to already has a pending request, try again later!",
        NoPendingRequest     = "You have no pending teleport request!",
        AcceptOnRoof         = "You can't accept a teleport while you're on a ceiling, get to ground level!",
        Accept               = "{player} has accepted your teleport request! Teleporting in {countdown} seconds!",
        AcceptTarget         = "You've accepted the teleport request of {player}!",
        Success              = "You teleported to {player}!",
        SuccessTarget        = "{player} teleported to you!",
        TimedOut             = "{player} did not answer your request in time!",
        TimedOutTarget       = "You did not answer {player}'s teleport request in time!",
        TargetDisconnected   = "{player} has disconnected, your teleport was cancelled!",
        TPRCooldown          = "Your teleport requests are currently on cooldown. You'll have to wait {time} to send your next teleport request.",
        TPRLimitReached      = "You have reached the daily limit of {limit} teleport requests today!",

        -- General Messages:
        Interrupted          = "Your teleport was interrupted!",
        InterruptedTarget    = "{player}'s teleport was interrupted!",

        -- Help Messages:
        TPHelp = {
            General = {
                "Please specify the module you want to view the help of. ",
                "The available modules are: ",
            },
            admintp = {
                "As an admin you have access to the following commands:",
                "/tp <targetplayer> - Teleports yourself to the target player.",
                "/tp <player> <targetplayer> - Teleports the player to the target player.",
                "/tp <x> <y> <z> - Teleports you to the set of coordinates.",
                "/tpl - Shows a list of saved locations.",
                "/tpl <location name> - Teleports you to a saved location.",
                "/tpsave <location name> - Saves your current position as the location name.",
                "/tpremove <location name> - Removes the location from your saved list.",
                "/tpb - Teleports you back to the place where you were before teleporting."
            },

            home = {
                "With the following commands you can set your home location to teleport back to:",
                "/sethome <home name> - Saves your current position as the location name.",
                "/listhomes - Shows you a list of all the locations you have saved.",
                "/removehome <home name> - Removes the location of your saved homes.",
                "/home <home name> - Teleports you to the home location."
            },
            tpr = {
                "With these commands you can request to be teleported to a player or accept someone else's request:",
                "/tpr <player name> - Sends a teleport request to the player.",
                "/tpa - Accepts an incoming teleport request."
            }
        },

        -- Settings Messages:
        TPSettings = {
            General = {
                "Please specify the module you want to view the settings of. ",
                "The available modules are: ",
            },
            home = {
                "Home System as the current settings enabled: ",
                "Time between teleports: {cooldown}",
                "Daily amount of teleports: {limit}",
                "Amount of saved Home locations: {amount}"
            },
            tpr = {
                "TPR System as the current settings enabled: ",
                "Time between teleports: {cooldown}",
                "Daily amount of teleports: {limit}"
            }
        },

        -- Error Messages:
        PlayerNotFound           = "The specified player couldn't be found please try again!",
        MultiplePlayersFound     = "Found multiple players with that name!",
        CantTeleportToSelf       = "You can't teleport to yourself!",
        CantTeleportPlayerToSelf = "You can't teleport a player to himself!",
        TeleportPending          = "You can't initiate another teleport while you have a teleport pending!",
        TeleportPendingTarget    = "You can't request a teleport to someone who's about to teleport!",
        LocationExists           = "A location with this name already exists at {location}!",
        LocationExistsNearby     = "A location with the name {name} already exists near this position!",
        LocationNotFound         = "Couldn't find a location with that name!",
        NoPreviousLocationSaved  = "No previous location saved!",
        HomeExists               = "You have already saved a home location by this name!",
        HomeExistsNearby         = "A home location with the name {name} already exists near this position!",
        HomeNotFound             = "Couldn't find your home with that name!",
        InvalidCoordinates       = "The coordinates you've entered are invalid!",
        InvalidHelpModule        = "Invalid module supplied!",
        InvalidCharacter         = "You have used an invalid character, please limit yourself to the letters a to z and numbers.",

        -- Syntax Errors Admin TP System:
        SyntaxCommandTP = {
            "A Syntax Error Occurred!",
            "You can only use the /tp command as follows:",
            "/tp <targetplayer> - Teleports yourself to the target player.",
            "/tp <player> <targetplayer> - Teleports the player to the target player.",
            "/tp <x> <y> <z> - Teleports you to the set of coordinates.",
            "/tp <player> <x> <y> <z> - Teleports the player to the set of coordinates."
        },
        SyntaxCommandTPL = {
            "A Syntax Error Occurred!",
            "You can only use the /tpl command as follows:",
            "/tpl - Shows a list of saved locations.",
            "/tpl <location name> - Teleports you to a saved location."
        },
        SyntaxCommandTPSave = {
            "A Syntax Error Occurred!",
            "You can only use the /tpsave command as follows:",
            "/tpsave <location name> - Saves your current position as 'location name'."
        },
        SyntaxCommandTPRemove = {
            "A Syntax Error Occurred!",
            "You can only use the /tpremove command as follows:",
            "/tpremove <location name> - Removes the location with the name 'location name'."
        },
        SyntaxCommandTPN = {
            "A Syntax Error Occurred!",
            "You can only use the /tpn command as follows:",
            "/tpn <targetplayer> - Teleports yourself the default distance behind the target player.",
            "/tpn <targetplayer> <distance> - Teleports you the specified distance behind the target player."
        },

        -- Syntax Errors Home System:
        SyntaxCommandSetHome = {
            "A Syntax Error Occurred!",
            "You can only use the /sethome command as follows:",
            "/sethome <home name> - Saves the current location as your home with the name 'home name'."
        },
        SyntaxCommandRemoveHome = {
            "A Syntax Error Occurred!",
            "You can only use the /removehome command as follows:",
            "/removehome <home name> - Removes the home location with the name 'location name'."
        },
        SyntaxCommandHome = {
            "A Syntax Error Occurred!",
            "You can only use the /home command as follows:",
            "/home <home name> - Teleports yourself to your home with the name 'home name'."
        },
        SyntaxCommandListHomes = {
            "A Syntax Error Occurred!",
            "You can only use the /listhomes command as follows:",
            "/listhomes - Shows you a list of all your saved home locations."
        },

        -- Syntax Errors TPR System:
        SyntaxCommandTPR = {
            "A Syntax Error Occurred!",
            "You can only use the /tpr command as follows:",
            "/tpr <player name> - Sends out a teleport request to 'player name'."
        },
        SyntaxCommandTPA = {
            "A Syntax Error Occurred!",
            "You can only use the /tpa command as follows:",
            "/tpa - Accepts an incoming teleport request."
        },
        SyntaxConsoleCommandToPos = { 
            "A Syntax Error Occurred!", 
            "You can only use the teleport.topos console command as follows:", 
            " > teleport.topos \"player\" x y z" 
        },
        SyntaxConsoleCommandToPlayer = { 
            "A Syntax Error Occurred!", 
            "You can only use the teleport.toplayer console command as follows:", 
            " > teleport.toplayer \"player\" \"target player\"" 
        }
    }
end

-- ----------------------------------------------------------------------------
-- PLUGIN:UpdateConfig()
-- ----------------------------------------------------------------------------
-- Updates the configuration file when required.
-- ----------------------------------------------------------------------------
function PLUGIN:UpdateConfig()
    if self.Config.Settings.ConfigVersion == "1.0.0" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.1"

        -- Modify the changed config values.
        self.Config.Messages.MultiplePlayersFound = "Found multiple players with that name!"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.1, 1 new message was added to the configuration file!" )
    end

    if self.Config.Settings.ConfigVersion == "1.1" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.1.0"
        
        -- Modify the changed config values.
        table.insert( self.Config.Messages.SyntaxCommandTP, "/tp <player> <x> <y> <z> - Teleports the player to the set of coordinates." )
        self.Config.Messages.SyntaxConsoleCommandToPos      = { "A Syntax Error Occurred!", "You can only use the teleport.topos console command as follows:", " > teleport.topos \"player\" x y z" }
        self.Config.Messages.SyntaxConsoleCommandToPlayer   = { "A Syntax Error Occurred!", "You can only use the teleport.toplayer console command as follows:", " > teleport.toplayer \"player\" \"target player\"" }
        self.Config.Messages.AdminTPTargetCoordinates       = "You teleported {player} to {coordinates}!"
        self.Config.Messages.AdminTPTargetCoordinatesTarget = "{admin} teleported you to {coordinates}!"
        self.Config.Messages.AdminTPConsoleTP               = "You were teleported to {destination}"
        self.Config.Messages.AdminTPConsoleTPPlayer         = "You were teleported to {player}"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.1.0, 7 new messages were added to the configuration file!" )
    end

    if self.Config.Settings.ConfigVersion == "1.1.0" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.2.0"

        -- Modify the changed config values.
        self.Config.Homes.UseFriendsAPI                    = true
        self.Config.Messages.HomeFoundationNotFriendsOwned = "You need to be in your own or in a friend's house to set your home!"
        self.Config.Messages.InvalidCharacter              = "You have used an invalid character, please limit yourself to the letters a to z and numbers.",

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.2.0, 1 new value and 2 new messages were added to the configuration file!" )
    end

    if self.Config.Settings.ConfigVersion == "1.2.0" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.2.1"
        
        -- Modify the changed config values.
        self.Config.Messages.AdminTPBoundaries = "X and Z values need to be between -{boundary} and {boundary} while the Y value needs to be between -100 and 2000!"
        
        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.2.1, 1 value was modified!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.2.1" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.3.0"

        -- Modify the changed config values.
        self.Config.AdminTP.TeleportNearDefaultDistance = 30
        self.Config.Messages.HomesListWiped = "You have wiped all the saved home locations!"
        self.Config.Messages.SyntaxCommandTPN = {
            "A Syntax Error Occurred!",
            "You can only use the /tpn command as follows:",
            "/tpn <targetplayer> - Teleports yourself the default distance behind the target player.",
            "/tpn <targetplayer> <distance> - Teleports you the specified distance behind the target player."
        }

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.3.0, 5 new values were added!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.3.0" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.0"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.0, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.0" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.1"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.1, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.1" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.2"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.2, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.2" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.3"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.3, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.3" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.4"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.4, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.4" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.5"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.5, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.5" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.6"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.6, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.6" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.7"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.7, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.7" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.8"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.8, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.8" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.9"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.9, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.9" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.12"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.12, version indication was updated!" )
    end
    
    if self.Config.Settings.ConfigVersion == "1.4.12" then
        -- Change the config version.
        self.Config.Settings.ConfigVersion = "1.4.13"

        -- Send a console message to notify the server owner of this change.
        print( "m-Teleportation: Your config file was updated to config version 1.4.13, version indication was updated!" )
    end

    -- Save the config.
    self:SaveConfig()
end

-- ----------------------------------------------------------------------------
-- PLUGIN:LoadSavedData()
-- ----------------------------------------------------------------------------
-- Load the DataTable file into a table or create a new table when the file
-- doesn't exist yet.
-- ----------------------------------------------------------------------------
function PLUGIN:LoadSavedData()
    -- Open the datafile if it exists, otherwise we'll create a new one.
    TeleportData           = datafile.GetDataTable( "m-Teleportation" )
    TeleportData           = TeleportData or {}
    TeleportData.AdminData = TeleportData.AdminData or {}
    TeleportData.HomeData  = TeleportData.HomeData or {}
    TeleportData.TPRData   = TeleportData.TPRData or {}
end

-- ----------------------------------------------------------------------------
-- PLUGIN:SaveData()
-- ----------------------------------------------------------------------------
-- Saves the table with all the teleportdata to a DataTable file.
-- ----------------------------------------------------------------------------
function PLUGIN:SaveData()  
    -- Save the DataTable
    datafile.SaveDataTable( "m-Teleportation" )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleport( player, cmd, args )                        Admin Command
-- ----------------------------------------------------------------------------
-- In-game '/tp' command for server admins to be able to teleport to players,
-- teleport players to other players and to teleport to a set of coordinates on
-- the map.
-- ----------------------------------------------------------------------------
function PLUGIN: cmdTeleport( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming that the player is 
        -- attempting to teleport himself/herself to another online player.

        -- Search for the BasePlayer for the given (partial) name.
        local targetPlayer = self:FindPlayerByName( args[0] )

        -- Check if we found the targetted player.
        if #targetPlayer == 0 then
            -- The targetted player couldn't be found, send a message to the 
            -- player.
            self:SendMessage( player, self.Config.Messages.PlayerNotFound )

            return
        end

        -- Check if we found multiple players with that partial name.
        if #targetPlayer > 1 then
            -- Multiple players were found, send a message to the player.
            self:SendMessage( player, self.Config.Messages.MultiplePlayersFound )

            return
        else
            -- Only one player was found, modify the targetPlayer variable 
            -- value.
            targetPlayer = targetPlayer[1]
        end

        -- Check if the targetted player isn't the player that is running the
        -- command.
        if player == targetPlayer then
            -- The player and the targetted player are the same, send a message
            -- to the player.
            self:SendMessage( player, self.Config.Messages.CantTeleportToSelf )
            
            return
        end

        -- The targetted player was found and is a valid target. Save the
        -- player his current location for the '/tpb' command and initiate a
        -- teleport to the target.
        self:SaveLocation( player )
        self:TeleportToPlayer( player, targetPlayer )

        -- Show a message to the player.
        self:SendMessage( player, self:Parse( self.Config.Messages.AdminTP, { player = targetPlayer.displayName } ) ) 

        -- Check the settings if we're supposed to send a message to the
        -- targetted player or not.
        if self.Config.AdminTP.AnnounceTeleportToTarget then
            -- Send the message to the targetted player.
            self:SendMessage( targetPlayer, self:Parse( self.Config.Messages.AdminTPTarget, { player = player.displayName } ) )
        end
    elseif args.Length == 2 then
        -- The player supplied two arguments, assuming that the player is
        -- attempting to teleport a different player to another player.

        -- Search for the BasePlayer for the given (partial) names.
        local originPlayer = self:FindPlayerByName( args[0] )
        local targetPlayer = self:FindPlayerByName( args[1] )

        -- Check if we found the targetted player.
        if #originPlayer == 0 or #targetPlayer == 0 then
            -- One or both players couldn't be found, send a message to the
            -- player.
            self:SendMessage( player, self.Config.Messages.PlayerNotFound )

            return
        end

        -- Check if we found multiple players with that partial name.
        if #originPlayer > 1 or #targetPlayer > 1 then
            -- Multiple players were found, send a message to the player.
            self:SendMessage( player, self.Config.Messages.MultiplePlayersFound )

            return
        else
            -- Only one player was found, modify the targetPlayer variable
            -- value.
            originPlayer = originPlayer[1]
            targetPlayer = targetPlayer[1]
        end

        -- Check if the origin player is different from the targetted player.
        if originPlayer == targetPlayer then
            -- Both players are the same, send a message to the player.
            self:SendMessage( player, self.Config.Messages.CantTeleportPlayerToSelf )

            return
        end

        -- Check if the player is teleporting himself.
        if self:IsAllowed( originPlayer ) then
            -- The player is teleporting himself so we need to save his current
            -- location.
            self:SaveLocation( player )
        end

        -- Both players were found and are valid. Initiate a teleport for the
        -- origin player to the targetted player.
        self:TeleportToPlayer( originPlayer, targetPlayer )

        -- Show a message to the player, origin player and targetted player.
        self:SendMessage( player, self:Parse( self.Config.Messages.AdminTPPlayers, { player = originPlayer.displayName, target = targetPlayer.displayName } ) )
        self:SendMessage( originPlayer, self:Parse( self.Config.Messages.AdminTPPlayer, { admin = player.displayName, player = targetPlayer.displayName } ) )
        self:SendMessage( targetPlayer, self:Parse( self.Config.Messages.AdminTPPlayerTarget, { admin = player.displayName, player = originPlayer.displayName } ) )
    elseif args.Length == 3 then
        -- The player supplied three arguments, assuming that the player is
        -- attempting to teleport himself/herself to a set of coordinates.

        -- Store the coordinates as numbers into variables.
        local x = tonumber( args[0] )
        local y = tonumber( args[1] )
        local z = tonumber( args[2] )

        -- Validate the three coordinates, first check if all three are numbers
        -- and then check if the coordinates are within the map boundaries.
        if x and y and z then
            -- The three supplied axis values are numbers, check if they are
            -- within the boundaries of the map.
            local boundary = global.TerrainMeta.get_Size().x / 2

            if ( x <= boundary and x >= -boundary ) and ( y < 2000 and y >= -100 ) and ( z <= boundary and z >= -boundary ) then
                -- A valid location was specified, save the player his current
                -- location for the '/tpb' command and initiate a teleport.
                self:SaveLocation( player )
                self:TeleportToPosition( player, x, y, z )

                -- Show a message to the player.
                self:SendMessage(player, self:Parse( self.Config.Messages.AdminTPCoordinates, { coordinates = x .. " " .. y .. " " .. z } ) )
            else
                -- One or more axis values are out of bounds, show a message to
                -- the player.
                self:SendMessage( player, self.Config.Messages.AdminTPOutOfBounds )
                self:SendMessage( player, self:Parse( self.Config.Messages.AdminTPBoundaries, { boundary = boundary } ) )
            end
        else
            -- One or more axis values are not a number and are invalid, show a
            -- a message to the player.
            self:SendMessage( player, self.Config.Messages.InvalidCoordinates )
        end
    elseif args.Length == 4 then
        -- The player supplied four arguments, assuming that the player is
        -- attempting to teleport a player to a set of coordinates.
        
        -- Search for the BasePlayer for the given (partial) name.
        local targetPlayer = self:FindPlayerByName( args[0] )

        -- Check if we found the targetted player.
        if #targetPlayer == 0 then
            -- The targetted player couldn't be found, send a message to the
            -- player.
            self:SendMessage( player, self.Config.Messages.PlayerNotFound )

            return
        end

        -- Check if we found multiple players with that partial name.
        if #targetPlayer > 1 then
            -- Multiple players were found, send a message to the player.
            self:SendMessage( player, self.Config.Messages.MultiplePlayersFound )

            return
        else
            -- Only one player was found, modify the targetPlayer variable
            -- value.
            targetPlayer = targetPlayer[1]
        end

        -- Store the coordinates as numbers into variables.
        local x = tonumber( args[1] )
        local y = tonumber( args[2] )
        local z = tonumber( args[3] )

        -- Validate the three coordinates, first check if all three are numbers
        -- and then check if the coordinates are within the map boundaries.
        if x and y and z then
            -- The three supplied axis values are numbers, check if they are
            -- within the boundaries of the map.
            local boundary = global.TerrainMeta.get_Size().x / 2

            if ( x <= boundary and x >= -boundary ) and ( y < 2000 and y >= -100 ) and ( z <= boundary and z >= -boundary ) then
                -- A valid location was specified, save the player his/her
                -- current location for the '/tpb' command if necessary and
                -- initiate a teleport.
                if self:IsAllowed( targetPlayer ) then
                    -- The player is an admin so we need to save his current
                    -- location.
                    self:SaveLocation( targetPlayer )
                end

                self:TeleportToPosition( targetPlayer, x, y, z )

                -- Show a message to the player.
                if player == targetPlayer then
                    self:SendMessage(player, self:Parse( self.Config.Messages.AdminTPCoordinates, { coordinates = x .. " " .. y .. " " .. z } ) )
                else
                    self:SendMessage(player, self:Parse( self.Config.Messages.AdminTPTargetCoordinates, { player = targetPlayer.displayName, coordinates = x .. " " .. y .. " " .. z } ) )
                    self:SendMessage(targetPlayer, self:Parse( self.Config.Messages.AdminTPTargetCoordinatesTarget, { admin = player.displayName, coordinates = x .. " " .. y .. " " .. z } ) )
                end
            else
                -- One or more axis values are out of bounds, show a message to
                -- the player.
                self:SendMessage( player, self.Config.Messages.AdminTPOutOfBounds )
                self:SendMessage( player, self:Parse( self.Config.Messages.AdminTPBoundaries, { boundary = boundary } ) )
            end
        else
            -- One or more axis values are not a number and are invalid, show a
            -- a message to the player.
            self:SendMessage( player, self.Config.Messages.InvalidCoordinates )
        end
    else
        -- No arguments or an invalid amount of arguments were supplied, send a
        -- message to the player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTP )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportNear( player, cmd, args )                    Admin Command
-- ----------------------------------------------------------------------------
-- In-game '/tpn' command for server admins to be able to teleport near a
-- player.
-- ----------------------------------------------------------------------------
function PLUGIN: cmdTeleportNear( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 or args.Length == 2 then
        -- The player supplied one argument, assuming that the player is
        -- attempting to teleport himself/herself to another online player.

        -- Search for the BasePlayer for the given (partial) name.
        local targetPlayer = self:FindPlayerByName( args[0] )

        -- Check if we found the targetted player.
        if #targetPlayer == 0 then
            -- The targetted player couldn't be found, send a message to the
            -- player.
            self:SendMessage( player, self.Config.Messages.PlayerNotFound )

            return
        end

        -- Check if we found multiple players with that partial name.
        if #targetPlayer > 1 then
            -- Multiple players were found, send a message to the player.
            self:SendMessage( player, self.Config.Messages.MultiplePlayersFound )

            return
        else
            -- Only one player was found, modify the targetPlayer variable
            -- value.
            targetPlayer = targetPlayer[1]
        end

        -- Check if the targetted player isn't the player that is running the
        -- command.
        if player == targetPlayer then
            -- The player and the targetted player are the same, send a message
            -- to the player.
            self:SendMessage( player, self.Config.Messages.CantTeleportToSelf )
            
            return
        end

        -- Determine the distance behind the player.
        local distance = tonumber( self.Config.AdminTP.TeleportNearDefaultDistance )

        -- Check if a different distance was supplied.
        if args.Length == 2 then
            if tonumber( args[1] ) then
                distance = tonumber( args[1] )
            end
        end

        -- Generate a random x value between 0 and the distance required.
        local targetX = math.random( -distance, distance )
        local targetZ = math.sqrt( math.pow( distance, 2 ) - math.pow( targetX, 2 ) )

        local destination = targetPlayer.transform.position
        destination.x = destination.x - targetX
        destination.y = 5000
        destination.z = destination.z - targetZ

        -- Calculate the height at the new coordinates.
        destination = self:GetGround( destination )

        -- The targetted player was found and is a valid target. Save the
        -- player his/her current location for the '/tpb' command and initiate
        -- a teleport to the target.
        self:SaveLocation( player )
        self:TeleportToPosition( player, destination.x, destination.y, destination.z )
        
        -- Show a message to the player.
        self:SendMessage( player, self:Parse( self.Config.Messages.AdminTP, { player = targetPlayer.displayName } ) ) 

        -- Check the settings if we're supposed to send a message to the
        -- targetted player or not.
        if self.Config.AdminTP.AnnounceTeleportToTarget then
            -- Send the message to the targetted player.
            self:SendMessage( targetPlayer, self:Parse( self.Config.Messages.AdminTPTarget, { player = player.displayName } ) )
        end
    else
        -- No arguments or an invalid amount of arguments were supplied, send a
        -- message to the player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPN )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportLocation( player, cmd, args )                Admin Command
-- ----------------------------------------------------------------------------
-- In-game '/tpl' command that allows a server admin to teleport to a
-- previously saved location or to get a list of all saved locations.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportLocation( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 0 then
        -- The player didn't supply any arguments, assuming that the player
        -- wants to get a list of all his available teleport locations.

        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.AdminData[playerID] then
            if self:Count( TeleportData.AdminData[playerID].SavedLocations ) > 0 then
                -- The player has one or more save locations available, show a
                -- message to the player and show him/her all the available
                -- saved locations.
                self:SendMessage( player, self.Config.Messages.AdminLocationList )

                -- Loop through all the saved locations and print them one by
                -- one.
                for location, coordinates in pairs( TeleportData.AdminData[playerID].SavedLocations ) do
                    self:SendMessage( player, location .. ": " .. math.floor( coordinates.x ) .. " " .. math.floor( coordinates.y ) .. " " .. math.floor( coordinates.z ) )
                end

                return
            end
        end

        -- The player has no saved locations available, show a message to
        -- him/her. 
        self:SendMessage( player, self.Config.Messages.AdminLocationListEmpty )
    elseif args.Length == 1 then
        -- The player supplied one argument, assuming that the player is
        -- attempting to teleport himself/herself to a saved location.

        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.AdminData[playerID] then
            if self:Count( TeleportData.AdminData[playerID].SavedLocations ) > 0 then
                -- The player has one or more save locations available, check
                -- if the location that the player specified is a saved
                -- location.

                -- Set some variables to store the location in when we find it.
                local locationFound       = false
                local locationCoordinates = nil

                -- Loop through all the saved locations for the player and
                -- check for a match against the entered location.
                for location, coordinates in pairs( TeleportData.AdminData[playerID].SavedLocations ) do
                    if string.lower( args[0] ) == string.lower( location ) then
                        -- We found a match for the entered location.
                        locationFound       = true
                        locationCoordinates = coordinates

                        -- Exit the loop.
                        break
                    end
                end
                
                if not locationFound then
                    self:SendMessage( player, self.Config.Messages.LocationNotFound )

                    return
                end
                -- A valid location was specified, save the player his current
                -- location for the '/tpb' command and initiate a teleport.
                self:SaveLocation( player )
                self:TeleportToPosition( player, locationCoordinates.x, locationCoordinates.y, locationCoordinates.z ) 

                -- Send a message to the player.
                self:SendMessage( player, self:Parse( self.Config.Messages.AdminTPLocation, { location = args[0] } ) )

                return
            end
        end

        -- The player has no saved locations available, show a message to
        -- him/her. 
        self:SendMessage( player, self.Config.Messages.AdminLocationListEmpty )
    else
        -- An invalid amount of arguments were supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPL )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdSaveTeleportLocation( player, cmd, args )            Admin command
-- ----------------------------------------------------------------------------
-- In-game '/tpsave' command that allows a server admin to save his current
-- location to be able to teleport to it later.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdSaveTeleportLocation( player, cmd, args )
     -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming that the player is
        -- attempting to save his/her current location.
        
        -- Check if the tables to save the location to exist, if they don't we
        -- have to create them first or an error will occur.
        TeleportData.AdminData[playerID]                = TeleportData.AdminData[playerID] or {}
        TeleportData.AdminData[playerID].SavedLocations = TeleportData.AdminData[playerID].SavedLocations or {}

        -- Set some variables that we'll use to check if there is already a
        -- location saved near the current position or with the same name.
        local locationFound             = false
        local locationFoundNearby       = false
        local locationName              = nil
        local positionCoordinates       = player.transform.position
        local locationCoordinates       = new( UnityEngine.Vector3._type, nil )
        local locationCoordinatesString = nil

        -- Loop through all the saved locations for the player to check if a
        -- location with the same name or near that position already exists.
        for location, coordinates in pairs( TeleportData.AdminData[playerID].SavedLocations ) do
            locationName          = location
            locationCoordinates.x = coordinates.x
            locationCoordinates.y = coordinates.y
            locationCoordinates.z = coordinates.z

            -- Check if the player already has a location with the same name.
            if args[0] == locationName then
                -- A location with this name already exists.
                locationFound = true

                -- Exit the loop.
                break
            end

            -- Check if the player already has a location nearby this position
            -- with a different name.
            if UnityEngine.Vector3.Distance( positionCoordinates, locationCoordinates ) < self.Config.AdminTP.LocationRadius then
                -- A location was found near the current position.
                locationFound = true

                -- Exit the loop.
                break
            end
        end

        -- If the location can't be created because a location with the same
        -- name or near the current position already exist we'll setup a string
        -- with the coordinates of that location to show to the player.
        if locationFound or locationFoundNearby then
            locationCoordinatesString = math.floor( locationCoordinates.x ) .. " " .. math.floor( locationCoordinates.y ) .. " " .. math.floor( locationCoordinates.z )
        end

        -- Determine the next step depending on the existance of the location.
        if not locationFound and not locationFoundNearby then
            -- No saved locations found near this position or with the same
            -- name, so this position can be saved with the supplied name.

            -- Set the data and save it.
            TeleportData.AdminData[playerID].SavedLocations[args[0]] = { x = positionCoordinates.x, y = positionCoordinates.y, z = positionCoordinates.z }
            self:SaveData()

            -- Show a message to the player.
            self:SendMessage( player, self.Config.Messages.AdminTPLocationSave )
        elseif locationFound and not locationFoundNearby then
            -- A saved location was found with the same name, send a message to
            -- the player with the coordinates of the location.
            self:SendMessage( player, self:Parse( self.Config.Messages.LocationExists, { location = locationCoordinatesString } ) )
        elseif not locationFound and locationFoundNearby then
            -- A saved location was found near the current position, send a
            -- message to the player with the name of the location.
            self:SendMessage( player, self:Parse( self.Config.Messages.LocationExistsNearby, { name = locationName } ) )
        end
    else
        -- No arguments or an invalid amount of arguments were supplied, send a
        -- message to the player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPSave )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdRemoveTeleportLocation( player, cmd, args )          Admin Command
-- ----------------------------------------------------------------------------
-- In-game '/tpremove' command that allows a server admin to remove a saved
-- location.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdRemoveTeleportLocation( player, cmd, args )
     -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming that the player is
        -- attempting to remove the specified location from his/her saved
        -- locations list.
        
        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.AdminData[playerID] then
            if self:Count( TeleportData.AdminData[playerID].SavedLocations ) > 0 then
                -- The player has one or more save locations available, check
                -- if the location that the player specified is a saved
                -- location.

                -- Set some variables to store the location in when we find it.
                local locationFound       = false

                -- Loop through all the saved locations for the player and
                -- check for a match against the entered location.
                for location, coordinates in pairs( TeleportData.AdminData[playerID].SavedLocations ) do
                    if args[0] == location then
                        -- We found a match for the entered location.
                        locationFound       = true

                        -- Exit the loop.
                        break
                    end
                end

                -- Check if we found a match while comparing the specified
                -- location to the list of saved locations.    
                if locationFound then
                    -- We have found a location with the specified name so we
                    -- can now remove this from the DataTable and save it.
                    TeleportData.AdminData[playerID].SavedLocations[args[0]] = nil
                    self:SaveData()

                    -- Show a message to the player.
                    self:SendMessage( player, self:Parse( self.Config.Messages.AdminTPLocationRemove, { location = args[0] } ) )

                else
                    -- We haven't found a location with the specified name,
                    -- send a message to the player.
                    self:SendMessage( player, self.Config.Messages.LocationNotFound )
                end

                return
            end
        end

        -- The player has no saved locations available, show a message to the
        -- player.
        self:SendMessage( player, self.Config.Messages.AdminLocationListEmpty )
    else
        -- No arguments or an invalid amount of arguments were supplied, send a
        -- message to the player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPRemove )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportBack( player, cmd, args )                    Admin Command
-- ----------------------------------------------------------------------------
-- In-game '/tpb' command that allows a server admin to teleport back to his
-- previous location after teleporting.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportBack( player, cmd, args )
     -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 0 then
        -- The player supplied no arguments, assuming that the player is
        -- attempting to teleport back to his previous location.
        
        -- Check if there is data saved for the player, after that check if the
        -- data contains a previous location for the player.
        if TeleportData.AdminData[playerID] then
            if TeleportData.AdminData[playerID].PreviousLocation then
                -- A previous location was found, teleport the player back to
                -- that
                -- position.
                self:TeleportToPosition( player, TeleportData.AdminData[playerID].PreviousLocation.x, TeleportData.AdminData[playerID].PreviousLocation.y, TeleportData.AdminData[playerID].PreviousLocation.z )

                -- Remove the saved location from the DataTable and save it.
                TeleportData.AdminData[playerID].PreviousLocation = nil
                self:SaveData()

                -- Show a message to the player.
                self:SendMessage( player, self.Config.Messages.AdminTPBack )
            end
        end

        -- There is no previously saved position available, show a message to
        -- the player.
        self:SendMessage( player, self.Config.Messages.NoPreviousLocationSaved )
    else
        -- An invalid amount of arguments was supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPB )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdSetHome( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/sethome' command that allows any player to save his/her current
-- position as a home that can be used to teleport back to.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdSetHome( player, cmd, args )
    -- Check if the Home module is enabled.
    if not self.Config.Settings.HomesEnabled then return end

    -- Check if the player is allowed to use the command.
    canTeleport, err = self:CanPlayerTeleport( player )
    if not canTeleport then
        -- The player isn't allowed to teleport right now, send him a message
        -- from the plugin that is blocking the teleport and cancel the
        -- teleport process.
        self:SendMessage( player, err )

        return
    end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one arguments, assuming that the player is
        -- attempting to save his/her current position as a home location.
        
        -- Check if the tables to save the location to exist, if they don't we
        -- have to create them first or an error will occur.
        TeleportData.HomeData[playerID]               = TeleportData.HomeData[playerID] or {}
        TeleportData.HomeData[playerID].HomeLocations = TeleportData.HomeData[playerID].HomeLocations or {}

        -- Set some variables that we'll use to check if there is already a
        -- location saved near the current position or with the same name.
        local locationFound             = false
        local locationFoundNearby       = false
        local locationName              = nil
        local positionCoordinates       = player.transform.position
        local locationCoordinates       = new( UnityEngine.Vector3._type, nil )
        local locationCoordinatesString = nil

        -- Check if the player already has saved home locations before.
        if self:Count( TeleportData.HomeData[playerID].HomeLocations ) > 0 then
            -- Check if the amount of homes is limited and if it is then check
            -- if the amount of saved homes will not go over the limit.
            if self.Config.Homes.HomesLimit > 0 and self:Count( TeleportData.HomeData[playerID].HomeLocations ) >= self.Config.Homes.HomesLimit then
                -- The player has reached the maximum amount of saved homes,
                -- show a message to the player.
                self:SendMessage( player, self:Parse( self.Config.Messages.HomeMaxLocations, { amount = self.Config.Homes.HomesLimit } ) )

                return
            end

            -- Loop through all the saved locations for the player to check if
            -- a location with the same name or near that position already
            -- exists.
            for location, coordinates in pairs( TeleportData.HomeData[playerID].HomeLocations ) do
                locationName          = location
                locationCoordinates.x = coordinates.x
                locationCoordinates.y = coordinates.y
                locationCoordinates.z = coordinates.z

                -- Check if the player already has a location with the same
                -- name.
                if args[0] == locationName then
                    -- A location with this name already exists.
                    locationFound = true

                    -- Exit the loop.
                    break
                end

                -- Check if the player already has a location nearby this
                -- position with a different name.
                if UnityEngine.Vector3.Distance( positionCoordinates, locationCoordinates ) < self.Config.Homes.LocationRadius then
                    -- A location was found near the current position.
                    locationFoundNearby = true

                    -- Exit the loop.
                    break
                end
            end
        end

        -- If the location can't be created because a location with the same
        -- name or near the current position already exist we'll setup a string
        -- with the coordinates of that location to show to the player.
        if locationFound or locationFoundNearby then
            locationCoordinatesString = math.floor( locationCoordinates.x ) .. " " .. math.floor( locationCoordinates.y ) .. " " .. math.floor( locationCoordinates.z )
        end

        -- Determine the next step depending on the existance of the location.
        if not locationFound and not locationFoundNearby then
            -- No saved locations found near this position or with the same
            -- name, so this position can be saved with the supplied name.

            -- Check if the player is standing on a foundation if required.
            if self.Config.Homes.ForceOnTopOfFoundation then
                -- Modify the local position, add 2 to the y coordinate in case
                -- the terrain (grass) goes through the foundation.
                local position       = player.transform.position
                position.y = position.y + 2

                -- Setup an array to invoke RaycastAll with two Vector3
                -- arguments, the position and the direction down and invoke.
                local arr   = util.TableToArray( { position , UnityEngine.Vector3.get_down() } )
                local hits  = RaycastAll:Invoke( nil, arr )

                -- Create a local variable to store the BuildingBlock.
                local block = nil

                -- Create an iterator to loop through all the Raycast Hits.
                local it = hits:GetEnumerator()

                -- Iterate through all the Raycast Hits.
                while ( it:MoveNext() ) do
                    -- Check if the hit is a deployed item.
                    if it.Current.collider:GetComponentInParent( global.BuildingBlock._type ) then
                        local buildingBlock = it.Current.collider:GetComponentInParent( global.BuildingBlock._type )

                        if buildingBlock.name:find( "foundation", 1, true ) then
                            -- The deployed item is a foundation, store it in
                            -- a variable.
                            block = buildingBlock

                            break
                        else
                            -- Exit the loop when the first BuildingBlock hit
                            -- isn't a foundation.
                            break
                        end
                    end
                end

                -- Check if we have a BuildingBlock for the player.
                if not block then
                    -- The player is not standing on a foundation, send
                    -- the player a message.
                    self:SendMessage( player, self.Config.Messages.HomeSaveFoundationOnly )

                    return
                end

                -- Check if a player is on top of a door.
                if UnityEngine.Vector3.Distance( player.transform.position, block.transform.position ) > 2 then
                    -- The player is not standing on a foundation, send
                    -- the player a message.
                    self:SendMessage( player, self.Config.Messages.HomeSaveFoundationOnly )

                    return
                end

                -- Check if the player owns the foundation if required.
                if self.Config.Homes.CheckFoundationForOwner then
                    if playerID ~= self:GetOwner( block ) then
                        -- The player is not standing on a owned foundation, 
                        -- send the player a message if the foundation is also
                        -- not owned by a friend if this is enabled in the
                        -- settings.
                        if self.Config.Homes.UseFriendsAPI and not FriendsAPI.Object:areFriends( self:GetOwner( block ), playerID ) then
                            -- The player is not standing on a foundation owned
                            -- by a friend.
                            self:SendMessage( player, self.Config.Messages.HomeFoundationNotFriendsOwned )

                            return
                        end

                        if not self.Config.Homes.UseFriendsAPI then
                            self:SendMessage( player, self.Config.Messages.HomeFoundationNotOwned )

                            return 
                        end                       
                    end
                end

            end

            -- Check the location name for invalid characters.
            if args[0]:match("%W") then
                -- Send the player a message.
                self:SendMessage( player, self.Config.Messages.InvalidCharacter )

                return
            end

            -- Set the data and save it.
            TeleportData.HomeData[playerID].HomeLocations[args[0]] = { x = positionCoordinates.x, y = positionCoordinates.y, z = positionCoordinates.z }
            self:SaveData()

            -- Show a message to the player.
            self:SendMessage( player, self.Config.Messages.HomeSave )
        elseif locationFound and not locationFoundNearby then
            -- A saved location was found with the same name, send a message to
            -- the player with the coordinates of the location.
            self:SendMessage( player, self.Config.Messages.HomeExists )
        elseif not locationFound and locationFoundNearby then
            -- A saved location was found near the current position, send a
            -- message to the player with the name of the location.
            self:SendMessage( player, self:Parse( self.Config.Messages.HomeExistsNearby, { name = locationName } ) )
        end
    else
        -- An invalid amount of arguments was supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandSetHome)
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdRemoveHome( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/removehome' command that allows a player to remove a previously
-- saved home location.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdRemoveHome( player, cmd, args )
    -- Check if the Home module is enabled.
    if not self.Config.Settings.HomesEnabled then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one arguments, assuming that the player is
        -- attempting to save his/her current position as a home location.
        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.HomeData[playerID] then
            if self:Count( TeleportData.HomeData[playerID].HomeLocations ) > 0 then
                -- The player has one or more save locations available, check
                -- if the location that the player specified is a saved
                -- location.

                -- Set some variables to store the location in when we find it.
                local locationFound       = false

                -- Loop through all the saved locations for the player and
                -- check for a match against the entered location.
                for location, coordinates in pairs( TeleportData.HomeData[playerID].HomeLocations ) do
                    if args[0] == location then
                        -- We found a match for the entered location.
                        locationFound       = true

                        -- Exit the loop.
                        break
                    end
                end

                -- Check if we found a match while comparing the specified
                -- location to the list of saved locations.    
                if locationFound then
                    -- We have found a location with the specified name so we
                    -- can now remove this from the DataTable and save it.
                    TeleportData.HomeData[playerID].HomeLocations[args[0]] = nil
                    self:SaveData()

                    -- Show a message to the player.
                    self:SendMessage( player, self:Parse( self.Config.Messages.HomeRemove, { home = args[0] } ) )

                else
                    -- We haven't found a location with the specified name,
                    -- send a message to the player.
                    self:SendMessage( player, self.Config.Messages.HomeNotFound )
                end

                return
            end
        end

        -- The player has no saved locations available, show a message to the
        -- player.
        self:SendMessage( player, self.Config.Messages.HomeListEmpty )
    else
        -- An invalid amount of arguments was supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandRemoveHome)
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportHome( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/home' command that allows a player to a previously saved home
-- location.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportHome( player, cmd, args )
    -- Check if the Home module is enabled.
    if not self.Config.Settings.HomesEnabled then return end

    -- Check if the player is allowed to use the command.
    canTeleport, err = self:CanPlayerTeleport( player )
    if not canTeleport then
        -- The player isn't allowed to teleport right now, send him a message
        -- from the plugin that is blocking the teleport and cancel the
        -- teleport proces.
        self:SendMessage( player, err )

        return
    end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming that the player is 
        -- attempting to teleport himself/herself to a saved home location.

        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.HomeData[playerID] then
            if self:Count( TeleportData.HomeData[playerID].HomeLocations ) > 0 then
                -- The player has one or more save locations available, check
                -- if the location that the player specified is a saved
                -- location.

                -- Setup variables with todays date and the current timestamp.
                local timestamp   = time.GetUnixTimestamp()
                local currentDate = tostring( time.GetCurrentTime():ToString("d") )

                -- Check if there is saved teleport data available for the
                -- player.
                if TeleportData.HomeData[playerID].Teleports then
                    if TeleportData.HomeData[playerID].Teleports.date ~= currentDate then
                        TeleportData.HomeData[playerID].Teleports = nil
                    end
                end

                -- Grab the user his/her teleport data.
                TeleportData.HomeData[playerID].Teleports = TeleportData.HomeData[playerID].Teleports or {}
                TeleportData.HomeData[playerID].Teleports.amount = TeleportData.HomeData[playerID].Teleports.amount or 0
                TeleportData.HomeData[playerID].Teleports.date = currentDate
                TeleportData.HomeData[playerID].Teleports.timestamp = TeleportData.HomeData[playerID].Teleports.timestamp or 0

                -- Check if the cooldown option is enabled and if it is make
                -- sure that the cooldown time has passed.
                if self.Config.Homes.Cooldown > 0 and ( timestamp - TeleportData.HomeData[playerID].Teleports.timestamp ) < self.Config.Homes.Cooldown then
                    -- Get the remaining time.
                    local remainingTime = self:ParseRemainingTime( self.Config.Homes.Cooldown - ( timestamp - TeleportData.HomeData[playerID].Teleports.timestamp ) )
                    -- Teleport is on cooldown, show a message to the player.
                    self:SendMessage( player, self:Parse( self.Config.Messages.HomeTPCooldown, { time = remainingTime } ) )

                    return
                end

                -- Check if the teleports daily limit is enabled and make sure
                -- that the player has not yet reached the limit.
                if self.Config.Homes.DailyLimit > 0 and TeleportData.HomeData[playerID].Teleports.amount >= self.Config.Homes.DailyLimit then
                    -- The player has reached the limit, show a message to the
                    -- player.
                    self:SendMessage( player, self:Parse( self.Config.Messages.HomeTPLimitReached, { limit = self.Config.Homes.DailyLimit } ) )

                    return
                end

                -- Check if the player already has a teleport pending.
                if TeleportTimers[playerID] then
                    -- Send a message to the player.
                    self:SendMessage( player, self.Config.Messages.TeleportPending )

                    return
                end

                -- Set some variables to store the location in when we find it.
                local locationFound       = false
                local locationCoordinates = nil

                -- Loop through all the saved locations for the player and
                -- check for a match against the entered location.
                for location, coordinates in pairs( TeleportData.HomeData[playerID].HomeLocations ) do
                    if args[0] == location then
                        -- We found a match for the entered location.
                        locationFound       = true
                        locationCoordinates = coordinates

                        -- Exit the loop.
                        break
                    end
                end

                -- Check if we found a match while comparing the specified
                -- location to the list of saved locations.    
                if locationFound then

                    -- Location was found and no limits were reached so we ca
                    -- teleport the player to his home after a short delay.
                    TeleportTimers[playerID]              = {}
                    TeleportTimers[playerID].originPlayer = player
                    TeleportTimers[playerID].timer        = timer.Once ( self.Config.Homes.Countdown, 
                        function()
                            -- Teleport the player to his home location.
                            self:TeleportToPosition( player, locationCoordinates.x, locationCoordinates.y + 1, locationCoordinates.z )
                            
                            -- Modify the teleport amount and last teleport
                            -- timestamp.
                            TeleportData.HomeData[playerID].Teleports.amount = TeleportData.HomeData[playerID].Teleports.amount + 1
                            TeleportData.HomeData[playerID].Teleports.timestamp = timestamp
                            self:SaveData()

                            -- Show a message to the player.
                            self:SendMessage( player, self:Parse( self.Config.Messages.HomeTP, { home = args[0] } ) )

                            -- Remove the pending timer info.
                            TeleportTimers[playerID] = nil
                        end )

                    -- Send a message to the player.
                    self:SendMessage( player, self:Parse( self.Config.Messages.HomeTPStarted, { home = args[0], countdown = self.Config.Homes.Countdown } ) )

                    return
                else
                    -- Couldn't find a home location with the specified name.
                    self:SendMessage( player, self.Config.Messages.HomeNotFound )

                    return
                end
            end
        end

        -- The player has no saved locations available, show a message to
        -- him/her. 
        self:SendMessage( player, self.Config.Messages.HomeListEmpty )
    else
        -- An invalid amount of arguments were supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandHome )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdListHomes( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/listhomes' command that allows a player to look at his saved home
-- locations.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdListHomes( player, cmd, args )
    -- Check if the Home module is enabled.
    if not self.Config.Settings.HomesEnabled then return end

    -- Grab the player his/her SteamID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 0 then
        -- The player didn't supply any arguments, assuming that the player
        -- wants to get a list of all his available home locations.

        -- Check if there is data saved for the player, after that check if the
        -- data contains any saved locations for the player.
        if TeleportData.HomeData[playerID] then
            if self:Count( TeleportData.HomeData[playerID].HomeLocations ) > 0 then
                -- The player has one or more save locations available, show a
                -- message to the player and show him/her all the available
                -- saved locations.
                self:SendMessage( player, self.Config.Messages.HomeList )

                -- Loop through all the saved locations and print them one by
                -- one.
                for location, coordinates in pairs( TeleportData.HomeData[playerID].HomeLocations ) do
                    self:SendMessage( player, location .. ": " .. math.floor( coordinates.x ) .. " " .. math.floor( coordinates.y ) .. " " .. math.floor( coordinates.z ) )
                end

                return
            end
        end

        -- The player has no saved locations available, show a message to
        -- him/her. 
        self:SendMessage( player, self.Config.Messages.HomeListEmpty )
    else
        -- An invalid amount of arguments were supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandListHomes)
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportRequest( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/tpr' command that allows a player to send a teleport request to
-- another online player.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportRequest( player, cmd, args )
    -- Check if the TPR module is enabled.
    if not self.Config.Settings.TPREnabled then return end

    -- Check if the player is allowed to use the command.
    canTeleport, err = self:CanPlayerTeleport( player )
    if not canTeleport then
        -- The player isn't allowed to teleport right now, send him a message
        -- from the plugin that is blocking the teleport and cancel the
        -- teleport proces.
        self:SendMessage( player, err )

        return
    end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming that the player is
        -- attempting to request a teleport to another player.

        -- Search for the BasePlayer for the given (partial) name.
        local targetPlayer = self:FindPlayerByName( args[0] )

        -- Check if we found the targetted player.
        if #targetPlayer == 0 then
            -- The targetted player couldn't be found, send a message to the
            -- player.
            self:SendMessage( player, self.Config.Messages.PlayerNotFound )

            return
        end

        -- Check if we found multiple players with that partial name.
        if #targetPlayer > 1 then
            -- Multiple players were found, send a message to the player.
            self:SendMessage( player, self.Config.Messages.MultiplePlayersFound )

            return
        else
            -- Only one player was found, modify the targetPlayer variable
            -- value.
            targetPlayer = targetPlayer[1]
        end

        -- Check if the targetted player isn't the player that is running the
        -- command.
        if player == targetPlayer then
            -- The player and the targetted player are the same, send a message
            -- to the player.
            self:SendMessage( player, self.Config.Messages.CantTeleportToSelf )
            
            return
        end

        -- Grab the Steam ID of both players.
        originPlayerID = rust.UserIDFromPlayer( player )
        targetPlayerID = rust.UserIDFromPlayer( targetPlayer )

        -- Check if the player has not reached the limit yet and check if it's
        -- not on cooldown.

        -- Setup variables with todays date and the current timestamp.
        local timestamp   = time.GetUnixTimestamp()
        local currentDate = time.GetCurrentTime():ToString("d")

        -- Setup the player his/her TPRData table if it doesn't exist yet.
        TeleportData.TPRData[originPlayerID] = TeleportData.TPRData[originPlayerID] or {}

        -- Check if there is saved teleport data available for the player.
        if TeleportData.TPRData[originPlayerID].Teleports then
            if TeleportData.TPRData[originPlayerID].Teleports.date ~= currentDate then
                TeleportData.TPRData[originPlayerID].Teleports = nil
            end
        end

        -- Grab the user his/her teleport data.
        TeleportData.TPRData[originPlayerID].Teleports = TeleportData.TPRData[originPlayerID].Teleports or {}
        TeleportData.TPRData[originPlayerID].Teleports.amount = TeleportData.TPRData[originPlayerID].Teleports.amount or 0
        TeleportData.TPRData[originPlayerID].Teleports.date = currentDate
        TeleportData.TPRData[originPlayerID].Teleports.timestamp = TeleportData.TPRData[originPlayerID].Teleports.timestamp or 0

        -- Check if the cooldown option is enabled and if it is make sure
        -- that the cooldown time has passed.
        if self.Config.TPR.Cooldown > 0 and ( timestamp - TeleportData.TPRData[originPlayerID].Teleports.timestamp ) < self.Config.TPR.Cooldown then
            -- Get the remaining time.
            local remainingTime = self:ParseRemainingTime( self.Config.TPR.Cooldown - ( timestamp - TeleportData.TPRData[originPlayerID].Teleports.timestamp ) )
            -- Teleport is on cooldown, show a message to the player.
            self:SendMessage( player, self:Parse( self.Config.Messages.TPRCooldown, { time = remainingTime } ) )

            return
        end

        -- Check if the teleports daily limit is enabled and make sure that
        -- the player has not yet reached the limit.
        if self.Config.TPR.DailyLimit > 0 and TeleportData.TPRData[originPlayerID].Teleports.amount >= self.Config.TPR.DailyLimit then
            -- The player has reached the limit, show a message to the
            -- player.
            self:SendMessage( player, self:Parse( self.Config.Messages.TPRLimitReached, { limit = self.Config.TPR.DailyLimit } ) )

            return
        end

        -- Check if the player already has a teleport pending.
        if TeleportTimers[originPlayerID] then
            -- Send a message to the player.
            self:SendMessage( player, self.Config.Messages.TeleportPending )

            return
        end

        -- Check if the player his/her target already has a teleport pending.
        if TeleportTimers[targetPlayerID] then
            -- Send a message to the player.
            self:SendMessage( player, self.Config.Messages.TeleportPendingTarget )

            return
        end

        -- Check if the player or the targetted player already has a request
        -- pending.
        if PlayersRequests[originPlayerID] or PlayersRequests[targetPlayerID] then
            -- Show a message to the players.
            self:SendMessage( player, self.Config.Messages.PendingRequest )
            self:SendMessage( originPlayer, self.Config.Messages.PendingRequestTarget )

            return
        end

        -- Start a pending request for both the players.
        PlayersRequests[originPlayerID] = targetPlayer
        PlayersRequests[targetPlayerID] = player

        -- Start the teleport request timer.
        PendingRequests[targetPlayerID] = timer.Once( self.Config.TPR.RequestDuration,
            function()
                self:RequestTimedOut( player, targetPlayer )
            end )

        -- Send a message to both players.
        self:SendMessage( player, self:Parse( self.Config.Messages.Request, { player = targetPlayer.displayName } ) )
        self:SendMessage( targetPlayer, self:Parse( self.Config.Messages.RequestTarget, { player = player.displayName } ) )
    else
        -- An invalid amount of arguments were supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPR)
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportAccept( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/tpa' command that allows a player to accept a teleport request
-- from another player.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportAccept( player, cmd, args )
    -- Check if the TPR module is enabled.
    if not self.Config.Settings.TPREnabled then return end

    -- Check if the player is allowed to use the command.
    canTeleport, err = self:CanPlayerTeleport( player )
    if not canTeleport then
        -- The player isn't allowed to teleport right now, send him a message
        -- from the plugin that is blocking the teleport and cancel the
        -- teleport proces.
        self:SendMessage( player, err )

        return
    end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 0 then
        -- The player supplied no arguments, assuming that the player is
        -- attempting to accept a teleport request from another player.

        -- Grab the player his/her Steam ID.
        local playerID = rust.UserIDFromPlayer( player )

        -- Check if the player has a pending teleport request.
        if PendingRequests[playerID] then
            -- Grab the other player.
            local originPlayer   = PlayersRequests[playerID]
            local originPlayerID = rust.UserIDFromPlayer( originPlayer )
           
            -- Setup variables with todays date and the current timestamp.
            local timestamp   = time.GetUnixTimestamp()
            local currentDate = time.GetCurrentTime():ToString("d")

            -- Perform a ceiling check if enabled.
            if self.Config.TPR.BlockTPAOnCeiling then                
                -- Modify the local position, add 2 to the y coordinate.
                local position = player.transform.position
                position.y = position.y + 1

                -- Setup an array to invoke RaycastAll with two Vector3
                -- arguments, the position and the direction down and invoke.
                local arr   = util.TableToArray( { position , UnityEngine.Vector3.get_down() } )
                local hits  = RaycastAll:Invoke( nil, arr )

                -- Create a local variable to store the BuildingBlock.
                local ceiling = false
                local firstHit = true

                -- Create an iterator to loop through all the Raycast Hits.
                local it = hits:GetEnumerator()

                -- Iterate through all the Raycast Hits.
                 while ( it:MoveNext() ) do
                    -- Check the distance between the player and the first
                    -- "hit". 
                    if firstHit then
                        firstHit = false

                        -- If the distance is longer than 2m then the
                        -- player is most likely attempting to stand on a
                        -- ledge to bug the teleport.
                        if it.Current.distance > 2 then
                            ceiling = true

                            break
                        end
                    end

                    -- Check if the hit is a deployed item.
                    if it.Current.collider:GetComponentInParent( global.BuildingBlock._type ) then
                        local buildingBlock = it.Current.collider:GetComponentInParent( global.BuildingBlock._type )
                        
                        if buildingBlock.name:find( "floor", 1, true ) then
                            -- The deployed item is a ceiling, set the boolean 
                            -- `ceiling` to true
                            ceiling = true

                            break
                        end

                        -- Check the distance between the player and the first
                        -- "hit". 
                        if firstHit then
                            firstHit = false

                            -- If the distance is longer than 2m then the
                            -- player is most likely attempting to stand on a
                            -- ledge to bug the teleport.
                            if it.Current.distance > 2 then
                                ceiling = true

                                break
                            end

                            if not buildingBlock.name:find( "foundation", 1, true ) then
                                ceiling = true

                                break
                            end
                        end
                    end
                end

                if ceiling then
                    -- The player is trying to accept a teleport on top of a
                    -- ceiling, show the player a message.
                    self:SendMessage( player, self.Config.Messages.AcceptOnRoof )

                    return
                end
            end
            
            -- The teleport request is valid and can be accepted, send a
            -- message to both the players.
            self:SendMessage( originPlayer, self:Parse( self.Config.Messages.Accept, { player = player.displayName, countdown = self.Config.TPR.Countdown } ) ) 
            self:SendMessage( player, self:Parse( self.Config.Messages.AcceptTarget, { player = originPlayer.displayName } ) )
            
            -- Initiate the teleport timer.
            TeleportTimers[originPlayerID] = {}
            TeleportTimers[originPlayerID].originPlayer = originPlayer
            TeleportTimers[originPlayerID].targetPlayer = player
            TeleportTimers[originPlayerID].timer = timer.Once( self.Config.TPR.Countdown,
                function()
                    -- Check if the player is allowed to use the command.
                    canTeleport, err = self:CanPlayerTeleport( originPlayer )
                    if not canTeleport then
                        -- The player isn't allowed to teleport right now, send
                        -- both players a message from the plugin that is
                        -- blocking the teleport and cancel the teleport.
                        self:SendMessage( originPlayer, err )
                        self:SendMessage( player, err )

                        return
                    end

                    -- Check if the target player is allowed to use this
                    -- command.
                    canTeleport, err = self:CanPlayerTeleport( player )
                    if not canTeleport then
                        -- The player isn't allowed to teleport right now, send
                        -- both players a message from the plugin that is
                        -- blocking the teleport and cancel the teleport.
                        self:SendMessage( originPlayer, err )
                        self:SendMessage( player, err )

                        return
                    end

                    -- Teleport the player.
                    local destination = self:CheckPosition( player.transform.position, originPlayer )
                    self:Teleport( originPlayer, destination )
 
                    -- Modify the teleport amount and last teleport timestamp.
                    TeleportData.TPRData[originPlayerID].Teleports.amount = TeleportData.TPRData[originPlayerID].Teleports.amount + 1
                    TeleportData.TPRData[originPlayerID].Teleports.timestamp = timestamp
                    self:SaveData()

                    -- Send a message to both players.
                    self:SendMessage( originPlayer, self:Parse( self.Config.Messages.Success, { player = player.displayName } ) )
                    self:SendMessage( player, self:Parse( self.Config.Messages.SuccessTarget, { player = originPlayer.displayName } ) )
                    
                    -- Remove the pending timer info.
                    TeleportTimers[originPlayerID] = nil
                end )

            -- Destroy the pending request timer.
            PendingRequests[playerID]:Destroy()

            -- Remove the table entries
            PendingRequests[playerID]       = nil
            PlayersRequests[playerID]       = nil
            PlayersRequests[originPlayerID] = nil
        else
            -- The player doesn't have a pending request, show him/her a
            -- message.
            self:SendMessage( player, self.Config.Messages.NoPendingRequest )
        end
    else
        -- An invalid amount of arguments were supplied, send a message to the
        -- player with the available command possibilities.
        self:SendMessage( player, self.Config.Messages.SyntaxCommandTPA)
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdWipeHomes( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/wipehomes' command to wipe all the saved homes.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdWipeHomes( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if not self:IsAllowed( player ) then return end

    -- Clear the data.
    TeleportData.HomeData = {}

    -- Save the data.
    self:SaveData()

    -- Send a message to the player.
    self:SendMessage( player, self.Config.Messages.HomesListWiped )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:SendHelpText( player )
-- ----------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- ----------------------------------------------------------------------------
function PLUGIN:SendHelpText(player)
    if self.Config.Settings.HomesEnabled or self.Config.Settings.TPREnabled then
        self:SendMessage( player, "Use \"/tphelp\" to see the available teleport commands." )
        self:SendMessage( player, "Use \"/tplimits\" to see the teleport limits." )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportHelp( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/tphelp' command that allows players to see all the available
-- teleport commands per module.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportHelp( player, cmd, args )
    -- Check if there is a player module enabled and if the player is an admin.
    if not self.Config.Settings.TPREnabled and not self.Config.Settings.HomesEnabled and not self:IsAllowed( player ) then return end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming the player wants to view
        -- the help for a specific module.

        -- Grab the request help module.
        local TPModule = string.lower( args[0] )

        -- Check if a valid module was supplied.
        if self.Config.Messages.TPHelp[TPModule] then
            -- The player supplied a valid help module, show the list of
            -- commands.
            self:SendMessage( player, self.Config.Messages.TPHelp[TPModule] )
        else
            -- The player supplied an invalid help module, show an error
            -- message to the player.
            self:SendMessage( player, self.Config.Messages.InvalidHelpModule )
        end

    else
        -- The player supplied no arguments or too much arguments, assuming
        -- that the player is attempting to view the available help modules.

        -- Send the player the general help message.
        self:SendMessage( player, self.Config.Messages.TPHelp.General )

        -- If the player is allowed to access the Admin Teleport System then 
        -- he/she is allowed to see the help commands.
        if self:IsAllowed( player ) then
            self:SendMessage( player, "/tphelp AdminTP" )
        end
        
        if self.Config.Settings.HomesEnabled then
            self:SendMessage( player, "/tphelp Home" )
        end
        
        if self.Config.Settings.TPREnabled then
            self:SendMessage( player, "/tphelp TPR" )
        end
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:cmdTeleportLimits( player, cmd, args )
-- ----------------------------------------------------------------------------
-- In-game '/tplimits' command that allows players to see all the available 
-- teleport commands per module.
-- ----------------------------------------------------------------------------
function PLUGIN:cmdTeleportLimits( player, cmd, args )
    -- Check if there is a player module enabled.
    if not self.Config.Settings.TPREnabled and not self.Config.Settings.HomesEnabled then return end

    -- Determine what the player is trying to do depending on the amount of
    -- arguments that the player has supplied.
    if args.Length == 1 then
        -- The player supplied one argument, assuming the player wants to view
        -- the help for a specific module.

        -- Grab the request help module.
        local TPModule = string.lower( args[0] )

        -- Check if a valid module was supplied.
        if self.Config.Messages.TPSettings[TPModule] then
            -- The player supplied a valid help module, show the list of
            -- commands.
            if TPModule == "home" then
                for _,message in pairs( self.Config.Messages.TPSettings[TPModule] ) do
                    self:SendMessage( player, self:Parse( message, { cooldown = self:ParseRemainingTime( self.Config.Homes.Cooldown ), limit = self.Config.Homes.DailyLimit, amount = self.Config.Homes.HomesLimit } ) )
                end
            elseif TPModule == "tpr" then
                for _,message in pairs( self.Config.Messages.TPSettings[TPModule] ) do
                    self:SendMessage( player, self:Parse( message, { cooldown = self:ParseRemainingTime( self.Config.TPR.Cooldown ), limit = self.Config.TPR.DailyLimit } ) )
                end
            end
        else
            -- The player supplied an invalid help module, show an error
            -- message to the player.
            self:SendMessage( player, self.Config.Messages.InvalidHelpModule )
        end

    else
        -- The player supplied no arguments or too much arguments, assuming
        -- that the player is attempting to view the available help modules.

        -- Send the player the general help message.
        self:SendMessage( player, self.Config.Messages.TPSettings.General )
        
        if self.Config.Settings.HomesEnabled then
            self:SendMessage( player, "/tplimits Home" )
        end
        
        if self.Config.Settings.TPREnabled then
            self:SendMessage( player, "/tplimits TPR" )
        end
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:ccmdTeleport( arg )
-- ----------------------------------------------------------------------------
-- Console commands to mimic the old Legacy console commands teleport.topos and 
-- teleport.toplayer.
-- ----------------------------------------------------------------------------
function PLUGIN:ccmdTeleport( arg )
    local player = nil
    local command = arg.cmd.namefull

    if arg.connection then
        player = arg.connection.player
    end

    if player and not self:IsAllowed( player ) then
        return true
    end
    
    if command == "teleport.topos" then
        if not arg.Args or arg.Args.Length ~= 4 then
            local replyMessage = table.concat( self.Config.Messages.SyntaxConsoleCommandToPos, "\r\n" )
            arg:ReplyWith( replyMessage )
        else
            local playerName = arg:GetString( 0, nil )
            local x          = arg:GetFloat( 1, -10000 )
            local y          = arg:GetFloat( 2, -10000 )
            local z          = arg:GetFloat( 3, -10000 )

            -- Search for the BasePlayer for the given (partial) name.
            local targetPlayer = self:FindPlayerByName( playerName )

            -- Check if we found the targetted player.
            if #targetPlayer == 0 then
                -- The targetted player couldn't be found, send a message to
                -- the console.
                arg:ReplyWith( self.Config.Messages.PlayerNotFound )

                return
            end

            -- Check if we found multiple players with that partial name.
            if #targetPlayer > 1 then
                -- Multiple players were found, send a message to the console.
                arg:ReplyWith( player, self.Config.Messages.MultiplePlayersFound )

                return
            else
                -- Only one player was found, modify the targetPlayer variable
                -- value.
                targetPlayer = targetPlayer[1]
            end

            -- Validate the three coordinates, first check if all three are
            -- numbers and then check if the coordinates are within the map
            -- boundaries.
            if x and y and z then
                -- The three supplied axis values are numbers, check if they
                -- are within the boundaries of the map.
                local boundary = global.TerrainMeta.get_Size().x / 2

                if ( x <= boundary and x >= -boundary ) and ( y < 2000 and y >= -100 ) and ( z <= boundary and z >= -boundary ) then
                    -- A valid location was specified, save the player his/her
                    -- current location for the '/tpb' command if necessary and
                    -- initiate a teleport.
                    if self:IsAllowed( targetPlayer ) then
                        -- The player is an admin so we need to save his/her
                        -- current location.
                        self:SaveLocation( targetPlayer )
                    end

                    self:TeleportToPosition( targetPlayer, x, y, z )

                    -- Send a message to the player
                    self:SendMessage( targetPlayer, self:Parse( self.Config.Messages.AdminTPConsoleTP, { destination = x .. " " .. y .. " " .. z } ) )
                    -- Show a message in the console.
                    arg:ReplyWith( self:Parse( self.Config.Messages.AdminTPTargetCoordinates, { player = targetPlayer.displayName, coordinates = x .. " " .. y .. " " .. z } ) )

                    return
                else
                    -- One or more axis values are out of bounds, show a
                    -- message to the player.
                    arg:ReplyWith( self.Config.Messages.AdminTPOutOfBounds .. "\r\n" .. self.Config.Messages.AdminTPBoundaries )
                    
                    return
                end
            else
                -- One or more axis values are not a number and are invalid,
                -- show a message in the console.
                arg:ReplyWith( self.Config.Messages.InvalidCoordinates )

                return
            end
        end
    elseif command == "teleport.toplayer" then
        if not arg.Args or arg.Args.Length ~= 2 then
            local replyMessage = table.concat( self.Config.Messages.SyntaxConsoleCommandToPlayer, "\r\n" )
            arg:ReplyWith( replyMessage )
        else
            -- Search for the BasePlayer for the given (partial) names.
            local originPlayer = self:FindPlayerByName( arg:GetString( 0, nil ) )
            local targetPlayer = self:FindPlayerByName( arg:GetString( 1, nil ) )

            -- Check if we found both players.
            if #originPlayer == 0 or #targetPlayer == 0 then
                -- One or both players couldn't be found, send a message to the
                -- console.
                arg:ReplyWith( self.Config.Messages.PlayerNotFound )

                return
            end

            -- Check if we found multiple players with that partial names.
            if #originPlayer > 1 or #targetPlayer > 1 then
                -- Multiple players were found, send a message to the console.
                arg:ReplyWith( self.Config.Messages.MultiplePlayersFound )

                return
            else
                -- Only one player was found, modify the targetPlayer variable
                -- value.
                originPlayer = originPlayer[1]
                targetPlayer = targetPlayer[1]
            end

            -- Check if the origin player is different from the targetted
            -- player.
            if originPlayer == targetPlayer then
                -- Both players are the same, send a message to the console.
                arg:ReplyWith( self.Config.Messages.CantTeleportPlayerToSelf )

                return
            end

            -- Check if the player is an admin.
            if self:IsAllowed( originPlayer ) then
                -- The player who's being teleported is an admin, save his/her 
                -- location for the '/tpb' command.
                self:SaveLocation( originPlayer )
            end

            -- Both players were found and are valid. Initiate a teleport for
            -- the origin player to the targetted player.
            self:TeleportToPlayer( originPlayer, targetPlayer )

            -- Show a message to both the players.
            self:SendMessage( originPlayer, self:Parse( self.Config.Messages.AdminTPConsoleTPPlayer, { player = targetPlayer.displayName } ) )
            arg:ReplyWith( self:Parse( self.Config.Messages.AdminTPPlayers, { player = originPlayer.displayName, target = targetPlayer.displayName } ) )
        end
    end

    return
end

-- ----------------------------------------------------------------------------
-- PLUGIN:OnEntityAttacked( entity, hitinfo )
-- ----------------------------------------------------------------------------
-- OnEntityAttacked Oxide Hook. This hook is triggered when an entity
-- (BasePlayer or BaseNPC) is attacked. This hook is used to interrupt
-- a teleport when a player takes damage.
-- ----------------------------------------------------------------------------
function PLUGIN:OnEntityTakeDamage( entity, hitinfo )
    -- Check if the entity taking damage is a player.
    if entity:ToPlayer() then
        -- The entity taking damage is a player, grab his/her Steam ID.
        local playerID = rust.UserIDFromPlayer( entity )

        -- Check if the player has a teleport pending.
        if TeleportTimers[playerID] then
            -- Send a message to the players or to both players.
            self:SendMessage( TeleportTimers[playerID].originPlayer, self.Config.Messages.Interrupted )

            if TeleportTimers[playerID].targetPlayer then
                self:SendMessage( TeleportTimers[playerID].targetPlayer, self:Parse( self.Config.Messages.InterruptedTarget, { player = TeleportTimers[playerID].originPlayer.displayName } ) )
            end

            -- Destroy the timer.
            TeleportTimers[playerID].timer:Destroy()

            -- Remove the table entry.
            TeleportTimers[playerID] = nil
        end

    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:OnPlayerDisconnected( player )
-- ----------------------------------------------------------------------------
-- OnPlayerDisconnected Oxide Hook. This hook is triggered when a player leaves
-- the server. This hook is used to cancel pending the teleport requests and
-- pending teleports for the disconnecting player.
-- ----------------------------------------------------------------------------
function PLUGIN:OnPlayerDisconnected( player )
    -- Grab the player his/her Steam ID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Check if the player has any pending requests.
    if PendingRequests[playerID] then
        -- The player has a pending request, send a message to the player that
        -- send this request, kill the timer and remove the data.

        -- Grab the target player and his/her Steam ID.
        local originPlayer   = PlayersRequests[playerID]
        local originPlayerID = rust.UserIDFromPlayer( originPlayer )

        -- Send a message to the 
        self:SendMessage( originPlayer, self.Config.Messages.RequestTargetOff )

        -- Destroy the timer and remove the table entries.
        PendingRequests[playerID]:Destroy()
        PendingRequests[playerID] = nil
        PlayersRequests[playerID] = nil
        PlayersRequests[originPlayerID] = nil
    end

    -- Check if the player has a teleport in progress.
    if TeleportTimers[playerID] then
        -- The player is about to be teleported, cancel the teleport and remove
        -- the table entry.
        TeleportTimers[playerID].timer:Destroy()
        TeleportTimers[playerID] = nil
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:SaveLocation( player )
-- ----------------------------------------------------------------------------
-- Save the location of the player, this is used to save the location upon
-- teleporting an admin to be able to use the ingame command '/tpb'.
-- ----------------------------------------------------------------------------
function PLUGIN:SaveLocation( player )
    -- Get the player's UserID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Check if we already have an entry in the saved data for the player.
    TeleportData.AdminData[playerID] = TeleportData.AdminData[playerID] or {}

    -- If the player already has a previous location saved we will preserve
    -- that one, otherwise we will save his current location to file.
    if ( not TeleportData.AdminData[playerID].PreviousLocation ) then
        local location = player.transform.position
        local x = location.x
        local y = location.y
        local z = location.z

        -- Set the data and save it.
        TeleportData.AdminData[playerID].PreviousLocation = { x = x, y = y, z = z }
        self:SaveData()

        -- Send a message to the player.
       self:SendMessage( player, self.Config.Messages.AdminTPBackSave )
    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:RequestTimedOut( player, target )
-- ----------------------------------------------------------------------------
-- Sends a message to both players when the teleport request timed out.
-- ----------------------------------------------------------------------------
function PLUGIN:RequestTimedOut( player, target )
    -- Grab the UserIDs for both players.
    originUserID = rust.UserIDFromPlayer( player )
    targetUserID = rust.UserIDFromPlayer( target )

    -- Remove the table entries
    PlayersRequests[targetUserID] = nil
    PlayersRequests[originUserID] = nil
    PendingRequests[targetUserID] = nil

    -- Send a message to the players.
    self:SendMessage( player, self:Parse( self.Config.Messages.TimedOut, { player = target.displayName } ) )
    self:SendMessage( target, self:Parse( self.Config.Messages.TimedOutTarget, { player = player.displayName } ) )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:IsAllowed( player )
-- ----------------------------------------------------------------------------
-- Checks if the player is allowed to run an admin (or moderator) only command.
-- ----------------------------------------------------------------------------
function PLUGIN:IsAllowed( player )
    -- Grab the player his AuthLevel and set the required AuthLevel.
    local playerAuthLevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
    local requiredAuthLevel = 2
    
    -- Check if Moderators are also allowed to use the commands.
    if self.Config.AdminTP.UseableByModerators then
        -- Moderators are allowed to run the commands, reduce the required
        -- AuthLevel to 1.
        requiredAuthLevel = 1   
    end

    -- Compare the AuthLevel with the required AuthLevel, if it's higher or
    -- equal then the user is allowed to run the command.
    if playerAuthLevel >= requiredAuthLevel then
        return true
    end

    return false
end

-- ----------------------------------------------------------------------------
-- PLUGIN:ParseRemainingTime( time )
-- ----------------------------------------------------------------------------
-- Returns an amount of seconds as a nice time string.
-- ----------------------------------------------------------------------------
function PLUGIN:ParseRemainingTime( time )
    local minutes  = nil
    local seconds  = nil
    local timeLeft = nil

    -- If the amount of seconds is higher than 60 we'll have minutes too, so
    -- start with grabbing the amount of minutes and then take the remainder as
    -- the seconds that are left on the timer.
    if time >= 60 then
        minutes = math.floor( time / 60 )
        seconds = time - ( minutes * 60 )
    else
        seconds = time
    end

    -- Build a nice string with the remaining time.
    if minutes and seconds > 0 then
        timeLeft = minutes .. " min " .. seconds .. " sec "
    elseif minutes and seconds == 0 then
        timeLeft = minutes .. " min "
    else    
        timeLeft = seconds .. " sec "
    end

    -- Return the time string.
    return timeLeft        
end

-- ----------------------------------------------------------------------------
-- PLUGIN:TeleportToPlayer( player, targetPlayer )
-- ----------------------------------------------------------------------------
-- Teleports a player to the target player.
-- ----------------------------------------------------------------------------
function PLUGIN:TeleportToPlayer( player, targetPlayer )
    -- Set the destination for the player.
    local destination = targetPlayer.transform.position

    -- Teleport the player to the destination.
    self:Teleport( player, destination )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:TeleportToPosition( player, x, y, z )
-- ----------------------------------------------------------------------------
-- Teleports a player to a set of coordinates.
-- ----------------------------------------------------------------------------
function PLUGIN:TeleportToPosition( player, x, y, z )
    -- set the destination for the player.
    local destination = new( UnityEngine.Vector3._type, nil )
    destination.x = x 
    destination.y = y
    destination.z = z

    -- Teleport the player to the destination.
    self:Teleport( player, destination )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:Teleport( player, destination )
-- ----------------------------------------------------------------------------
-- Teleports a player to a specific location.
-- ----------------------------------------------------------------------------
function PLUGIN:Teleport( player, destination )
    -- Let the player sleep to prevent the player from falling through objects.
    player:StartSleeping()

    timer.Once(0.5, function()
        player.transform.position = destination
        player:ClientRPC(nil, player, "ForcePositionTo", destination)
    end )
end

-- ----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- ----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- ----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end
    if not message then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- ----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- ----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- ----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    for k, v in pairs( values ) do
        -- Replace the variable in the message with the specified value.
        tostring(v):gsub("(%%)", "%%%%") 
        message = message:gsub( "{" .. k .. "}", v)
    end

    return message
end

-- ----------------------------------------------------------------------------
-- PLUGIN:Count( tbl )
-- ----------------------------------------------------------------------------
-- Counts the elements of a table.
-- ----------------------------------------------------------------------------
function PLUGIN:Count( tbl ) 
    local count = 0

    if type( tbl ) == "table" then
        for _ in pairs( tbl ) do 
            count = count + 1 
        end
    end

    return count
end

-- ----------------------------------------------------------------------------
-- PLUGIN:FindPlayerByName( playerName )
-- ----------------------------------------------------------------------------
-- Searches the online players for a specific name.
-- ----------------------------------------------------------------------------
function PLUGIN:FindPlayerByName( playerName )
    -- Check if a player name was supplied.
    if not playerName then return end

    -- Set the player name to lowercase to be able to search case insensitive.
    playerName = string.lower( playerName )

    -- Setup some variables to save the matching BasePlayers with that partial
    -- name.
    local matches = {}
    local itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    
    -- Iterate through the online player list and check for a match.
    while itPlayerList:MoveNext() do
        -- Get the player his/her display name and set it to lowercase.
        local displayName = string.lower( itPlayerList.Current.displayName )
        
        -- Look for a match.
        if string.find( displayName, playerName, 1, true ) then
            -- Match found, add the player to the list.
            table.insert( matches, itPlayerList.Current )
        end

        if string.len( playerName ) == 17 then
            if string.find( rust.UserIDFromPlayer( itPlayerList.Current ), playerName ) then
                -- Match found, add the player to the list.
                table.insert( matches, itPlayerList.Current )
            end
        end
    end

    -- Return all the matching players.
    return matches
end

-- ----------------------------------------------------------------------------
-- PLUGIN:GetGround( position )
-- ----------------------------------------------------------------------------
-- Searches for a valid height for the given position.
-- ----------------------------------------------------------------------------
function PLUGIN:GetGround( position )
    -- Setup a raycast from high up to the ground.
    local arr  = util.TableToArray( { position, UnityEngine.Vector3.get_down() } )
    local hits = RaycastAll:Invoke( nil, arr )
    local nearestDistance = 9999
    local nearestPoint    = nil
    local hitsIterator = hits:GetEnumerator()

    -- Loop through all the hit objects.
    while hitsIterator:MoveNext() do
        if hitsIterator.Current.distance < nearestDistance then
            nearestDistance = hitsIterator.Current.distance
            nearestPoint = hitsIterator.Current.point
        end
    end

    -- Return the highest point.
    return nearestPoint
end

-- ----------------------------------------------------------------------------
-- PLUGIN:CheckPosition( position )
-- ----------------------------------------------------------------------------
-- Checks and corrects a player's position when teleporting with tpr/tpa so 
-- that the player can't glitch into a wall.
-- ----------------------------------------------------------------------------
function PLUGIN:CheckPosition( position, player )
    -- Setup an OverlapSphere to check for overlapping colliders within a 2m 
    -- radius of the player.
    local arr = util.TableToArray( { position, 2 } )
    util.ConvertAndSetOnArray( arr, 1, 2, System.Int32._type )
    local hits = OverlapSphere:Invoke( nil, arr )
    
    -- Setup some variables to use to iterate over the collider hits.
    local colliderIterator = hits:GetEnumerator()
    local colliderDistance = 5
    local colliderPosition = nil
    local buildingBlock    = nil

    -- Loop through all the colliders overlapping with the player.
    while ( colliderIterator:MoveNext() ) do
        -- Check if the collider is a building block, if this isn't the case 
        -- then we don't have to do anything.
        if colliderIterator.Current:GetComponentInParent( global.BuildingBlock._type ) then
            -- Temporarily  store the building block in a variable to work with
            -- it.
            local block = colliderIterator.Current:GetComponentInParent( global.BuildingBlock._type )

            -- The pushback shouldn't trigger on foundations and floors so we
            -- can exclude these.
            if not block.name:find( "foundation" ) and not block.name:find( "floor" ) and not block.name:find( "pillar" ) then
                -- Check if this is the nearest building block and save the
                -- values if this is the case.
                if UnityEngine.Vector3.Distance( block.transform.position, position ) < colliderDistance then
                    buildingBlock    = block
                    colliderDistance = UnityEngine.Vector3.Distance( block.transform.position, position ) 
                    colliderPosition = block.transform.position
                end
            end
        end
    end
    
    -- If a BuildingBlock was found within the specified radius we need to push
    -- the player back.
    if buildingBlock then
        -- Setup a few required variables to calculate the push-back location.
        local correctedLocations = {}
        local blockRotation      = nil
        local blockRotation      = buildingBlock.transform.rotation.eulerAngles.y
        local angles             = { 360 - blockRotation, 180 - blockRotation }
        local r                  = 1.9
        local location           = nil
        local locationDistance   = 100

        -- Calculate the two possible push-back locations.
        for _, angle in pairs( angles ) do
            local radians = math.rad( angle )
            local newX = r * math.cos( radians )
            local newZ = r * math.sin( radians )
            local newLoc = new( UnityEngine.Vector3._type, nil )

            newLoc.x = colliderPosition.x + newX
            newLoc.y = colliderPosition.y + 0.2
            newLoc.z = colliderPosition.z + newZ

            table.insert (correctedLocations, newLoc )
        end

        -- Check which position of the calculated positions should be used.
        for _, newPosition in pairs( correctedLocations ) do
            if UnityEngine.Vector3.Distance( position, newPosition ) < locationDistance then
                location         = newPosition
                locationDistance = UnityEngine.Vector3.Distance( position, newPosition )
            end
        end
        
        -- Return a new location a bit further away from the wall, at the 
        -- same height.
        if position.y - location.y > 2.5 then
            location.y = position.y
        end
        
        return location
    end

    return position
end

-- ----------------------------------------------------------------------------
-- PLUGIN:GetOwner( buildingBlock )
-- ----------------------------------------------------------------------------
-- Checks the owner of a specific building block in the Building Owners plugin
-- data.
-- ----------------------------------------------------------------------------
function PLUGIN:GetOwner( buildingBlock )
    -- Setup the array to use to invoke the FindBlockData method from the
    -- BuildingOwners plugin.
    local arr = util.TableToArray( { buildingBlock } )
    util.ConvertAndSetOnArray( arr, 0, buildingBlock, UnityEngine.Object._type )

    -- Get the owner id.
    local ownerID = plugins.CallHook( "FindBlockData", arr )

    -- Return the owner id.
    return ownerID
end

-- ----------------------------------------------------------------------------
-- PLUGIN:CanPlayerTeleport( player )
-- ----------------------------------------------------------------------------
-- Function that checks all other plugins if the player is allowed to teleport,
-- this is required for the Zones plugin by Reneb:
-- http://forum.rustoxide.com/plugins/r-zones.739/
-- ----------------------------------------------------------------------------
function PLUGIN:CanPlayerTeleport( player )
    local arr = util.TableToArray( { player } )
    util.ConvertAndSetOnArray( arr, 0, player, UnityEngine.Object._type )
    local _return = plugins.CallHook( "canTeleport", arr )

    if not _return then
        return true
    end

    return false, tostring( _return )
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\m-Time.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


-- -----------------------------------------------------------------------------------
-- Rust Day & Night System                                               Version 1.0.3
-- -----------------------------------------------------------------------------------
-- Filename:          m-Time.lua
-- Last Modification: 01-21-2015
-- -----------------------------------------------------------------------------------
-- Description:
--
-- This plugin is developed for Rust servers with the Oxide Server Mod and will offer
-- server admins the option to change the current in-game time, modify the length of
-- the days and even freeze the time.
-- -----------------------------------------------------------------------------------


PLUGIN.Title       = "Day & Night System"
PLUGIN.Description = "Change the current time, change the daylength or even freeze the time!"
PLUGIN.Version     = V( 1, 0, 3 )
PLUGIN.HasConfig   = true
PLUGIN.Author      = "Mughisi"
PLUGIN.ResourceId  = 671


-- -----------------------------------------------------------------------------------
-- Globals
-- -----------------------------------------------------------------------------------
-- Some globals that are used in multiple functions.
-- -----------------------------------------------------------------------------------
local Sky  = nil
local Time = nil

local TimeData = nil

local Sunrise        = 6
local Sunset         = 18
local TimeTickUpdate = false

local DayNightTimer  = nil
local DayNightUpdate = nil
local FrozenTimer    = nil
local UpdateInterval = nil

-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat commands are registered and data
-- from the DataTable file is loaded.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init()
    -- Add the admin chat commands.
    command.AddChatCommand("settime",        self.Plugin, "cmdSetTime")
    command.AddChatCommand("setdaylength",   self.Plugin, "cmdSetDayLength")
    command.AddChatCommand("setnightlength", self.Plugin, "cmdSetNightLength")
    command.AddChatCommand("freezetime",     self.Plugin, "cmdFreezeTime")
    command.AddChatCommand("unfreezetime",   self.Plugin, "cmdUnfreezeTime")

    -- Add the player commands.
    command.AddChatCommand("time",  self.Plugin, "cmdTime" )

    -- Add the admin console commands.
    command.AddConsoleCommand("env.freeze",      self.Plugin, "ccmdEnvTime")
    command.AddConsoleCommand("env.unfreeze",    self.Plugin, "ccmdEnvTime")
    command.AddConsoleCommand("env.daylength",   self.Plugin, "ccmdEnvTime")
    command.AddConsoleCommand("env.nightlength", self.Plugin, "ccmdEnvTime")

    -- Load the saved data.
    self:LoadSavedData()

    -- Check the config.
    self:CheckConfig()
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:Unload()
-- -----------------------------------------------------------------------------------
-- On plugin unloading all the running timers are destroyed to prevent problems.
-- -----------------------------------------------------------------------------------
function PLUGIN:Unload()
    -- Destroy the day/night modifier timer if it is running.
    if DayNightTimer then
        DayNightTimer:Destroy()
    end

    -- Destroy the freeze timer if it is running.
    if FrozenTimer then
        FrozenTimer:Destroy()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadSavedData()
-- -----------------------------------------------------------------------------------
-- Load the DataTable file into a table or create a new table when the file doesn't
-- exist yet.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadSavedData()
    -- Open the datafile if it exists, otherwise we'll create a new one.
    TimeData = datafile.GetDataTable("m-Time")
    TimeData = TimeData or { }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SaveData()
-- -----------------------------------------------------------------------------------
-- Saves the table with all the teleportdata to a DataTable file.
-- -----------------------------------------------------------------------------------
function PLUGIN:SaveData()
    -- Save the DataTable
    datafile.SaveDataTable("m-Time")
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:OnServerInitialized()
-- -----------------------------------------------------------------------------------
-- When the server has finished the startup process the plugin will grab the world's
-- TOD_Sky and TOD_Time components. At this point saved values will also be loaded.
-- -----------------------------------------------------------------------------------
function PLUGIN:OnServerInitialized()
    -- Get the Sky and Time components of the world.
    Sky = global.TOD_Sky.get_Instance()
    Time = Sky:GetComponent( "TOD_Components" ):GetComponent( "TOD_Time" )

    -- Disable the time curve to be able to handle time better. This is also more 
    -- realistic, a minute during the night should be as long as a minute during
    -- the day!
    Time.UseTimeCurve = false

    -- Set the DayLengthInMinutes if durations are specified for both day and night
    -- and when time is not frozen.
    if TimeData.DayDuration and TimeData.NightDuration and not TimeData.Frozen then
        -- Time is not frozen, check if the time matches day or night and set the
        -- DayLengthInMinutes accordingly.
        if Sky.Cycle.Hour >= Sunrise and Sky.Cycle.Hour <= Sunset then
            -- Day
            Time.DayLengthInMinutes = TimeData.DayDuration * 2
        else
            -- Night
            Time.DayLengthInMinutes = TimeData.NightDuration * 2
        end
    end

    -- Determine the updateInterval by looking at the DayLengthInMinutes field of
    -- TOD_Time.
    UpdateInterval = Time.DayLengthInMinutes * 60 / 24

    -- Check if the time should be frozen, if it should be then we need to set the
    -- current time to the frozen time and instantiate a timer to keep the time more
    -- or less the same over time. If the time isn't frozen check if the duration has
    -- been set for both day and night and instantiate a timer to check the time each
    -- in-game hour to be able to determine when to adjust the DayLengthInMinutes and
    -- to modify the delay of the timer for switches between day and night.
    if TimeData.Hour and TimeData.Frozen then
        -- Set the time after a few seconds, this won't work if we load it directly 
        -- because TOD_Sky data is still being loaded.
        timer.Once( 3, function() Sky.Cycle.Hour = TimeData.Hour end, self.Plugin )
        
        -- Modify DayLengthInMinutes and the update interval.
        Time.DayLengthInMinutes = 60
        UpdateInterval = Time.DayLengthInMinutes * 60 / 24 / 2

        -- Start the FrozenTimer.
        FrozenTimer = timer.Repeat( UpdateInterval, 0, function() Sky.Cycle.Hour = TimeData.Hour end )
    elseif TimeData.DayDuration and TimeData.NightDuration then
        -- Start the DayNightTimer.
        DayNightTimer = timer.Repeat( UpdateInterval, 0, function() self:TimeTick() end )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:TimeTick()
-- -----------------------------------------------------------------------------------
-- Timer callback to modify the server TOD_Time.DayLengthInMinutes value to allow the
-- server admin to individually modify the day and night lengths.
-- -----------------------------------------------------------------------------------
function PLUGIN:TimeTick()
    -- Round the hour so that we have an exact value to work with.
    Sky.Cycle.Hour = math.floor( Sky.Cycle.Hour + 0.5 )

    -- Check if the current time is day or night. Need to subtract 1 of both sunrise
    -- and sunset because we need to modify the delay of the timer 1 in-game hour
    -- before we change the length of the day or night.
    if Sky.Cycle.Hour >= ( Sunrise - 1 ) and Sky.Cycle.Hour < ( Sunset - 1 ) then
        -- Current time is day, check if all values are set or modify them where
        -- needed.

        -- Check if the DayLengthInMinutes needs to be updated to increase the
        -- length of the day.
        if DayNightUpdate then
            Time.DayLengthInMinutes = TimeData.DayDuration * 2
            DayNightUpdate = false
        end

        -- Check if the interval of the timer needs to be modified to change
        -- the time between timer ticks during the day.
        if Time.DayLengthInMinutes ~= TimeData.DayDuration * 2 then
            DayNightUpdate = true
            UpdateInterval = TimeData.DayDuration * 2 * 60 / 24
            DayNightTimer.Delay = UpdateInterval
        end
    else
        -- Current time is night, check if all values are set or modify them where
        -- needed.

        -- Check if the DayLengthInMinutes needs to be updated to increase the
        -- length of the night.
        if DayNightUpdate then
            Time.DayLengthInMinutes = TimeData.NightDuration * 2
            DayNightUpdate = false
        end
        
        -- Check if the interval of the timer needs to be modified to change
        -- the time between timer ticks during the night.
        if Time.DayLengthInMinutes ~= TimeData.NightDuration * 2 then
            DayNightUpdate = true
            UpdateInterval = TimeData.NightDuration * 2 * 60 / 24
            DayNightTimer.Delay = UpdateInterval
        end
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the admins. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
    -- General Settings:
    self.Config.Settings = {
        ChatName           = "Time",
        Version            = "1.0"
    }

    -- Plugin Messages:
    self.Config.Messages = {
        -- Messages involving /settime and env.time
        SetTimeSuccess        = "Changing the time to {hour}, please wait a moment.",
        SyntaxCommandSetTime  = {
            "A Syntax Error Occurred!",
            "You can only use the /settime command as follows:",
            "/settime <hour> - Sets the in-game time to the specified hour, 0 to 24."
        },
        SyntaxCCommandSetTime = {
            "A Syntax Error Occurred!",
            "You can only use the env.time command as follows:",
            "env.time <hour> - Sets the in-game time to the specified hour, 0 to 24."
        },

        -- Messages involving /freezetime and env.freeze
        FreezeTimeSuccess       = "You have stopped the time from progressing.",
        FreezeTimeAlreadyFrozen = "Time is already frozen!",

        -- Messages involving /unfreezetime and env.unfreeze
        UnfreezeTimeSuccess        = "You have started time progression.",
        UnfreezeTimeAlreadyRunning = "Time is not frozen!",

        -- Messages involving /setdayduration and env.daylength
        SetDayLengthSuccess        = "You have modified the length of an in-game day to {minutes} minutes.",
        SyntaxCommandSetDayLength  = {
            "A Syntax Error Occurred!",
            "You can only use the /setdaylength command as follows:",
            "/setdaylength <length> - Changes the duration of an in-game day to length.",
            "Length is in minutes and needs to be a value between 5 and 720!"
        },
        SyntaxCCommandSetDayLength = {
            "A Syntax Error Occurred!",
            "You can only use the env.daylength command as follows:",
            "env.daylength <length> - Changes the duration of an in-game day to length.",
            "Length is in minutes and needs to be a value between 5 and 720!"
        },

        -- Messages involving /setnightduration and env.nightlength
        SetNightLengthSuccess        = "You have modified the length of an in-game night to {minutes} minutes.",
        SyntaxCommandSetNightLength  = {
            "A Syntax Error Occurred!",
            "You can only use the /setnightlength command as follows:",
            "/setdaylength <length> - Changes the duration of an in-game day to length.",
            "Length is in minutes and needs to be a value between 5 and 720!"
        },
        SyntaxCCommandSetNightLength = {
            "A Syntax Error Occurred!",
            "You can only use the env.nightlength command as follows:",
            "env.nightlength <length> - Changes the duration of an in-game day to length.",
            "Length is in minutes and needs to be a value between 5 and 720!"
        },

        -- Messages involving /time
        Time = "It's currently {time}",
        TimeFrozen = "Time is currently frozen."
    }
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:CheckConfig()
-- -----------------------------------------------------------------------------------
-- This function checks if the configuration file is up to date and starts an update
-- if this is not the case.
-- -----------------------------------------------------------------------------------
function PLUGIN:CheckConfig() 
    -- Check if the current plugin version is the latest.
    if self.Config.Settings.Version ~= "1.0" then
        -- Different configuration version, update it now.
        self:UpdateConfig()
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- This function updates the configuration file.
-- -----------------------------------------------------------------------------------
function PLUGIN:UpdateConfig()
    self:LoadDefaultConfig()
    self:SaveConfig()
    print( "m-Time.lua : Default Config Loaded" )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdSetTime( player, cmd, args )                                Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/settime' command for server admins to be able to modify the current time.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdSetTime( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if player.net.connection.authLevel == 0 then 
        return 
    end

    -- Check if the player specified an argument.
    if args.Length == 1 then
        -- The player specified an argument, checking if this is a number.
        local newHour = tonumber( args[0] )

        -- Checking if the new hour is valid.
        if newHour >= 0 and newHour <= 24 then
            -- The new hour is valid, modify the time and inform the player.
            self:ModifyTime( math.floor( newHour ) )
            self:SendMessage( player, self:Parse( self.Config.Messages.SetTimeSuccess, { hour = math.floor( newHour ) } ) )

            return
        end
    end

    -- Something went wrong, show a syntax error to the player.
    self:SendMessage( player, self.Config.Messages.SyntaxCommandSetTime )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdFreezeTime( player, cmd, args )                             Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/freezetime' command for server admins to be able to stop the time from
-- progressing.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdFreezeTime( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if player.net.connection.authLevel == 0 then 
        return 
    end

    -- Check if the time is already frozen or not.
    if TimeData.Frozen then
        -- Time is already frozen, send the player a message.
        self:SendMessage( player, self.Config.Messages.FreezeTimeAlreadyFrozen )
    else
        -- Time isn't frozen, freeze it and send the player a message.
        self:ModifyProgression( true )
        self:SendMessage( player, self.Config.Messages.FreezeTimeSuccess )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdUnfreezeTime( player, cmd, args )                           Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/unfreezetime' command for server admins to be able to start the time 
-- progression again after freezing it.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdUnfreezeTime( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if player.net.connection.authLevel == 0 then 
        return 
    end

    -- Check if the time is frozen or not.
    if TimeData.Frozen then
        -- Time is already frozen, unfreeze it and send the player a message.
        self:ModifyProgression( false )
        self:SendMessage( player, self.Config.Messages.UnfreezeTimeSuccess )
    else
        -- Time isn't frozen, send the player a message.
        self:SendMessage( player, self.Config.Messages.UnfreezeTimeAlreadyRunning )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdSetDayLength( player, cmd, args )                           Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/setdaylength' command for server admins to be able to change the length
-- of the day.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdSetDayLength( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if player.net.connection.authLevel == 0 then 
        return 
    end

    -- Check if the player specified an argument.
    if args.Length == 1 then
        -- The player specified an argument, checking if this is a number.
        local newLength = tonumber( args[0] )

        -- Checking if the new length is valid.
        if newLength >= 5 and newLength <= 720 then
            -- The new hour is valid, modify the time and inform the player.
            self:ModifyDayLength( newLength)
            self:SendMessage( player, self:Parse( self.Config.Messages.SetDayLengthSuccess, { minutes = newLength } ) )

            return
        end
    end

    -- Something went wrong, show a syntax error to the player.
    self:SendMessage( player, self.Config.Messages.SyntaxCommandSetDayLength )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdSetNightLength( player, cmd, args )                         Admin Command
-- -----------------------------------------------------------------------------------
-- In-game '/setnightlength' command for server admins to be able to change the length
-- of the night.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdSetNightLength( player, cmd, args )
    -- Check if the player is allowed to run the command.
    if player.net.connection.authLevel == 0 then 
        return 
    end

    -- Check if the player specified an argument.
    if args.Length == 1 then
        -- The player specified an argument, checking if this is a number.
        local newLength = tonumber( args[0] )

        -- Checking if the new length is valid.
        if newLength >= 5 and newLength <= 720 then
            -- The new hour is valid, modify the time and inform the player.
            self:ModifyNightLength( newLength)
            self:SendMessage( player, self:Parse( self.Config.Messages.SetNightLengthSuccess, { minutes = newLength } ) )

            return
        end
    end

    -- Something went wrong, show a syntax error to the player.
    self:SendMessage( player, self.Config.Messages.SyntaxCommandSetNightLength )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdTime( player, cmd, args )
-- -----------------------------------------------------------------------------------
-- In-game '/time' command for players to check the current in-game time.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdTime( player, cmd, args )
    -- Setup a variable to store the time value in.
    local time = nil

    -- Get the hour, minutes and seconds. Depending on if the time is frozen or not we
    -- return the actual value or just the hour with a message that time is frozen or
    -- not.
    if TimeData.Frozen then
        time = TimeData.Hour .. ":00:00, " .. self.Config.Messages.TimeFrozen
    else
        time = Sky.Cycle.DateTime:ToString("HH:mm:ss")
    end

    -- Send the player a message.
    self:SendMessage( player, self:Parse( self.Config.Messages.Time, { time = time } ) )
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ccmdEnvTime( arg )                                     Admin Console Command
-- -----------------------------------------------------------------------------------
-- Various time related console commands for server admins.
-- env.time <hour>  - Set the current in-game time.
-- env.freezetime   - Disable time progression and freezes the current time.
-- env.unfreezetime - Enables time progression.
-- env.daylength    - Changes the length of in-game days.
-- env.nightlength  - Changes the length of in-game nights.
-- -----------------------------------------------------------------------------------
function PLUGIN:ccmdEnvTime( arg )
    -- Setup a few variables.
    local player = nil
    local command = arg.cmd.namefull

    -- Check if the command is used in the in-game console or an external console.
    if arg.connection then
        player = arg.connection.player
    end

    -- Check if the player is allowed to run the command.
    if player then
        if player.net.connection.authLevel == 0 then
            return
        end
    end
   
    -- Check which console command the user is trying to run.
    if command == "env.time" then
        -- Check if the user specified an argument.
        if arg.Args and arg.Args.Length == 1 then
            -- The player specified an argument, checking if this is a number.
            local newHour = tonumber( arg.Args[0] )

            -- Checking if the new hour is valid.
            if newHour >= 0 and newHour <= 24 then
                -- The new hour is valid, modify the time and inform the player.
                self:ModifyTime( math.floor( newHour ) )
                arg:ReplyWith( self:Parse( self.Config.Messages.SetTimeSuccess, { hour = math.floor( newHour ) } ) )

                return
            end
        end
        
        -- Something went wrong, show a syntax error to the player.
        arg:ReplyWith( table.concat( self.Config.Messages.SyntaxCommandSetTime, "\r\n" ) )

        return

    elseif command == "env.freeze" then
        if TimeData.Frozen then
            -- Time is already frozen, send the player a message.
            arg:ReplyWith( self.Config.Messages.FreezeTimeAlreadyFrozen )
            
            return
        else
            -- Time isn't frozen, freeze it and send the player a message.
            self:ModifyProgression( true )
            arg:ReplyWith( self.Config.Messages.FreezeTimeSuccess )

            return
        end

    elseif command == "env.unfreeze" then
        if TimeData.Frozen then
            -- Time is already frozen, unfreeze it and send the player a message.
            self:ModifyProgression( false )
            arg:ReplyWith( self.Config.Messages.UnfreezeTimeSuccess )

            return
        else
            -- Time isn't frozen, send the player a message.
            arg:ReplyWith( self.Config.Messages.UnfreezeTimeAlreadyRunning )

            return
        end
    
    elseif command == "env.daylength" then
        -- Check if the user specified an argument.
        if arg.Args and arg.Args.Length == 1 then
            -- The player specified an argument, checking if this is a number.
            local newLength = tonumber( arg.Args[0] )

            -- Checking if the new length is valid.
            if newLength >= 5 and newLength <= 720 then
                -- The new length is valid, modify the time and inform the player.
                self:ModifyDayLength( newLength )
                arg:ReplyWith( self:Parse( self.Config.Messages.SetDayLengthSuccess, { minutes = math.floor( newLength ) } ) )

                return
            end
        end
        
        -- Something went wrong, show a syntax error to the player.
        arg:ReplyWith( table.concat( self.Config.Messages.SyntaxCCommandSetDayLength, "\r\n" ) )

        return

    elseif command == "env.nightlength" then
        -- Check if the user specified an argument.
        if arg.Args and arg.Args.Length == 1 then
            -- The player specified an argument, checking if this is a number.
            local newLength = tonumber( arg.Args[0] )

            -- Checking if the new length is valid.
            if newLength >= 5 and newLength <= 720 then
                -- The new length is valid, modify the time and inform the player.
                self:ModifyNightLength( newLength )
                arg:ReplyWith( self:Parse( self.Config.Messages.SetNightLengthSuccess, { minutes = math.floor( newLength ) } ) )

                return
            end
        end
        
        -- Something went wrong, show a syntax error to the player.
        arg:ReplyWith( table.concat( self.Config.Messages.SyntaxCCommandSetNightLength, "\r\n" ) )

        return
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ModifyTime( hour )
-- -----------------------------------------------------------------------------------
-- Helper function to modify the current time to the specified hour and modifying the
-- DayNightTimer when required.
-- -----------------------------------------------------------------------------------
function PLUGIN:ModifyTime( hour )
    -- Set the new time value.
    Sky.Cycle.Hour = hour   

    -- Save the value to the datafile.
    TimeData.Hour = hour
    self:SaveData()

    -- Check if a DayNightTimer is running, if this would be running the timer needs
    -- to be reset so that the change of time does not mess up the day and night
    -- cycle.
    if DayNightTimer and not TimeData.Frozen then
        -- Destroy the current timer.
        DayNightTimer:Destroy()

        -- Update the DayLengthInMinutes depending on if it's day or night.
        if Sky.Cycle.Hour >= Sunrise and Sky.Cycle.Hour <= Sunset then
            -- Day
            Time.DayLengthInMinutes = TimeData.DayDuration * 2
        else
            -- Night
            Time.DayLengthInMinutes = TimeData.NightDuration * 2
        end

        -- Change the update interval of the timer.
        UpdateInterval = Time.DayLengthInMinutes * 60 / 24

        -- Start a new timer.
        DayNightTimer = timer.Repeat( UpdateInterval, 0, function() self:TimeTick() end )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ModifyProgression( IsFrozen )
-- -----------------------------------------------------------------------------------
-- Helper function to enable or disable the time progression.
-- -----------------------------------------------------------------------------------
function PLUGIN:ModifyProgression( IsFrozen )
    -- Save the value to the datafile.
    TimeData.Frozen = IsFrozen
    self:SaveData()

    -- Check if the time progression should be enabled or disabled.
    if IsFrozen then
        -- Modify DayLengthInMinutes and the update interval.
        Time.DayLengthInMinutes = 60
        UpdateInterval = Time.DayLengthInMinutes * 60 / 24 / 2

        -- Time is frozen, so to disable the time progression we will run a timer
        -- repeatedly to set the time back to the requested time.
        FrozenTimer = timer.Repeat( UpdateInterval, 0, function() Sky.Cycle.Hour = TimeData.Hour end )

        -- Check if we have a DayNightTimer running, if we have this running then it
        -- is safe to destroy this as this is not required when the time is frozen.
        if DayNightTimer then
            DayNightTimer:Destroy()
        end
    else
        -- Time is no longer frozen, so to enable the time progression again we will 
        -- destroy the timer.
        FrozenTimer:Destroy()

        -- Check if a DayNightTimer needs to run, if both the length  of days and
        -- nights are saved we will create a new DayNightTimer to use these values.
        if TimeData.DayDuration and TimeData.NightDuration then
            -- Round the hour so that we have an exact value to work with.
            Sky.Cycle.Hour = math.floor( Sky.Cycle.Hour + 0.5 )

            -- Update the DayLengthInMinutes depending on if it's day or night.
            if Sky.Cycle.Hour >= Sunrise and Sky.Cycle.Hour <= Sunset then
                -- Day
                Time.DayLengthInMinutes = TimeData.DayDuration * 2
            else
                -- Night
                Time.DayLengthInMinutes = TimeData.NightDuration * 2
            end

            -- Change the update interval of the timer.
            UpdateInterval = Time.DayLengthInMinutes * 60 / 24

            -- Start a new timer.
            DayNightTimer = timer.Repeat( UpdateInterval, 0, function() self:TimeTick() end )
        end
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ModifyDayLength( length )
-- -----------------------------------------------------------------------------------
-- Helper function to modify the length of an in-game day in minutes and to create
-- a new DayNightTimer.
-- -----------------------------------------------------------------------------------
function PLUGIN:ModifyDayLength( length )
    -- Save the value to the datafile.
    TimeData.DayDuration = length
    self:SaveData()
    
    -- Check if a DayNightTimer needs to run, if both the length of days and nights 
    -- are saved we will create a new DayNightTimer to use these values.
    if TimeData.DayDuration and TimeData.NightDuration and not FrozenTimer then
        -- Check if there is already a timer running, if this is the case then
        -- destroy it and start a new one.
        if DayNightTimer then
            DayNightTimer:Destroy()
        end
        
        -- Round the hour so that we have an exact value to work with.
        Sky.Cycle.Hour = math.floor( Sky.Cycle.Hour + 0.5 )

        -- Update the DayLengthInMinutes depending on if it's day or night.
        if Sky.Cycle.Hour >= Sunrise and Sky.Cycle.Hour <= Sunset then
            -- Day
            Time.DayLengthInMinutes = TimeData.DayDuration * 2
        else
            -- Night
            Time.DayLengthInMinutes = TimeData.NightDuration * 2
        end

        -- Change the update interval of the timer.
        UpdateInterval = Time.DayLengthInMinutes * 60 / 24

        -- Start a new timer.
        DayNightTimer = timer.Repeat( UpdateInterval, 0, function() self:TimeTick() end )
    end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:ModifyNightLength( length )
-- -----------------------------------------------------------------------------------
-- Helper function to modify the length of an in-game night in minutes and to create 
-- a new DayNightTimer.
-- -----------------------------------------------------------------------------------
function PLUGIN:ModifyNightLength( length )
    -- Save the value to the datafile.
    TimeData.NightDuration = length
    self:SaveData()
    
    -- Check if a DayNightTimer needs to run, if both the length of days and nights 
    -- are saved we will create a new DayNightTimer to use these values.
    if TimeData.DayDuration and TimeData.NightDuration and not FrozenTimer then
        -- Check if there is already a timer running, if this is the case then
        -- destroy it and start a new one.
        if DayNightTimer then
            DayNightTimer:Destroy()
        end
        
        -- Round the hour so that we have an exact value to work with.
        Sky.Cycle.Hour = math.floor( Sky.Cycle.Hour + 0.5 )

        -- Update the DayLengthInMinutes depending on if it's day or night.
        if Sky.Cycle.Hour >= Sunrise and Sky.Cycle.Hour <= Sunset then
            -- Day
            Time.DayLengthInMinutes = TimeData.DayDuration * 2
        else
            -- Night
            Time.DayLengthInMinutes = TimeData.NightDuration * 2
        end

        -- Change the update interval of the timer.
        UpdateInterval = Time.DayLengthInMinutes * 60 / 24

        -- Start a new timer.
        DayNightTimer = timer.Repeat( UpdateInterval, 0, function() self:TimeTick() end )
    end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:SendMessage( target, message )
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player.
-- -----------------------------------------------------------------------------
function PLUGIN:SendMessage( target, message )
    -- Check if we have an existing target to send the message to.
    if not target then return end
    if not target:IsConnected() then return end

    -- Check if the message is a table with multiple messages.
    if type( message ) == "table" then
        -- The message is a table with multiple messages, send them one by one.
        for _, message in pairs( message ) do
            self:SendMessage( target, message )
        end

        return
    end

    -- "Build" the message to be able to show it correctly.
    message = UnityEngine.StringExtensions.QuoteSafe( message )

    -- Send the message to the targetted player.
    target:SendConsoleCommand( "chat.add \"" .. self.Config.Settings.ChatName .. "\""  .. message );
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Parse( message, values )
-- -----------------------------------------------------------------------------
-- Replaces the parameters in a message with the corresponding values.
-- -----------------------------------------------------------------------------
function PLUGIN:Parse( message, values )
    for k, v in pairs( values ) do
        -- Replace the variable in the message with the specified value.
        tostring(v):gsub("(%%)", "%%%%") 
        message = message:gsub( "{" .. k .. "}", v)
    end

    return message
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\metabolismcontrol.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Metabolism Control"
PLUGIN.Description = "Allows control of player metabolism stats and rates."
PLUGIN.Author = "Wulfspider"
PLUGIN.Version = V(1, 1, 1)
PLUGIN.ResourceId = 680
PLUGIN.HasConfig = true

local lastCalories = 1000
local lastHydration = 1000
local lastHealth = 1

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    -- Health
    self.Config.Settings.Health = self.Config.Settings.Health or {}
    self.Config.Settings.Health.MaxValue = tonumber(self.Config.Settings.Health.MaxValue) or tonumber(self.Config.Settings.Health.maxValue) or 100
    self.Config.Settings.Health.SpawnValue = self.Config.Settings.Health.SpawnValue or self.Config.Settings.Health.spawnValue or "default"
    self.Config.Settings.Health.GainRate = self.Config.Settings.Health.GainRate or self.Config.Settings.Health.gainRate or "default"
    -- Calories
    self.Config.Settings.Calories = self.Config.Settings.Calories or {}
    self.Config.Settings.Calories.MaxValue = tonumber(self.Config.Settings.Calories.MaxValue) or tonumber(self.Config.Settings.Calories.maxValue) or 1000
    self.Config.Settings.Calories.SpawnValue = self.Config.Settings.Calories.SpawnValue or self.Config.Settings.Calories.spawnValue or "default"
    self.Config.Settings.Calories.LossRate = self.Config.Settings.Calories.LossRate or self.Config.Settings.Calories.loseRate or "default"
    -- Hydration
    self.Config.Settings.Hydration = self.Config.Settings.Hydration or {}
    self.Config.Settings.Hydration.MaxValue = tonumber(self.Config.Settings.Hydration.MaxValue) or tonumber(self.Config.Settings.Hydration.maxValue) or 1000
    self.Config.Settings.Hydration.SpawnValue = self.Config.Settings.Hydration.SpawnValue or self.Config.Settings.Hydration.spawnValue or "default"
    self.Config.Settings.Hydration.LossRate = self.Config.Settings.Hydration.LossRate or self.Config.Settings.Hydration.loseRate or "default"
    -- Remove old
    self.Config.Settings.Health.maxValue = nil -- Removed in 0.1.1
    self.Config.Settings.Health.spawnValue = nil -- Removed in 0.1.1
    self.Config.Settings.Health.gainRate = nil -- Removed in 0.1.1
    self.Config.Settings.Calories.maxValue = nil -- Removed in 0.1.1
    self.Config.Settings.Calories.spawnValue = nil -- Removed in 0.1.1
    self.Config.Settings.Calories.loseRate = nil -- Removed in 0.1.1
    self.Config.Settings.Hydration.maxValue = nil -- Removed in 0.1.1
    self.Config.Settings.Hydration.spawnValue = nil -- Removed in 0.1.1
    self.Config.Settings.Hydration.loseRate = nil -- Removed in 0.1.1
    self:SaveConfig()
end

function PLUGIN:OnPlayerInit(player)
    self:SetMetabolismValues(player)
end

function PLUGIN:OnPlayerSpawn(player)
    self:SetMetabolismValues(player)
end

-- ----------------------------
-- Rust default rates
-- ----------------------------
-- healthgain = 0.03
-- caloriesloss = 0 - 0.05
-- hydrationloss = 0 - 0.025
-- ----------------------------
function PLUGIN:OnRunPlayerMetabolism(metabolism)
    local caloriesLossRate = self.Config.Settings.Calories.LossRate
    local hydrationLossRate = self.Config.Settings.Hydration.LossRate
    local healthGainRate = self.Config.Settings.Health.GainRate
    local heartRate = metabolism.heartrate.value
    if caloriesLossRate ~= "default" then
        if calorieLossRate == 0 or calorieLossRate == "0" then
            metabolism.calories.value = metabolism.calories.value
        else
            metabolism.calories.value = metabolism.calories.value - (tonumber(caloriesLossRate) + (heartRate / 10))
        end
    end
    if hydrationLossRate ~= "default" then
        if hydrationLossRate == 0 or hydrationLossRate == "0" then
            metabolism.hydration.value = metabolism.hydration.value
        else
            metabolism.hydration.value = metabolism.hydration.value - (tonumber(hydrationLossRate) + (heartRate / 10))
        end
    end
    if healthGainRate ~= "default" then
        if healthGainRate == 0 or healthGainRate == "0" then
            metabolism.health = metabolism.health
        else
            metabolism.health = metabolism.health + tonumber(healthGainRate) - 0.03
        end
    end
end

function PLUGIN:SetMetabolismValues(player)
    local maxHydration = tonumber(self.Config.Settings.Hydration.MaxValue)
    local maxCalories = tonumber(self.Config.Settings.Calories.MaxValue)
    local maxHealth = tonumber(self.Config.Settings.Health.MaxValue)
    local hydrationValue, caloriesValue, healthValue = false, false, false
    if self.Config.Settings.Hydration.SpawnValue ~= "default" then
        hydrationValue = tonumber(self.Config.Settings.Hydration.SpawnValue)
    end
    if self.Config.Settings.Calories.SpawnValue ~= "default" then
        caloriesValue = tonumber(self.Config.Settings.Calories.SpawnValue)
    end
    if self.Config.Settings.Health.SpawnValue ~= "default" then
        healthValue = tonumber(self.Config.Settings.Health.SpawnValue)
    end
    player.metabolism.calories.max = maxCalories
    player.health = maxHealth
    player.metabolism.hydration.max = maxHydration
    if healthValue then
        player.health = healthValue
    else
        player.health = maxHealth
    end
    if caloriesValue then
        player.metabolism.calories.value = caloriesValue
    end
    if hydrationValue then
        player.metabolism.hydration.value = hydrationValue
    end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\money-for-gather.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "MoneyForGather"
PLUGIN.Version = V(1, 2, 1)
PLUGIN.Description = "Gain money through the Economics API for gathering"
PLUGIN.Author = "Mr. Bubbles AKA BlazR"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/money-for-gather.770/"
PLUGIN.ResourceId = 770
PLUGIN.HasConfig = true

local API = nil
local notified = "false"

-- Quotesafe function to help prevent unexpected output
local function QuoteSafe(string)
	return UnityEngine.StringExtensions.QuoteSafe(string)
end

function PLUGIN:Init()
	-- Load the default config and set the commands
	self:LoadDefaultConfig()
	command.AddChatCommand("setforwood", self.Plugin, "cmdSetAmount")
	command.AddChatCommand("setforores", self.Plugin, "cmdSetAmount")
	command.AddChatCommand("setforcorpses", self.Plugin, "cmdSetAmount")
	command.AddChatCommand("setforanimal", self.Plugin, "cmdSetAmount")
	-- command.AddChatCommand("gather", self.Plugin, "cmdGather")
	command.AddChatCommand("m4gtoggle", self.Plugin, "cmdToggle")
	command.AddChatCommand("m4gtogglechat", self.Plugin, "cmdToggleChat")
	command.AddChatCommand("m4gtogglewood", self.Plugin, "cmdToggleWood")
	command.AddChatCommand("m4gtoggleores", self.Plugin, "cmdToggleOres")
	command.AddChatCommand("m4gtogglecorpses", self.Plugin, "cmdToggleCorpses")
	command.AddChatCommand("m4gtoggleanimals", self.Plugin, "cmdToggleAnimals")
	command.AddChatCommand("m4ghelp", self.Plugin, "cmdHelp")
	command.AddConsoleCommand("m4g.setforwood", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.setforores", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.setforcorpses", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.setforanimal", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.toggle", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.togglechat", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.togglewood", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.toggleores", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.togglecorpses", self.Plugin, "ccmdM4G")
	command.AddConsoleCommand("m4g.toggleanimals", self.Plugin, "ccmdM4G")
end

function PLUGIN:OnServerIntialized()
	pluginsList = plugins.GetAll()
	for i = 0, tonumber(pluginsList.Length) - 1 do
		if pluginsList[i].Object.Title:match("Economics") then  
			API = GetEconomyAPI()
		end
	end
	if API == nil then
		print("Economics plugin not found. MoneyForGather plugin will not function!")
	end
end

function PLUGIN:LoadDefaultConfig()
	-- Set/load the default config options
	self.Config.Settings = self.Config.Settings or {
		ChatName = "[MoneyForGather]",
		PluginEnabled = "true",
		WoodAmount = "100",
		OreAmount = "100",
		CorpseAmount = "100",
		GatherMessagesEnabled = "true",
		-- GatherEnabled = "true",
		MoneyForWoodEnabled = "true",
		MoneyForOresEnabled = "true",
		MoneyForCorpsesEnabled = "false",
		MoneyForAnimalKillsEnabled = "true",
		BearKillAmount = "200",
		WolfKillAmount = "100",
		StagKillAmount = "75",
		BoarKillAmount = "50",
		ChickenKillAmount = "25",
		AuthLevel = "1"
	}
	-- Various messages used by the plugin
	self.Config.Messages = self.Config.Messages or {
		AmountChanged = "The %s amount has been changed to %s",
		NoPermission = "You do not have permission for that command.",
		PluginStatusChanged = "MoneyForGather has been %s.",
		ReceivedMoney = "You have received %s for gathering %s.",
		GatherMessagesChanged = "MoneyForGather gather messages in chat have been %s.",
		MoneyOnGatherStateChanged = "Money for gathering %s has been %s.",
		OnAnimalKill = "You have received %s for killing a %s.",
		HelpText = "Use /m4ghelp to get a list of MoneyForGather commands.",
		HelpText1 = "/setforwood <amount> - Sets the amount of money given for gathering wood",
		HelpText2 = "/setforores <amount> - Sets the amount of money given for gathering ores",
		HelpText3 = "/setforcorpses <amount> - Sets the amount of money given for gathering from corpses",
		HelpText4 = "/setforanimal <animal> <amount> - Sets the amount of money given for killing a particular animal",
		HelpText5 = "/m4gtoggle - Toggles the MoneyForGather plugin on/off",
		HelpText6 = "/m4gtogglechat - Toggles the MoneyForGather gather messages in chat on/off",
		HelpText7 = "/m4gtogglewood - Toggles getting money for gathering wood on/off",
		HelpText8 = "/m4gtoggleores - Toggles getting money for gathering ores on/off",
		HelpText9 = "/m4gtogglecorpses - Toggles getting money for gathering corpses on/off",
		HelpText10 = "/m4gtoggleanimals - Toggles getting money for killing animlas",
		InvalidAnimal = "You have specified an invalid animal type. Valid types are bear, wolf, stag, boar, and chicken."
		-- GatherEnabled = "Gathering has been enabled.",
		-- GatherDisabled = "Gathering has been disabled."
	}
	self:SaveConfig()
end

function PLUGIN:OnGather(dispenser, player, item)
	if API ~= nil and self.Config.Settings.PluginEnabled == "true" then
		player = player:ToPlayer()
		if player then
			userdata = API:GetUserDataFromPlayer(player)
			if dispenser:GetComponentInParent(global.TreeEntity._type) and self.Config.Settings.MoneyForWoodEnabled == "true" then
				userdata:Deposit(tonumber(self.Config.Settings.WoodAmount))
				if self.Config.Settings.GatherMessagesEnabled == "true" then
					self:SendMessage(player, self.Config.Messages.ReceivedMoney:format(self.Config.Settings.WoodAmount, item.info.displayname))
				end
			elseif item.info.displayname == "Metal Ore" or item.info.displayname == "Sulfur Ore" then
				if self.Config.Settings.MoneyForOresEnabled == "true" then
					userdata:Deposit(tonumber(self.Config.Settings.OreAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.ReceivedMoney:format(self.Config.Settings.OreAmount, item.info.displayname))
					end
				end
			elseif dispenser:ToString():match("corpse") and self.Config.Settings.MoneyForCorpsesEnabled == "true" then
				userdata:Deposit(tonumber(self.Config.Settings.CorpseAmount))
				if self.Config.Settings.GatherMessagesEnabled == "true" then
					self:SendMessage(player, self.Config.Messages.ReceivedMoney:format(self.Config.Settings.CorpseAmount, "from a corpse"))
				end
			end
		end
	elseif API == nil and notified == "false" and self.Config.Settings.PluginEnabled == "true" then
		pluginsList = plugins.GetAll()
		for i = 0, tonumber(pluginsList.Length) - 1 do
			if pluginsList[i].Object.Title:match("Economics") then  
				API = GetEconomyAPI()
			end
		end
		if API == nil then
			print("Economics plugin not found. MoneyForGather plugin will not function!")
			notified = "true"
		end
	end
end

function PLUGIN:OnEntityDeath(entity, hitinfo)	
	if API ~= nil and self.Config.Settings.MoneyForAnimalKillsEnabled == "true" and self.Config.Settings.PluginEnabled == "true" then
		if(entity:GetComponent("BaseNPC")) then
			if(hitinfo.Initiator:ToPlayer()) then
				player = hitinfo.Initiator:ToPlayer()
				userdata = API:GetUserDataFromPlayer(player)
				animal = entity.corpseEntity
				print("Animal: " .. animal)
				if animal:lower():match("bear") then
					userdata:Deposit(tonumber(self.Config.Settings.BearKillAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.OnAnimalKill:format(self.Config.Settings.BearKillAmount, "bear"))
					end
				elseif animal:lower():match("wolf") then
					userdata:Deposit(tonumber(self.Config.Settings.WolfKillAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.OnAnimalKill:format(self.Config.Settings.WolfKillAmount, "wolf"))
					end
				elseif animal:lower():match("stag") then
					userdata:Deposit(tonumber(self.Config.Settings.StagKillAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.OnAnimalKill:format(self.Config.Settings.StagKillAmount, "stag"))
					end
				elseif animal:lower():match("boar") then
					userdata:Deposit(tonumber(self.Config.Settings.BoarKillAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.OnAnimalKill:format(self.Config.Settings.BoarKillAmount, "boar"))
					end
				elseif animal:lower():match("chicken") then
					userdata:Deposit(tonumber(self.Config.Settings.ChickenKillAmount))
					if self.Config.Settings.GatherMessagesEnabled == "true" then
						self:SendMessage(player, self.Config.Messages.OnAnimalKill:format(self.Config.Settings.ChickenKillAmount, "chicken"))
					end
				end
			end
		end
	elseif API == nil and notified == "false" and self.Config.Settings.PluginEnabled == "true"then
		pluginsList = plugins.GetAll()
		for i = 0, tonumber(pluginsList.Length) - 1 do
			if pluginsList[i].Object.Title:match("Economics") then  
				API = GetEconomyAPI()
			end
		end
		if API == nil then
			print("Economics plugin not found. MoneyForGather plugin will not function!")
			notified = "true"
		end
	end
end

function PLUGIN:cmdSetAmount(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if args.Length == 1 then
			if cmd == "setforwood" then
				self.Config.Settings.WoodAmount = tostring(args[0])
				self:SaveConfig()
				self:SendMessage(player, self.Config.Messages.AmountChanged:format("Wood", tostring(args[0])))
			elseif cmd == "setforores" then
				self.Config.Settings.OreAmount = tostring(args[0])
				self:SaveConfig()
				self:SendMessage(player, self.Config.Messages.AmountChanged:format("Ores", tostring(args[0])))
			elseif cmd == "setforcorpses" then
				self.Config.Settings.CorpseAmount = tostring(args[0])
				self:SaveConfig()
				self:SendMessage(player, self.Config.Messages.AmountChanged:format("corpses", tostring(args[0])))
			elseif cmd == "setforanimal" then
				self:SendMessage(player, self.Config.Messages.HelpText4)
			end
		elseif args.Length == 2 then
			if cmd == "setforwood" then
				self:SendMessage(player, self.Config.Messages.HelpText1)
			elseif cmd == "setforores" then
				self:SendMessage(player, self.Config.Messages.HelpText2)
			elseif cmd == "setforcorpses" then
				self:SendMessage(player, self.Config.Messages.HelpText3)
			elseif cmd == "setforanimal" then
				if args[0]:lower() == "bear" then
					self.Config.Settings.BearKillAmount = tostring(args[1])
					self:SendMessage(player, self.Config.Messages.AmountChanged:format("bears", tostring(args[1])))
				elseif args[0]:lower() == "wolf" then
					self.Config.Settings.WolfKillAmount = tostring(args[1])
					self:SendMessage(player, self.Config.Messages.AmountChanged:format("wolves", tostring(args[1])))
				elseif args[0]:lower() == "stag" then
					self.Config.Settings.StagKillAmount = tostring(args[1])
					self:SendMessage(player, self.Config.Messages.AmountChanged:format("stags", tostring(args[1])))
				elseif args[0]:lower() == "boar" then
					self.Config.Settings.BoarKillAmount = tostring(args[1])
					self:SendMessage(player, self.Config.Messages.AmountChanged:format("boars", tostring(args[1])))
				elseif args[0]:lower() == "chicken" then
					self.Config.Settings.ChickenKillAmount = tostring(args[1])
					self:SendMessage(player, self.Config.Messages.AmountChanged:format("chickens", tostring(args[1])))
				else
					self:SendMessage(player, self.Config.Messages.InvalidAnimal)
				end
			end
		else
			if cmd == "setforwood" then
				self:SendMessage(player, self.Config.Messages.HelpText1)
			elseif cmd == "setforores" then
				self:SendMessage(player, self.Config.Messages.HelpText2)
			elseif cmd == "setforcorpses" then
				self:SendMessage(player, self.Config.Messages.HelpText3)
			elseif cmd == "setforanimal" then
				self:SendMessage(player, self.Config.Messages.HelpText4)
			end
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

-- function PLUGIN:cmdGather(player, cmd, args)
	-- Add code to toggle config.Settings.GatherEnabled here
-- end

function PLUGIN:cmdToggle(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.PluginEnabled == "true" then
			self.Config.Settings.PluginEnabled = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.PluginStatusChanged:format("disabled"))
		else
			self.Config.Settings.PluginEnabled = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.PluginStatusChanged:format("enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdToggleChat(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.GatherMessagesEnabled == "true" then
			self.Config.Settings.GatherMessagesEnabled = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.GatherMessagesChanged:format("disabled"))
		else
			self.Config.Settings.GatherMessagesEnabled = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.GatherMessagesChanged:format("enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdToggleWood(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.MoneyForWoodEnabled == "true" then
			self.Config.Settings.MoneyForWoodEnabled = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("Wood", "disabled"))
		else
			self.Config.Settings.MoneyForWoodEnabled = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("Wood", "enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdToggleOres(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.MoneyForOresEnabled == "true" then
			self.Config.Settings.MoneyForOresEnabled = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("Ore", "disabled"))
		else
			self.Config.Settings.MoneyForOresEnabled = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("Ore", "enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdToggleCorpses(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.MoneyForCorpsesEnabled == "true" then
			self.Config.Settings.MoneyForCorpsesEnabled = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("corpses", "disabled"))
		else
			self.Config.Settings.MoneyForCorpsesEnabled = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("corpses", "enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdToggleAnimals(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		if self.Config.Settings.MoneyForAnimalKillsEnabled  == "true" then
			self.Config.Settings.MoneyForAnimalKillsEnabled  = "false"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("animal kills", "disabled"))
		else
			self.Config.Settings.MoneyForAnimalKillsEnabled  = "true"
			self:SaveConfig()
			self:SendMessage(player, self.Config.Messages.MoneyOnGatherStateChanged:format("animal kills", "enabled"))
		end
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:cmdHelp(player, cmd, args)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		self:SendMessage(player, self.Config.Messages.HelpText1)
		self:SendMessage(player, self.Config.Messages.HelpText2)
		self:SendMessage(player, self.Config.Messages.HelpText3)
		self:SendMessage(player, self.Config.Messages.HelpText4)
		self:SendMessage(player, self.Config.Messages.HelpText5)
		self:SendMessage(player, self.Config.Messages.HelpText6)
		self:SendMessage(player, self.Config.Messages.HelpText7)
		self:SendMessage(player, self.Config.Messages.HelpText8)
	else
		self:SendMessage(player, self.Config.Messages.NoPermission)
	end
end

function PLUGIN:ccmdM4G(arg)
	command = arg.cmd.namefull
	if command == "m4g.setforwood" then
		if not arg.Args or arg.Args.Length ~= 1 then
			arg:ReplyWith("You must specify an amount. 'm4g.setforwood <amount>'")
		elseif arg.Args[0] then
			self.Config.Settings.WoodAmount = tostring(arg.Args[0])
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.AmountChanged:format("Wood", tostring(arg.Args[0])))
		end
	elseif command == "m4g.setforores" then
		if not arg.Args or arg.Args.Length ~= 1 then
			arg:ReplyWith("You must specify an amount. 'm4g.setforores <amount>'")
		elseif arg.Args[0] then
			self.Config.Settings.OreAmount = tostring(arg.Args[0])
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.AmountChanged:format("Ores", tostring(arg.Args[0])))
		end
	elseif command == "m4g.setforcorpses" then
		if not arg.Args or arg.Args.Length ~= 1 then
			arg:ReplyWith("You must specify an amount. 'm4g.setforcorpses <amount>'")
		elseif arg.Args[0] then
			self.Config.Settings.CorpseAmount = tostring(arg.Args[0])
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.AmountChanged:format("corpses", tostring(arg.Args[0])))
		end
	elseif command == "m4g.setforanimal" then
		if not arg.Args or arg.Args.Length ~= 2 then
			arg:ReplyWith("You must specify an animal type and amount. 'm4g.setforanimals <animal> <amount>'")
		elseif arg.Args[0] and arg.Args[1] then
			if arg.Args[0]:lower() == "bear" then
					self.Config.Settings.BearKillAmount = tostring(arg.Args[1])
					arg:ReplyWith(self.Config.Messages.AmountChanged:format("bears", tostring(arg.Args[1])))
				elseif arg.Args[0]:lower() == "wolf" then
					self.Config.Settings.WolfKillAmount = tostring(arg.Args[1])
					arg:ReplyWith(self.Config.Messages.AmountChanged:format("wolves", tostring(arg.Args[1])))
				elseif arg.Args[0]:lower() == "stag" then
					self.Config.Settings.StagKillAmount = tostring(arg.Args[1])
					arg:ReplyWith(self.Config.Messages.AmountChanged:format("stags", tostring(arg.Args[1])))
				elseif arg.Args[0]:lower() == "boar" then
					self.Config.Settings.BoarKillAmount = tostring(arg.Args[1])
					arg:ReplyWith(self.Config.Messages.AmountChanged:format("boars", tostring(arg.Args[1])))
				elseif arg.Args[0]:lower() == "chicken" then
					self.Config.Settings.ChickenKillAmount = tostring(arg.Args[1])
					arg:ReplyWith(self.Config.Messages.AmountChanged:format("chickens", tostring(arg.Args[1])))
				else
					arg:ReplyWith(self.Config.Messages.InvalidAnimal)
				end
			self:SaveConfig()
		end
	elseif command == "m4g.toggle" then
		if self.Config.Settings.PluginEnabled == "true" then
			self.Config.Settings.PluginEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.PluginDisabled)
		else
			self.Config.Settings.PluginEnabled = "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.PluginEnabled)
		end
	elseif command == "m4g.togglechat" then
		if self.Config.Settings.GatherMessagesEnabled == "true" then
			self.Config.Settings.GatherMessagesEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.GatherMessagesChanged:format("disabled"))
		else
			self.Config.Settings.GatherMessagesEnabled= "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.GatherMessagesChanged:format("enabled"))
		end
	elseif command == "m4g.togglewood" then
		if self.Config.Settings.MoneyForWoodEnabled == "true" then
			self.Config.Settings.MoneyForWoodEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("Wood", "disabled"))
		else
			self.Config.Settings.MoneyForWoodEnabled = "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("Wood", "enabled"))
		end
	elseif command == "m4g.toggleores" then
		if self.Config.Settings.MoneyForOresEnabled == "true" then
			self.Config.Settings.MoneyForOresEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("Ores", "disabled"))
		else
			self.Config.Settings.MoneyForOresEnabled = "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("Ores", "enabled"))
		end
	elseif command == "m4g.togglecorpses" then
		if self.Config.Settings.MoneyForCorpsesEnabled == "true" then
			self.Config.Settings.MoneyForCorpsesEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("corpses", "disabled"))
		else
			self.Config.Settings.CorpsesEnabled = "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("corpses", "enabled"))
		end
	elseif command == "m4g.toggleanimals" then
		if self.Config.Settings.MoneyForAnimalKillsEnabled == "true" then
			self.Config.Settings.MoneyForAnimalKillsEnabled = "false"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("animal kills", "disabled"))
		else
			self.Config.Settings.MoneyForAnimalKillsEnabled = "true"
			self:SaveConfig()
			arg:ReplyWith(self.Config.Messages.MoneyOnGatherStateChanged:format("animal kills", "enabled"))
		end
	end
	return
end

function PLUGIN:SendHelpText(player)
	if player.net.connection.authLevel >= tonumber(self.Config.Settings.AuthLevel) then
		self:SendMessage(player, self.Config.Messages.HelpText)
	end
end

function PLUGIN:SendMessage(player, message)
	player:SendConsoleCommand("chat.add " .. QuoteSafe(self.Config.Settings.ChatName) .. " " .. QuoteSafe(message))
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\MoneyTime.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "MoneyTime"
PLUGIN.Version = V(0, 8, 5)
PLUGIN.Description = "Pays Players a specified amount for every specified seconds played."
PLUGIN.Author = "Spiritwind"
PLUGIN.HasConfig = true
PLUGIN.Url = "http://oxidemod.org/resources/moneytime-for-economics.836/"
PLUGIN.ResourceId  = 836


function PLUGIN:Init()
	if GetEconomyAPI then
		EcoAPI = GetEconomyAPI()
	else
		print("This plugin requires Economics! Please install: http://forum.rustoxide.com/plugins/economics.717/  ")
		return 
    end
	Timers = {}
	self.Config.ChatName = self.Config.ChatName or "SERVER"
	self.Config.Interval = self.Config.Interval or 600
	self.Config.PayAmount = self.Config.PayAmount or 150
	self.Config.PayMessage = self.Config.PayMessage or "You were paid $150 for playing on the server!"
	self:SaveConfig()
end

function PLUGIN:PayTime( player )
        EcoAPI:GetUserDataFromPlayer(player):Deposit(self.Config.PayAmount)
				rust.SendChatMessage(player, self.Config.ChatName, self.Config.PayMessage)
end

function PLUGIN:OnPlayerInit( player )
    local steam = rust.UserIDFromPlayer(player)
    Timers[steam] = timer.Repeat(self.Config.Interval, 0, function() self:PayTime(player) end, self.Plugin)
  print("Timer Created for MoneyTime on connection:DEBUG")
end

function PLUGIN:OnPlayerDisconnected( player )
    local steam = rust.UserIDFromPlayer(player)
	if Timers[steam] then
    Timers[steam]:Destroy()
  print("Timer destroyed for MoneyTime on disconnect:DEBUG")
    else
  print("No MoneyTime Timer found for player on disconnect:DEBUG")
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\namecolors.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Custom Name Colors"
PLUGIN.Description  = "change chat colors"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,0,2)
PLUGIN.HasConfig    = true
PLUGIN.ResourceId     = 979

function PLUGIN:Init()
	command.AddChatCommand("color", self.Object, "cmdColor")
	self:LoadDefaultConfig()
end

function PLUGIN:LoadDefaultConfig()
	self.Config.Colors = self.Config.Colors or {}
	
	self.Config.Colors.AuthLevel2 = self.Config.Colors.AuthLevel2 or "orange"
	self.Config.Colors.AuthLevel1 = self.Config.Colors.AuthLevel1 or "yellow"
	self.Config.Colors.AuthLevel0 = self.Config.Colors.AuthLevel0 or "lime"
	
	self:SaveConfig()
end

function PLUGIN:OnPlayerChat(arg)
	local message = arg:GetString(0, "text")
	local player = arg.connection.player
	local userid = rust.UserIDFromPlayer(player)
	
	if player.net.connection.authLevel == 0 then
		rust.BroadcastChat("<color=" .. self.Config.Colors.AuthLevel0 .. ">" .. player.displayName .. "</color><color=white>", "</color>" ..message, userid)
	elseif player.net.connection.authLevel == 1 then
		rust.BroadcastChat("<color=" .. self.Config.Colors.AuthLevel1 .. ">" .. player.displayName .. "</color><color=white>", "</color>" .. message, userid)
	elseif player.net.connection.authLevel == 2 then
		rust.BroadcastChat("<color=" .. self.Config.Colors.AuthLevel2 .. ">" .. player.displayName .. "</color><color=white>", "</color>" .. message, userid)
	else
	end
	return ""
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\natives.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Natives"
PLUGIN.Version = V(0, 1, 8)
PLUGIN.Description = "Allows only players from the server's country to join."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/678/"
PLUGIN.ResourceId = 678
PLUGIN.HasConfig = true

local debug = false

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

local function GetIp(ip)
    return ("%s.%s.%s.%s"):format(bit32.rshift(ip, 24), bit32.band(bit32.rshift(ip, 16), 0xff), bit32.band(bit32.rshift(ip, 8), 0xff), bit32.band(ip, 0xff))
end

local homeland = "undefined"
function PLUGIN:OnServerInitialized()
    self.ipTimer = timer.Once(5, function()
        local serverIp
        serverIp = GetIp(Steamworks.SteamGameServer.GetPublicIP())
        if debug then print("[" .. self.Title .. "] Server's IP: " .. serverIp) end
        webrequests.EnqueueGet("http://ipinfo.io/" .. serverIp .. "/country", function(code, response)
            homeland = response:gsub("\n", "")
            if homeland == "undefined" and code ~= "200" then print("[" .. self.Title .. "] Getting country for server failed!"); return end
            print("[" .. self.Title .. "] Server's country: " .. homeland)
        end, self.Plugin)
        if serverIp == "" or serverIp == "0.0.0.0" then print("[" .. self.Title .. "] Getting IP for server failed!") end
    end)
end

function PLUGIN:CanClientLogin(connection)
    local country = "undefined"
    local playerIp = connection.ipaddress:match("([^:]*):")
    if debug then playerIp = "8.8.8.8"; print("[" .. self.Title .. "] Player's IP: " .. playerIp) end
    if playerIp ~= "127.0.0.1" then
        local steamId = rust.UserIDFromConnection(connection)
        local url = "http://ipinfo.io/" .. playerIp .. "/country"
        webrequests.EnqueueGet(url, function(code, response)
            country = response:gsub("\n", "")
            print("[" .. self.Title .. "] " .. connection.username .. " connected from " .. country)
            if country == "undefined" or code ~= 200 then
                print("[" .. self.Title .. "] Checking country for " .. connection.username .. " failed!")
                self:Deport(connection, country)
                return
            end
            if country ~= homeland then self:Deport(connection, country) end
        end, self.Plugin)
    end
end

function PLUGIN:Deport(connection, country)
    Network.Net.sv:Kick(connection, self.Config.Messages.Rejected)
    local kicked = self.Config.Messages.Kicked:gsub("{player}", connection.username); local kicked = kicked:gsub("{country}", homeland)
    print("[" .. self.Title .. "] " .. kicked)
    if self.Config.Settings.Broadcast ~= "false" then rust.BroadcastChat(self.Config.Settings.ChatName, kicked) end
end

function PLUGIN:Unload()
    if self.ipTimer then self.ipTimer:Destroy(); self.ipTimer = nil end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.Broadcast = self.Config.Settings.Broadcast or "true"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "SERVER"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.Kicked = self.Config.Messages.Kicked or "{player} kicked for not being from the homeland, {country}!"
    self.Config.Messages.Rejected = self.Config.Messages.Rejected or "Sorry, this server allows only players from its native country!"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\notifico.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Notifico"
PLUGIN.Version = V(0, 2, 4)
PLUGIN.Description = "Sends messages and alerts to configured IRC channels via Notifico - http://n.tkte.ch/"
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/704/"
PLUGIN.ResourceId = 704
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Additional user information such as IP, country, SteamID, etc

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:OnPlayerConnected(packet)
    if not packet then return end
    if not packet.connection then return end
    local player = packet.connection
    if self.Config.Settings.ShowConnects ~= "false" then
        local payload = self.Config.Messages.Connected:gsub("{player}", player.username)
        self:SendPayload(player, payload)
    end
end

function PLUGIN:OnPlayerDisconnected(player)
    if not player then return end
    if self.Config.Settings.ShowDisconnects ~= "false" then
        local payload = self.Config.Messages.Disconnected:gsub("{player}", player.displayName)
        self:SendPayload(player, payload)
    end
end

function PLUGIN:OnRunCommand(arg)
    if not arg then return end; if not arg.connection then return end; if not arg.connection.player then return end
    if not arg.cmd then return end; if not arg.cmd.namefull then return end
    local player = arg.connection.player
    if not self:PermissionsCheck(player) then return end
    local chat = arg:GetString(0, "text"); local console = arg.cmd.namefull; local excluded
    for key, value in pairs(self.Config.Settings.Exclusions) do if value == console then excluded = true; break end end
    if not excluded then
        if self.Config.Settings.ShowConsoleCommands ~= "false" then
            self:SendPayload(player, player.displayName .. " ran console command: " .. console)
        end
    elseif chat:sub(1, 1) == "/" then
        if self.Config.Settings.ShowChatCommands ~= "false" then
            self:SendPayload(player, player.displayName .. " ran chat command: " .. chat)
        end
    end
end

function PLUGIN:OnPlayerChat(arg)
    if not arg then return end; if not arg.connection then return end; if not arg.connection.player then return end
    local player = arg.connection.player
    local chat = arg:GetString(0, "text")
    if not chat or chat == "" or chat:sub(1, 1) == "/" then return end
    if self.Config.Settings.ShowChat ~= "false" then
        self:SendPayload(player, player.displayName .. ": " .. chat)
    end
end

function PLUGIN:SendPayload(netuser, payload)
    if self.Config.Settings.HookUrl == "" then print(self.Title .. ": You need to set your Notifico hook URL!"); return end
    local url = self.Config.Settings.HookUrl .. "?payload=" .. payload
    webrequests.EnqueueGet(url, function(code, response)
        if code ~= 200 then print(self.Title .. ": Failed to send message to Notifico!"); return end
    end, self.Plugin)
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.Exclusions = self.Config.Settings.Exclusions or {
        "chat.say", "craft.add", "craft.cancel", "global.kill", "global.respawn", "global.respawn_sleepingbag", "global.status",
        "global.wakeup", "inventory.endloot"
    }
    self.Config.Settings.HookUrl = self.Config.Settings.HookUrl or ""
    self.Config.Settings.ShowChat = self.Config.Settings.ShowChat or "true"
    self.Config.Settings.ShowChatCommands = self.Config.Settings.ShowChatCommands or "true"
    self.Config.Settings.ShowConnects = self.Config.Settings.ShowConnects or "true"
    self.Config.Settings.ShowConsoleCommands = self.Config.Settings.ShowConsoleCommands or "true"
    self.Config.Settings.ShowDisconnects = self.Config.Settings.ShowDisconnects or "true"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.Connected = self.Config.Messages.Connected or "{player} has connected to the server"
    self.Config.Messages.Disconnected = self.Config.Messages.Disconnected or "{player} has disconnected from the server"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\onlinelog.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Online Log"
PLUGIN.Version = V(0, 1, 1)
PLUGIN.Description = "Creates a JSON formatted log of all online players for use with external scripts."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/690/"
PLUGIN.ResourceId = 690
PLUGIN.HasConfig = false

function PLUGIN:Init()
    self.datatable = datafile.GetDataTable("onlinelog")
end

function PLUGIN:OnPlayerConnected(packet)
    if not packet then return end
    if not packet.connection then return end
    local steamId = rust.UserIDFromConnection(packet.connection)
    self.datatable.Online = self.datatable.Online or {}
    self.datatable.Online.Count = global.BasePlayer.activePlayerList.Count + 1
    self.datatable.Online.Players = self.datatable.Online.Players or {}
    self.datatable.Online.Players[steamId] = packet.connection.username
    datafile.SaveDataTable("onlinelog")
end

function PLUGIN:OnPlayerDisconnected(player)
    if not player then return end
    local steamId = rust.UserIDFromPlayer(player)
    self.datatable.Online.Count = global.BasePlayer.activePlayerList.Count - 1
    self.datatable.Online.Players[steamId] = nil
    datafile.SaveDataTable("onlinelog")
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\ping.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Ping"
PLUGIN.Version = V(0, 2, 6)
PLUGIN.Description = "Player ping checking and with optional high ping rejection on join."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://oxidemod.org/resources/656/"
PLUGIN.ResourceId = 656
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Add command to change max ping, with permissions
------ permission.RegisterPermission("ping", self.Plugin)
------ UserHasPermission(player, "ping.max")

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "ping"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "global.ping"
    self.Config.Settings.MaxPing = tonumber(self.Config.Settings.MaxPing) or 200 -- Milliseconds
    self.Config.Settings.PingKick = self.Config.Settings.PingKick or "true"
    self.Config.Settings.ShowKick = self.Config.Settings.ShowKick or "true"

    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or "Use /ping player to check target player's ping"
    self.Config.Messages.ConsoleHelp = self.Config.Messages.ConsoleHelp or "Use player.ping player to check target player's ping"
    self.Config.Messages.InvalidTarget = self.Config.Messages.InvalidTarget or "Invalid target player! Please try again"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.PlayerCheck = self.Config.Messages.PlayerCheck or self.Config.Messages.PingCheck or "{player} has a ping of {ping}ms"
    self.Config.Messages.SelfCheck = self.Config.Messages.SelfCheck or "You have a ping of {ping}ms"
    self.Config.Messages.PlayerConnected = self.Config.Messages.PlayerConnected  or "{player} ({steamid}) connected with {ping}ms ping"
    self.Config.Messages.PlayerKicked = self.Config.Messages.PlayerKicked or "{player} was kicked for high ping ({ping}ms)"
    self.Config.Messages.Rejected = self.Config.Messages.Rejected or "Your ping is too high for this server!"

    self.Config.Settings.ChatName = nil -- Removed in 0.2.5
    self.Config.Settings.ChatNameHelp = nil -- Removed in 0.2.5
    self.Config.Messages.PingCheck = nil -- Removed in 0.2.5

    self:SaveConfig()
end

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "ChatCommand")
    command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ConsoleCommand")
end

local function ParseMessage(message, values)
    for key, value in pairs(values) do 
        message = message:gsub("{" .. key .. "}", value)
    end
    return message
end

local function HasPermission(self, connection)
    local authLevel
    if connection then
        authLevel = connection.authLevel
    else
        authLevel = 2
    end
    if debug then print(connection.username .. " has auth level: " .. tostring(authLevel)) end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if authLevel and authLevel >= neededLevel then
        return true
    else
        return false
    end
end

local function FindPlayer(self, player, target)
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        if not player then
            print("[" .. self.Title .. "] " .. self.Config.Messages.InvalidTarget)
        else
            rust.SendChatMessage(player, self.Config.Messages.InvalidTarget)
        end
        return
    end
    return targetPlayer
end

local function Kick(connection, message) Network.Net.sv:Kick(connection, message) end

local function Ping(connection) return Network.Net.sv:GetAveragePing(connection) end

function PLUGIN:PingKick(connection)
    local ping = Ping(connection)
    if self.Config.Settings.PingKick == "true" then
        if ping >= self.Config.Settings.MaxPing then
            if self.Config.Settings.ShowKick ~= "false" then
                local message = ParseMessage(self.Config.Messages.PlayerKicked, { player = connection.username, ping = ping })
                rust.BroadcastChat(message)
            end
            Kick(connection, self.Config.Messages.Rejected)
        end
    end
    return ping
end

function PLUGIN:OnPlayerConnected(packet)
    if not packet then return end
    if not packet.connection then return end
    local connection = packet.connection
    local steamId = rust.UserIDFromConnection(connection)
    local ping = self:PingKick(connection)
    local message = ParseMessage(self.Config.Messages.PlayerConnected, { player = connection.username, steamid = steamId, ping = ping })
    print("[" .. self.Title .. "] " .. message)
end

function PLUGIN:ChatCommand(player, cmd, args)
    if args.Length > 1 then
        rust.SendChatMessage(player, self.Config.Messages.ChatHelp)
        return
    end
    if args.Length == 1 then
        if player and not HasPermission(self, player.net.connection) then
            rust.SendChatMessage(player, self.Config.Messages.NoPermission)
            return
        end
        local targetPlayer = FindPlayer(self, player, args[0])
        if targetPlayer then
            local ping = self:PingKick(targetPlayer.net.connection)
            local message = ParseMessage(self.Config.Messages.PlayerCheck, { player = targetPlayer.displayName, ping = ping })
            rust.SendChatMessage(player, message)
        end
    else
        local ping = Ping(player.net.connection)
        local message = ParseMessage(self.Config.Messages.SelfCheck, { player = player.displayName, ping = ping })
        rust.SendChatMessage(player, message)
    end
end

function PLUGIN:ConsoleCommand(args)
    local player
    if args.connection then
        player = args.connection.player
    end
    if player and not HasPermission(self, args.connection) then
        args:ReplyWith(self.Config.Messages.NoPermission)
        return
    end
    if not args:HasArgs(1) then
        args:ReplyWith(self.Config.Messages.ConsoleHelp)
        return
    end
    local targetPlayer = FindPlayer(self, player, args:GetString(0))
    if targetPlayer then
        local ping = self:PingKick(targetPlayer.net.connection)
        local message = ParseMessage(self.Config.Messages.PlayerCheck, { player = targetPlayer.displayName, ping = ping })
        args:ReplyWith(message)
    end
end

function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, self.Config.Messages.ChatHelp)
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\playerlist.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Players list"
PLUGIN.Description  = "Allows users to see who or how many people are online"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(1, 4, 0)
PLUGIN.HasConfig    = true
PLUGIN.ResourceID   = 661


function PLUGIN:Init()
    --command.AddChatCommand("who", self.Object, "cmdWho")
    self:LoadDefaultConfig()
    for _, cmd in pairs(self.Config.Settings.ChatCommands) do
        command.AddChatCommand(cmd, self.Object, "cmdWho")
    end
end

function PLUGIN:LoadDefaultConfig()
    -- Settings
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.OnlyShowPlayerCount = self.Config.Settings.OnlyShowPlayerCount or "true"
    self.Config.Settings.MaxPlayersPerLine = self.Config.Settings.MaxPlayersPerLine or 8
    self.Config.Settings.SeparateAdmins = self.Config.Settings.SeparateAdmins or "false"
    self.Config.Settings.OnlyShowAdminCount = self.Config.Settings.OnlyShowAdminCount or "false"
    self.Config.Settings.ChatCommands = self.Config.Settings.ChatCommands or {"who", "online"}
    -- Messages
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.OnePlayerMessage = self.Config.Messages.OnePlayerMessage or "You're the only one online"
    self.Config.Messages.PlayerCountMessage = self.Config.Messages.PlayerCountMessage or "{count} players online"
    self.Config.Messages.PlayerNameMessage = self.Config.Messages.PlayerNameMessage or "{count} players online: "
    self.Config.Messages.NoAdminMessage = self.Config.Messages.NoAdminMessage or "No admin online"
    self.Config.Messages.AdminCountMessage = self.Config.Messages.AdminCountMessage or "{count} admins online"
    self.Config.Messages.AdminNameMessage = self.Config.Messages.AdminNameMessage or "{count} admins online: "
    self.Config.Messages.HelpText = self.Config.Messages.HelpText or "use /who or /online to show who's online"

    self:SaveConfig()
end

-- --------------------------------
-- admin permission check
-- --------------------------------
local function IsAdmin(player)
    return player:GetComponent("BaseNetworkable").net.connection.authLevel > 0
end

function PLUGIN:cmdWho(player)
    if not player then return end
    local playerList = player.activePlayerList
    local enum = playerList:GetEnumerator()
    local playerCount, adminCount, allCount = 0, 0, 0
    local playerString, adminString = "", ""
    local playerStringTbl, adminStringTbl = {}, {}
    local i = 0
    local maxPlayersPerLine = self.Config.Settings.MaxPlayersPerLine
    while enum:MoveNext() do
        if self.Config.Settings.SeparateAdmins == "true" and IsAdmin(enum.Current) then
            adminCount = adminCount + 1
            allCount = allCount + 1
            adminString = adminString..enum.Current.displayName..", "
            if adminCount == maxPlayersPerLine then
                adminStringTbl[i + 1] = adminString
                adminString = ""
                i = i + 1
            end
        else
            playerCount = playerCount + 1
            allCount = allCount + 1
            playerString = playerString..enum.Current.displayName..", "
            if playerCount == maxPlayersPerLine then
                playerStringTbl[i + 1] = playerString
                playerString = ""
                i = i + 1
            end
        end
    end
    if allCount == 1 then
        rust.SendChatMessage(player, self.Config.Messages.OnePlayerMessage)
        return
    end
    -- remove comma at the end
    if string.sub(playerString, -2, -2) == "," then
        playerString = string.sub(playerString, 1, -3)
    end
    if string.sub(adminString, -2, -2) == "," then
        adminString = string.sub(adminString, 1, -3)
    end
    -- Build admin message
    if self.Config.Settings.SeparateAdmins == "true" then
        if adminCount == 0 then
            rust.SendChatMessage(player, self.Config.Messages.NoAdminMessage)
        else
            if self.Config.Settings.OnlyShowAdminCount == "true" then
                local msg = string.gsub(self.Config.Messages.AdminCountMessage, "{count}", tostring(adminCount))
                rust.SendChatMessage(player, msg)
            else
                if #adminStringTbl >= 1 then
                    local msg = string.gsub(self.Config.Messages.AdminNameMessage, "{count}", tostring(adminCount))
                    rust.SendChatMessage(player, msg)
                    for i = 1, #adminStringTbl, 1 do
                        rust.SendChatMessage(player, adminStringTbl[i])
                    end
                    rust.SendChatMessage(player, adminString)
                else
                    local msg = string.gsub(self.Config.Messages.AdminNameMessage, "{count}", tostring(adminCount))
                    rust.SendChatMessage(player, msg..adminString)
                end
            end
        end
    end
    -- Build player message
    if self.Config.Settings.OnlyShowPlayerCount == "true" then
        local msg = string.gsub(self.Config.Messages.PlayerCountMessage, "{count}", tostring(playerCount))
        rust.SendChatMessage(player, msg)
    else
        if #playerStringTbl >= 1 then
            local msg = string.gsub(self.Config.Messages.PlayerNameMessage, "{count}", tostring(playerCount))
            rust.SendChatMessage(player, msg)
            for i = 1, #playerStringTbl, 1 do
                rust.SendChatMessage(player, playerStringTbl[i])
            end
            rust.SendChatMessage(player, playerString)
        else
            local msg = string.gsub(self.Config.Messages.PlayerNameMessage, "{count}", tostring(playerCount))
            rust.SendChatMessage(player, msg..playerString)
        end
    end
end

function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, self.Config.Messages.HelpText)
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\playerlocation.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Player location"
PLUGIN.Description  = "Allows users to see their current location"
PLUGIN.Author       = "#Domestos"
PLUGIN.Version      = V(1, 2, 0)
PLUGIN.HasConfig    = true
PLUGIN.ResourceID   = 663

function PLUGIN:Init()
    self:LoadDefaultConfig()
    for _, cmd in pairs(self.Config.Settings.ChatCommands) do
        command.AddChatCommand(cmd, self.Object, "cmdLocation")
    end
end

function PLUGIN:LoadDefaultConfig()
    -- settings
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.ChatCommands   = self.Config.Settings.ChatCommands or {"loc", "location" }
    self.Config.Settings.Precision      = self.Config.Settings.Precision    or "0"
    -- messages
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.Location = self.Config.Messages.Location or "Current location x: {x} y: {y} z: {z}"
    self.Config.Messages.HelpText = self.Config.Messages.HelpText or "use /location or /loc to see your current location"
    -- save the config to file
    self:SaveConfig()
end

function PLUGIN:cmdLocation(player, cmd, args)
    if not player then return end
    local format = "%."..self.Config.Settings.Precision.."f"
    local x = string.format(format, player.transform.position.x)
    local y = string.format(format, player.transform.position.y)
    local z = string.format(format, player.transform.position.z)
    local output = string.gsub(self.Config.Messages.Location, "{x}", x)
    output = string.gsub(output, "{y}", y)
    output = string.gsub(output, "{z}", z)
    rust.SendChatMessage(player, output)
end

function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, self.Config.Messages.HelpText)
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\playertalk.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Player Talk"
PLUGIN.Description  = "	Talk trough players"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(0,9,0)
PLUGIN.HasConfig    = true
PLUGIN.ResourceId	= 866

function PLUGIN:Init()
	command.AddChatCommand("talk", self.Object, "cmdTalk")
	self:LoadDefaultConfig()	
end

function PLUGIN:LoadDefaultConfig()
	--self.Config.Authlevel = self.Config.Authlevel or "2"
	self.Config.NoPermission = self.Config.NoPermission or "You have no permission to use this command!"
end

function PLUGIN:cmdTalk(player, cmd, args)
	if player.net.connection.authLevel < 2 then
		rust.SendChatMessage(player, "PLAYER TALK", self.Config.NoPermission)
	else
		if args.Length == 2 then
			local TalkingPlayer = global.BasePlayer.Find(args[0])
			local Message = tostring(args[1])
			local userid = rust.UserIDFromPlayer(TalkingPlayer)
			if TalkingPlayer.net.connection.authLevel < 1 then
				rust.BroadcastChat("<color=#58ACFA>" .. TalkingPlayer.displayName, "</color><color=white>" .. Message .. "</color>", userid)
			else
				rust.BroadcastChat("<color=#ACFA58>" .. TalkingPlayer.displayName, "</color><color=white>" .. Message .. "</color>", userid)
			end
		else
			rust.SendChatMessage(player, "PLAYER TALK", "Syntax: /talk [PlayerName] ''[Message]''")		
		end
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\portgun.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "portgun"
PLUGIN.Title       = "Portgun"
PLUGIN.Description = "Teleport to where you are looking at"
PLUGIN.Version     = V(1, 3, 2)
PLUGIN.HasConfig   = true
PLUGIN.Author      = "Reneb"

function PLUGIN:Init()
    command.AddChatCommand( "p",  self.Plugin, "cmdTeleport" )
	command.AddChatCommand( "pg",  self.Plugin, "cmdTeleport" )
	command.AddChatCommand( "forward",  self.Plugin, "cmdForward" )
	command.AddChatCommand( "fw",  self.Plugin, "cmdForward" )
	command.AddChatCommand( "up",  self.Plugin, "cmdUp" )
	command.AddChatCommand( "down",  self.Plugin, "cmdDown" )
	TeleportVectors = {}
end
function PLUGIN:LoadDefaultConfig()
	self.Config.PortgunForModerators = true
end

function PLUGIN:Teleport( player, destination, rot )
	player.transform.position = destination
	newobj = util.TableToArray( { destination } )
	util.ConvertAndSetOnArray( newobj, 0, destination, UnityEngine.Object._type )
	player:ClientRPC(nil,player,"ForcePositionTo",newobj)
end
local function ChatMessage(player,msg)
	player:SendConsoleCommand( "chat.add \"SERVER\" \"" .. msg .. "\"" );
end
function PLUGIN:cmdTeleport( player, cmd, args )
    local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = 2
	if(self.Config.PortgunForModerators) then
		neededlevel = 1
	end
	if(authlevel and authlevel >= neededlevel) then
		self:TeleportRay( player )
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end

function PLUGIN:cmdForward( player, cmd, args )
    local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = 2
	if(self.Config.PortgunForModerators) then
		neededlevel = 1
	end
	if(authlevel and authlevel >= neededlevel) then
		local dist = 4
		if(args.Length > 0) then
			if(tonumber(args[0]) ~= nil) then
				dist = tonumber(args[0])
			end
		end
		self:TeleportForward( player, dist )
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end


function PLUGIN:cmdUp( player, cmd, args )
    local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = 2
	if(self.Config.PortgunForModerators) then
		neededlevel = 1
	end
	if(authlevel and authlevel >= neededlevel) then
		local dist = 4
		if(args.Length > 0) then
			if(tonumber(args[0]) ~= nil) then
				dist = tonumber(args[0])
			end
		end
		self:TeleportUp( player, dist )
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end
function PLUGIN:cmdDown( player, cmd, args )
    local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = 2
	if(self.Config.PortgunForModerators) then
		neededlevel = 1
	end
	if(authlevel and authlevel >= neededlevel) then
		local dist = 4
		if(args.Length > 0) then
			if(tonumber(args[0]) ~= nil) then
				dist = tonumber(args[0])
			end
		end
		self:TeleportDown( player, dist )
	else
		player:ChatMessage("You are not allowed to use this command")
	end
end

function PLUGIN:GetPoint(ray)
	local hits = UnityEngine.Physics.RaycastAll["methodarray"][1]:Invoke(nil, util.TableToArray({ ray }))
	local closestdist = 9999
	local closestpoint = false
	local enumhit = hits:GetEnumerator()
	while (enumhit:MoveNext()) do
		if(not enumhit.Current.collider:GetComponentInParent(global.TriggerBase._type)) then
			if(enumhit.Current.distance < closestdist) then
				closestdist = enumhit.Current.distance
				closestpoint = enumhit.Current.point
			end
		end
	end
	if(closestpoint) then
		closestpoint.y = closestpoint.y + 4
	end
	return closestpoint
end

function PLUGIN:TeleportRay( player )
	local ray = player.eyes:Ray()
	local rotation = player.transform.rotation
	if(not ray) then
		player:ChatMessage("Try again, i couldn't get your eyes!")
		return
	end
	local target = self:GetPoint(ray)
	if(not target) then
		player:ChatMessage("Try again, i couldn't see where you are looking at!")
		return
	end
	self:Teleport( player, target, rotation )
end

function PLUGIN:TeleportForward( player, dist )
	local ray = player.eyes:Ray()
	local rotation = player.transform.rotation
	if(not ray) then
		player:ChatMessage("Try again, i couldn't get your eyes!")
		return
	end
	local target = ray:GetPoint(dist)
	if(not target) then
		player:ChatMessage("Try again, i couldn't see where you are looking at!")
		return
	end
	self:Teleport( player, target, rotation )	
end

function PLUGIN:TeleportUp( player , dist )
	local pos = player:GetComponent("BaseEntity").transform.position
	pos.y = pos.y + dist
	self:Teleport( player, pos, player.transform.rotation )	
end
function PLUGIN:TeleportDown( player , dist )
	local pos = player:GetComponent("BaseEntity").transform.position
	pos.y = pos.y - dist
    self:Teleport( player, pos, player.transform.rotation )
end

function PLUGIN:SendHelpText(player)
    if player:IsAdmin() then
        player:ChatMessage("/pg - To teleport to where you are looking at")
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\privatemessage.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Private Messaging"
PLUGIN.Description = "Allows users to chat private with each other"
PLUGIN.Author = "#Domestos"
PLUGIN.Version = V(1, 2, 3)
PLUGIN.HasConfig = false
PLUGIN.ResourceID = 659


local pmHistory = {}
function PLUGIN:Init()
    command.AddChatCommand("pm", self.Object, "cmdPm")
    command.AddChatCommand("r", self.Object, "cmdReply")
end

-- --------------------------------
-- Chat command for pm
-- --------------------------------
function PLUGIN:cmdPm(player, cmd, args)
    if not player then return end
    local args = self:ArgsToTable(args, "chat")
    local target, message = args[1], ""
    local i = 2
    while args[i] do
        message = message..args[i].." "
        i = i + 1
    end
    if not target or message == "" then
        -- no target or no message is given
        rust.SendChatMessage(player, "Syntax: /pm <name> <message>")
        return
    end
    local targetPlayer = global.BasePlayer.Find(target)
    if not targetPlayer then
        rust.SendChatMessage(player, "Player not found")
        return
    end
    local senderName = player.displayName
    local senderSteamID = rust.UserIDFromPlayer(player)
    local targetName = targetPlayer.displayName
    local targetSteamID = rust.UserIDFromPlayer(targetPlayer)
    rust.SendChatMessage(targetPlayer, "<color=#ff00ff>PM from "..senderName.."</color>", message, senderSteamID)
    rust.SendChatMessage(player, "<color=#ff00ff>PM to "..targetName.."</color>", message, senderSteamID)
    pmHistory[targetSteamID] = senderSteamID
end
-- --------------------------------
-- Chat command for reply
-- --------------------------------
function PLUGIN:cmdReply(player, cmd, args)
    if not player then return end
    local senderName = player.displayName
    local senderSteamID = rust.UserIDFromPlayer(player)
    local args = self:ArgsToTable(args, "chat")
    local message = ""
    local i = 1
    while args[i] do
        message = message..args[i].." "
        i = i + 1
    end
    if message == "" then
        -- no args given
        rust.SendChatMessage(player, "Syntax: /r <message> to reply to last pm")
        return
    end
    if pmHistory[senderSteamID] then
        local targetPlayer = global.BasePlayer.Find(pmHistory[senderSteamID])
        if not targetPlayer then
            rust.SendChatMessage(player, "Player is offline")
            return
        end
        local targetName = targetPlayer.displayName
        rust.SendChatMessage(targetPlayer, "<color=#ff00ff>PM from "..senderName.."</color>", message, senderSteamID)
        rust.SendChatMessage(player, "<color=#ff00ff>PM to "..targetName.."</color>", message, senderSteamID)
    else
        rust.SendChatMessage(player, "No PM found to reply to")
        return
    end
end
-- --------------------------------
-- returns args as a table
-- --------------------------------
function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end

function PLUGIN:OnPlayerDisconnected(player)
    local steamID = rust.UserIDFromPlayer(player)
    if pmHistory[steamID] then
        pmHistory[steamID] = nil
    end
end

function PLUGIN:SendHelpText(player)
    rust.SendChatMessage(player, "use /pm <name> <message> to pm someone")
    rust.SendChatMessage(player, "use /r <message> to reply to the last pm")
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\push.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Push API"
PLUGIN.Version = V(0, 1, 4)
PLUGIN.Description = "API for sending messages via Pushover and Pushalot mobile notification services."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/705/"
PLUGIN.ResourceId = 705
PLUGIN.HasConfig = true

local debug = true

function PLUGIN:Init()
    self:LoadDefaultConfig()
end

function PLUGIN:PushMessage(title, message, priority, sound)
    if message == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.MessageRequired) return end
    if string.lower(self.Config.Settings.Service) == "pushover" then
        if self.Config.Pushover.ApiToken == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetApiToken) return end
        if self.Config.Pushover.UserKey == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetUserKey) return end
        self.title = title or global.server.hostname
        if priority == "high" then self.priority = "1" elseif priority == "low" then self.priority = "0" elseif priority == "quiet" then self.priority = "-1" end
        self.sound = sound or "gamelan"
        self.url = "https://api.pushover.net/1/messages.json"
        self.data = "token=" .. self.Config.Pushover.ApiToken
        .. "&user=" .. self.Config.Pushover.UserKey
        .. "&title=" .. self.title
        .. "&message=" .. message
        .. "&priority=" .. self.priority
        .. "&sound=" .. self.sound
    elseif string.lower(self.Config.Settings.Service) == "pushalot" then
        if self.Config.Pushalot.AuthToken == "" then print("[" .. self.Title .. "] " .. self.Config.Messages.SetApiToken) return end
        self.title = title or global.server.hostname
        if priority == "high" then self.priority = "IsImportant=true" elseif priority == "low" then self.priority = "IsImportant=false" elseif priority == "quiet" then self.priority = "IsQuiet=true" end
        self.url = "https://pushalot.com/api/sendmessage"
        self.data = "AuthorizationToken=" .. self.Config.Pushalot.AuthToken
        .. "&Title=" .. self.title
        .. "&Body=" .. message
        .. "&" .. self.priority
    end
    webrequests.EnqueuePost(self.url, self.data, function(code, response)
        if debug then self:DebugMessages(self.url, self.data, code) end
        if code ~= 200 then
            print("[" .. self.Title .. "] " .. self.Config.Messages.SendFailed)
        else
            print("[" .. self.Title .. "] " .. self.Config.Messages.SendSuccess)
        end
    end, self.Plugin)
end

function PLUGIN:DebugMessages(url, data, code)
    if debug then
        print("[" .. self.Title .. "] POST URL: " .. tostring(url))
        print("[" .. self.Title .. "] POST data: " .. tostring(data))
        print("[" .. self.Title .. "] HTTP code: " .. code)
    end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.Service = self.Config.Settings.Service or "pushover"
    self.Config.Pushalot = self.Config.Pushalot or {}
    self.Config.Pushalot.AuthToken = self.Config.Pushalot.AuthToken or ""
    self.Config.Pushover = self.Config.Pushover or {}
    self.Config.Pushover.ApiToken = self.Config.Pushover.ApiToken or self.Config.Settings.ApiToken or ""
    self.Config.Pushover.UserKey = self.Config.Pushover.UserKey or self.Config.Settings.UserKey or ""
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.MessageRequired = self.Config.Messages.MessageRequired or "Message not given! Please enter one and try again"
    self.Config.Messages.SendFailed = self.Config.Messages.SendFailed or "Notification failed to send!"
    self.Config.Messages.SendSuccess = self.Config.Messages.SendSuccess or "Notification successfully sent!"
    self.Config.Messages.SetApiToken = self.Config.Messages.SetApiToken or self.Config.Messages.SetApiKey or "API token not set! Please set it and try again."
    self.Config.Messages.SetUserKey = self.Config.Messages.SetUserKey or "User key not set! Please set it and try again."
    self.Config.Settings.ApiToken = nil -- Removed in 0.1.1
    self.Config.Settings.UserKey = nil -- Removed in 0.1.1
    self.Config.Messages.SetApiKey = nil -- Removed in 0.1.1
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\pvpswitch.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "PVP Switch"
PLUGIN.Description = "Allows you to switch between pvp and pve"
PLUGIN.Author = "#Domestos"
PLUGIN.Version = V(1, 1, 1)
PLUGIN.HasConfig = true
PLUGIN.ResourceID = 694

function PLUGIN:Init()
    command.AddChatCommand("pvp", self.Object, "cmdSetConfig")
    self:LoadDefaultConfig()
end

local function QuoteSafe(string)
    return UnityEngine.StringExtensions.QuoteSafe(string)
end

function PLUGIN:ChatMessage(targetPlayer, chatName, msg)
    if msg then
        targetPlayer:SendConsoleCommand("chat.add "..QuoteSafe(chatName).." "..QuoteSafe(msg))
    else
        msg = chatName
        targetPlayer:SendConsoleCommand("chat.add SERVER "..QuoteSafe(msg))
    end
end
-- --------------------------------
-- admin permission check
-- --------------------------------
local function IsAdmin(player)
    if player:GetComponent("BaseNetworkable").net.connection.authLevel == 0 then
        return false
    end
    return true
end

function PLUGIN:cmdSetConfig(player)
    if not IsAdmin(player) then
        self:ChatMessage(player, "You dont have permission to use this command")
        return
    end
    if self.Config.PVP == "true" then
        self.Config.PVP = "false"
        self:ChatMessage(player, "pvp now disabled")
    else
        self.Config.PVP = "true"
        self:ChatMessage(player, "pvp now enabled")
    end
    self:SaveConfig()
end

function PLUGIN:LoadDefaultConfig()
    self.Config.PVP = self.Config.PVP or "true"
    self:SaveConfig()
end

function PLUGIN:OnPlayerAttack(attacker, hitinfo)
    if self.Config.PVP == "false" then
        if hitinfo.HitEntity then
            if hitinfo.HitEntity:ToPlayer() then
                return true
            end
        end
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\r-Lanterns.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "r-Lanterns"
PLUGIN.Title = "r-Lanterns"
PLUGIN.Version = V(1, 0, 3)
PLUGIN.Description = "Manage Lanterns On/Off by Building Privilege zones"
PLUGIN.Author = "Reneb & Mughisi"
PLUGIN.HasConfig = true


function PLUGIN:Init()
	------------------------------------------------------------------------
	-- Debug Config
	------------------------------------------------------------------------
	--self.Config = {}
	--self:LoadDefaultConfig()
	------------------------------------------------------------------------
	
	PlayerLanternZones = {} 
	LaternsZones = {}
	
	command.AddChatCommand( "lanterns_on", self.Plugin, "cmdLanternsOn" )
	command.AddChatCommand( "lanterns_off", self.Plugin, "cmdLanternsOff" )
end

-- -----------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- auto-creation of the config file if: PLUGIN.HasConfig = true
-- -----------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
	self.Config.Settings = {}
	--self.Config.nightTime = 18
	--self.Config.dayTime = 6
	self.Config.Settings.authLevel = 1
	self.Config.Settings.chatName = "Auto-Light"
end

-- -----------------------------------------------------------------------------
-- add_ZoneLight( triggerbase , lantern )
-- add a lantern inside a zone
-- -----------------------------------------------------------------------------
local function add_ZoneLight(triggerbase,lantern)
	if(not LaternsZones[lantern]) then LaternsZones[lantern] = {} end
	LaternsZones[lantern][triggerbase] = true
end

-- -----------------------------------------------------------------------------
-- hasPlayer(triggerbase)
-- check if a zone has a connected player or not
-- -----------------------------------------------------------------------------

local function hasPlayer(triggerbase)
	if(not PlayerLanternZones[triggerbase]) then PlayerLanternZones[triggerbase] = {} end
	for k,v in pairs(PlayerLanternZones[triggerbase]) do
		return true
	end
	return false
end

-- -----------------------------------------------------------------------------
-- countPlayers(triggerbase)
-- count the current online players inside a zone
-- -----------------------------------------------------------------------------

local function countPlayers(triggerbase)
	if(not PlayerLanternZones[triggerbase]) then PlayerLanternZones[triggerbase] = {} end
	count = 0
	for k,v in pairs(PlayerLanternZones[triggerbase]) do
		count = count + 1
	end
	return count
end

-- -----------------------------------------------------------------------------
-- start_sphereCastLights(triggerbase,pos,radius)
-- Start all lanterns in a zone
-- -----------------------------------------------------------------------------
local function start_sphereCastLights(triggerbase,pos,radius)
	arr = util.TableToArray( { pos , radius } )
	util.ConvertAndSetOnArray(arr, 1, radius, System.Single._type)
	hits = UnityEngine.Physics.OverlapSphere["methodarray"][1]:Invoke(nil,arr)
	local it = hits:GetEnumerator()
	while (it:MoveNext()) do
		if tostring(it.Current):find("lantern") then
			it.Current:GetComponent(global.BaseEntity._type):SetFlag(global["BaseEntity+Flags"].On, true)
			add_ZoneLight(triggerbase,it.Current:GetComponent(global.BaseEntity._type))
		end
	end
end

-- -----------------------------------------------------------------------------
-- canSwitchOff(lantern)
-- Check if a lantern can be turned off, check if one of the zone where he is in has a player or not.
-- -----------------------------------------------------------------------------
local function canSwitchOff(lantern)
	if(not LaternsZones[lantern]) then return true end
	for triggerbase,abool in pairs(LaternsZones[lantern]) do
		if(hasPlayer(triggerbase)) then
			return false
		end
	end
	return true
end

-- -----------------------------------------------------------------------------
-- stop_sphereCastLights(triggerbase,pos,radius)
-- Stops all lanterns in a zone, uses canSwitchOff(lantern)
-- -----------------------------------------------------------------------------
local function stop_sphereCastLights(triggerbase,pos,radius)
	arr = util.TableToArray( { pos , radius } )
	util.ConvertAndSetOnArray(arr, 1, radius, System.Single._type)
	hits = UnityEngine.Physics.OverlapSphere["methodarray"][1]:Invoke(nil,arr)
	local it = hits:GetEnumerator()
	while (it:MoveNext()) do
		if tostring(it.Current):find("lantern") then
			if canSwitchOff(it.Current:GetComponent(global.BaseEntity._type)) then
				it.Current:GetComponent(global.BaseEntity._type):SetFlag(global["BaseEntity+Flags"].On, false)
			end
		end
	end
end

-- -----------------------------------------------------------------------------
-- startLights(triggerbase)
-- calls: start_sphereCastLights(triggerbase,pos,radius)
-- -----------------------------------------------------------------------------
local function startLights(triggerbase)
	start_sphereCastLights(triggerbase,triggerbase:GetComponent(UnityEngine.Transform._type).transform.position,triggerbase:GetComponent(UnityEngine.SphereCollider._type).radius)
end

-- -----------------------------------------------------------------------------
-- stopLights(triggerbase)
-- calls: stop_sphereCastLights(triggerbase,pos,radius)
-- -----------------------------------------------------------------------------
local function stopLights(triggerbase)
	stop_sphereCastLights(triggerbase,triggerbase:GetComponent(UnityEngine.Transform._type).transform.position,triggerbase:GetComponent(UnityEngine.SphereCollider._type).radius)
end

-- -----------------------------------------------------------------------------
-- add_PlayerZone(baseplayer,triggerbase)
-- add a player in a zone
-- -----------------------------------------------------------------------------
local function add_PlayerZone(baseplayer,triggerbase)
	if(not PlayerLanternZones[triggerbase]) then PlayerLanternZones[triggerbase] = {} end
	PlayerLanternZones[triggerbase][baseplayer] = true
end

-- -----------------------------------------------------------------------------
-- remove_PlayerZone(baseplayer,triggerbase)
-- remove a player from a zone
-- -----------------------------------------------------------------------------
local function remove_PlayerZone(baseplayer,triggerbase)
	if(PlayerLanternZones[triggerbase] and PlayerLanternZones[triggerbase][baseplayer]) then
		TempZones = {}
		for k,v in pairs(PlayerLanternZones[triggerbase]) do
			if(k ~= baseplayer) then
				TempZones[k] = true
			end
		end
		PlayerLanternZones[triggerbase] = TempZones
	end
end

-- -----------------------------------------------------------------------------
-- update_playersZones(player)
-- check if the player is in one or multiple zones and adds him inside them, lighting up lights in those zones
-- -----------------------------------------------------------------------------
local function update_playersZones(player)
	allBuildingZones = UnityEngine.Object.FindObjectsOfTypeAll(global.BuildPrivilegeTrigger._type)
	for i=0, allBuildingZones.Length-1 do
		if(allBuildingZones[i].entityContents.Count > 0) then
			if(allBuildingZones[i].entityContents:Contains(player:GetComponent("BaseEntity"))) then
				triggerbase = allBuildingZones[i]:GetComponent(global.TriggerBase._type)
				if(not hasPlayer(triggerbase)) then
					startLights(triggerbase)
				end
				add_PlayerZone(player,triggerbase)
			end
		end
	end
end

-- -----------------------------------------------------------------------------
-- remove_Player(player)
-- remove a player from all zones, shutting down lights in zones where he was the last one inside
-- -----------------------------------------------------------------------------
local function remove_Player(player)
	for triggerbase,players in pairs(PlayerLanternZones) do
		if(PlayerLanternZones[triggerbase][player]) then
			remove_PlayerZone(player,triggerbase)
			if(countPlayers(triggerbase) <= 1) then
				stopLights(triggerbase)
			end
		end
	end
end

-- -----------------------------------------------------------------------------
-- switchAllLanterns(light)
-- switch all server lanterns to on (true) or off (false)
-- -----------------------------------------------------------------------------
local function switchAllLanterns(light)
	allWorldItems = UnityEngine.Object.FindObjectsOfTypeAll(global.BaseEntity._type)
	for i=0, allWorldItems.Length-1 do
		if tostring(allWorldItems[i]):find("lantern") then
			allWorldItems[i]:SetFlag(global["BaseEntity+Flags"].On, light)
		end
	end
end

-- -----------------------------------------------------------------------------
-- PLUGIN:cmd*(player, cmd, args)
-- commands
-- -----------------------------------------------------------------------------
function PLUGIN:cmdLanternsOff(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then
		rust.SendChatMessage(player, "You are not allowed to use this command")
		return
	end
	switchAllLanterns(false)
	rust.SendChatMessage(player, "Lanterns were all switched off")
end

function PLUGIN:cmdLanternsOn(player, cmd, args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then
		rust.SendChatMessage(player, "You are not allowed to use this command")
		return
	end
	switchAllLanterns(true)
	rust.SendChatMessage(player, "Lanterns were all switched on")
end

-- -----------------------------------------------------------------------------
-- HOOK
-- PLUGIN:OnEntityEnter(triggerbase,entity)
-- called when an entity (player or animal) enters a zone
-- -----------------------------------------------------------------------------

function PLUGIN:OnEntityEnter(triggerbase,entity)
	if(triggerbase:GetComponent(global.BuildPrivilegeTrigger._type)) then
		if(entity:GetComponentInParent(global.BasePlayer._type) and entity:GetComponentInParent(global.BasePlayer._type):IsConnected()) then
			if(not hasPlayer(triggerbase)) then
				startLights(triggerbase)
			end
			add_PlayerZone(entity:GetComponentInParent(global.BasePlayer._type),triggerbase)
		end
	end
end

-- -----------------------------------------------------------------------------
-- HOOK
-- PLUGIN:OnEntityLeave(triggerbase,entity)
-- called when an entity (player or animal) leaves a zone
-- -----------------------------------------------------------------------------
function PLUGIN:OnEntityLeave(triggerbase,entity)
	if(triggerbase:GetComponent(global.BuildPrivilegeTrigger._type)) then
		if(entity:GetComponentInParent(global.BasePlayer._type)) then
			remove_PlayerZone(entity:GetComponentInParent(global.BasePlayer._type),triggerbase)
			if(countPlayers(triggerbase) <= 1) then
				stopLights(triggerbase)
			end
		end
	end
end

-- -----------------------------------------------------------------------------
-- HOOK
-- PLUGIN:OnPlayerDisconnected(player,connection)
-- called when a player disconnects
-- -----------------------------------------------------------------------------
function PLUGIN:OnPlayerDisconnected(player,connection)
	remove_Player(player)
end

-- -----------------------------------------------------------------------------
-- HOOK
-- PLUGIN:OnPlayerInit(player,connection)
-- called when a player connects
-- -----------------------------------------------------------------------------
function PLUGIN:OnPlayerInit( player )
	update_playersZones(player)
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\raid[T].lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "raid[T]"
PLUGIN.Title = "Raid[Temporary]"
PLUGIN.Description = "A temporary plugin which will make bases raidable."
PLUGIN.Version = V(1, 0, 6)
PLUGIN.Author = "SPooCK"
PLUGIN.HasConfig = true

function PLUGIN:OnPlayerAttack(player, hitinfo)
if (hitinfo and hitinfo.HitEntity and hitinfo.HitEntity:GetComponent("BuildingBlock")) then
local name = tostring(hitinfo.HitEntity.name)
local Grade = tonumber(hitinfo.HitEntity.blockDefinition.grades.Length)

if (self.Config.MetalFloor["Enabled"]) then
if (name:find("floor") and Grade == 3 and hitinfo.ProjectileID and hitinfo.ProjectileID == 0) then hitinfo.HitEntity:Heal(self.Config.MetalFloor["Melee"]) 
elseif (name:find("floor") and Grade == 3) then hitinfo.HitEntity:Heal(self.Config.MetalFloor["Range"]) end
end

	if (hitinfo.ProjectileID and hitinfo.ProjectileID == 0) then
	if (Grade == 1 and self.Config.Wood["Enabled"] or Grade == 2 and self.Config.Stone["Enabled"]) then
	local type = Rust.DamageType.Generic
	local add = 0 
		if (name:find("hinged")) then
		if (Grade == 1) then add = self.Config.Wood["DoorVactor"]
		elseif (Grade == 2) then add = self.Config.Stone["DoorVactor"] end
			hitinfo:AddDamage(type, add)
			hitinfo.HitMaterial = 0
		else
		if (Grade == 1) then add = self.Config.Wood["WallsVactor"]
		elseif (Grade == 2) then add = self.Config.Stone["WallsVactor"] end
			hitinfo:AddDamage(type, add)
			hitinfo.HitMaterial = 0
		end
	end
	end
end
end

function PLUGIN:LoadDefaultConfig()
self.Config.Wood = {}
self.Config.Wood["Enabled"] = true
self.Config.Wood["DoorVactor"] = 150
self.Config.Wood["WallsVactor"] = 200
self.Config.Stone = {}
self.Config.Stone["Enabled"] = true
self.Config.Stone["DoorVactor"] = 380
self.Config.Stone["WallsVactor"] = 400
self.Config.MetalFloor = {}
self.Config.MetalFloor["Enabled"] = true
self.Config.MetalFloor["Melee"] = 9
self.Config.MetalFloor["Range"] = 39
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RealFall.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RealFall"
PLUGIN.Title = "Realistic Falling Damage"
PLUGIN.Description = "Allows you to set the maximum fall height for deaths."
PLUGIN.Version = V(1, 0, 1)
PLUGIN.Author = "M@CH!N3"
PLUGIN.HasConfig = true

function PLUGIN:Init()
	-- Load the default config and set the commands
	self:LoadDefaultConfig()
	command.AddChatCommand("maxfall", self.Plugin, "cmdMaxFall")
	command.AddChatCommand("setmaxfall", self.Plugin, "cmdSetMaxFall")
	command.AddConsoleCommand("set.maxfall", self.Plugin, "cmdSetMaxFallcon")
end

function PLUGIN:LoadDefaultConfig()
	self.Config = self.Config or {
		MaxFallHeight = "12"
	}
	self:SaveConfig()
end

function PLUGIN:OnEntityAttacked(player, hitinfo)

	if (player:GetComponent("BasePlayer")) then

		if (not tostring(hitinfo.damageTypes):find("DamageTypeList") or hitinfo.damageTypes:Total() <= 0) then
			return
		end

		local type = hitinfo.damageTypes:GetMajorityDamageType()
			if (tostring(type):find("Fall")) then
				local damage = tonumber(hitinfo.damageTypes:Total())
				local newdamage, max, health = (damage * 0.35), self.Config.MaxFallHeight, tonumber(player:Health())
				local setdamage = (health/max) * newdamage
				hitinfo.damageTypes:Set(type, setdamage)
			end
	end
end

function PLUGIN:cmdSetMaxFall(player, cmd, args)
	if player.net.connection.authLevel >= 2 then
			if cmd == "setmaxfall" then
				self.Config.MaxFallHeight = tostring(args[0])
				self:SaveConfig()
				local feet = tonumber(args[0]) * 3.3
				rust.SendChatMessage(player, "Max Fall Height is Now: "..tonumber(args[0]).."m ("..feet.."ft)")
			end
	end
end

function PLUGIN:cmdSetMaxFallcon(arg)
	command = arg.cmd.namefull
		if not arg.Args or arg.Args.Length ~= 1 then
			arg:ReplyWith("You must specify an amount. 'set.maxfall <amount>'")
		elseif arg.Args[0] then
			self.Config.MaxFallHeight = arg.Args[0]
			self:SaveConfig()
			local feet = arg.Args[0] * 3.3
			print("Max Fall Height is Now: "..arg.Args[0].."m ("..feet.."ft)")
		end
end

function PLUGIN:cmdMaxFall(player, cmd)
	if cmd == "maxfall" then
		local feet = self.Config.MaxFallHeight * 3.3
		rust.SendChatMessage(player, "Max Fall Height is : "..self.Config.MaxFallHeight.."m ("..feet.."ft)")
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\reloadall.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Easy Reloader"
PLUGIN.Description  = "Reloads your Plugins"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,1,0)
PLUGIN.HasConfig    = false
PLUGIN.ResourceID   = 854

function PLUGIN:Init()	
 	command.AddChatCommand("reload", self.Object, "cmdReload")
end

function PLUGIN:cmdReload(player, cmd, args, PluginName)
    if args.Length == 1 then
        local PluginName = tostring(args[0])
        if not player.net.connection.authLevel == 2 then return end
        rust.RunServerCommand("oxide.reload " .. PluginName)
		rust.SendChatMessage(player, "RELOADER", "Plugin " .. PluginName .. " successfully reloaded")
    else
		rust.RunServerCommand("oxide.reload " .. "*")
		rust.SendChatMessage(player, "RELOADER", "Plugins successfully reloaded")
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\reserved.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Reserved"
PLUGIN.Version = V(0, 1, 6)
PLUGIN.Description = "Reserves a number of slots so that reserved players can connect."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/674/"
PLUGIN.ResourceId = 674
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Add console command
---- Fix slots action not working due to args.Length check

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdReserved")
    --command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdReserved")
end

function PLUGIN:CanClientLogin(connection)
    local activePlayers = global.BasePlayer.activePlayerList.Count
    local maxPlayers = global.server.maxplayers
    local steamId = rust.UserIDFromConnection(connection)
    if debug then print(tostring(activePlayers) .. " players online. Max players " .. tostring(maxPlayers) .. " with " .. self.Config.Settings.ReservedSlots .. " reserved") end
    if activePlayers + tonumber(self.Config.Settings.ReservedSlots) >= maxPlayers then
        for key, value in pairs(self.Config.Settings.ReservedList) do if steamId == value then return end end
        return self.Config.Messages.Rejected
    end
end

function PLUGIN:cmdReserved(player, cmd, args)
    if player and not self:PermissionsCheck(player) then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission)
        return
    end
    if args.Length ~= 2 then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.ChatHelp)
        return
    end
    local action = args[0]
    local argument = args[1]
    local list = self.Config.Settings.ReservedList
    local steamId
    if action == "add" or action == "remove" then
        if string.len(args[1]) == 17 and string.match(argument, "%d+") then
            steamId = argument
        else
            local targetPlayer = global.BasePlayer.Find(argument)
            if targetPlayer then
                steamId = rust.UserIDFromPlayer(targetPlayer)
            else
                rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.InvalidTarget)
                return
            end
        end
    end
    if action == nil or action ~= "add" and action ~= "remove" and action ~= "slots" then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.UnknownAction)
        return
    end
    if action == "add" then
        local reserved
        for key, value in pairs(list) do if steamId == value then reserved = true; break end end
        if reserved ~= true then
            table.insert(list, steamId)
            local message = string.gsub(self.Config.Messages.PlayerAdded, "{player}", player.displayName .. " (" .. steamId .. ")")
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = string.gsub(self.Config.Messages.AlreadyAdded, "{player}", player.displayName .. " (" .. steamId .. ")")
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
        self:SaveConfig()
        return
    end
    if action == "remove" then
        for key, value in pairs(list) do
            if steamId == value then
                table.remove(list, key)
                self:SaveConfig()
                local message = self.Config.Messages.PlayerRemoved:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
                rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
                break
            else
                local message = self.Config.Messages.NotReserved:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
                rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
            end
        end
        return
    end
    --[[if action == "slots" then
        self.Config.Settings.ReservedSlots = argument
        rust.SendChatMessage(player, self.Config.Settings.ChatName, "Reserved slots set to " .. argument)
        self:SaveConfig()
        return
    end]]
end

function PLUGIN:ccmdReserved(args)
    -- TODO
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp) end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "reserved"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "RESERVED"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or self.Config.Settings.HelpChatName or "HELP"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "server.reserved"
    self.Config.Settings.ReservedList = self.Config.Settings.ReservedList or { "76561197960634567", "76561197994144473" }
    self.Config.Settings.ReservedSlots = tonumber(self.Config.Settings.ReservedSlots) or 10
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.AlreadyAdded = self.Config.Messages.AlreadyAdded or "{player} is already on the reserved list!"
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or self.Config.Messages.ChatHelpText or "Use '/reserved add|remove|slots player|steamid|#'"
    self.Config.Messages.InvalidTarget = self.Config.Messages.InvalidTarget or "Invalid player or SteamID! Please try again"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.NotReserved = self.Config.Messages.NotReserved or "{player} is not on the reserved list!"
    self.Config.Messages.PlayerAdded = self.Config.Messages.PlayerAdded or "{player} has been added to the reserved list!"
    self.Config.Messages.PlayerRemoved = self.Config.Messages.PlayerRemoved or "{player} has been removed from the reserved list!"
    self.Config.Messages.Rejected = self.Config.Messages.Rejected or "Sorry, the maximum number of players are connected!"
    self.Config.Messages.UnknownAction = self.Config.Messages.UnknownAction or "Unknown command action! Use add, remove, or slots"
    self.Config.Settings.HelpChatName = nil -- Removed in ??
    self.Config.Messages.ChatHelpText = nil -- Removed in ??
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\respawner.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Respawner"
PLUGIN.Version = V(0, 1, 7)
PLUGIN.Description = "Automatically respawns players after they die."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://oxidemod.org/resources/669/"
PLUGIN.ResourceId = 669
PLUGIN.HasConfig = true

function PLUGIN:LoadDefaultConfig()
    self.Config.AutoWakeUp = self.Config.AutoWakeUp or "true"
    self.Config.SameLocation = self.Config.SameLocation or "false"
    self.Config.SleepingBags = self.Config.SleepingBags or "true"
    self.Config.Settings = nil -- Removed in 0.1.7
    self:SaveConfig()
end

function PLUGIN:Init() self:LoadDefaultConfig() end

local FindForPlayer = global.SleepingBag.FindForPlayer.methodarray[0]
local function FindSleepingBags(steamId)
    param = util.TableToArray({ steamId, true })
    util.ConvertAndSetOnArray(param, 0, steamId, System.UInt64._type)
    return FindForPlayer:Invoke(nil, param)
end

function PLUGIN:RespawnPlayer(player)
    local steamId = rust.UserIDFromPlayer(player)
    local spawnTimer = {}
    spawnTimer[steamId] = timer.Once(1, function()
        if self.Config.SleepingBags == "true" then
            local sleepingBags = FindSleepingBags(steamId)
            if player and sleepingBags.Length > 0 then
                local sleepingBag = sleepingBags[math.random(1, sleepingBags.Length - 1)]
                player.transform.position = sleepingBag.transform.position
                player.transform.rotation = sleepingBag.transform.rotation
                player:Respawn(false)
                if self.Config.AutoWakeUp == "true" then player:EndSleeping() end
                return
            end
        end
        if self.Config.SameLocation == "true" then
            player.transform.position = player.transform.position
            player.transform.rotation = player.transform.rotation
            player:Respawn(false)
            if self.Config.AutoWakeUp == "true" then player:EndSleeping() end
            return
        end
        player:Respawn(true)
        if self.Config.AutoWakeUp == "true" then player:EndSleeping() end
    end, self.Plugin)
end

function PLUGIN:OnEntityDeath(entity)
    local player = entity:ToPlayer()
    if player and player:IsConnected() then self:RespawnPlayer(player) end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\restrictnames.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "restrictnames"
PLUGIN.Title = "Restrict Names"
PLUGIN.Version = V(0, 1, 1)
PLUGIN.Description = "Restrict Names from entering your server"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true

function PLUGIN:Init()
    
end

function PLUGIN:LoadDefaultConfig()
	self.Config.IgnoreModerators = true
	self.Config.useRestrictName = self.Config.useRestrictName or true
	self.Config.useRestrictCharacters = self.Config.useRestrictCharacters or true
	self.Config.RestrictedNames = self.Config.RestrictedNames or {"SERVER CONSOLE","SERVER","Oxide"}
	self.Config.AllowedCharacters = self.Config.AllowedCharacters or "abcdefghijklmnopqrstuvwxyz1234567890 [](){}!@#$%^&*_-=+.|"
end

function PLUGIN:CanClientLogin(connection)
	if(not connection) then return end
	if(not connection.username) then return end
	if(self.Config.IgnoreModerators and connection.authLevel > 0) then return end
	local name = connection.username
	if(self.Config.useRestrictName) then
		for i=1, #self.Config.RestrictedNames do
			if(name == self.Config.RestrictedNames[i]) then
				print(connection.username .. " connection refused: Illegal Name")
				return "Connection Refused: You are not allowed to use this name"
			end
		end
	end
	if(self.Config.useRestrictCharacters) then
		for i = 1, name:len() do
			if(string.find( self.Config.AllowedCharacters,name:sub(i,i):lower(), nil, true ) == nil) then
				print(connection.username .. " connection refused: Illegal Character")
				return "Connection Refused: You have illegal characters in your name"
			end
		end
	end
	print(connection.username .. " has successfully joined the server")
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\rgive.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Random Item Give"
PLUGIN.Description  = "Give players a random item"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,0,5)
PLUGIN.HasConfig    = false
PLUGIN.ResourceId	= 929

function PLUGIN:Init()
    self:LoadDefaultConfig()
	command.AddChatCommand("rgive", self.Object, "cmdGive")
end

function PLUGIN:LoadDefaultConfig()
	self.Config.Sent = self.Config.Sent or "You have sent a random item!"
	self.Config.Recieved = self.Config.Recieved or "You have recieved a random item!"
	self.Config.NoPermissionMsg = self.Config.NoPermissionMsg or "You have no permission to use this command!"
	self.Config.Items = self.Config.Items or {
	"bow_hunting",
	"knife_bone",
	"pistol_eoka",
	"pistol_revolver",
	"rifle_ak",
	"rifle_bolt",
	"shotgun_pump",
	"shotgun_waterpipe",
	"smg_thompson",
	"spear_stone",
	"spear_wooden",
	"cupboard.tool",
	"lock.code",
	"lock.key",
	"box_wooden",
	"box_wooden_large",
	"campfire",
	"furnace",
	"lantern",
	"sleepingbag",
	"bucket_helmet",
	"burlap_gloves",
	"burlap_shirt",
	"burlap_shoes",
	"burlap_trousers",
	"coffeecan_helmet",
	"hazmat_boots",
	"hazmat_gloves",
	"hazmat_helmet",
	"hazmat_jacket",
	"hazmat_pants",
	"jacket_snow",
	"jacket_snow2",
	"jacket_snow3",
	"longsleeve_tshirt",
	"metal_facemask",
	"metal_plate_torso",
	"urban_boots",
	"urban_jacket",
	"urban_pants",
	"urban_shirt",
	"vagabond_jacket",
	"axe_salvaged",
	"explosive.time",
	"hammer",
	"hammer_salvaged",
	"hatchet",
	"icepick_salvaged",
	"pickaxe",
	"stonehatchet",
	"torch",
	"antiradpills",
	"bandage",
	"largemedkit",
	"syringe_medical",
	"trap_bear",
	"F1 Grenade",
	"Acoustic Guitar",
	"Camera"
	}
end

function PLUGIN:cmdGive(player, cmd, args)
	if	player.net.connection.authLevel > 0 then
		if args.Length == 1 then
			local targetPlayer = global.BasePlayer.Find(args[0])
			local item = self.Config.Items[math.random(1, #self.Config.Items)]
			rust.RunServerCommand("inv.giveplayer " .. targetPlayer.displayName .. " " .. item)
			print("<color=orange>[rGIVE] </color>" .. item ..  " given to "  .. targetPlayer.displayName)
			rust.SendChatMessage(player, "rGIVE", "" .. self.Config.Sent)
			rust.SendChatMessage(targetPlayer, "rGIVE", "" .. self.Config.Recieved)
		else
		rust.SendChatMessage(player, "rGIVE", "Syntax: /rgive [NAME]")
		end
	else
		rust.SendChatMessage(player, "rGIVE", "" .. self.Config.NoPermissionMsg)
	end
end




--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RotAG-Banco.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RotAG-Banco"
PLUGIN.Title = "RotAG-Banco"
PLUGIN.Version = V(1, 3, 0)
PLUGIN.Description = "Bank System to use with Economics from Bombardir."
PLUGIN.Author = "TheRotAG"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 735

----------------------------------------- LOCALS -----------------------------------------
local USERS, API, base_banco, cmds, msgs  = {}, {}, {}, {}, {}
local function SendMessage(player, msg)
	player:SendConsoleCommand("chat.add \"".. msgs.ChatName.."\" \"".. msg .."\"")
end
local function HasAcces(player)
	return player:GetComponent("BaseNetworkable").net.connection.authLevel >= API.Admin_LvL
end
------------------------------------------------------------------------------------------

----------------------------------------- API -----------------------------------------
function base_banco:Set(money)
	self[1] = money
	API.SaveData()
end

function base_banco:Transfer(base_bco, money)
	if self:Withdraw(money) then
		base_bco:Deposit(money)
		return true
	else
		return false 
	end
end

function base_banco:Deposit(money)
	self:Set(self[1] + money)
end

function base_banco:Withdraw(money)
	if self[1] >= money then
		self:Set(self[1] - money)
		return true
	else
		return false
	end
end

function GetBancoAPI()
	return API
end
 
function API.SaveData()
	datafile.SaveDataTable( "Banco" )
end

function API:GetUserDataFromPlayer(player)
	return self:GetUserData(rust.UserIDFromPlayer(player))
end

function API:GetUserData(steamid)
	local data = USERS[steamid]
	if not data then
		data = {}
		data[1] = self.SaldoInicial
		setmetatable(data, {__index = base_banco})
		USERS[steamid] = data
	end
	return data
end 
---------------------------------------------------------------------------------------

function PLUGIN:Init()
	if GetEconomyAPI then
		EcoAPI = GetEconomyAPI()
	else
		print("This Bank requires Economics! Please install: http://forum.rustoxide.com/plugins/economics.717/  ")
		return 
	end 
	
	USERS = datafile.GetDataTable( "Banco" ) or {}
	
	self.BankDataFile, self.BankData = USERS or {}
	
	API.SaldoInicial = self.Config.SaldoInicial or 10000
	API.Admin_LvL = self.Config.Admin_LvL or 2
	API.Limit = self.Config.Limit or 10000000
	API.DepositFee = self.Config.DepositFee or 5
	API.WithdrawFee = self.Config.WithdrawFee or 5
	
	self.Config.Limit = API.Limit
	self.Config.DepositFee = API.DepositFee
	self.Config.WithdrawFee = API.WithdrawFee
	self.Config.SaldoInicial = API.SaldoInicial
	self.Config.Admin_LvL = API.Admin_LvL
	self.Config.BaseLimpa = self.Config.BaseLimpa or true
	
	for k, v in pairs(USERS) do
		if self.Config.BaseLimpa and v[1] == API.SaldoInicial then -- Clean Base
			USERS[k] = nil
		else
			setmetatable(USERS[k], {__index = base_banco}) -- Bind Functions
		end 
	end
	datafile.SaveDataTable( "Banco" )
	
	self.Start = self.Config.Start
	self.Limit = self.Config.Limit
	self.DepositFee = self.Config.DepositFee
	self.WithdrawFee = self.Config.WithdrawFee
	self.TransferFee = self.Config.TransferFee
	self.AllowTrans = self.Config.AllowTrans
	
	self.Config.Commands = self.Config.Commands or {}
	self.Config.Commands.BB = self.Config.Commands.BB or "bb"
	self.Config.Commands.SetBB = self.Config.Commands.SetBB or "setbb"
	self.Config.Commands.TB = self.Config.Commands.TB or "tb"
	self.Config.Commands.DB = self.Config.Commands.DB or "db"
	self.Config.Commands.WB = self.Config.Commands.WB or "wb"
	
	self.Config.Messages = self.Config.Messages or {}
	self.Config.Messages.ChatName = self.Config.Messages.ChatName or "[Bank]"
	self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "No Permission!"
	self.Config.Messages.NoPlayer = self.Config.Messages.NoPlayer or "No Player Found!"
	self.Config.Messages.MultiplePlayersFound = self.Config.Messages.MultiplePlayersFound or "Multiple players found with that info!"
	self.Config.Messages.New_Player_Balance = self.Config.Messages.New_Player_Balance or "New player balance: %s"
	self.Config.Messages.Syntax_Error = self.Config.Messages.Syntax_Error or "Syntax Error! /%s <name/steamid> <money>"
	self.Config.Messages.Withdraw_Error = self.Config.Messages.Withdraw_Error or "You don't have enough money in the bank!"
	self.Config.Messages.My_Balance = self.Config.Messages.My_Balance or "Your Balance: %s"
	self.Config.Messages.Balance = self.Config.Messages.Balance or "Player Balance: %s"
	self.Config.Messages.Transfer_Money_Error = self.Config.Messages.Transfer_Money_Error or  "You do not have enough money!"
	self.Config.Messages.Transfer_Negative_Error = self.Config.Messages.Transfer_Negative_Error or "Money can not be negative!"
	self.Config.Messages.Transfer_Error = self.Config.Messages.Transfer_Error or "You can not transfer money to yourself!"
	self.Config.Messages.Transfer_Succes = self.Config.Messages.Transfer_Succes or "You have successfully transferred money to '%s'!"
	self.Config.Messages.Own_Transfer_Succes = self.Config.Messages.Own_Transfer_Succes or "You have successfully transferred money to your bank account!"
	self.Config.Messages.Transfer_Succes_To = self.Config.Messages.Transfer_Succes_To or "'%s' has transferred money to you! Check your bank account '/bb'!"
	self.Config.Messages.Save_Succes = self.Config.Messages.Save_Succes or "Bank data saved!"
	self.Config.Messages.DepositLimit = self.Config.Messages.DepositLimit or "This deposit will make your account exceed the Limit!"
	self.Config.Messages.TransferLimit = self.Config.Messages.TransferLimit or "This transfer will make your friend's account exceed the Limit!"
	self.Config.Messages.AccLimit = self.Config.Messages.AccLimit or "Your account already reached the limit!"
	self.Config.Messages.FriendAccLimit = self.Config.Messages.FriendAccLimit or "Your friend's account already reached the limit!"
	self.Config.Messages.Help = self.Config.Messages.Help or  {"use /bb to check your Bank Balance","use /tb \\\"friend's name\\\" amount -- to transfer money from your bank account to the bank account from a friend","use /db \\\"player name\\\" amount -- to deposit the requested amount from your wallet into the target player bank account","use /wb amount -- to withdraw the requested amount from your bank account to your wallet"}
	
	cmds = self.Config.Commands
	msgs = self.Config.Messages
	self:SaveConfig()

	command.AddConsoleCommand( "bnc.c", self.Plugin, "CC_Bnc" )

	if cmds.BB ~= "" then command.AddChatCommand(cmds.BB, self.Plugin, "C_BB") end
	if cmds.SetBB ~= "" then command.AddChatCommand(cmds.SetBB, self.Plugin, "C_SetBB") end
	if cmds.TB ~= "" then command.AddChatCommand(cmds.TB, self.Plugin, "C_TB") end
	if cmds.DB ~= "" then command.AddChatCommand(cmds.DB, self.Plugin, "C_DB") end
	if cmds.WB ~= "" then command.AddChatCommand(cmds.WB, self.Plugin, "C_WB") end	
end	

function PLUGIN:SendHelpText(player)
    for i=1,#msgs.Help do
		SendMessage(player, msgs.Help[i])
	end
end

function PLUGIN:C_TB(player, cmd, args)
	if args.Length > 1 then
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[0] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			SendMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			SendMessage( player, msgs.MultiplePlayersFound )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
			
		end
		local money = tonumber(args[1])	
		if money then
			if money > 0 then
				if target then
					if (target ~= player) then
						local pID = rust.UserIDFromPlayer(target)
						local moneyCheck = API:GetUserDataFromPlayer(player)[1]
						local data = API:GetUserDataFromPlayer(target)[1]
						local targetBB = API:GetUserDataFromPlayer(target)
						local isLimit = tonumber(data)
						if(isLimit < self.Limit) then
							if (money <= self.Limit) then
								if (money <= moneyCheck) then
									if API:GetUserDataFromPlayer(player):Transfer(API:GetUserDataFromPlayer(target), money) then
										SendMessage(player, msgs.Transfer_Succes:format(target.displayName))
										print("The user "..player.displayName.." transfered "..money.." to target.displayName")
										SendMessage(target, msgs.Transfer_Succes_To:format(player.displayName))
									end
								else
									SendMessage(player, msgs.Transfer_Money_Error)
								end
							else
								SendMessage(player, msgs.TransferLimit)
								return
							end
						else
							SendMessage( player, msgs.FriendAccLimit)
							return
						end
					else
						SendMessage(player, msgs.Transfer_Error)
					end
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Transfer_Negative_Error)
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.Transfer))
		end
	else
		SendMessage(player, msgs.Syntax_Error:format(cmds.Transfer))
	end
end

function PLUGIN:C_BB(player, cmd, args)
	if args.Length > 0 then
		if HasAcces(player) then
			-- Search for the BasePlayer for the given (partial) name.
			local targetPlayer = self:FindPlayerByName( args[0] )

			-- Check if we found the targetted player.
			if #targetPlayer == 0 then
				-- The targetted player couldn't be found, send a message to the player.
				SendMessage( player, msgs.NoPlayer )

				return
			end

			-- Check if we found multiple players with that partial name.
			if #targetPlayer > 1 then
				-- Multiple players were found, send a message to the player.
				SendMessage( player, msgs.MultiplePlayersFound )

				return
			else
				-- Only one player was found, modify the targetPlayer variable value.
				target = targetPlayer[1]
				
			end
			if target then
				SendMessage(player, msgs.Balance:format( API:GetUserDataFromPlayer(target)[1] )) 
			else
				SendMessage(player, msgs.NoPlayer)
			end
		else
			SendMessage(player, msgs.NoPermission)
		end
	else
		SendMessage(player, msgs.My_Balance:format(API:GetUserDataFromPlayer(player)[1]))
	end
end

function PLUGIN:C_SetBB(player, cmd, args) 
	if HasAcces(player) then
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[0] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			SendMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			SendMessage( player, msgs.MultiplePlayersFound )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
			
		end
		if args.Length > 1 then
			local money = tonumber(args[1])
			if money then
				if target then
					local data = API:GetUserDataFromPlayer(target)
					data:Set(money)
					SendMessage(player, msgs.New_Player_Balance:format( data[1] )) 
				else
					SendMessage(player, msgs.NoPlayer)
				end
			else
				SendMessage(player, msgs.Syntax_Error:format(cmds.SetMoney))
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.SetMoney))
		end
	else
		SendMessage(player, msgs.NoPermission)
	end
end

function PLUGIN:C_DB(player, cmd, args)
	local money = 0
	local target
	if args.Length > 1 then
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[0] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			SendMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			SendMessage( player, msgs.MultiplePlayersFound )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
			
		end
		money = tonumber(args[1])
		if money then
			if money > 0 then
				if target then
					local pID = rust.UserIDFromPlayer(target)
					local depositFee = math.floor(money * (self.DepositFee / 100))
					local moneyCheck = EcoAPI:GetUserDataFromPlayer(player)[1]
					local data = API:GetUserDataFromPlayer(target)[1]
					local targetBB = API:GetUserDataFromPlayer(target)
					local isLimit = tonumber(data)
					if(isLimit < self.Limit) then
						if (money <= self.Limit) then
							if (money <= moneyCheck) then
								EcoAPI:GetUserDataFromPlayer(player):Withdraw(money)
								targetBB:Deposit(money)
								targetBB:Withdraw(depositFee)
								SendMessage(player, msgs.Transfer_Succes:format(target.displayName))
								SendMessage(target, msgs.Transfer_Succes_To:format(player.displayName))
							else
								SendMessage(player, msgs.Transfer_Money_Error)
							end
						else
							SendMessage(player, msgs.DepositLimit)
							return
						end
					else
						SendMessage( player, msgs.AccLimit)
						return
					end
				else
					return
				end
			else
				return
			end
		end
	elseif args.Length == 1 then
		money = tonumber(args[0])
		local depositFee = math.floor(money * (self.DepositFee / 100))
		local moneyCheck = EcoAPI:GetUserDataFromPlayer(player)[1]
		local data = API:GetUserDataFromPlayer(player)[1]
		local targetBB = API:GetUserDataFromPlayer(player)
		local isLimit = tonumber(data)
		local pID = rust.UserIDFromPlayer(player)
		if(isLimit < self.Limit) then
			if (money <= self.Limit) then
				if (money <= moneyCheck) then
					if (tonumber(moneyCheck) > money) then		
						EcoAPI:GetUserDataFromPlayer(player):Withdraw(money)
						targetBB:Deposit(money)
						targetBB:Withdraw(depositFee)
						SendMessage(player, msgs.Own_Transfer_Succes)
					else
						SendMessage(player, msgs.Transfer_Money_Error)
					end
				else
					SendMessage(player, msgs.Transfer_Money_Error)
				end
			else
				SendMessage(player, msgs.DepositLimit)
				return
			end
		else
			SendMessage( player, msgs.AccLimit)
			return
		end
	else
		SendMessage(player, msgs.Syntax_Error:format(cmds.DB))
	end
end

function PLUGIN:C_WB(player, cmd, args) 
	if args.Length > 0 then
		local money = tonumber(args[0])
		if money then
			local WithdrawWithFee = money + math.floor(money * (self.WithdrawFee / 100))
			local WithdrawFee = WithdrawWithFee - money	
			local balanceCheck = API:GetUserDataFromPlayer(player)[1]
			local playerBB = API:GetUserDataFromPlayer(player)
			local playerEco = EcoAPI:GetUserDataFromPlayer(player)
			if (tonumber(balanceCheck) >= WithdrawWithFee) then
				playerBB:Withdraw(WithdrawWithFee)
				playerEco:Deposit(money)
				SendMessage(player, msgs.New_Player_Balance:format( playerEco[1] ))
			else
				SendMessage(player, msgs.Withdraw_Error)
			end
		else
			SendMessage(player, msgs.Syntax_Error:format(cmds.WB))
		end
	else
		SendMessage(player, msgs.Syntax_Error:format(cmds.WB))
	end
end

function PLUGIN:CC_Bnc(arg)
	local reply = ""
	local player
	if arg.connection then
		player = arg.connection.player
	end
	if not player or HasAcces(player) then
		local cmd = arg:GetString( 0, "" )
		if cmd == "save" then
			API.SaveData()
			reply = "Banco data saved!"
		elseif cmd == "deposit" or cmd == "balance" or cmd == "withdraw" or cmd == "setmoney" then
			local steam  = arg:GetString( 1, "" )
			local target = global.BasePlayer.Find(steam)
			local userdata
			if target then
				userdata = API:GetUserDataFromPlayer( target )
				steam = target.displayName
			elseif steam:match("%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d") then
				userdata = API:GetUserData(steam)
			end
			if userdata then
				if cmd == "balance" then
					reply =  "Balance(" .. steam .. ") = " .. tostring(userdata[1]) 
				else
					local money = tonumber(arg:GetString( 2, "" ))
					if money then
						if cmd == "setmoney" then
							userdata:Set(money)
							reply = "(SetMoney) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						elseif cmd == "deposit" then
							userdata:Deposit(money)
							reply = "(Deposit) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						elseif userdata:Withdraw(money) then
							reply = "(Withdraw) New '" .. steam .. "' balance: " .. tostring(userdata[1])
						else
							reply = "This user doesn't have enough money!"
						end
					else
						reply =  "Syntax Error! (bnc.c " .. cmd .. " <steam/name> <money>)"
					end
				end
			else
				reply = "No user with steam/name: '" .. steam .. "' !"
			end
		else
			reply = "Economy Commands: 'bnc.c deposit', 'bnc.c save','bnc.c balance', 'bnc.c withdraw', 'bnc.c setmoney'"  
		end
	else
		reply = "No permission!"
	end
	arg:ReplyWith(reply)
	return true
end

function PLUGIN:FindPlayerByName( playerName )
    -- Check if a player name was supplied.
    if not playerName then return end

    -- Set the player name to lowercase to be able to search case insensitive.
    playerName = string.lower( playerName )

    -- Setup some variables to save the matching BasePlayers with that partial
    -- name.
    local matches = {}
    local itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    
    -- Iterate through the online player list and check for a match.
    while itPlayerList:MoveNext() do
        -- Get the player his/her display name and set it to lowercase.
        local displayName = string.lower( itPlayerList.Current.displayName )
        
        -- Look for a match.
        if string.find( displayName, playerName, 1, true ) then
            -- Match found, add the player to the list.
            table.insert( matches, itPlayerList.Current )
        end
    end

    -- Return all the matching players.
    return matches
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RotAG-Groups.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RotAG-Groups"
PLUGIN.Title = "RotAG-Groups"
PLUGIN.Version = V(1, 7, 3)
PLUGIN.Description = "Groups System plugin for Oxide 2.0"
PLUGIN.Author = "TheRotAG"
PLUGIN.HasConfig = true

----------------------------------------- LOCALS -----------------------------------------
local adm, cmds, msgs, sets, API, AntiSpam, sys, ginfomsg, ccolor  = {}, {}, {}, {}, {}, {}, {}, {}, ""
local timestamp = time.GetUnixTimestamp()

local function QuoteSafe(string)
    return UnityEngine.StringExtensions.QuoteSafe(string)
end

local function HasAcces(player)
	return player:GetComponent("BaseNetworkable").net.connection.authLevel >= adm.Auth_LVL
end

------------------------------------------------------------------------------------------

----------------------------------- OTHER FUNCTIONS --------------------------------------
function PLUGIN:parseHelpMsgs(player, helpmsg)
	for i=1,#helpmsg do
		self:ChatMessage(player, helpmsg[i])
	end
end

function PLUGIN:GetAllPlayers()
    itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    playerList = {}
    while itPlayerList:MoveNext() do
        table.insert(playerList,itPlayerList.Current)
    end
    return playerList
end

function PLUGIN:ChatMessage(targetPlayer, msg)
	targetPlayer:SendConsoleCommand("chat.add", 0, "<color="..ccolor..">".. msgs.ChatName.."</color> "..msg)
end

------------------------------------------------------------------------------------------

-- for future use in case of need
-- ++++++++++++++++++++++++++++++
function GetGroupsAPI() 
	return API
end

function API:GetUserDataFromPlayer(player)
	return self:GetUserData(rust.UserIDFromPlayer(player))
end

function API:GetUserData(steamid)
	local data = USERS[steamid]
	return data
end 
-- ++++++++++++++++++++++++++++++

function PLUGIN:ArgsToTable(args, src)
    local argsTbl = {}
    if src == "chat" then
        local length = args.Length
        for i = 0, length - 1, 1 do
            argsTbl[i + 1] = args[i]
        end
        return argsTbl
    end
    if src == "console" then
        local i = 1
        while args:HasArgs(i) do
            argsTbl[i] = args:GetString(i - 1)
            i = i + 1
        end
        return argsTbl
    end
    return argsTbl
end

function PLUGIN:Init()
	
	self:LoadDefaultConfig()
	
	USERS = datafile.GetDataTable( "Groups" ) or {}
	adm.Auth_LVL = self.Config.Settings.Admin_LvL or 2
	self.Config.Settings.Admin_LvL = adm.Auth_LVL
	
	cmds = self.Config.Commands
	msgs = self.Config.Messages
	sets = self.Config.Settings
	self:LoadSavedData()
    self:SaveConfig()
	
	if cmds.groupHelp ~= "" then command.AddChatCommand(cmds.groupHelp, self.Plugin, "C_groupHelp") end
	if cmds.Group ~= "" then command.AddChatCommand(cmds.Group, self.Plugin, "C_Group") end
	if cmds.GroupChat ~= "" then command.AddChatCommand(cmds.GroupChat, self.Plugin, "C_GroupChat") end
	if cmds.GroupRemove ~= "" then
		command.AddChatCommand(cmds.GroupRemove, self.Plugin, "C_GroupRemove")
		command.AddConsoleCommand( "groups.remove", self.Plugin, "CC_GroupRemove" )
	end
	if cmds.GroupFF ~= "" then command.AddChatCommand(cmds.GroupFF, self.Plugin, "C_GroupFriendlyFire") end
	
	ccolor = sets.ChatColor
	
	print("Group Data loaded! v"..tostring( self.Version ) )
end

function PLUGIN:LoadDefaultConfig()
	
	self.Config.Version = self.Config.Version or "1.7.2."
	
	if self.Config.Version and self.Config.Version ~= "1.7.2" then
		self.Config.Settings = nil
		self.Config.Settings = {}
	end
	
	self.Config.Settings = self.Config.Settings or {}
	self.Config.Settings.GroupDamage = self.Config.Settings.GroupDamage or false
	self.Config.Settings.GroupNameLength = self.Config.Settings.GroupNameLength or 6
	self.Config.Settings.ChatColor = self.Config.Settings.ChatColor or "#3afb0fff"
	self.Config.Settings.GroupChatColor = self.Config.Settings.GroupChatColor or "#008000ff"
	
	--Player cmds:
	self.Config.Commands = self.Config.Commands or {}
	self.Config.Commands.groupHelp = self.Config.Commands.groupHelp or "grouphelp"
	--Group cmds:
    self.Config.Commands.Group = self.Config.Commands.Group or "group"
	self.Config.Commands.GroupChat = self.Config.Commands.GroupChat or "gc"
	--Admin cmds:
	self.Config.Commands.GroupRemove = self.Config.Commands.GroupRemove or "gr"
	self.Config.Commands.GroupFF = self.Config.Commands.GroupFF or "gff"
	--Help:
	self.Config.Messages = self.Config.Messages or {}
	self.Config.Messages.Help = self.Config.Messages.Help or {"Group System by TheRotAG","Use /grouphelp to see all Group commands."}
	self.Config.Messages.ChatName = self.Config.Messages.ChatName or "[Group System]"
	self.Config.Messages.GChatName = self.Config.Messages.GChatName or "[Group Chat]"
	self.Config.Messages.GroupHelp = self.Config.Messages.GroupHelp or {"----------------------------------------------------------------","RPG Group Help","----------------------------------------------------------------","Use /group create \"Group Name\"  -- to create a group","Use /group invite \"Player Name\" -- invite a player to your group *Only the leader can do it*","Use /group accept -- to accept the invitation to join a group","Use /group leave -- to leave you current group **","Use /group kick \"Player Name\" -- to kick the desired player from your group","Use /group leader \"Player Name\" -- to give the desired player Leader rights","Use /group list -- to see all groups","Use /group -- to check you group name and its members","Use /gc \"message\" -- to send a message to you group","----------------------------------------------------------------","** If you are the leader of the group, by using /group leave the group will be deleted forever"}
	self.Config.Messages.AdminHelp = self.Config.Messages.AdminHelp or {"----------------------------------------------------------------","----------------------------Admin Help--------------------------","Use /gr groupname -- to remove that group","----------------------------------------------------------------"}
	self.Config.Messages.Group = self.Config.Messages.Group or "Group Name: "
	self.Config.Messages.Leader = self.Config.Messages.Leader or "Leaders: "
	self.Config.Messages.Members = self.Config.Messages.Members or "Members: "
	self.Config.Messages.InTheGroup = self.Config.Messages.InTheGroup or "You are already in this group!"
	self.Config.Messages.GNameError = self.Config.Messages.GNameError or "The group name can't have more than 6 characters"
	self.Config.Messages.NoPData = self.Config.Messages.NoPData or "No player data found!"
	self.Config.Messages.UrentInGroup = self.Config.Messages.UrentInGroup or "You aren't in a group!"
	self.Config.Messages.WrongHelp = self.Config.Messages.WrongHelp or "Wrong Command! Use /grouphelp!"
	self.Config.Messages.WrongCmd = self.Config.Messages.WrongCmd or "Use /group create \"Group Name\" to create a group"
	self.Config.Messages.InAGroup = self.Config.Messages.InAGroup or "You already have a group called: "
	self.Config.Messages.GroupExists = self.Config.Messages.GroupExists or "This group already exists!"
	self.Config.Messages.GDataError = self.Config.Messages.GDataError or "There was an error while looking for the Group Data! Report it to an ADMIN"
	self.Config.Messages.GroupCreated = self.Config.Messages.GroupCreated or "You created the group "
	self.Config.Messages.LeftGroup = self.Config.Messages.LeftGroup or "You left the group "
	self.Config.Messages.NoPlayer = self.Config.Messages.NoPlayer or "No Player Found!"
	self.Config.Messages.MultiplePlayers = self.Config.Messages.MultiplePlayers or "Multiple players found with that info!"
	self.Config.Messages.NoPtoInvite = self.Config.Messages.NoPtoInvite or "You need to input the name from whose you want to invite"
	self.Config.Messages.InviteToJoin = self.Config.Messages.InviteToJoin or " has been invited to join your group"
	self.Config.Messages.Invited = self.Config.Messages.Invited or "You were invited to the group %s, to join the group use /group accept"
	self.Config.Messages.NotInvited = self.Config.Messages.NotInvited or "You doesn't have any invite pending"
	self.Config.Messages.ReportAdmin = self.Config.Messages.ReportAdmin or "Error encountered! Report it to an admin!"
	self.Config.Messages.YouJoined = self.Config.Messages.YouJoined or "You joined the group "
	self.Config.Messages.Joined = self.Config.Messages.Joined or " joined the group!"
	self.Config.Messages.UKicked = self.Config.Messages.UKicked or "You kicked %s from your group!"
	self.Config.Messages.GotKicked = self.Config.Messages.GotKicked or "You got kicked from your group!"
	self.Config.Messages.NoGroups = self.Config.Messages.NoGroups or "There are no groups in the server at the moment"
	self.Config.Messages.WhoKick = self.Config.Messages.WhoKick or "You need to inform whose you want to kick from your group."
	self.Config.Messages.GroupsInServer = self.Config.Messages.GroupsInServer or "\n Groups in the server at the moment: \n Group: %s \n\n Leaders: \n %s \n ------------------------------------------------------"
	self.Config.Messages.NoGroup = self.Config.Messages.NoGroup or "Group not found!"
	self.Config.Messages.RemovedGroup = self.Config.Messages.RemovedGroup or "You removed the group "
	self.Config.Messages.FF = self.Config.Messages.FF or "Friendly Fire! You hit "
	self.Config.Messages.GroupFFoff = self.Config.Messages.GroupFFoff or "Group Friendly Fire turned OFF"
	self.Config.Messages.GroupFFon = self.Config.Messages.GroupFFon or "Group Friendly Fire turned ON"
	self.Config.Messages.LeaderDelGroup = self.Config.Messages.LeaderDelGroup or "Your group has been disbanded by your Leader..."
	self.Config.Messages.HasBeenKicked = self.Config.Messages.HasBeenKicked or " has been kicked from your group!"
	self.Config.Messages.RemovedAllGroups = self.Config.Messages.RemovedAllGroups or "You've WIPED you Group Data!"
	self.Config.Messages.LeaderAdded = self.Config.Messages.LeaderAdded or "%s is now a Leader from your group"
	self.Config.Messages.NoLeaderToAdd = self.Config.Messages.NoLeaderToAdd or "Use /group leader \"Player Name\" -- to add the desired player as a leader of your group"
	self.Config.Messages.LeaderToAddNotInGroup = self.Config.Messages.LeaderToAddNotInGroup or "The player name is invalid or it isn't a member from your group"
	self.Config.Messages.InviteSyntax = self.Config.Messages.InviteSyntax or "Use /group invite \"Player Name\" -- invite a player to your group *Only the leader can do it*"
	self.Config.Messages.AlreadyLeader = self.Config.Messages.AlreadyLeader or "This player is already one of your leaders"
	self.Config.Messages.AlreadyInGroup = self.Config.Messages.AlreadyInGroup or "This player is already in your group"
	self.Config.Messages.MustBeLeader = self.Config.Messages.MustBeLeader or "You must be the leader of the group to invite someone"
	self.Config.Messages.KickSyntax = self.Config.Messages.KickSyntax or "Use /group kick \"Player Name\" -- to kick the desired player from your group"
	self.Config.Messages.LeaderSyntax = self.Config.Messages.LeaderSyntax or "Use /group leader \"Player Name\" -- to give the desired player Leader rights"
end

function PLUGIN:LoadSavedData()
    GroupData           	= datafile.GetDataTable( "Groups" )
    GroupData           	= GroupData or {}
	GroupData.PlayerData	= GroupData.PlayerData or {}
	GroupData.Groups		= GroupData.Groups or {}
	self:SaveData()
end

function PLUGIN:SaveData()  
    datafile.SaveDataTable( "Groups" )
end

function PLUGIN:SendHelpText(player)
    for i=1,#msgs.Help do
		self:ChatMessage(player, msgs.Help[i])
	end
	if HasAcces(player) then
		for i=1,#msgs.AdminHelp do
			self:ChatMessage( player, msgs.AdminHelp[i] )
		end
	end
end


-- HELPs
function PLUGIN:C_groupHelp( player, cmd, args )
	self:parseHelpMsgs( player, msgs.GroupHelp )
end


--
--Group Cmds

function PLUGIN:C_Group( player, cmd, args )
	local args = self:ArgsToTable(args, "chat")
	local pID = rust.UserIDFromPlayer( player )
	local pData = GroupData.PlayerData[pID]
	local gData = GroupData.Groups
	local func, target = args[1], args[2]
	if not func then
		local gName = tostring(pData.Group)
		if not pData then
			self:ChatMessage( player, msgs.NoPData )
			return
		elseif not gName or (gName == "") then
			self:ChatMessage( player, msgs.UrentInGroup )
			return
		end
		local gLeaders = table.concat(gData[gName].LeadersNames, ", ")
		local gMembers = table.concat(gData[gName].Members, ", ")
		self:ChatMessage( player, msgs.Group .. gName )
		self:ChatMessage( player, msgs.Leader .. gLeaders )
		self:ChatMessage( player, msgs.Members .. gMembers )
		return
	end
	--Group Help misspell error
	if func == "help" then
		self:ChatMessage(player, msgs.WrongHelp)
		return
	end
	--Group Add Leader
	if func == "leader" then
		if not args[2] then
			self:ChatMessage(player, msgs.LeaderSyntax)
			return
		end
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[2] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			self:ChatMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			self:ChatMessage( player, msgs.MultiplePlayers )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
		end
		if target then
			local tID = rust.UserIDFromPlayer(target)
			local gName = GroupData.PlayerData[pID].Group
			if (gName == GroupData.PlayerData[tID].Group) then
				local isLeader = table.concat(GroupData.Groups[gName].Leaders, " ")
				if string.find(isLeader, tID) then
					self:ChatMessage(player, msgs.AlreadyLeader )
					return
				end
				table.insert(GroupData.Groups[gName].Leaders, tID)
				table.insert(GroupData.Groups[gName].LeadersNames, GroupData.PlayerData[tID].RealName)
				sys[ pID ] = ""
				ginfomsg[ pID ] = msgs.LeaderAdded:format(GroupData.PlayerData[tID].RealName)
				self:C_GroupChat( player, "", "" )
				self:SaveData()
			else
				self:ChatMessage(player, msgs.LeaderToAddNotInGroup)
			end
			return
		else
			self:ChatMessage(player, msgs.NoLeaderToAdd)
			return
		end
	end
	--Group Create
	if func == "create" then
		if not target then
			self:ChatMessage(player, msgs.WrongCmd)
			return
		end
		if string.len(target) > sets.GroupNameLength then
			self:ChatMessage( player, msgs.GNameError )
			return
		end
		local newGroup = tostring(target)
		GroupData.PlayerData[pID] = GroupData.PlayerData[pID] or {}
		GroupData.PlayerData[pID].Group = GroupData.PlayerData[pID].Group or ""
		local gName = tostring(pData.Group)
		local gData = GroupData.Groups[gName]
		if gName == newGroup and gData == newGroup then
			self:ChatMessage( player, msgs.InTheGroup )
			return
		elseif gName ~= "" then
			self:ChatMessage( player, msgs.InAGroup .. gName )
			return
		elseif GroupData.Groups[newGroup] then
			self:ChatMessage( player, msgs.GroupExists )
			return
		end
		GroupData.PlayerData[pID].Group = newGroup
		GroupData.Groups[newGroup] = GroupData.Groups[newGroup] or {}
		GroupData.Groups[newGroup].Leaders = GroupData.Groups[newGroup].Leaders or {}
		table.insert(GroupData.Groups[newGroup].Leaders, pID)
		GroupData.Groups[newGroup].LeadersNames = GroupData.Groups[newGroup].LeadersNames or {}
		table.insert(GroupData.Groups[newGroup].LeadersNames, GroupData.PlayerData[pID].RealName)
		GroupData.Groups[newGroup].Members = GroupData.Groups[newGroup].Members or {}
		GroupData.Groups[newGroup].Members = { tostring( GroupData.PlayerData[pID].RealName ) }
		self:ChatMessage( player, msgs.GroupCreated..tostring( newGroup ).."!" )
		self:SaveData()
		return
	end
	--Group Leave
	if func == "leave" then
		local gName = tostring(pData.Group)
		if (gName == nil or gName == "") then
			self:ChatMessage(player, msgs.UrentInGroup)
			return
		else
		local isLeader = table.concat(GroupData.Groups[gName].Leaders, " ")
		if string.find(isLeader, pID) then
			local playerList = self:GetAllPlayers()
			for k,pIDs in pairs(playerList) do
				local gPID = rust.UserIDFromPlayer(pIDs)
				local gCatch = GroupData.PlayerData[gPID].Group
				if gName == gCatch then
					self:ChatMessage(pIDs, msgs.LeaderDelGroup)
					GroupData.PlayerData[gPID].Group = ""
				end
			end
			GroupData.Groups[gName].Leaders = nil
			GroupData.Groups[gName].Members = nil
			GroupData.Groups[gName] = nil
		end
		GroupData.PlayerData[pID].Group = ""
		self:ChatMessage( player, msgs.LeftGroup .. gName )
		self:SaveData()
		end
		return
	end
	--Group Invite
	if func == "invite" then
		if not args[2] then
			self:ChatMessage( player, msgs.InviteSyntax )
			return
		end
		self:checkPData( player )
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[2] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			self:ChatMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			self:ChatMessage( player, msgs.MultiplePlayers )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
			
		end
		local pID = rust.UserIDFromPlayer(player)
		local gName = GroupData.PlayerData[pID].Group
		if (gName == "" or gName == nil ) then
			self:ChatMessage( player, msgs.UrentInGroup )
			return
		end
		local gLeader = table.concat(GroupData.Groups[gName].Leaders, " ")
		if target then
			local targetuserpID = rust.UserIDFromPlayer( target )
			if string.find(gLeader, pID) then	
				for _,members in pairs(GroupData.Groups[gName].Members) do
					if members == GroupData.PlayerData[targetuserpID].RealName then
						self:ChatMessage(player, msgs.AlreadyInGroup )
						return
					end
				end
			else
				self:ChatMessage(player, msgs.MustBeLeader )
				return
			end
			self:checkPData( target )
			sys[ targetuserpID ] = gName
			ginfomsg[ pID ] = GroupData.PlayerData[targetuserpID].RealName..msgs.InviteToJoin.."!"
			self:C_GroupChat(player, "", "")
			self:ChatMessage( target, msgs.Invited:format(gName))
		else
			self:ChatMessage(player, msgs.NoPtoInvite)
		end
		return
	end
	--Group Accept
	if func == "accept" then
		local Group = sys[ pID ]
		local pName = GroupData.PlayerData[pID].RealName
		if Group == "" or Group == nil then
			self:ChatMessage( player, msgs.NotInvited )
			return
		end
		local gMembers = GroupData.Groups[Group].Members
		GroupData.PlayerData[pID].Group = Group
		table.insert(gMembers, pName)
		sys[ pID ] = ""
		self:ChatMessage( player, msgs.YouJoined .. Group )
		ginfomsg[ pID ] = tostring(player.displayName)..msgs.Joined
		self:C_GroupChat( player, "", "" )
		self:SaveData()
		return
	end	
	--Group Kick
	if func == "kick" then
		if not args[2] then
			self:ChatMessage( player, msgs.KickSyntax )
			return
		end
		if not GroupData.PlayerData[pID].Group or GroupData.PlayerData[pID].Group == "" then
			self:ChatMessage( player, msgs.UrentInGroup )
			return
		end
		
		-- Search for the BasePlayer for the given (partial) name.
		local targetPlayer = self:FindPlayerByName( args[2] )

		-- Check if we found the targetted player.
		if #targetPlayer == 0 then
			-- The targetted player couldn't be found, send a message to the player.
			self:ChatMessage( player, msgs.NoPlayer )

			return
		end

		-- Check if we found multiple players with that partial name.
		if #targetPlayer > 1 then
			-- Multiple players were found, send a message to the player.
			self:ChatMessage( player, msgs.MultiplePlayers )

			return
		else
			-- Only one player was found, modify the targetPlayer variable value.
			target = targetPlayer[1]
			
		end
		local pGroup = GroupData.PlayerData[pID].Group
		if pGroup == "" or pGroup == nil then
			self:ChatMessage( player, msgs.UrentInGroup )
			return
		end
		local gMembers = GroupData.Groups[pGroup].Members
		local gLeaders, gLNames = GroupData.Groups[pGroup].Leaders, GroupData.Groups[pGroup].LeadersNames
		if target then
			local isLeader = table.concat(GroupData.Groups[pGroup].Leaders)
			local tSID = rust.UserIDFromPlayer(target)
			local rmember = GroupData.PlayerData[tSID].RealName
			if string.find(isLeader, pID) then
				if string.find(isLeader, tSID) then
					for i=0, #gLeaders do
						if gLeaders[i] == tSID then
							table.remove(gLeaders, i)
							break
						end
					end
					for i=0, #gLNames do
						if gLNames[i] == rmember then
							table.remove(gLNames, i)
							break
						end
					end
				end
				GroupData.PlayerData[tSID].Group = ""
				for i=1, #gMembers do
					if gMembers[i] == rmember then
						table.remove(gMembers, i)
						break
					end
				end
				self:ChatMessage( player, msgs.UKicked:format(rmember) )
				self:ChatMessage( target, msgs.GotKicked )
				ginfomsg[pID] = rmember..msgs.HasBeenKicked
				self:C_GroupChat( player, "", "" )
				return
			end
		else
			self:ChatMessage( player, msgs.WhoKick )
			return
		end
	end
	--Group List
	if func == "list" then
		for gName,gData in pairs(GroupData.Groups) do
			self:ChatMessage(player, "RETURN")
			if gName and (gName ~= "") then
				self:ChatMessage(player, msgs.GroupsInServer:format(tostring(gName),tostring(table.concat(GroupData.Groups[gName].LeadersNames, ", "))))
				return
			else
				self:ChatMessage( player, msgs.NoGroups )
				return
			end
		end
		self:ChatMessage( player, msgs.NoGroups )
	end
end

function PLUGIN:C_GroupChat( player, cmd, args )
	local pID = rust.UserIDFromPlayer( player )
	local pGroup = GroupData.PlayerData[pID].Group
	local rName = GroupData.PlayerData[pID].RealName
	if not args then
		return
	end
	if not pGroup or pGroup == "" then
		self:ChatMessage( player, msgs.UrentInGroup )
		return
	end
	local gmsg = ""
	if args.Length then
		for i=0, args.Length-1 do
			gmsg = gmsg..args[i].." "
		end
	else
		gmsg = ginfomsg[pID]
	end
	print( "GrpMsg - "..player.displayName..": "..gmsg )
	local playerList = self:GetAllPlayers()
    for k,pIDs in pairs(playerList) do
		local gPID = rust.UserIDFromPlayer(pIDs)
		local gCatch = GroupData.PlayerData[gPID].Group
		if pGroup == gCatch then
			ccolor = sets.GroupChatColor
			local originalChatName = msgs.ChatName
			msgs.ChatName = msgs.GChatName
			self:ChatMessage( pIDs, rName..": "..gmsg )
			msgs.ChatName = originalChatName
		end
	end
	ccolor = sets.ChatColor
end



--===============================================================================================================
--Admin Player Cmds

function PLUGIN:C_GroupRemove( player, cmd, args )
	if not HasAcces(player) then
		return
	end
	if not args[0] then
		self:parseHelpMsgs( player, msgs.AdminHelp )
		return
	end
	--Group Remove
	local groupname = tostring( args[0] )
	if groupname == "all" then
		GroupData.Groups = nil
		GroupData.Groups = {}
		GroupData.PlayerData = nil
		GroupData.PlayerData = {}
		self:ChatMessage( player, msgs.RemovedAllGroups )
		self:SaveData()
		return
	elseif not GroupData.Groups[ groupname ] then
		self:ChatMessage( player, msgs.NoGroup )
		return
	end
	for ID,PlyData in pairs(GroupData.PlayerData) do
		if PlyData.Group then
			if PlyData.Group == groupname then
				PlyData.Group = ""
			end
		end
	end
	GroupData.Groups[ groupname ] = nil
	self:ChatMessage( player, msgs.RemovedGroup..groupname.."!" )
	self:SaveData()
	return
end

function PLUGIN:CC_GroupRemove( arg )
	local reply = ""
	local player
	if arg.connection then
		player = arg.connection.player
	end
	if not player or HasAcces(player) then
	end
	--Group Remove
	local groupname = arg:GetString( 0, "" )
	--print(groupname)
	if groupname == "all" then
		GroupData.Groups = nil
		GroupData.Groups = {}
		GroupData.PlayerData = nil
		GroupData.PlayerData = {}
		arg:ReplyWith( msgs.RemovedAllGroups )
		self:SaveData()
		return
	elseif not GroupData.Groups[ groupname ] then
		arg:ReplyWith( msgs.NoGroup )
		return
	end
	for ID,PlyData in pairs(GroupData.PlayerData) do
		if PlyData.Group then
			if PlyData.Group == groupname then
				PlyData.Group = ""
			end
		end
	end
	GroupData.Groups[ groupname ] = nil
	arg:ReplyWith( msgs.RemovedGroup..groupname.."!" )
	self:SaveData()
	return
end

function PLUGIN:C_GroupFriendlyFire( player, cmd, args )
	if not HasAcces(player) then
		return
	end
	if (sets.GroupDamage == false) then
		sets.GroupDamage = true
		self:ChatMessage( player, msgs.GroupFFoff )
	else
		sets.GroupDamage = false
		self:ChatMessage( player, msgs.GroupFFon )
	end
end
--===============================================================================================================

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--Check Friendly Fire for the group

function PLUGIN:OnEntityAttacked( ent, hitinfo )
	if (not hitinfo or not ent:ToPlayer()) then return end
	if (not hitinfo.Initiator or hitinfo.damageTypes:Total() <= 0 or ent == hitinfo.Initiator) then return end
	if hitinfo.Initiator:ToPlayer() then
		aUser = hitinfo.Initiator
		aSID = rust.UserIDFromPlayer( aUser )
	else
		return
	end
	local vSID = rust.UserIDFromPlayer(ent)
	GroupData.PlayerData[aSID] = GroupData.PlayerData[aSID] or {}
	GroupData.PlayerData[aSID].Group = GroupData.PlayerData[aSID].Group or ""
	GroupData.PlayerData[vSID] = GroupData.PlayerData[vSID] or {}
	GroupData.PlayerData[vSID].Group = GroupData.PlayerData[vSID].Group or ""
    local apData = GroupData.PlayerData[aSID]
	local vpData = GroupData.PlayerData[vSID]
	if apData.Group and (apData.Group ~= "") and (apData.Group == vpData.Group) then
		if sets.GroupDamage == false then
			hitinfo.HitMaterial = 0
			hitinfo.damageTypes = new(Rust.DamageTypeList._type, nil)				
			AntiSpam[aSID] = AntiSpam[aSID] or 0
			if ( timestamp - AntiSpam[aSID] ) > 30 then
				self:ChatMessage( aUser, "Friendly Fire! You hit "..ent.displayName )
				AntiSpam[aSID] = timestamp
			end
		end
		return
	end
end


--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
--Rust Hooks


function PLUGIN:OnPlayerInit( player )
	local pID = rust.UserIDFromPlayer( player )
	self:checkPData( player )
	GroupData.PlayerData[pID].RealName = player.displayName
	print("The player "..pID.." uses the name of "..GroupData.PlayerData[pID].RealName)
	self:TagName( player )
	self:SaveData()
end

function PLUGIN:OnPlayerSpawn( player )
	local pID = rust.UserIDFromPlayer( player )
	self:checkPData( player )
	GroupData.PlayerData[pID].RealName = GroupData.PlayerData[pID].RealName or player.displayName
	self:TagName( player )
end

function PLUGIN:OnPlayerChat(arg)
	local player = arg.connection.player
	self:TagName(player)
end

--"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

--############################################################################################################
--Plugin Functions
function PLUGIN:checkPData( player )
	local pID = rust.UserIDFromPlayer( player )
	GroupData.PlayerData[pID]			= GroupData.PlayerData[pID] or {}
	GroupData.PlayerData[pID].Group		= GroupData.PlayerData[pID].Group or ""
end

function PLUGIN:TagName( player, args )
	local pID = rust.UserIDFromPlayer( player )
	local realName = GroupData.PlayerData[pID].RealName
	local gTag = ""
	if GroupData.PlayerData[pID].Group and (GroupData.PlayerData[pID].Group ~= "") then
		gTag = "["..tostring(GroupData.PlayerData[pID].Group).."] "
	else
		gTag = ""
	end
	player.displayName = gTag..realName
end

function PLUGIN:FindPlayerByName( playerName )
    -- Check if a player name was supplied.
    if not playerName then return end

    -- Set the player name to lowercase to be able to search case insensitive.
    playerName = string.lower( playerName )

    -- Setup some variables to save the matching BasePlayers with that partial
    -- name.
    local matches = {}
    local itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    
    -- Iterate through the online player list and check for a match.
    while itPlayerList:MoveNext() do
        -- Get the player his/her display name and set it to lowercase.
        local displayName = string.lower( itPlayerList.Current.displayName )
        
        -- Look for a match.
        if string.find( displayName, playerName, 1, true ) then
            -- Match found, add the player to the list.
            table.insert( matches, itPlayerList.Current )
        end
    end

    -- Return all the matching players.
    return matches
end
--############################################################################################################
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RotAG-NameChanger.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RotAG-NameChanger"
PLUGIN.Title = "RotAG-NameChanger"
PLUGIN.Version = V(2, 3, 3)
PLUGIN.Description = "NameChanger plugin for the experimental RUST branch"
PLUGIN.Author = "TheRotAG"
PLUGIN.HasConfig = true
PLUGIN.ResourceId  = 737

----------------------------------------- LOCALS -----------------------------------------
local mod, cmds, msgs, sets, pID, getNew, getOriginal  = {}, {}, {}, {}, "", "", ""

local function HasAccess(player)
	return player:GetComponent("BaseNetworkable").net.connection.authLevel >= mod.Auth_LVL
end

function PLUGIN:SendHelpText(player)
	if HasAccess(player) then
		rust.SendChatMessage(player, msgs.Help1:format(cmds.Name))
		rust.SendChatMessage(player, msgs.Help2:format(cmds.TempName))
		rust.SendChatMessage(player, msgs.Help3:format(cmds.NameOff))
	end
end
------------------------------------------------------------------------------------------

function PLUGIN:Init()
		if GetRPGAPI then
			RPGAPI = true
		end
		if GetGroupsAPI then
			GAPI = GetGroupsAPI()
		end
		
		mod.Auth_LVL = self.Config.Auth_LvL or 1
		self.Config.Auth_LvL = mod.Auth_LVL
		
		self.Config.Messages = self.Config.Messages or {}
		self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You don't have permission to use this command!"
		self.Config.Messages.Ok = self.Config.Messages.Ok or "Name changed!"
		self.Config.Messages.OriginalOk = self.Config.Messages.OriginalOk or "Default Name changed! Everytime you relog your Default Name will be loaded! Use /nameoff to load it now!"
		self.Config.Messages.ChatName = self.Config.Messages.ChatName or "[NameChanger]"
		self.Config.Messages.Help1 = self.Config.Messages.Help1 or "use /%s \\\"desired name\\\" -- to change your default name"
		self.Config.Messages.Help2 = self.Config.Messages.Help2 or "use /%s \\\"desired name\\\" -- to change your current name to a temporary one"
		self.Config.Messages.Help3 = self.Config.Messages.Help3 or "use /%s -- to load your default name"
		self.Config.Messages.Syntax = self.Config.Messages.Syntax or "Command Error! Use /%s \\\"desired name\\\""
		
		self.Config.Commands = self.Config.Commands or {}
		self.Config.Commands.Name = self.Config.Commands.Name or "name"
		self.Config.Commands.TempName = self.Config.Commands.TempName or "tempname"
		self.Config.Commands.NameOff = self.Config.Commands.NameOff or "nameoff"
		
		msgs = self.Config.Messages
		cmds = self.Config.Commands
		self:LoadSavedData()
        self:SaveConfig()
		
		if cmds.Name ~= "" then command.AddChatCommand(cmds.Name, self.Plugin, "C_Name") end
		if cmds.TempName ~= "" then command.AddChatCommand(cmds.TempName, self.Plugin, "C_TempName") end
		if cmds.NameOff ~= "" then command.AddChatCommand(cmds.NameOff, self.Plugin, "C_NameOff") end
end		

function PLUGIN:LoadSavedData()
	if not datafile.GetDataTable( "NameChanger" ) then
		self:SaveData()
	end
    NameData           	= datafile.GetDataTable( "NameChanger" )
    NameData           	= NameData or {}
	NameData.Original 	= NameData.Original or {}
	NameData.New		= NameData.New or {}
end

function PLUGIN:SaveData()  
    datafile.SaveDataTable( "NameChanger" )
end

function PLUGIN:C_Name(player, cmd, args)
	pID = rust.UserIDFromPlayer( player )
	if args.Length > 0 then
		if HasAccess(player) then
			getOriginal = tostring(args[0])
			NameData.Original[pID] = NameData.Original[pID] or {}
			NameData.Original[pID].Name = NameData.Original[pID].Name or ""
			NameData.Original[pID].Name = tostring(getOriginal)
			self:SaveData()
			rust.SendChatMessage(player, msgs.OriginalOk)
		else
			rust.SendChatMessage(player, msgs.NoPermission)
		end
	elseif NameData.Original[pID].Name and NameData.Original[pID].Name ~= "" then
		rust.SendChatMessage(player, "You name default name is "..NameData.Original[pID].Name)
	else	
		rust.SendChatMessage(player, msgs.Syntax:format(cmds.Name))
	end
end

function PLUGIN:C_TempName(player, cmd, args)
	if args.Length > 0 then
		if HasAccess(player) then
			pID = rust.UserIDFromPlayer( player )
			getOriginal = player.displayName
			getNew = tostring(args[0])
			NameData.New[pID] = NameData.New[pID] or {}
			NameData.New[pID].Name = NameData.New[pID].Name or ""
			NameData.New[pID].Name = getNew
			player.displayName = getNew
			if RPGAPI then
				RPGData.PlayerData[pID].RealName = getNew
				rust.SendChatMessage(player, "Seu nome de RPG mudou!" )
			elseif GAPI then
				GroupData.PlayerData[pID].RealName = getNew
				rust.SendChatMessage(player, "Your player name has been changed accordingly to the Groups plugin")
			end
			self:SaveData()
			rust.SendChatMessage(player, msgs.Ok)
			print(tostring(getOriginal).." changed his name to "..getNew)
		else
			rust.SendChatMessage(player, msgs.NoPermission)
		end
	else
		rust.SendChatMessage(player, msgs.Syntax:format(cmds.TempName))
	end
end

function PLUGIN:C_NameOff(player, cmd)
	if HasAccess(player) then
		pID = rust.UserIDFromPlayer(player)
		NameData.New[pID] = NameData.New[pID] or {}
		NameData.New[pID].Name = NameData.Original[pID].Name
		getNew = tostring(NameData.New[pID].Name)
		if RPGAPI then
			RPGData.PlayerData[pID].RealName = getNew
			rust.SendChatMessage(player, "Seu nome de RPG mudou!" )
		elseif GAPI then
			GroupData.PlayerData[pID].RealName = getNew
			rust.SendChatMessage(player, "Your player name has been changed accordingly to the Groups plugin")
		end
		print(player.displayName.." is now "..getNew)
		self:SaveData()
		rust.SendChatMessage(player, msgs.Ok)
	else
		rust.SendChatMessage(player, msgs.NoPermission)
		return
	end
	player.displayName = getNew
end

function PLUGIN:OnPlayerInit( player )
	if HasAccess(player) then
		local pID = rust.UserIDFromPlayer(player)
		NameData.Original[pID] = NameData.Original[pID] or {}
		NameData.Original[pID].Name = NameData.Original[pID].Name or ""
		getNew = NameData.Original[pID].Name
		if RPGAPI then
			RPGData.PlayerData[pID].RealName = getNew
			rust.SendChatMessage(player, "Seu nome de RPG mudou!" )
		elseif GAPI then
			GroupData.PlayerData[pID].RealName = getNew
			rust.SendChatMessage(player, "Your player name has been changed accordingly to the Groups plugin")
		end
		if NameData.Original[pID].Name ~= "" then
			print(player.displayName.." is now "..NameData.Original[pID].Name)
			player.displayName = getNew
		end
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RotAG-RadEvent.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RotAG-RadEvent"
PLUGIN.Title = "RotAG-RadEvent"
PLUGIN.Version = V(1, 0, 0)
PLUGIN.Description = "RadTowns Event plugin for Oxide 2.0"
PLUGIN.Author = "TheRotAG"
PLUGIN.HasConfig = true

local run = {}

function PLUGIN:Init()
	self.Config.NoRadTime = self.Config.NoRadTime or 1800
	self.Config.RadTime = self.Config.RadTime or 7200
	self.Config.ChatName = self.Config.ChatName or "[RadBroadcast]"
	self.Config.EventStart = self.Config.EventStart or "The radiations seems to be down! Now its a good time to loot everything we can!"
	self.Config.EventStop = self.Config.EventStop or "GET OUT OF THE RAD LOCATIONS NOW! THE RADIATION IS REACHING ITS PEAK AGAIN!!!"
	self:SaveConfig()
	self:RunEvent()
end

function PLUGIN:RunEvent()
	timer.Once(self.Config.RadTime, function() self:TurnRad() return end )
end

function PLUGIN:TurnRad()
	if global.server.radiation == true then
		global.server.radiation = false
		print("Rad is now disabled - RadEvent started!")
		global.ConsoleSystem.Broadcast("chat.add \"" .. self.Config.ChatName .. "\" \"" .. self.Config.EventStart .. "\"")
		timer.Once(self.Config.NoRadTime, function()
			global.server.radiation = true
			global.ConsoleSystem.Broadcast("chat.add \"" .. self.Config.ChatName .. "\" \"" .. self.Config.EventStop .. "\"")
			self:RunEvent()
			return
		end)
	else
		global.server.radiation = true
		self:RunEvent()
		return
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RotAG-Roubo.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RotAG-Roubo"
PLUGIN.Title = "RotAG-Roubo"
PLUGIN.Version = V(1, 1, 2)
PLUGIN.Description = "Robbery plugin to use with Economics plugin from Bombardir"
PLUGIN.Author = "TheRotAG"
PLUGIN.HasConfig = true
PLUGIN.ResourceId  = 736

local function SendMessage(player, msg)
	player:SendConsoleCommand("chat.add \"".. msgs.ChatName.."\" \"".. msg .."\"")
end

function PLUGIN:Init()
	if GetEconomyAPI then
		EcoAPI = GetEconomyAPI()
	else
		print("This plugin requires Economics! Please install: http://forum.rustoxide.com/plugins/economics.717/  ")
		return 
	end 

	self.Config.Settings = self.Config.Settings or {}
	self.Config.Settings.PercWake = self.Config.Settings.PercWake or 100
	self.Config.Settings.PercSlpng = self.Config.Settings.PercSlpng or 100
	
	self.Config.Messages = self.Config.Messages or {}
	self.Config.Messages.RobResult = self.Config.Messages.RobResult or "You stole $%i from %s!"
	self.Config.Messages.ChatName = self.Config.Messages.ChatName or "[SERVER]"
	
	sets = self.Config.Settings
	msgs = self.Config.Messages
	self:SaveConfig()
end

function PLUGIN:OnEntityDeath(entity, hitinfo)
	if(hitinfo == nil) then
		return
	else
		if(entity:ToPlayer()) then
			self:PlayerDeath(entity,hitinfo)
		end
	end
end

function PLUGIN:PlayerDeath(victim,hitinfo)
	if string.sub(tostring(hitinfo.damageTypes:GetMajorityDamageType()), 1, 7) ~= "Suicide" then
		if(hitinfo.Initiator:ToPlayer()) then
			local attacker = hitinfo.Initiator:ToPlayer()
			local killed = victim.displayName
			local attackerWallet = EcoAPI:GetUserDataFromPlayer(attacker)
			local victimWalletData = EcoAPI:GetUserDataFromPlayer(victim)[1]
			local victimWallet = EcoAPI:GetUserDataFromPlayer(victim)
			if(victim:IsSleeping()) then
				local cash = math.floor(victimWalletData * (sets.PercSlpng / 100))
				local cashMath = cash
				victimWallet:Transfer(attackerWallet, cash)
				SendMessage(attacker, msgs.RobResult:format(cashMath, killed))
			else
				local cash = math.floor(victimWalletData * (sets.PercWake / 100))
				local cashMath = cash
				victimWallet:Transfer(attackerWallet, cash)
				SendMessage(attacker, msgs.RobResult:format(cashMath, killed))
			end
		end
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\RustDB.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "RustDB"
PLUGIN.Title = "RustDB"
PLUGIN.Version = V(1, 2, 2)
PLUGIN.Description = "Use RustDB to protect your server and share your bans"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true
 
function PLUGIN:Init()
	--self.Config = {}
	--self:LoadDefaultConfig()
	command.AddChatCommand( "rustdb", self.Plugin, "cmdRustDB" )
	ServerInitialized = false
end
 
function urlencode(str)
   if (str) then
      str = string.gsub (str, "\n", "\r\n")
      str = string.gsub (str, "([^%w ])",
         function (c) return string.format ("%%%02X", string.byte(c)) end)
      str = string.gsub (str, " ", "+")
   end
   return str    
end



function PLUGIN:OnServerInitialized()
	ServerInitialized = true
	pluginList = plugins.GetAll()
	for i = 0, pluginList.Length - 1 do
        local pluginTitle = pluginList[i].Object.Title
        if pluginTitle == "deadPlayerList" then
            deadplayerlist = pluginList[i].Object
            break
        end
    end
end

function PLUGIN:cmdRustDB(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < 2) then
		rust.SendChatMessage(player,"[RustDB]",self.Config.Messages.NotAllowed)
		return
	end
	if(self.Config.RustDB.serverOwner == "XXXXXXXXXXXXXXXXX") then
		rust.SendChatMessage(player,"[RustDB]",self.Config.Messages.serverOwnerIsXXX)
		return
	end
	if(string.len(self.Config.RustDB.serverOwner) ~= 17 or tonumber(self.Config.RustDB.serverOwner) == nil) then
		rust.SendChatMessage(player,"[RustDB]",self.Config.Messages.serverOwnerIsWrong)
		return
	end
	if self.Config.RustDB.allowRustDBtoShowOwner then
	 show = "1"
	else
	 show = "0"
	end
	requestData = "action=owners&steamid="..tostring(self.Config.RustDB.serverOwner).."&reason="..tostring(show).."&ip="..tostring(self.Config.serverIP).."&port="..tostring(self.Config.serverPort)
	local r = webrequests.EnqueueGet("http://rustdb.net/api2.php?"..requestData, function(code, response)
		if(response == nil) then
			rust.SendChatMessage(player,"[RustDB]",self.Config.Messages.tryAgain)
			return
		end
		print(response)
		rust.SendChatMessage(player,"[RustDB]",self.Config.Messages.lookIntoConsole)
	end, self.Plugin)
end
function PLUGIN:sendToAdmins(msg)
	itPlayerList = global.BasePlayer.activePlayerList:GetEnumerator()
    playerList = {}
    while itPlayerList:MoveNext() do
        if(itPlayerList.Current:GetComponent("BaseNetworkable").net.connection.authLevel > 0) then
       		rust.SendChatMessage( itPlayerList.Current, "[RustDB]", msg )
        end
    end
end
function PLUGIN:rustDBAnswers(response)
	if(response == nil) then return end
	if(self.Config.showRustDBAnswers) then
		print(response)
	end
end
function PLUGIN:RustDBBan( sourcePlayer, name, steamID, reason )
	if(name == nil or steamID == nil or reason == nil) then
		return 
	end
	if(name == "" or string.len(steamID) ~= 17 or reason == "") then
		return
	end
	if(sourcePlayer and sourcePlayer ~= nil) then
		reason = reason .. "(" .. sourcePlayer.displayName .. ")"
	end
	requestData = "action=ban&steamid="..urlencode(tostring(steamID)).."&name="..urlencode(tostring(name)).."&reason="..urlencode(tostring(reason)).."&ip="..tostring(self.Config.serverIP).."&port="..tostring(self.Config.serverPort)
	local r = webrequests.EnqueueGet("http://rustdb.net/api2.php?"..requestData, function(code, response)
		self:rustDBAnswers(response)
	end, self.Plugin)
end

function PLUGIN:RustDBUnban( steamID )
	if(steamID == nil) then
		return 
	end
	if(string.len(steamID) ~= 17) then
		return
	end
	requestData = "action=unban&steamid="..urlencode(tostring(steamID)).."&ip="..tostring(self.Config.serverIP).."&port="..tostring(self.Config.serverPort)
	local r = webrequests.EnqueueGet("http://rustdb.net/api2.php?"..requestData, function(code, response)
		self:rustDBAnswers(response)
	end, self.Plugin)
end
function PLUGIN:BuildServerTags(tags) tags:Add("rustdb") end
function PLUGIN:OnPlayerInit( player )
	if(self.Config.onJoin.broadcastBans or self.Config.onJoin.autoKick.activated) then
		requestData = "action=banned&steamid="..rust.UserIDFromPlayer(player).."&ip="..tostring(self.Config.serverIP).."&port="..tostring(self.Config.serverPort)
		local r = webrequests.EnqueueGet("http://rustdb.net/api2.php?"..requestData, function(code, response)
			if(response == nil) then return end
			if(string.sub(response,1,1) ~= nil and string.sub(response,1,1) ~= "0" and string.sub(response,1,1) ~= "") then
				nbans = string.sub(response,1,string.find(response, "%s"))
				if(nbans ~= nil and nbans ~= "" and tonumber(nbans) ~= nil) then
					if(tonumber(nbans) > 0) then
						local reason = string.sub(response,(string.find(response, "%s")+1))
						if(string.find(reason, "<")) then reason = string.sub(reason,1,(string.find(reason, "<") - 1)) end
						if(self.Config.onJoin.autoKick.activated and tonumber(nbans) >= self.Config.onJoin.autoKick.minBansRequired) then
							rust.BroadcastChat("[RustDB]","" .. player.displayName .. " has too many bans (" .. nbans ..") on RustDB (" .. reason .. ")! Connection has been rejected")
							rust.SendChatMessage( player, "[RustDB]", "You have been a badboy and have too much bans on RustDB!!")
							Network.Net.sv:Kick(player.net.connection, "You have been a badboy and have too much bans on RustDB!!")
						elseif(self.Config.onJoin.broadcastBanned) then
							if(tonumber(nbans) > 1) then
								rust.BroadcastChat("[RustDB]","" .. player.displayName .. " has " .. nbans .. " ban entries in RustDB (" .. reason .. ")")
							else
								rust.BroadcastChat("[RustDB]","" .. player.displayName .. " has " .. nbans .. " ban entry in RustDB (" .. reason .. ")")
							end
						elseif(self.Config.onJoin.sendToAdminsBanned) then
							self:sendToAdmins("" .. player.displayName .. " has " .. nbans .. " ban entry in RustDB (" .. reason .. ")")
						end
						if(self.Config.onJoin.logBanned) then
							print("[RustDB] " .. player.displayName .. " has " .. nbans .. " ban entry in RustDB. (" .. reason .. ")")
						end
					end
				end
			end
			self:rustDBAnswers(response)
		end, self.Plugin)  
	end
end

function PLUGIN:OnRunCommand(arg, wantsfeedback)
    -- Sanity checks
    if (not arg) then return end
    if (not arg.cmd) then return end
    if (not arg.cmd.name) then return end
	if(not ServerInitialized) then return end
	if(arg.cmd.name == "ban" or arg.cmd.name == "banid") then
		if(arg.Args.Length < 2) then arg:ReplyWith(self.Config.Messages.youMustSpecifyAReason) return end
		player = nil
    	if(arg.connection and arg.connection.player) then
    		player = arg.connection.player
   		end
   		targetSteam = false
   		targetReason = false
   		targetName = false
   		targetPlayer, err = self:FindPlayer(tostring(arg.Args[0]))
		if(not targetPlayer) then
			if(tonumber(arg.Args[0]) == nil or string.len(arg.Args[0]) ~= 17) then
				arg:ReplyWith(err)
				return false
			else
				targetSteam = arg.Args[0]
			end
		else
			targetName = targetPlayer.displayName
			if(tostring(type(err)) == "table") then
				targetSteam = targetPlayer.userID
			else
				targetSteam = rust.UserIDFromPlayer(targetPlayer)
			end
		end
		if(arg.Args.Length > 2) then
			targetReason = arg.Args[2]
			targetName = arg.Args[1]
		else
			targetReason = arg.Args[1]
		end
		self:RustDBBan( player, targetName, targetSteam, targetReason )
	end
end

function PLUGIN:LoadDefaultConfig()
	self.Config.onJoin = {}
	self.Config.onJoin.broadcastBanned = true
	self.Config.onJoin.logBanned = false
	self.Config.onJoin.sendToAdminsBanned = false
	self.Config.onJoin.autoKick = {}
	self.Config.onJoin.autoKick.activated = true
	self.Config.onJoin.autoKick.minBansRequired = 1
	
	self.Config.RustDB = {}
	self.Config.RustDB.serverOwner = "XXXXXXXXXXXXXXXXX"
	self.Config.RustDB.allowRustDBtoShowOwner = true
	
	self.Config.Messages = {}
	self.Config.Messages.NotAllowed = "You are not allowed to use this command"
	self.Config.Messages.serverOwnerIsXXX = "You need to set the serverOwner SteamID64 in the configs"
	self.Config.Messages.serverOwnerIsWrong = "You didn't set a proper SteamID64."
	self.Config.Messages.tryAgain = "Couldn't contact RustDB, please try again"
	self.Config.Messages.lookIntoConsole = "Please look into your server console to see RustDB's answer"
	self.Config.Messages.youMustSpecifyAReason = "You must specify a reason to add a ban on RustDB"
	self.Config.Messages.PlayerDoesntExist  = "No players found"
	self.Config.Messages.MultiplePlayersFound = "Multiple players found"
	
	self.Config.showRustDBAnswers = true
	self.Config.serverIP = ""
	self.Config.serverPort = ""
end

function PLUGIN:FindPlayer( target )
	local steamid = false
	if(tonumber(target) ~= nil and string.len(target) == 17) then
		steamid = target
	end
	local targetplayer = false
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		local currentplayer = allBasePlayer[ i ];
		if(steamid) then
			if(steamid == rust.UserIDFromPlayer(currentplayer)) then
				return currentplayer
			end
		else
			if(currentplayer.displayName == target) then
				return currentplayer
			elseif(string.find(currentplayer.displayName,target)) then
				if(targetplayer) then
					return false, self.Config.Messages.MultiplePlayersFound
				end
				targetplayer = currentplayer
			end
		end
	end
	if(not targetplayer) then 
		if deadplayerlist then
			targetsteamid, targetplayer = deadplayerlist:FindDeadPlayer(target)
		end
		if(not targetsteamid) then
			return false, self.Config.Messages.PlayerDoesntExist 
		end
		targetplayer.userID = targetsteamid
	end
	return targetplayer
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\servertags.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Server Tags"
PLUGIN.Version = V(0, 1, 0)
PLUGIN.Description = "Adds specified tags to the existing server tags."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/764/"
PLUGIN.ResourceId = 764
PLUGIN.HasConfig = true

function PLUGIN:Init()
    self.Config.Tags = self.Config.Tags or { "custom", "pvp" }
    self:SaveConfig()
end

function PLUGIN:BuildServerTags(tags)
    for i = 1, #self.Config.Tags do tags:Add(self.Config.Tags[i]) end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\Shop.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Shop"
PLUGIN.Version = V(1, 1, 0)
PLUGIN.Description = ""
PLUGIN.Author = "Bombardir"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 721  
   
 ----------------------------------------- LOCALS -----------------------------------------
local data, API, cmds, msgs, gen  = {}, {}, {}, {}, {}
local function SendChatMessage(player, msg)
	player:SendConsoleCommand("chat.add", (msgs.ChatPlayerIcon and rust.UserIDFromPlayer(player)) or 0, msgs.ChatFormat:format(msg))
end
function PLUGIN:GeneratePriceList()
	local enum = global.ItemManager.GetItemDefinitions():GetEnumerator()
	while enum:MoveNext() do
		local bps = enum.Current:GetComponent("ItemBlueprint")
		if not bps or not bps.userCraftable then
			local name    = enum.Current.displayName.translated
			local price = data.base[name] or 0
			data.base[name] = price
			data.generated[tostring(enum.Current.itemid)] = {price, price*gen.Sell_Modificator, false, name}
		end
	end
	local ASDF = true
	while ASDF do
		ASDF = false
		local enum = global.ItemManager.GetItemDefinitions():GetEnumerator()
		while enum:MoveNext() do
			local bps = enum.Current:GetComponent("ItemBlueprint")
			if bps and bps.userCraftable then 
				local name    = tostring(enum.Current.itemid)
				data.generated[name] = {false, false, false, enum.Current.displayName.translated}
				local bp_enum = bps.ingredients:GetEnumerator()
				while bp_enum:MoveNext() do
					local ingredient = bp_enum.Current.itemDef.displayName.translated
					local ingredient_id = tostring(bp_enum.Current.itemid)
					if gen.Generate_Ingredients then
						data.generated[name][5] = data.generated[name][5] or {}
						data.generated[name][5][ingredient] = bp_enum.Current.amount
					end
					local price = data.base[ingredient] or (data.generated[ingredient_id] and data.generated[ingredient_id][1])
					if price then
						local price = price*bp_enum.Current.amount
						data.generated[name][1] = (data.generated[name][1] or 0) + price
						data.generated[name][2] = data.generated[name][1]*gen.Sell_Modificator
						data.generated[name][3] = data.generated[name][1]*gen.Blueprint_Modificator
					else
						ASDF = true
					end
				end  
			end 
		end 
	end
	self.Config.Generate.New_Price_List = false
	self.Config.PriceList = data
	self:SaveConfig()
	print("Price List Generated!")  
end 

local function FindName( name )
	name = name:lower():gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]", "%%%0")
	local finds, bool =  nil, false
	for item_id, tbl in pairs(data.generated) do
		local name2 = tbl[4]:lower()
		if name2 == name then
			finds = { item_id, tbl }
			bool  = true
			break
		end
		if name2:find(name) then
			if finds then
				if bool then
					finds = { finds[2][4], tbl[4] }
					bool = false
				else
					table.insert(finds, tbl[4])
				end
			else
				finds = { item_id, tbl }
				bool  = true
			end
		end
	end
	return bool, finds
end
------------------------------------------------------------------------------------------         
 
function PLUGIN:Init()
	if GetEconomyAPI then
		API = GetEconomyAPI()
	else
		print("This Shop requires Economics! Please install: http://forum.rustoxide.com/plugins/economics.717/  ")
		return 
	end 
	
	gen  = self.Config.Generate or {}
	gen.New_Price_List = gen.New_Price_List
	if gen.New_Price_List == nil then gen.New_Price_List = true end
	gen.Generate_Ingredients = gen.Generate_Ingredients or false
	gen.Sell_Modificator = gen.Sell_Modificator or 0.5
	gen.Blueprint_Modificator = gen.Blueprint_Modificator or 2
	gen.List_Items_Per_Page = gen.List_Items_Per_Page or 7
	self.Config.Generate = gen
	
	cmds = self.Config.Commands or {}
	cmds.Buy = cmds.Buy or "buy"
	cmds.Sell = cmds.Sell or "sell"
	cmds.List = cmds.List or "bsl"          
	self.Config.Commands = cmds        
	  
	msgs = self.Config.Message or {}
	msgs.ChatFormat = msgs.ChatFormat or "<color=#af5>[Shop]</color> %s" 
	if msgs.ChatPlayerIcon == nil then msgs.ChatPlayerIcon = true end
	msgs.Syntax_Error = msgs.Syntax_Error or "Syntax Error! /%s [\"item\" or \"item_bp\"] [<amount>]"
	msgs.Buy_Succes = msgs.Buy_Succes or  "Thank you for your purchase! We are waiting for you again! (You spent: %s)"
	msgs.Buy_Error = msgs.Buy_Error or  "You do not have enough money (still need: %s)!"
	msgs.Buy_Error2 = msgs.Buy_Error2 or  "You don't have enough space in your inventory!"
	msgs.Buy_Price = msgs.Buy_Price or  "The purchase price of this item: %s"
	msgs.Buy_Not = msgs.Buy_Not or  "This item can not be bought."
	msgs.Blueprint_Indicator = msgs.Blueprint_Indicator or "_bp"
	msgs.Sell_Succes = msgs.Sell_Succes or  "You have successfully sold item for %s!"
	msgs.Sell_Error = msgs.Sell_Error or  "You can't sell what you do not have!"
	msgs.Sell_Price = msgs.Sell_Price or  "Sale price of this item: %s"
	msgs.Sell_Not = msgs.Sell_Not or  "This item can not be sold."
	msgs.Not_Find = msgs.Not_Find or  "The item with this name can't be found in the store!"
	msgs.Matches = msgs.Matches or  "Found multiple items: %s"
	msgs.List = msgs.List or  "Name: {Name}, Price: {PPrice}, Sale: {SPrice}, Blueprint: {BPrice}"
	msgs.List_Beg = msgs.List_Beg or  "------------------- PAGE %s -------------------"
	msgs.List_No_Sale = msgs.List_No_Sale or  "no"
	msgs.List_No_Purchase = msgs.List_No_Purchase or  "no"
	msgs.List_No_Blueprint = msgs.List_No_Blueprint or  "no"
	msgs.List_End = msgs.List_End or  "-------------------------------------------------"
	msgs.Help = msgs.Help or  {"/sell \"item\" -- Shows the sales price","/sell \"item\" <amount> -- Sell item","/buy \"item\" -- Shows the purchase price","/buy \"item\" <amount> -- Buy item", "/buy \"item_bp\" <amount> -- Buy item blueprint","/bsl [<page>] -- Shows a list of the prices of a specific page"}
	self.Config.Message = msgs
 
	data = self.Config.PriceList or {}
	data.base = data.base or {}
	data.generated = data.generated or {}
	self.Config.PriceList = data
	print("Price List Loaded!") 
	self:SaveConfig()
	
	if cmds.Buy ~= "" then command.AddChatCommand(cmds.Buy, self.Plugin, "C_Buy") end
	if cmds.Sell ~= "" then command.AddChatCommand(cmds.Sell, self.Plugin, "C_Sell") end
	if cmds.List ~= "" then command.AddChatCommand(cmds.List, self.Plugin, "C_List") end
end

function PLUGIN:OnServerInitialized()
	if gen.New_Price_List then
		self:GeneratePriceList() 
	end
end

function PLUGIN:SendHelpText(player)
    for i=1,#msgs.Help do
		SendChatMessage(player, msgs.Help[i])
	end
end 

function PLUGIN:C_Buy(player, cmd, args)
	if args.Length > 0 then
		local name, count = args[0]:gsub(msgs.Blueprint_Indicator, "")
		local isBP = count > 0
		local b, tbl = FindName(name)
		if b then
			local item_price
			if isBP then 
				item_price = tbl[2][3]
			else 
				item_price = tbl[2][1]
			end
			if item_price then
				local amount = args.Length > 1 and (tonumber(args[1]) or 1)
				if amount and amount > 0 then
					amount = math.floor(amount)
					local money = (isBP and item_price) or item_price*amount
					local user_ec = API:GetUserDataFromPlayer(player) 
					if user_ec:Withdraw(money) then
						if isBP then
							--local arr = util.TableToArray( { 0 } )
							--util.ConvertAndSetOnArray( arr, 0, tonumber(tbl[1]), System.Int32._type )
							--player.blueprints:Learn(global.ItemManager.FindItemDefinition.methodarray[0]:Invoke(nil,arr))
							if player.inventory:GiveItem(global.ItemManager.CreateByItemID(tonumber(tbl[1]),1,true)) then
								SendChatMessage(player, msgs.Buy_Succes:format(money))
							else
								SendChatMessage(player, msgs.Buy_Error2)
							end
						else
							if player.inventory:GiveItem(tonumber(tbl[1]), amount, true) then
								SendChatMessage(player, msgs.Buy_Succes:format(money))
							else
								SendChatMessage(player, msgs.Buy_Error2)
							end
						end
					else
						SendChatMessage(player, msgs.Buy_Error:format(money-user_ec[1]))
					end
				else
					SendChatMessage(player, msgs.Buy_Price:format(item_price))
				end
			else
				SendChatMessage(player, msgs.Buy_Not)
			end
		elseif tbl then
			SendChatMessage(player, msgs.Matches:format(table.concat(tbl, ", ")))
		else
			SendChatMessage(player, msgs.Not_Find)
		end
	else
		SendChatMessage(player, msgs.Syntax_Error:format(cmds.Buy))
	end
end

function PLUGIN:C_Sell(player, cmd, args)
	if args.Length > 0 then
		local b, tbl = FindName(args[0])
		if b then
			local item_price = tbl[2][2]
			if item_price then
				local amount = args.Length > 1 and (tonumber(args[1]) or 1)
				if amount and amount > 0 then
					amount = math.floor(amount)
					local inv = player.inventory
					local item_id = tonumber(tbl[1])
					if inv:GetAmount(item_id) >= amount  then
						inv:Take(inv:FindItemIDs(item_id), item_id, amount)
						local money = item_price*amount
						API:GetUserDataFromPlayer(player):Deposit(money)
						SendChatMessage(player, msgs.Sell_Succes:format(money))
					else
						SendChatMessage(player, msgs.Sell_Error)
					end
				else
					SendChatMessage(player, msgs.Sell_Price:format(item_price))
				end
			else
				SendChatMessage(player, msgs.Sell_Not)
			end
		elseif tbl then
			SendChatMessage(player, msgs.Matches:format(table.concat(tbl, ", ")))
		else
			SendChatMessage(player, msgs.Not_Find)
		end
	else
		SendChatMessage(player, msgs.Syntax_Error:format(cmds.Sell))
	end
end
 

function PLUGIN:C_List(player, cmd, args)
	local amount = (args.Length > 0 and tonumber(args[0])) or 1
	amount = math.floor(amount)
	local list_cur = 1
	local list_beh = (amount-1)*gen.List_Items_Per_Page
	local list_end = list_beh + gen.List_Items_Per_Page
	SendChatMessage(player, msgs.List_Beg:format(amount) )
	for _, table in pairs(data.generated) do
		if list_cur >= list_beh then
			if list_cur < list_end then
				SendChatMessage(player, msgs.List:gsub("{PPrice}", table[1] or msgs.List_No_Purchase):gsub("{SPrice}", table[2] or msgs.List_No_Sale):gsub("{BPrice}", table[3] or msgs.List_No_Blueprint):gsub("{Name}", table[4]) )
			else
				break
			end
		end
		list_cur = list_cur + 1    
	end
	SendChatMessage(player, msgs.List_End)
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\spawns.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Spawns Database"
PLUGIN.Title = "Spawns Database"
PLUGIN.Version = V(1, 0, 4)
PLUGIN.Description = "Set Custom Spawns"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true
---------- TO DO LIST ----------
-- /spawns_list --
-- /spawns_tp NUMBER - to teleport to the spawns number (good to see which one to remove or not)
--------------------------------
function PLUGIN:Init()
	self:InitializeCommands()
	self.Data = {}
	LoadedSpawns = {}
end
function PLUGIN:InitializeCommands()
	command.AddChatCommand( "spawns_new",  self.Plugin, "cmdSpawnsNew" )
	command.AddChatCommand( "spawns_add",  self.Plugin, "cmdSpawnsAdd" )
	command.AddChatCommand( "spawns_remove",  self.Plugin, "cmdSpawnsRemove" )
	command.AddChatCommand( "spawns_save",  self.Plugin, "cmdSpawnsSave" )
	command.AddChatCommand( "spawns_open",  self.Plugin, "cmdSpawnsOpen" )
	command.AddChatCommand( "spawns_close",  self.Plugin, "cmdSpawnsClose" )
	command.AddChatCommand( "spawns_help",  self.Plugin, "cmdSpawnsHelp" )
end
local function ChatMessage(player,msg)
	player:SendConsoleCommand( "chat.add \"SERVER\" \"" .. msg .. "\"" );
end
function PLUGIN:LoadDefaultConfig()
	self.Config.Settings = {}
	self.Config.Settings.authLevel = 1
	self.Config.Messages = {}
	self.Config.Messages.NotAllowed = "You are not allowed to use this command"
	self.Config.Messages.AlreadyCreatingSpawnFile = "You are already creating a spawn file"
	self.Config.Messages.CreatingANewSpawnFile = "You are now creating a new spawn file"
	self.Config.Messages.NotMakingASpawnFile = "You need to start a new spawnfile first: /spawns_new"
	self.Config.Messages.SuccessfullyAddASpawn = "You have successfully added a spawn point"
	self.Config.Messages.ErrorTryAgain = "An Error occured, please try again."
	self.Config.Messages.YouNeedToSetANumber = "You need to set a number"
	self.Config.Messages.NumberOutOfRange = "This number is out of range"
	self.Config.Messages.SuccessfullyRemovedASpawn = "You have successfully removed a spawn point"
	self.Config.Messages.SuccessfullyClosed = "You have successfully closed the spawnfile without saving"
	self.Config.Messages.YouNeedToSetAFileName = "You need to set a filename"
	self.Config.Messages.NoSpawnsSet = "No Spawns were set"
	self.Config.Messages.SuccessfullySavedFile = "You have successfully saved the file"
	self.Config.Messages.SpawnFileIsEmpty = "Spawnfile is Empty"
	self.Config.Messages.SuccessfullyOpenedFile = "You have successfully opened the file"
	self.Config.Messages.Help = {}
	self.Config.Messages.Help[1] = "Start by making a new data with: /spawns_new"
	self.Config.Messages.Help[2] = "Add new spawn points where you are standing with /spawns_add"
	self.Config.Messages.Help[3] = "Remove a spawn point that you didn't like with /spawns_remove NUMBER"
	self.Config.Messages.Help[4] = "Save the spawn points into a file with: /spawns_save FILENAME"
	self.Config.Messages.Help[5] = "Use /spawns_open later on to open it back and edit it"
	self.Config.Messages.Help[6] = "Use /spawns_close to stop setting points without saving"
end

function PLUGIN:cmdSpawnsNew( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(self.Data[player]) then ChatMessage(player, self.Config.Messages.AlreadyCreatingSpawnFile ) return end
	self.Data[player] = {}
	ChatMessage(player, self.Config.Messages.CreatingANewSpawnFile )
end
function PLUGIN:cmdSpawnsOpen( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(self.Data[player]) then ChatMessage(player, self.Config.Messages.AlreadyCreatingSpawnFile ) return end
	if(args.Length == 0) then ChatMessage(player, self.Config.Messages.YouNeedToSetAFileName ) return end
	local DataFile = datafile.GetDataTable( tostring(args[0]) )
	DataFile = DataFile or {}
	local empty = true
	self.Data[player] = {}
	for k,v in pairs( DataFile ) do
		if(k and v) then 
			self.Data[player][tonumber(k)] = v
			empty = false 
		end
	end
	if(empty) then ChatMessage(player, self.Config.Messages.SpawnFileIsEmpty .. " ("..args[0]..")" ) return end
	ChatMessage(player, self.Config.Messages.SuccessfullyOpenedFile .. " ("..args[0]..")" )
end

function PLUGIN:cmdSpawnsAdd( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(not self.Data[player]) then ChatMessage(player, self.Config.Messages.NotMakingASpawnFile ) return end
	if(not player.transform or (player.transform and not player.transform.position)) then ChatMessage(player, self.Config.Messages.ErrorTryAgain ) return end
	local coords = {}
	coords["x"] = math.ceil( (player.transform.position.x)*100)/100
	coords["y"] = math.ceil( player.transform.position.y )
	coords["z"] = math.ceil( (player.transform.position.z)*100)/100
	table.insert(self.Data[player],coords)
	ChatMessage(player, self.Config.Messages.SuccessfullyAddASpawn .. " (n" .. #self.Data[player] .. ")")
end

function PLUGIN:cmdSpawnsRemove( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(not self.Data[player]) then ChatMessage(player, self.Config.Messages.NotMakingASpawnFile ) return end
	if(args.Length == 0) then ChatMessage(player, self.Config.Messages.YouNeedToSetANumber ) return end
	if(tonumber(args[0])==nil) then ChatMessage(player, self.Config.Messages.YouNeedToSetANumber ) return end
	if(tonumber(args[0]) > #self.Data[player]) then ChatMessage(player, self.Config.Messages.NumberOutOfRange ) return end
	table.remove(self.Data[player],tonumber(args[0]))
	ChatMessage(player, self.Config.Messages.SuccessfullyRemovedASpawn .. " (n" .. args[0] .. ")")
end

function PLUGIN:cmdSpawnsSave( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(not self.Data[player]) then ChatMessage(player, self.Config.Messages.NotMakingASpawnFile ) return end
	if(#self.Data[player]==0) then ChatMessage(player, self.Config.Messages.NoSpawnsSet ) return end
	if(args.Length == 0) then ChatMessage(player, self.Config.Messages.YouNeedToSetAFileName ) return end
	local DataFile = datafile.GetDataTable( tostring(args[0]) )
	DataFile = DataFile or {}
	for i,d in pairs(DataFile) do
		DataFile[i] = nil
	end
	for i=1, #self.Data[player] do
		DataFile[tostring(i)] = self.Data[player][i]
	end 
	datafile.SaveDataTable( tostring(args[0]) )
	if(LoadedSpawns[tostring(args[0])]) then LoadedSpawns[tostring(args[0])] = false end
	self.Data[player] = nil
	ChatMessage(player, self.Config.Messages.SuccessfullySavedFile .. " (" .. args[0] .. ".json)")
end

function PLUGIN:cmdSpawnsClose( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	if(not self.Data[player]) then ChatMessage(player, self.Config.Messages.NotMakingASpawnFile ) return end
	self.Data[player] = nil
	ChatMessage(player, self.Config.Messages.SuccessfullyClosed )
end

function PLUGIN:GetSpawnsCount( filename )
	local count = 0
	local DataFile = datafile.GetDataTable( filename )
	DataFile = DataFile or {}
	for k,v in pairs( DataFile ) do
		if(k and v) then 
			count = count + 1
		end
	end
	if(count == 0) then return false, "This file doesn't exist or is empty" end
	return count
end
local function loadSpawnfile( filename )
	local DataFile = datafile.GetDataTable( filename )
	DataFile = DataFile or {}
	local empty = true
	for k,v in pairs( DataFile ) do
		if(k and v) then
			empty = false
			break
		end
	end
	if(empty) then return false, "This file doesn't exist or is empty" end
	LoadedSpawns[filename] = {}

	for k,v in pairs( DataFile ) do
		if(k and v) then
			LoadedSpawns[filename][tonumber(k)] = v
		end
	end
	return true
end
function PLUGIN:GetRandomSpawn( filename , max )
	if(not LoadedSpawns[filename]) then
		local success, err = loadSpawnfile(filename)
		if(not success) then return false, err end
	end
	if(not LoadedSpawns[filename][max]) then return false, "This spawn number is out of range" end
	return LoadedSpawns[filename][math.random(max)]
end
function PLUGIN:GetRandomSpawnVector3( filename , max )
	if(not LoadedSpawns[filename]) then
		local success, err = loadSpawnfile(filename)
		if(not success) then return false, err end
	end
	if(not LoadedSpawns[filename][max]) then return false, "This spawn number is out of range" end
	newPos = new( UnityEngine.Vector3._type, nil);
	spawndata = LoadedSpawns[filename][math.random(max)]
	newPos.x = spawndata.x
	newPos.y = spawndata.y
	newPos.z = spawndata.z
	return newPos
end
function PLUGIN:GetSpawn( filename , number )
	if(not LoadedSpawns[filename]) then
		local success, err = loadSpawnfile(filename)
		if(not success) then return false, err end
	end
	if(not LoadedSpawns[filename][number]) then return false, "This spawn number is out of range" end
	return LoadedSpawns[filename][number]
end

function PLUGIN:OnPlayerDisconnected(player,connection)
	if (self.Data[player]) then
		self.Data[player] = nil
	end
end
function PLUGIN:cmdSpawnsHelp( player, cmd, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then ChatMessage(player, self.Config.Messages.NotAllowed ) return end
	for i=1, #self.Config.Messages.Help do
		ChatMessage(player, self.Config.Messages.Help[i] )
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\spectateMgr.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "spectateMgr"
PLUGIN.Title = "Spectate Manager"
PLUGIN.Description = "Manage and log use of spectate on server"
PLUGIN.Author = "OHG"
PLUGIN.Version = V(0, 0, 1)
PLUGIN.HasConfig = false
PLUGIN.Debug = false

function PLUGIN:OnRunCommand( arg, player, cmd )
    if (not arg) then
		return
	end

	if (not arg.connection) then
		return
	end

	if (not arg.connection.player) then
		return
	end

	local lPlayer = arg.connection.player

	if ( arg.cmd ) then
		if ( arg.cmd.name == "spectate" ) then
			print ( ".::(TRACE - OnRunCommand) spectate: " .. tostring ( lPlayer.displayName ) )
			return true
		end
	end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\spectatePlayer.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Spectate Admin Handler"
PLUGIN.Title = "Spectate Admin Handler"
PLUGIN.Version = V(1, 0, 3)
PLUGIN.Description = "Choose who to spectate, hopefully a temporary plugin"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true

function PLUGIN:Init()
	command.AddConsoleCommand("spectate.player", self.Plugin, "ccmdSpectatePlayer")
	print(tostring(global.Type.Dead))
end

function PLUGIN:LoadDefaultConfig()
	self.Config.authLevel = 1
end

function PLUGIN:ccmdSpectatePlayer(arg)
	if not arg.connection then
        arg:ReplyWith("You must be a player to use this command.")
        return
    end
    sourcePlayer = arg.connection.player
    if (sourcePlayer:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.authLevel)  then
        arg:ReplyWith("You are not allowed to use this command.")
        return
    end
    if(arg.Args.Length == 0) then
    	arg:ReplyWith("You must specify a player name/steamid to spectate.")
    	return
    end
    targetPlayer, err = self:FindPlayer(arg.Args[0])
    if(not targetPlayer) then
    	arg:ReplyWith(err)
    	return
    end
    if(not sourcePlayer:IsSpectating() and not sourcePlayer:IsDead()) then
    	sourcePlayer:Hurt(1000,Rust.DamageType.Suicide,nil)
    end
    --[[print(tostring(global.Type.Spectating))
    sourcePlayer:ChangePlayerState(global.Type.Spectating,false)
    sourcePlayer:GetComponentInParent(global.BaseEntity._type):CancelInvoke("MetabolismUpdate")
    sourcePlayer:GetComponentInParent(global.BaseEntity._type):CancelInvoke("InventoryUpdate")]]
    timer.Once(0.1, function()
		if( not sourcePlayer:IsSpectating() ) then sourcePlayer:StartSpectating() end
		rust.SendChatMessage(sourcePlayer,"Spectating: " .. targetPlayer.displayName .. " - " .. rust.UserIDFromPlayer(targetPlayer))
		sourcePlayer:SetParent(targetPlayer)
    end)
end


function PLUGIN:FindPlayer( target )
	local steamid = false
	if(tonumber(target) ~= nil and string.len(target) == 17) then
		steamid = target
	end
	local targetplayer = false
	local allBasePlayer = UnityEngine.Object.FindObjectsOfTypeAll(global.BasePlayer._type)
	for i = 0, tonumber(allBasePlayer.Length - 1) do
		local currentplayer = allBasePlayer[ i ];
		if(steamid) then
			if(steamid == rust.UserIDFromPlayer(currentplayer)) then
				return currentplayer
			end
		else
			if(currentplayer.displayName == target) then
				return currentplayer
			elseif(string.find(currentplayer.displayName,target)) then
				if(targetplayer) then
					return false, "Multiple players found."
				end
				targetplayer = currentplayer
			end
		end
	end
	if(not targetplayer) then return false, "No players found." end
	return targetplayer
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\stickynotes.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "Sticky Notes"
PLUGIN.Title = "Sticky Notes"
PLUGIN.Version = V(1, 1,1)
PLUGIN.Description = "Place sticky notes for other players to read"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true

local DataFile = "stickynotes"
local NotesData = {}
local PlayersData = {}
local RadiationZonesNote = {}
 
function PLUGIN:Init()
	command.AddChatCommand( "note", self.Plugin, "cmdNote" )
	command.AddChatCommand( "note_reset", self.Plugin, "cmdNoteReset" )
	command.AddChatCommand( "note_count", self.Plugin, "cmdNoteCount" )
	command.AddChatCommand( "note_read", self.Plugin, "cmdNoteRead" )
	--self.Config = {}
	--self:LoadDefaultConfig()
	self:LoadDataFile()
	
	
end
function PLUGIN:OnServerInitialized()
	pcall(new, UnityEngine.Vector3._type, nil)
    pcall(new, UnityEngine.Quaternion._type , nil)
	newpos = new( UnityEngine.Vector3._type , nil )
	newrot = new( UnityEngine.Quaternion._type , nil )
	self:InitNotes()
	
end
function PLUGIN:LoadDefaultConfig()
	self.Config.Settings = {}
	self.Config.Settings.authLevel = 1
	self.Config.Settings.messageName = "Sticky-Note"
	
	self.Config.Messages = {}
	self.Config.Messages.NoPermissions = "You do not have the permission to use this command"
	self.Config.Messages.NoMoreStickyNotesLeft = "You are not allowed to add any other sticky notes at the moment"
	self.Config.Messages.WrongNoteArgument1 = "You must add a message after /note"
	self.Config.Messages.NoMessageSet = "You didnt put any message"
	self.Config.Messages.NoSourcePlayer = "No players set as adding the note"
	self.Config.Messages.SuccessfullyAddedTheStickyNote = "You successfully added the sticky note"
	self.Config.Messages.YouMustSpecifyASteamID = "You must specify a steamID"
	self.Config.Messages.NewMessage = "You've got a new message from: "
	self.Config.Messages.MessageAutoDestroyed = "This sticky note was auto destroyed"
	self.Config.Messages.NotesDeletedAroundPos = " notes were deleted around your position"
	self.Config.Messages.NoNotesAroundYou = "No notes were found around your position"
	self.Config.Messages.SuccessfullyResetNotes = "Successfully resetted all notes"
	self.Config.Messages.CountNotes = " total notes deployed"
	
	self.Config.Messages.NoteCMD0 = "/note \"Message\" - to add a sticky note where you are for players to see when they come here"
	self.Config.Messages.NoteCMD1 = "/note - to remove sticky notes where you are standing at"
	self.Config.Messages.NoteCMDAdmin0 = "/note_reset - to reset all notes"
	self.Config.Messages.NoteCMDAdmin1 = "/note_count - to see how many notes are around the map"
	self.Config.Messages.NoteCMDAdmin2 = "/note_read RADIUS - Read all notes around you in the radius (default is 30m)"
	self.Config.StickyNotes = {}
	self.Config.StickyNotes.zoneRadius = 2
	self.Config.StickyNotes.timeBeforeDestroy = 86400 -- 1 day
	self.Config.StickyNotes.maxStickyNotesPerPlayer = 5
	self.Config.StickyNotes.levelForCommandUsage = 0
	self.Config.StickyNotes.overRideLimitAuthLevel = 1
	self.Config.StickyNotes.anonymous = false
end
local function newTriggerBase(x,y,z,rad)
	trigger = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerRadiation._type)
	
	newgameobj = new( UnityEngine.GameObject._type , nil )
	newpos = newgameobj:GetComponent(UnityEngine.Transform._type).position
	newgameobj.layer = UnityEngine.LayerMask.NameToLayer("Trigger")
	newpos.x = x
	newpos.y = y
	newpos.z = z
	newgameobj.name = "Sticky Notes"
	newgameobj:GetComponent(UnityEngine.Transform._type).position = newpos
	newgameobj:AddComponent(UnityEngine.SphereCollider._type)
	newgameobj:GetComponent(UnityEngine.SphereCollider._type).radius = rad
	newgameobj:SetActive(true);
	newgameobj:AddComponent(global.TriggerBase._type)
	newgameobj:GetComponent(global.TriggerBase._type).interestLayers = trigger[trigger.Length-1]:GetComponent(global.TriggerBase._type).interestLayers
	return newgameobj:GetComponent(global.TriggerBase._type)
end 

function PLUGIN:LoadDataFile()
    local data = datafile.GetDataTable("stickynotes")
    NotesData = data or {}
end
function PLUGIN:SaveData()
    datafile.SaveDataTable("stickynotes")
end
local function Distance2D(p1, p2)
    return math.sqrt(math.pow(p1.x - p2.x,2) + math.pow(p1.z - p2.z,2)) 
end
local function GetFreeID(steamID)
	if(not NotesData[steamID]) then NotesData[steamID] = {} return 1 end
	for i=1,10000 do
		if(not NotesData[steamID][tostring(i)]) then
			return i
		end
	end
	return false
end

local function addPlayerZone(steamid,zone)
	if(not PlayersData[steamid]) then PlayersData[steamid] = {} end
	PlayersData[steamid][zone] = true
end
local function createZone(steamID,freeid,data)
	newpos.x = data.position.x
	newpos.y = data.position.y
	newpos.z = data.position.z
	local newBaseEntity = newTriggerBase(data.position.x, data.position.y, data.position.z, self.Config.StickyNotes.zoneRadius)
	if(not newBaseEntity) then
		print("Error while making a sticky note, couldn't create a new zone")
		return false
	end
	RadiationZonesNote[newBaseEntity] = {
					name=data.from,
					message=data.msg,
					origin=steamID,
					started=data.addTime,
					originid=tostring(freeid)
				}
	addPlayerZone(steamID,newBaseEntity)
				
end
local function isZone(steamID,freeid,data)
	allRadiationZone = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
	for i=0, allRadiationZone.Length-1 do
		if(allRadiationZone[i].gameObject.name == "Sticky Notes") then
			if(allRadiationZone[i]:GetComponent(UnityEngine.Transform._type).transform.position.x == data.position.x and allRadiationZone[i]:GetComponent(UnityEngine.Transform._type).transform.position.z == data.position.z) then
				RadiationZonesNote[allRadiationZone[i]] = {
					name=data.from,
					message=data.msg,
					origin=steamID,
					started=data.addTime,
					originid=tostring(freeid)
				}
				addPlayerZone(steamID,allRadiationZone[i])
				return true
			end
		end
	end
	return false
end
function PLUGIN:removeNotesByPos(pos)
	count = 0
	allRadiationZone = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
	for i=0, allRadiationZone.Length-1 do
		if(allRadiationZone[i].gameObject.name == "Sticky Notes") then
			if(RadiationZonesNote[allRadiationZone[i]]) then
				if(Distance2D(allRadiationZone[i]:GetComponent(UnityEngine.Transform._type).transform.position,pos) <= self.Config.StickyNotes.zoneRadius) then
					count = count + 1
					allRadiationZone[i]:RemoveObject(allRadiationZone[i].gameObject)
					NotesData[RadiationZonesNote[allRadiationZone[i]].origin][RadiationZonesNote[allRadiationZone[i]].originid] = nil
					PlayersData[RadiationZonesNote[allRadiationZone[i]].origin][RadiationZonesNote[allRadiationZone[i]]] = nil
					RadiationZonesNote[allRadiationZone[i]] = nil
				end
			end
		end
	end
	self:SaveData()
	return count
end
local function removeZone(steamID,freeid)
	allRadiationZone = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
	for i=0, allRadiationZone.Length-1 do
		if(allRadiationZone[i].gameObject.name == "Sticky Notes") then
			if(RadiationZonesNote[allRadiationZone[i]]) then
				if(RadiationZonesNote[allRadiationZone[i]].origin == steamID and RadiationZonesNote[allRadiationZone[i]].originid == freeid) then
					allRadiationZone[i]:RemoveObject(allRadiationZone[i].gameObject)
					RadiationZonesNote[allRadiationZone[i]] = nil
					return true
				end
			end
		end
	end
	return false
end
function PLUGIN:InitNotes()
	for steamid, data in pairs(NotesData) do
		for i, zonedata in pairs(data) do
			if(not isZone(steamid,i,zonedata)) then
				createZone(steamid,i,zonedata)
			end
		end
	end
end
function PLUGIN:addZone(steamid,pos,zoneradius,name,message)
	freeid = GetFreeID(steamid)
	NotesData[steamid][tostring(freeid)] = {
		from=name,
		msg=message,
		position = {
			x=pos.x,
			y=pos.y,
			z=pos.z
		},
		zradius=tonumber(zoneradius),
		addTime=time.GetUnixTimestamp()
	}
	createZone(steamid,freeid,NotesData[steamid][tostring(freeid)])
	self:SaveData()
	return true
end

function PLUGIN:countNotes(steamID)
	if(not PlayersData[steamID]) then return 0 end
	count = 0
	for zone, s in pairs(PlayersData) do
		count = count + 1
	end
	return count
end
function PLUGIN:tryAddNote(player,message)
	name = "Anonymous"
	if(not player or not player.displayName) then
		return false, self.Config.Messages.NoSourcePlayer
	end
	if(not self.Config.StickyNotes.anonymous) then
		name = player.displayName
	end
	if(message == nil or message == "" or message == " ") then
		return false, self.Config.Messages.NoMessageSet
	end
	steamid = rust.UserIDFromPlayer(player)
	if(self:countNotes(steamid) >= self.Config.StickyNotes.maxStickyNotesPerPlayer and player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.StickyNotes.overRideLimitAuthLevel) then
		return false, self.Config.Messages.NoMoreStickyNotesLeft
	end
	success, err = self:addNote(steamid,player.transform.position,self.Config.StickyNotes.zoneRadius,name,message)
	if(not success) then
		return false, err
	end
	return success
end
function PLUGIN:removeNote(steamid,freeid)
	if(tonumber(freeid) == nil) then
		print("Error while trying to remove a sticky note from: " .. steamid)
		return false
	end
	if(tonumber(steamid) == nil) then
		print("Error while trying to remove a sticky note, couldn't get the steamID")
		return false
	end
	freeid = tostring(freeid)
	success = removeZone(steamid,freeid)
	NotesData[steamid][freeid] = nil
	if(not success) then
		print("No zones found while trying to remove note from " .. steamid .. " n ".. freeid)
		return false
	end
	return true
end
function PLUGIN:addNote(steamid,position,zradius,name,message)
	if(not steamid) then steamid = 10000000000000000 end
	if(not name) then name = "Anonymous" end
	if(not message) then return false, self.Config.Messages.NoMessageSet end
	if(tonumber(zradius) == nil) then return false, "Radius needs to be a number" end
	self:addZone(steamid,position,zradius,name,message)
	return self.Config.Messages.SuccessfullyAddedTheStickyNote
end
function PLUGIN:cmdNoteReset(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoPermissions)
		return
	end
	for k,v in pairs(NotesData) do
		for i,u in pairs(v) do
			removeZone(k,i)
			NotesData[k][i] = nil
		end
		NotesData[k] = nil
	end
	NotesData = {}
	self:SaveData()
	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.SuccessfullyResetNotes)
end
function PLUGIN:cmdNoteCount(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoPermissions)
		return
	end
	count = 0
	for k,v in pairs(PlayersData) do
		for i,u in pairs(v) do
			count = count+1
		end
	end
	rust.SendChatMessage(player,self.Config.Settings.messageName,count .. self.Config.Messages.CountNotes)
end
function PLUGIN:cmdNoteRead(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.Settings.authLevel) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoPermissions)
		return
	end
	dist = 30
	if(args.Length >= 1) then
		if(tonumber(args[0]) ~= nil) then
			dist = tonumber(args[0])
		end
	end
	allRadiationZone = UnityEngine.Object.FindObjectsOfTypeAll(global.TriggerBase._type)
	for i=0, allRadiationZone.Length-1 do
		if(allRadiationZone[i].gameObject.name == "Sticky Notes") then
			if(RadiationZonesNote[allRadiationZone[i]]) then
				if(Distance2D(allRadiationZone[i]:GetComponent(UnityEngine.Transform._type).transform.position,player.transform.position) <= dist) then
					rust.SendChatMessage(player,self.Config.Settings.messageName,math.ceil(Distance2D(allRadiationZone[i]:GetComponent(UnityEngine.Transform._type).transform.position,player.transform.position)*10)/10 .. "m - " .. RadiationZonesNote[allRadiationZone[i]].origin .. " - " .. RadiationZonesNote[allRadiationZone[i]].originid .. " - " .. RadiationZonesNote[allRadiationZone[i]].message)
				end
			end
		end
	end
end
function PLUGIN:cmdNote(player,cmd,args)
	if(player:GetComponent("BaseNetworkable").net.connection.authLevel < self.Config.StickyNotes.levelForCommandUsage) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoPermissions)
		return
	end
	if(args.Length == 0) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.WrongNoteArgument1)
		success = self:removeNotesByPos(player.transform.position)
		if(success > 0) then
			rust.SendChatMessage(player,self.Config.Settings.messageName,success .. self.Config.Messages.NotesDeletedAroundPos)
		else
			rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoNotesAroundYou)
		end
		return
	end
	msg = ""
	for i=0,args.Length-1 do
		msg = msg .. args[i] .. " "
	end
	success, err = self:tryAddNote(player,msg)
	if(not success) then
		rust.SendChatMessage(player,self.Config.Settings.messageName,err)
		return
	end
end

function PLUGIN:OnEntityEnter(triggerbase,entity)
	if(entity:GetComponentInParent(global.BasePlayer._type)) then
		if(RadiationZonesNote[triggerbase]) then
			rust.SendChatMessage(entity,self.Config.Settings.messageName,self.Config.Messages.NewMessage .. tostring(RadiationZonesNote[triggerbase].name))
			rust.SendChatMessage(entity,self.Config.Settings.messageName,tostring(RadiationZonesNote[triggerbase].message))
			if( (time.GetUnixTimestamp() - RadiationZonesNote[triggerbase].started) >=  self.Config.StickyNotes.timeBeforeDestroy ) then
				triggerbase:RemoveObject(triggerbase.gameObject)
				rust.SendChatMessage(entity,self.Config.Settings.messageName,self.Config.Messages.MessageAutoDestroyed)
				NotesData[RadiationZonesNote[triggerbase].origin][RadiationZonesNote[triggerbase].originid] = nil
				PlayersData[RadiationZonesNote[triggerbase].origin][RadiationZonesNote[triggerbase]] = nil
				RadiationZonesNote[triggerbase] = nil
				self:SaveData()
			end
		end
	end
end

function PLUGIN:SendHelpText(player)
	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoteCMD0)
	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoteCMD1)
    if(player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Config.Settings.authLevel) then
    	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoteCMDAdmin0)
    	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoteCMDAdmin1)
    	rust.SendChatMessage(player,self.Config.Settings.messageName,self.Config.Messages.NoteCMDAdmin2)
    end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\suicide.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "suicide"
PLUGIN.Title = "Suicide & Kill"
PLUGIN.Version = V(0, 1, 2)
PLUGIN.Description = "Suicide & Kill chat command"
PLUGIN.Author = "Reneb"
PLUGIN.HasConfig = true

function PLUGIN:Init()
	command.AddChatCommand( "suicide", self.Plugin, "cmdSuicide" )
	command.AddChatCommand( "kill", self.Plugin, "cmdSuicide" )
	command.AddChatCommand( "die", self.Plugin, "cmdSuicide" )
end

function PLUGIN:LoadDefaultConfig()
	self.Config.KillForModerators = self.Config.KillForModerators or true
	self.Config.Messages = {}
	self.Config.Messages.NotAllowed = self.Config.Messages.NotAllowed or "You are not allowed to use this command on someone else"
	self.Config.Messages.PlayerDoesntExist = self.Config.Messages.PlayerDoesntExist or "{username} doesn't exist"
	self.Config.Messages.PlayerWasKilled = self.Config.Messages.PlayerWasKilled or "{username} was killed"
	self.Config.Messages.MultiplePlayersFound =  self.Config.Messages.MultiplePlayersFound or "Multiple Players Found"
end

function PLUGIN:cmdSuicide( player, com, args )
	local authlevel = player:GetComponent("BaseNetworkable").net.connection.authLevel
	local neededlevel = 2
	if(self.Config.KillForModerators) then
		neededlevel = 1
	end
	if(args.Length >= 1) then
		if(authlevel and authlevel >= neededlevel) then
			local target = ""
			for i=0, args.Length-1 do
				if(i == 0) then
					target = args[i]
				else
					target = target .. " " .. args[i]
				end
			end
			local targetplayer = global.BasePlayer.Find(target)
			if(not targetplayer) then
				local plistenum = player.activePlayerList
				local it = plistenum:GetEnumerator()
				while (it:MoveNext()) do
					if(targetplayer) then
						player:ChatMessage(self:BuildMSG(self.Config.Messages.MultiplePlayersFound,target))
						return
					end
					if(string.find(it.Current.displayName,target)) then
						targetplayer = it.Current
					end
				end
				if(not targetplayer) then
					player:ChatMessage(self:BuildMSG(self.Config.Messages.PlayerDoesntExist,target))
					return
				end
			end
			targetplayer:Hurt(1000,Rust.DamageType.Suicide,nil)
			player:ChatMessage(self:BuildMSG(self.Config.Messages.PlayerWasKilled,targetplayer.displayName))
		else
			player:ChatMessage(self:BuildMSG(self.Config.Messages.NotAllowed,targetplayer.displayName))
		end
	else
		player:Hurt(1000,Rust.DamageType.Suicide,nil)
	end
end
function PLUGIN:BuildMSG(msg,name)
	return tostring(string.gsub(msg, "{username}", name))
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\supplysignals.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title        = "Supply Signals"
PLUGIN.Description  = "Supply Signals just like in legacy"
PLUGIN.Author       = "LaserHydra"
PLUGIN.Version      = V(1,0,5)
PLUGIN.HasConfig    = true
PLUGIN.ResourceId     = 933
 
function PLUGIN:Init()
command.AddChatCommand("sstoggle", self.Object, "cmdToggle")
command.AddConsoleCommand("ss.toggle", self.Object, "ccmdToggle")
self:LoadDefaultConfig()
print("#####################################")
print("[Supply Signal]: Plugin by LaserHydra")
print("[Supply Signal]: Loaded!")
print("#####################################")
delay = 3.2
end

function PLUGIN:Unload()
print("#####################################")
print("[Supply Signal]: Unloaded!")
print("#####################################")
end

function PLUGIN:LoadDefaultConfig()
	self.Config.IsEnabled = self.Config.IsEnabled or "true"
	self.Config.NoPermissionMsg = self.Config.NoPermissionMsg or "You have no permission to use this command!"
end

function PLUGIN:cmdToggle(player)
	if player.net.connection.authLevel == 2 then
		if self.Config.IsEnabled == "false" then
			self.Config.IsEnabled = "true"
			self:SaveConfig()
			rust.RunServerCommand("oxide.reload supplysignals")
			rust.SendChatMessage(player, "<color=orange>SUPPLY SIGNALS:</color>", "Plugin enabled!")
			print("********************************************")
			print("[Supply Signal]: Supply Signals enabled!")
			print("********************************************")
		else
			self.Config.IsEnabled = "false"
			self:SaveConfig()
			rust.RunServerCommand("oxide.reload supplysignals")
			rust.SendChatMessage(player, "<color=orange>SUPPLY SIGNALS:</color>", "Plugin disabled!")
			print("********************************************")
			print("[Supply Signal]: Supply Signals disabled!")
			print("********************************************")
		end
	else
		rust.SendChatMessage(player, "<color=orange>SUPPLY SIGNALS:</color>", "" .. self.Config.NoPermissionMsg)
	end
end

function PLUGIN:ccmdToggle()
	if self.Config.IsEnabled == "false" then
		self.Config.IsEnabled = "true"
		self:SaveConfig()
		rust.RunServerCommand("oxide.reload supplysignals")
	print("********************************************")
	print("[Supply Signal]: Supply Signals enabled!")
	print("********************************************")
	else
		self.Config.IsEnabled = "false"
		self:SaveConfig()
		rust.RunServerCommand("oxide.reload supplysignals")
	print("********************************************")
	print("[Supply Signal]: Supply Signals disabled!")
	print("********************************************")
	end
end

function PLUGIN:OnEntitySpawned(entity)
    if self.Config.IsEnabled == "true" then
		if entity.name == "grenade.f1.deployed" or entity.name == "grenade.f1.deployed(Clone)" then
			timer.Once( delay, function() spawnAirdrop() end )
			function spawnAirdrop()
				------------ getting Grenade position ---------------
				local position = (entity:GetEstimatedWorldPosition())
				local pos = {}
				pos.x = tostring(position.x)
				pos.y = tostring(position.y)
				pos.z = tostring(position.z)
				------ Height Fix -----
				pos.y = pos.y + 150
				------- Rounding ------
				pos.x = math.ceil(pos.x)
				pos.y = math.ceil(pos.y)
				pos.z = math.ceil(pos.z)
				---- to one String ----
				dropPos = pos.x .. " " .. pos.y .. " " .. pos.z
				----------- sending Airdrop + Msg ------------
				print("[Supply Signal]: Supply Grenade at " .. dropPos)
				rust.RunServerCommand("airdrop.topos " .. dropPos)
				entity:KillMessage()
			end
		else	
		end
	end
end 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\TimedExecute.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "TimedExecute"
PLUGIN.Version = V(0, 1, 0)
PLUGIN.Description = "Executes a command every (x) seconds."
PLUGIN.Author = "Merka"
PLUGIN.HasConfig = true

function PLUGIN:LoadDefaultConfig()
    self.Config.ShowTimedCommands = "true"
    self.Config.TimedCommands = { 
{"server.save",300},
{"say 'hello world'",600},
}
end

function PLUGIN:OnServerInitialized()
    self:TimedCommands()
end

function PLUGIN:Init()
     self.timers = {}
end

function PLUGIN:Unload()
self:ResetTimers()
end

function PLUGIN:ResetTimers()
for k,v in pairs(self.timers) do
self.timers[k]:Destroy()
end
end



function PLUGIN:TimedCommands()
    self:ResetTimers()
for k,v in pairs(self.Config.TimedCommands) do 
self.timers[k] = timer.Repeat(v[2], 0, function()
        rust.RunServerCommand(v[1])
    end, self.Plugin)
end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\updater.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Updater"
PLUGIN.Version = V(0, 2, 10)
PLUGIN.Description = "Automatic update checking and notifications for plugins."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/681/"
PLUGIN.ResourceId = 681
PLUGIN.HasConfig = true

local debug = false

local function print(message)
    local array = util.TableToArray({ message })
    UnityEngine.Debug.Log.methodarray[0]:Invoke(nil, array)
end

local function warning(message)
    local array = util.TableToArray({ message })
    UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, array)
end

local updateTimer; local emailOutdated, emailUpdated, pushOutdated = "", "", ""
function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdUpdate")
    command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdUpdate")
end

function PLUGIN:OnServerInitialized()
    self:UpdateCheck()
    if tonumber(self.Config.Settings.CheckInterval) > 0 then updateTimer = timer.Repeat(tonumber(self.Config.Settings.CheckInterval), 0, function() self:UpdateCheck() end) end
end

function PLUGIN:cmdUpdate(player, cmd)
    if player and not self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission); return end
    self:UpdateCheck(player)
end

function PLUGIN:ccmdUpdate(arg)
    local player = nil
    if arg.connection then player = arg.connection.player end
    if player and not self:PermissionsCheck(player) then player:SendConsoleCommand("echo " .. self.Config.Messages.NoPermission); return end
    self:UpdateCheck(player)
end

function PLUGIN:UpdateCheck(player)
    print("[" .. self.Title .. "] " .. self.Config.Messages.CheckStarted)
    if player then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.CheckStarted) end
    local outdatedTable; local outdated = 0; local supported = 0
    local pluginList = plugins.GetAll()
    for i = 0, pluginList.Length - 1 do
        local title = pluginList[i].Title
        local version = pluginList[i].Version:ToString()
        local resourceId = tostring(pluginList[i].Object.ResourceId)
        if resourceId ~= nil and resourceId ~= "" and tonumber(resourceId) ~= 0 and resourceId:match("%d") then
            supported = supported + 1
            local url = "https://dev.wulf.im/oxide/" .. resourceId
            webrequests.EnqueueGet(url, function(code, response)
                supported = supported - 1
                if code == 200 and response ~= "" then
                    if version < response then
                        warning("[" .. self.Title .. "] " .. title .. " " .. self.Config.Messages.Outdated .. " " .. self.Config.Messages.Installed .. " " .. version .. ", " .. self.Config.Messages.Latest .. " " .. response)
                        warning("[" .. self.Title .. "] -- " .. self.Config.Messages.Visit .. " http://forum.rustoxide.com/resources/" .. resourceId .. "/")
                        if player then
                            rust.SendChatMessage(player, self.Config.Settings.ChatName, title .. " " .. self.Config.Messages.Outdated .. " " .. self.Config.Messages.Installed .. " " .. version .. ", " .. self.Config.Messages.Latest .. " " .. response)
                            rust.SendChatMessage(player, self.Config.Settings.ChatName, " -- " .. self.Config.Messages.Visit .. " http://forum.rustoxide.com/resources/" .. resourceId .. "/")
                        end
                        outdated = outdated + 1
                        emailOutdated = emailUpdated .. "<b>" .. title .. "</b> " .. self.Config.Messages.Outdated .. " " .. self.Config.Messages.Installed .. " " .. version .. ", " .. self.Config.Messages.Latest .. " " .. response .. "<br/>"
                        pushOutdated = pushOutdated .. title .. " " .. self.Config.Messages.Outdated .. " " .. self.Config.Messages.Installed .. " " .. version .. ", " .. self.Config.Messages.Latest .. " " .. response .. "\n"
                    elseif self.Config.Settings.ShowUpToDate ~= "false" then
                        print("[" .. self.Title .. "] " .. title .. " " .. self.Config.Messages.UpToDate .. " " .. version)
                        if player then rust.SendChatMessage(player, self.Config.Settings.ChatName, title .. " " .. self.Config.Messages.UpToDate .. " " .. version) end
                        emailUpdated = emailUpdated .. "<b>" .. title .. "</b> " .. self.Config.Messages.UpToDate .. " " .. self.Config.Messages.Installed .. " " .. version .. "<br/>"
                    end
                else
                    warning("[" .. self.Title .. "] " .. title .. " " .. self.Config.Messages.CheckFailed)
                    if player then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.CheckFailed) end
                end
                if supported == 0 then
                    print("[" .. self.Title .. "] " .. self.Config.Messages.CheckFinished)
                    if player then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.CheckFinished) end
                    if self.Config.Settings.EmailNotifications ~= "false" and outdated > 0 then
                        local message = self.Config.Messages.EmailMessage:gsub("{outdated}", outdated)
                        local message = message:gsub("{hostname}", global.server.hostname)
                        local message = message:gsub("{outdatedplugins}", emailOutdated)
                        local message = message:gsub("{updatedplugins}", emailUpdated)
                        emailApi = plugins.Find("email")
                        if emailApi then emailApi.Object:EmailMessage("Plugin updates available!", message) end
                        emailOutdated = ""; emailUpdated = ""
                    end
                    if self.Config.Settings.PushNotifications ~= "false" and outdated > 0 then
                        local message = self.Config.Messages.PushMessage:gsub("{outdated}", outdated)
                        local message = message:gsub("{hostname}", global.server.hostname)
                        local message = message:gsub("{outdatedplugins}", pushOutdated)
                        pushApi = plugins.Find("push")
                        if pushApi then pushApi.Object:PushMessage(self.Config.Messages.PushSubject, message, self.Config.Settings.PushPriority, self.Config.Settings.PushSound) end
                        pushOutdated = ""
                    end
                end
            end, self.Plugin)
        end
    end
    print("[" .. self.Title .. "] " .. "Supported plugin count: " .. tostring(supported))
end

function PLUGIN:Unload()
    if updateTimer then updateTimer:Destroy(); updateTimer = nil end
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp) end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "update"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "UPDATER"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or "HELP"
    self.Config.Settings.CheckInterval = tonumber(self.Config.Settings.CheckInterval) or 3600
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "server.update"
    self.Config.Settings.EmailNotifications = self.Config.Settings.EmailNotifications or "false"
    self.Config.Settings.PushNotifications = self.Config.Settings.PushNotifications or "false"
    self.Config.Settings.PushPriority = self.Config.Settings.PushPriority or "high"
    self.Config.Settings.PushSound = self.Config.Settings.PushSound or "gamelan"
    self.Config.Settings.ShowUpToDate = self.Config.Settings.ShowUpToDate or "false"
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or "Use /update to check for plugin updates"
    self.Config.Messages.CheckFailed = self.Config.Messages.CheckFailed or "plugin update check failed!"
    self.Config.Messages.CheckFinished = self.Config.Messages.CheckFinished or "##############  Update check finished!"
    self.Config.Messages.CheckStarted = self.Config.Messages.CheckStarted or "##############  Update check started!"
    self.Config.Messages.Installed = self.Config.Messages.Installed or "Installed:"
    self.Config.Messages.Latest = self.Config.Messages.Latest or "Latest:"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.Outdated = self.Config.Messages.Outdated or "is outdated!"
    self.Config.Messages.EmailMessage = self.Config.Messages.EmailMessage or "{outdated} plugin updates available on your server {hostname}<br/><br/>{outdatedplugins}<br/><br/>{updatedplugins}"
    self.Config.Messages.EmailSubject = self.Config.Messages.EmailSubject or "Plugin updates available!"
    self.Config.Messages.PushMessage = self.Config.Messages.PushMessage or "{outdated} plugin updates available on your server {hostname}\n\n{outdatedplugins}}"
    self.Config.Messages.PushSubject = self.Config.Messages.PushSubject or "Plugin updates available!"
    self.Config.Messages.UpToDate = self.Config.Messages.UpToDate or "is up-to-date, currently using version:"
    self.Config.Messages.Visit = self.Config.Messages.Visit or "Visit"
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\vipname.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Name = "vipname"
PLUGIN.Title = "ViP / Admin / Other - Auto Name Changer"
PLUGIN.Version = V(1, 0, 0)
PLUGIN.Description = "This plugin will autorename any player connecting to your server found in the VIP, Admin or Other lists."
PLUGIN.Author = "TheDoc - Uprising RuST Server"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 795

----------------------------------------- LOCALS -----------------------------------------

-- ----------------------------------------------------------------
-- IsVIP
--
-- Check if the SteamID is found in the list from the config file
-- ----------------------------------------------------------------
local function IsVIP(steamID, self)
	for _, value in pairs(self.Config.Vips) do
		if steamID == value then 
			return true 
		end
	end
end

-- ----------------------------------------------------------------
-- IsAdmin
--
-- Check if the SteamID is found in the list from the config file
-- ----------------------------------------------------------------
local function IsAdmin(steamID, self)
	for _, value in pairs(self.Config.Admins) do
		--print("*** Value = " .. value .. " SteamId= " .. steamID )
		if steamID == value then 
			return true 
		end
	end
end

-- ----------------------------------------------------------------
-- IsOther1
--
-- Check if the SteamID is found in the list from the config file
-- ----------------------------------------------------------------
local function IsOther1(steamID, self)
	for _, value in pairs(self.Config.Other1) do
		--print("*** Value = " .. value .. " SteamId= " .. steamID )
		if steamID == value then 
			return true 
		end
	end
end

-- ----------------------------------------------------------------
-- IsOther2
--
-- Check if the SteamID is found in the list from the config file
-- ----------------------------------------------------------------
local function IsOther2(steamID, self)
	for _, value in pairs(self.Config.Other2) do
		--print("*** Value = " .. value .. " SteamId= " .. steamID )
		if steamID == value then 
			return true 
		end
	end
end

-- ----------------------------------------------------------------
-- IsOther3
--
-- Check if the SteamID is found in the list from the config file
-- ----------------------------------------------------------------
local function IsOther3(steamID, self)
	for _, value in pairs(self.Config.Other3) do
		--print("*** Value = " .. value .. " SteamId= " .. steamID )
		if steamID == value then 
			return true 
		end
	end
end

-- --------------------------------
-- load the default config
-- --------------------------------
function PLUGIN:Init()
    self:LoadDefaultConfig()
end

-- --------------------------------
-- load the default config
-- --------------------------------
function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.VipTag = self.Config.Settings.VipTag or " ]ViP["
	self.Config.Settings.AdminTag = self.Config.Settings.AdminTag or "(Admin) "
	self.Config.Settings.Other1Tag = self.Config.Settings.Other1Tag or " ]Other1["
	self.Config.Settings.Other2Tag = self.Config.Settings.Other2Tag or " ]Other2["
	self.Config.Settings.Other3Tag = self.Config.Settings.Other3Tag or " ]Other3["
	self.Config.Settings.AddVipTag = self.Config.Settings.AddVipTag or "true"
	self.Config.Settings.AddAdminTag = self.Config.Settings.AddAdminTag or "true"
	self.Config.Settings.AddOther1Tag = self.Config.Settings.AddOther1Tag or "false"
	self.Config.Settings.AddOther2Tag = self.Config.Settings.AddOther2Tag or "false"
	self.Config.Settings.AddOther3Tag = self.Config.Settings.AddOther3Tag or "false"
	
	self.Config.Vips = self.Config.Vips or { 
		"99999999999999991",  -- Example 1
		"99999999999999992"   -- Example 2
	}

	self.Config.Admins = self.Config.Admins or { 
		"99999999999999991",  -- Example 1
		"99999999999999992"   -- Example 2
	}
	
	self.Config.Other1 = self.Config.Other1 or {
		"99999999999999991",  -- Example 1
		"99999999999999992"   -- Example 2
	}
	
	self.Config.Other2 = self.Config.Other2 or {
		"99999999999999991",  -- Example 1
		"99999999999999992"   -- Example 2
	}
	
	self.Config.Other3 = self.Config.Other3 or {
		"99999999999999991",  -- Example 1
		"99999999999999992"   -- Example 2
	}
	
    self:SaveConfig()
end

function PLUGIN:OnPlayerConnected(packet)
    if not packet then return end
    if not packet.connection then return end

	local steamID = rust.UserIDFromConnection(packet.connection)

	if self.Config.Settings.AddOther1Tag == "true" then
		if IsOther1(steamID, self) then
			local userDispName = ( packet.connection.username .. self.Config.Settings.Other1Tag)
			packet.connection.username = userDispName
		end
	end

	if self.Config.Settings.AddOther2Tag == "true" then
		if IsOther2(steamID, self) then
			local userDispName = ( packet.connection.username .. self.Config.Settings.Other2Tag)
			packet.connection.username = userDispName
		end
	end

	if self.Config.Settings.AddOther3Tag == "true" then
		if IsOther3(steamID, self) then
			local userDispName = ( packet.connection.username .. self.Config.Settings.Other3Tag)
			packet.connection.username = userDispName
		end
	end
	
	if self.Config.Settings.AddAdminTag == "true" then
		if IsAdmin(steamID, self) then
			local userDispName = ( self.Config.Settings.AdminTag .. packet.connection.username )
			packet.connection.username = userDispName
		end
	end

	if self.Config.Settings.AddVipTag == "true" then
		if IsVIP(steamID, self) then
			local userDispName = ( packet.connection.username .. self.Config.Settings.VipTag)
			packet.connection.username = userDispName
		end
	end

end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\voter.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Voter"
PLUGIN.Version = V(1, 4, 0)
PLUGIN.Description = "Rewards players for voting."
PLUGIN.Author = "Bombardir"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 752
 
----------------------------------------- LOCALS -----------------------------------------
local USERS, API, msgs, settings, requests, ITEMS  = {}, {}, {}, {}, {}, {}
local function SendMessage(player, msg, chatname)
	player:SendConsoleCommand("chat.add", (msgs.ChatPlayerIcon and rust.UserIDFromPlayer(player)) or 0, msgs.ChatFormat:gsub("{NAME}", chatname or msgs.ChatName):gsub("{MESSAGE}", msg))
end
------------------------------------------------------------------------------------------
function PLUGIN:Init()
	if GetEconomyAPI then
		API = GetEconomyAPI()
	end 
	settings = self.Config.Settings or {}

	settings.VoteCommand = settings.VoteCommand or "vote"
	settings.RewardsCommand = settings.RewardsCommand or "rewards"
	settings.DataFile = settings.DataFile or "VoterData"
	 
	local trackers = {
	["[TopRustServers]"] ={ "http://api.toprustservers.com/api/put?plugin=voter&key={KEY}&uid=", "toprustservers.com/server/" }, 
	["[Rust-Servers]"] = { "http://rust-servers.net/api/?action=custom&object=plugin&element=reward&key={KEY}&steamid=", "rust-servers.net/server/" }, 
	["[Rust-ServerList]"] = { "http://rust-serverlist.net/api.php?apikey={KEY}&mode=vote&uid=", "rust-serverlist.net/server.php?id=" } 
	} 
	settings.Trackers = settings.Trackers or {}
	for tracker, table in pairs(trackers) do
		settings.Trackers[tracker] = settings.Trackers[tracker] or {}
		settings.Trackers[tracker].Key = settings.Trackers[tracker].Key or ""
		settings.Trackers[tracker].ID = settings.Trackers[tracker].ID or ""
		settings.Trackers[tracker].PointsForVote = settings.Trackers[tracker].PointsForVote or 1
		if settings.Trackers[tracker].Key ~= "" and settings.Trackers[tracker].ID ~= "" then
			requests[tracker] = {}
			requests[tracker][1] = table[1]:gsub("{KEY}", settings.Trackers[tracker].Key)
			requests[tracker][2] = table[2] .. settings.Trackers[tracker].ID
		end
	end
	 
	settings.Rewards = settings.Rewards or {{ price = 3, reward = { burlap_shoes = 1, burlap_shoes_bp = 1, bow_hunting = 2 } }, { price = 4, reward = { shotgun_waterpipe = 2, Money = 50 } },{ price = 5, reward = { smg_thompson = 1, Money = 400 } }}
	self.Config.Settings = settings
	
	
	msgs = self.Config.Messages or {}
	msgs.ChatFormat = msgs.ChatFormat or "<color=#af5>{NAME}:</color> {MESSAGE}" 
	if msgs.ChatPlayerIcon == nil then msgs.ChatPlayerIcon = true end
	msgs.ChatName = msgs.ChatName or "[Voter]"
	
	msgs.RewardsBegin = (msgs.RewardsBegin or "-------- /%s [id] (Get Reward) --------"):format(settings.RewardsCommand)
	msgs.RewardsBalance = msgs.RewardsBalance or "Your points: %s"
	msgs.RewardsList = msgs.RewardsList or "Points: {PRICE}, Reward: {REWARD}"
	msgs.RewardsEnd = msgs.RewardsEnd or "-------------------------------------------------"
	msgs.RewardNotFound = msgs.RewardNotFound or "Reward with this ID cann't be found!"
	msgs.RewardNotPoints = msgs.RewardNotPoints or  "You do not have enough points for this reward!"
	msgs.RewardGived = msgs.RewardGived or  "You got your reward!"
	
	msgs.StatusCanVote = msgs.StatusCanVote or "You can vote at '%s' (Points for voting: %i)"
	msgs.StatusGetPoint = msgs.StatusGetPoint or "Thanks for vote! (Points received: %s)"
	msgs.StatusBadApiKey = msgs.StatusBadApiKey or "Invalid API key."
	msgs.StatusNotAvailable = msgs.StatusNotAvailable or "The tracker is not available now. Please try again later."
	msgs.Help = msgs.Help or  {"/vote -- show a list of available urls for voting and get points for voting","/rewards -- show the rewards information and your points","/rewards [ID] -- get the reward"}
	
	self.Config.Messages = msgs
	
	self:SaveConfig()
	
	USERS = datafile.GetDataTable( settings.DataFile ) or {}
	
	command.AddChatCommand(settings.VoteCommand, self.Plugin, "C_Vote")
	command.AddChatCommand(settings.RewardsCommand, self.Plugin, "C_Rewards")
end

function PLUGIN:OnServerInitialized()
	-- Credits to Reneb (http://forum.rustoxide.com/plugins/give.666/)
	local it = global.ItemManager.GetItemDefinitions():GetEnumerator()
	while (it:MoveNext()) do
		ITEMS[tostring(it.Current.shortname)] = it.Current.displayname.translated
	end
	------------------------------------------------------------------
end 

function PLUGIN:SendHelpText(player)
    for i=1,#msgs.Help do
		SendMessage(player, msgs.Help[i])
	end
end


function PLUGIN:C_Vote(player)
	local steamid = rust.UserIDFromPlayer(player)
	for shortname, table in pairs(requests) do
		local url = table[1]..steamid
		webrequests.EnqueueGet(url, 
		function(code, content)
			if (code == 200) then
				local cont = tostring(content)
				if cont == "1" then
					local points = settings.Trackers[shortname].PointsForVote
					USERS[steamid] = (USERS[steamid] or 0) + points
					SendMessage(player, msgs.StatusGetPoint:format(points) , shortname)
					datafile.SaveDataTable( settings.DataFile )
					if shortname == "[Rust-ServerList]" then
						webrequests.EnqueueGet(url:gsub("vote", "claimed"), function() end, self.Plugin)
					end
				elseif cont == "API NOT SET UP" or cont == "Error: incorrect server key" or cont == "Bad APIKEY" then
					SendMessage(player, msgs.StatusBadApiKey, shortname)
				else
					SendMessage(player, msgs.StatusCanVote:format(table[2], settings.Trackers[shortname].PointsForVote), shortname)
				end
			else
				SendMessage(player, msgs.StatusNotAvailable, shortname)
			end
		end, self.Plugin )
	end
end

function PLUGIN:C_Rewards(player, cmd, args)
	local arg2 = args.Length > 0 and tonumber(args[0])
	if arg2 then
		local reward = settings.Rewards[arg2]  
		if reward then
			local steamid = rust.UserIDFromPlayer(player)
			local data = USERS[steamid] or 0
			if data >= reward.price then
				local inv = player.inventory
				for shortname, amount in pairs(reward.reward) do
					if shortname == "Money" then
						if API then API:GetUserDataFromPlayer(player):Deposit(amount) end
					else
						local name, count = shortname:gsub("_bp", "")
						if count == 0 then
							item = global.ItemManager.CreateByName(name, amount)
						else
							local def = global.ItemManager.FindItemDefinition.methodarray[1]:Invoke(nil, util.TableToArray( { name } ) )
							if def then item = global.ItemManager.CreateByItemID(def.itemid,amount,true) end
						end
						if item then inv:GiveItem(item) end
					end
				end
				USERS[steamid] = data - reward.price
				datafile.SaveDataTable( settings.DataFile )
				SendMessage(player, msgs.RewardGived)
			else
				SendMessage(player, msgs.RewardNotPoints)
			end
		else
			SendMessage(player,  msgs.RewardNotFound)
		end
	else  
		SendMessage(player,  msgs.RewardsBegin)
		SendMessage(player, msgs.RewardsBalance:format(USERS[rust.UserIDFromPlayer(player)] or 0))
		for i=1, #settings.Rewards do		
			local reward = settings.Rewards[i]
			local msg = msgs.RewardsList:gsub("{PRICE}", tostring(reward.price))
			local names = {}
			for shortname, amount in pairs (reward.reward) do
				local name, count = shortname:gsub("_bp", "")
				table.insert(names, (ITEMS[name] or name) .. ((count > 0 and " BP") or "") .. " x" .. tostring(amount) )
			end
			SendMessage(player, msg:gsub("{REWARD}", table.concat(names, ", ")), "[ID " .. tostring(i) .. "]" )
		end
		SendMessage(player,  msgs.RewardsEnd)
	end
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\warp-system.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--[[ 
 Warp System
 
 Copyright (c) 2015 Nexus <talk@juliocesar.me>, <http://steamcommunity.com/profiles/76561197983103320/>
 
 -------------------------------------------------------------------------------------------------------------------
 This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US.
 -----------------------------------------------------------------------------------------------------------------
 
 $Id$
 Version 0.0.9 by Nexus on 2015-03-01 10:30 AM (UTC -03:00)
]]--

PLUGIN.Name = "warp-system"
PLUGIN.Title = "Warp System"
PLUGIN.Description = "Create teleport points with a custom command"
PLUGIN.Version = V(0, 0, 9)
PLUGIN.Author = "Nexus"
PLUGIN.HasConfig = true
PLUGIN.ResourceId = 760

-- Define Warp System Class
local Warp = {}

Warp.Data = {}
Warp.PreviousLocation = {}
Warp.Timers = {}
Warp.ConfigVersion = "0.0.5"
Warp.ox = PLUGIN

-- Define Settings
Warp.Settings = {}

-- Define Messages
Warp.Messages = {}

-- General Settings:
Warp.DefaultSettings = {
  ChatName = "Warp",
  ConfigVersion = "0.0.5",
  Enabled = true,
  RequiredAuthLevel = 2,
  EnableCooldown = true,
  EnableDailyLimit = true,
  EnableDailyLimitForAdmin = false,
  EnableCoolDownForAdmin = false,
  Cooldown = 60,
  Countdown = 15,
  DailyLimit = 10,
}

-- Plugin Messages:
Warp.DefaultMessages = {
  -- Warp System:
  Remove = "You have removed the warp %s!",
  List = "The following warps are available:",
  Warped = "You Warped to %s!",
  ListEmpty = "There is no warps available!",
  Back = "You have warped back to your previous location!",
  BackSave = "Your previous location has been saved before you warped, use /warp back to teleport back!",
  Save = "You have saved the %s warp as %d, %d, %d!",
  Delete = "You have deleted the %s warp!",
  Ren = 'You have renamed the warp %s to %s!',
  AuthNeeded = 'You don\'t have the right Auth Level to use "%s!"',
  Exists = 'The warp %s already exists!',
  Cooldown = "You need wait %s to use it again.",
  LimitReached = "You have reached the daily limit of %d, You need wait until tomorrow to warp again!",
  Interrupted = "You was interrupted, Before Warp!",
  Pending = "You cannot use a Warp now, Because you are still waiting to get Warped!",
  Started = "Your request is on the wait list, It will start in %d secs.",
  NoPreviousLocationSaved  = "No previous location saved!",
  AuthLog = " %s by %s (%s)",

  -- Error Messages:
  NotFound = "Couldn't find the %s warp !",

  -- Help to admin:
  HelpAdmin = {
    "As an admin you have access to the following commands:",
    "/warp add <name> - Create a new warp at your current location.",
    "/warp add <name> <x> <y> <z> - Create a new warp to the set of coordinates.",
    "/warp del <name> - Delete a warp.",
    "/warp go <name> - Goto a warp.",
    "/warp back - Teleport you back to the location that you was before warp.",
    "/warp list - List all saved warps.",
    "/warp limits - List warp limits"
  },

  -- Help to user
  HelpUser = {
    "As an user you have access to the following commands:",
    "/warp go <name> - Goto a warp.",
    "/warp back - Teleport you back to the location that you was before warp.",
    "/warp list - List all saved warps.",
    "/warp limits - List warp limits."
  },
  
  -- Limits
  Limits = {
    "Warp System as the current settings enabled: ",
    "Time between teleports: %s",
    "Daily amount of teleports: %d"
  },

  -- Syntax Errors Warp System:
  SyntaxCommand = "A Syntax Error Occurred!"
}

-- -----------------------------------------------------------------------------------
-- Warp:UpdateConfig()
-- -----------------------------------------------------------------------------------
-- It check if the config version is outdated
-- -----------------------------------------------------------------------------------
function Warp:UpdateConfig()
  -- Check if the current config version differs from the saved
  if self.ox.Config.Settings.ConfigVersion ~= self.ConfigVersion then
    -- Reset the whole table
    self.ox.Config.Settings = {}
    self.ox.Config.Messages = {}
    
    -- Load the default
    self.ox:LoadDefaultConfig()
    -- Save config
    self.ox:SaveConfig()
  end
  
  -- Copy Tables
  self.Settings = self.ox.Config.Settings
  self.Messages = self.ox.Config.Messages
end

-- -----------------------------------------------------------------------------------
-- Warp:IsAllowed(player)
-- -----------------------------------------------------------------------------------
-- Checks if the player is allowed to run an admin (or moderator) only command.
-- -----------------------------------------------------------------------------------
function Warp:IsAllowed(player)
  -- Check if player is valid
  if player ~= nil then
    -- Check if is connected
    if player:GetComponent("BaseNetworkable").net.connection ~= nil then
      -- Compare the Player's AuthLevel with the required AuthLevel, if it's higher or equal
      return player:GetComponent("BaseNetworkable").net.connection.authLevel >= self.Settings.RequiredAuthLevel
    end
  end

  return false
end

-- -----------------------------------------------------------------------------
-- Warp:Add(player, name, x, y, z)
-- -----------------------------------------------------------------------------
-- Add a new warp.
-- -----------------------------------------------------------------------------
function Warp:Add(player, name, x, y, z)
  -- Get current location
  local loc = player.transform.position

  -- Check if was sent any loc
  if x ~= 0 and y ~= 0 and z ~= 0 then
    -- Save new location
    local loc = {}
    -- Set new loc
    loc.x = math.floor(x)
    loc.y = math.floor(y)
    loc.z = math.floor(z)
  end

  -- Check if the player is allowed to run the command.
  if self:IsAllowed(player) then
    -- Check if Warp already exists
    if Warp.Data.WarpPoints[name] == nil then
      -- Add Warp at the the position
      Warp.Data.WarpPoints[name] = {x = loc.x, y = loc.y, z = loc.z}

      -- Save data
      self.ox:SaveData()

      -- Send message to player
      self:SendMessage(player, self.Messages.Save:format(name, loc.x, loc.y, loc.z) )
    else
      -- Send message to player
      self:SendMessage(player, self.Messages.Exists:format(name))
    end
  else
    -- Send message to player
    self:SendMessage(player, self.Messages.AuthNeeded:format('/warp add'))
  end
end

-- -----------------------------------------------------------------------------
-- Warp:Del(player, name)
-- -----------------------------------------------------------------------------
-- Delete a warp.
-- -----------------------------------------------------------------------------
function Warp:Del(player, name)
  -- Check if the player is allowed to run the command.
  if self:IsAllowed(player) then
    -- Check if Warp exists
    if Warp.Data.WarpPoints[name] ~= nil then
      -- Delete warp
      Warp.Data.WarpPoints[name] = nil

      -- Save data
      self.ox:SaveData()
      -- Send message to player
      self:SendMessage(player, self.Messages.Delete:format(name))
    else
      -- Send message to player
      self:SendMessage(player, self.Messages.NotFound:format(name))
    end
  else
    -- Send message to player
    self:SendMessage(player, self.Messages.AuthNeeded:format('/warp del'))
  end
end

-- -----------------------------------------------------------------------------
-- Warp:Ren(player, oldname, newname)
-- -----------------------------------------------------------------------------
-- Rename a warp.
-- -----------------------------------------------------------------------------
function Warp:Ren(player, oldname, newname)
  -- Check if the player is allowed to run the command.
  if self:IsAllowed(player) then
    -- Check if Warp exists
    if Warp.Data.WarpPoints[oldname] ~= nil then
      -- Check if Warp new exists
      if Warp.Data.WarpPoints[newname] == nil then
        -- Create a new warp
        Warp.Data.WarpPoints[newname] = Warp.Data.WarpPoints[oldname]
        -- Delete warp
        Warp.Data.WarpPoints[oldname] = nil

        -- Save data
        self.ox:SaveData()
        -- Send message to player
        self:SendMessage(player, self.Messages.Ren:format(newname, oldname))
      else
        -- Send message to player
        self:SendMessage( player, self.Messages.Exists:format(newname))
      end
    else
      -- Send message to player
      self:SendMessage(player, self.Messages.WarpNotFound:format(oldname))
    end
  else
    -- Send message to player
    self:SendMessage( player, self.Messages.AuthNeeded:format('/warp ren'))
  end
end

-- -----------------------------------------------------------------------------
-- Warp:Use(player, name)
-- -----------------------------------------------------------------------------
-- Use a Warp to teleport player to a location.
-- -----------------------------------------------------------------------------
function Warp:Use(player, name)
  -- Get PlayerID
  local playerID = rust.UserIDFromPlayer(player)
  
  -- Check if Warp exists
  if Warp.Data.WarpPoints[name] ~= nil then        
    -- Save current position
    Warp.PreviousLocation[playerID] = {x = player.transform.position.x, y = player.transform.position.y, z = player.transform.position.z}
    
    -- Teleport Player to Location
    self:Start(player, Warp.Data.WarpPoints[name].x, Warp.Data.WarpPoints[name].y, Warp.Data.WarpPoints[name].z, self.Messages.Warped:format(name), true)
  else
    -- Send message to player
    self:SendMessage(player, self.Messages.NotFound:format(name))
  end
end

-- -----------------------------------------------------------------------------
-- Warp:Back(player)
-- -----------------------------------------------------------------------------
-- Go back to a point where the player was
-- -----------------------------------------------------------------------------
function Warp:Back(player)
  -- Get PlayerID
  local playerID = rust.UserIDFromPlayer(player)
  -- Check if player already used the Warp
  if Warp.PreviousLocation[playerID] ~= nil then
    -- Teleport Player to Location
    self:Start(player, Warp.PreviousLocation[playerID].x, Warp.PreviousLocation[playerID].y, Warp.PreviousLocation[playerID].z, self.Messages.Back, false)
  else
    -- Send message to player
    self:SendMessage(player, self.Messages.NoPreviousLocationSaved)      
  end
end

-- -----------------------------------------------------------------------------
-- Warp:List(player)
-- -----------------------------------------------------------------------------
-- List all the saved warps
-- -----------------------------------------------------------------------------
function Warp:List(player)
  -- Count the Warp Points
  if self:Count(Warp.Data.WarpPoints) >= 1 then
    -- Send message to player
    self:SendMessage(player, self.Messages.List)

    -- Loop through all the saved locations and print them one by one.
    for location, coordinates in pairs(Warp.Data.WarpPoints) do
      self:SendMessage(player, location..": "..math.floor(coordinates.x).." "..math.floor(coordinates.y).." "..math.floor(coordinates.z))
    end
  else
    -- Send message to player
    self:SendMessage(player, self.Messages.ListEmpty)
  end
end

-- -----------------------------------------------------------------------------
-- Warp:Count(tbl)
-- -----------------------------------------------------------------------------
-- Counts the elements of a table.
-- -----------------------------------------------------------------------------
-- Credit: m-Teleportation
function Warp:Count(tbl)
  local count = 0

  if type(tbl) == "table" then
    for _ in pairs(tbl) do
      count = count + 1
    end
  end

  return count
end

-- -----------------------------------------------------------------------------
-- Warp:Go(player, destination)
-- -----------------------------------------------------------------------------
-- Teleports a player to a specific location.
-- -----------------------------------------------------------------------------
-- Credit: m-Teleportation
function Warp:Go(player, destination)
  -- Let the player sleep to prevent the player from falling through objects.
  player:StartSleeping()

  -- Change the player's position.
  rust.ForcePlayerPosition(player, destination.x, destination.y, destination.z)
  
  -- Set the player flag to receiving snapshots and update the player.
  player:SetPlayerFlag(global["BasePlayer+PlayerFlags"].ReceivingSnapshot, true)
  player:UpdateNetworkGroup()
  player:SendFullSnapshot()
end

-- -----------------------------------------------------------------------------
-- Warp:SendMessage(param, message)
-- -----------------------------------------------------------------------------
-- Sends a chatmessage to a player/console
-- -----------------------------------------------------------------------------
function Warp:SendMessage(param, message)
  -- Check if the message is a table with multiple messages.
  if type(message) == "table" then
    -- Loop by table of messages and send them one by one
    for i, message in pairs(message) do
      -- Loop back
      self:SendMessage(param, message)
    end
  else
    -- Check if param is not null
    if param ~= nil then
      -- Check if call came from user's chat or console
      if type(param.net) == 'userdata' then
          -- Send the message to the targetted player.
         rust.SendChatMessage(param, self.Settings.ChatName, message, rust.UserIDFromPlayer(param))
      elseif type(param.net) == 'string' then    
        -- Check if was passed by client's console 
        if param.connection then
          -- Reply back to player's console
          param:ReplyWith(self.Settings.ChatName..": "..message) 
          -- Send message with authLog to console
          self:SendMessage(nil, self.Messages.AuthLog:format(message, param.connection.player.displayName, rust.UserIDFromPlayer(param.connection.player)))
        else
          -- Send message to console
          self:SendMessage(nil, message)
        end
      end
    else
      -- Log
      self:Log(self.Settings.ChatName..": "..message) 
    end
  end
end

-- ----------------------------------------------------------------------------
-- Warp:ParseRemainingTime( time )
-- ----------------------------------------------------------------------------
-- Returns an amount of seconds as a nice time string.
-- ----------------------------------------------------------------------------
-- Credit: m-Teleportation
function Warp:ParseRemainingTime( time )
    local minutes = nil
    local seconds = nil
    local timeLeft = nil

    -- If the amount of seconds is higher than 60 we'll have minutes too, so
    -- start with grabbing the amount of minutes and then take the remainder as
    -- the seconds that are left on the timer.
    if time >= 60 then
        minutes = math.floor(time/60)
        seconds = time - (minutes*60)
    else
        seconds = time
    end

    -- Build a nice string with the remaining time.
    if minutes and seconds > 0 then
        timeLeft = minutes .. " min"..((minutes > 1) and "s" or "").." " .. seconds .. " sec"..((seconds > 1) and "s" or "")
    elseif minutes and seconds == 0 then
        timeLeft = minutes .. " min"..((minutes > 1) and "s" or "")
    else    
        timeLeft = seconds .. " sec"..((seconds > 1) and "s" or "")
    end

    -- Return the time string.
    return timeLeft        
end

-- -----------------------------------------------------------------------------
-- PLUGIN:Start(player, x, y, z, sendBackSaveMSG)
-- -----------------------------------------------------------------------------
-- Teleports a player to a set of coordinates.
-- -----------------------------------------------------------------------------
-- Credit: m-Teleportation
function Warp:Start(player, x, y, z, doneMessage, sendBackSaveMSG)
  -- Get playerID          
  local playerID = rust.UserIDFromPlayer(player)        

  -- Setup variables with todays date and the current timestamp.
  local timestamp = time.GetUnixTimestamp()
  local currentDate = tostring(time.GetCurrentTime():ToString("d"))

  -- Check if there is saved teleport data available for the
  -- player.
  if Warp.Data.Usage[playerID] then
    if Warp.Data.Usage[playerID].date ~= currentDate then
        Warp.Data.Usage[playerID] = nil
    end
  end

  -- Grab the user his/her teleport data.
  Warp.Data.Usage[playerID] = Warp.Data.Usage[playerID] or {}
  Warp.Data.Usage[playerID].amount = Warp.Data.Usage[playerID].amount or 0
  Warp.Data.Usage[playerID].date = currentDate
  Warp.Data.Usage[playerID].timestamp = Warp.Data.Usage[playerID].timestamp or 0

  -- Check if the cooldown option is enabled and if it is make
  -- sure that the cooldown time has passed.
  if self.Settings.EnableCooldown and (timestamp-Warp.Data.Usage[playerID].timestamp) < self.Settings.Cooldown and (not self:IsAllowed(player) and not self.Settings.EnableCooldownForAdmin) then
    -- Get the remaining time.
    local remainingTime = self:ParseRemainingTime(self.Settings.Cooldown-(timestamp-Warp.Data.Usage[playerID].timestamp))
    -- Teleport is on cooldown, show a message to the player.
    self:SendMessage(player, self.Messages.Cooldown:format(remainingTime))
  
    return
  end
  
  -- Check if the teleports daily limit is enabled and make sure
  -- that the player has not yet reached the limit.
  if self.Settings.EnableDailyLimit and Warp.Data.Usage[playerID].amount >= self.Settings.DailyLimit and (not self:IsAllowed(player) and not self.Settings.EnableDailyLimitForAdmin) then
    -- The player has reached the limit, show a message to the
    -- player.
    self:SendMessage(player, self.Messages.LimitReached:format(self.Settings.DailyLimit))
  
    return
  end

  -- Check if the player already has a teleport pending.
  if Warp.Timers[playerID] then
    -- Send a message to the player.
    self:SendMessage(player, self.Messages.Pending)

    return
  end
  
  -- no limits were reached so we ca
  -- teleport the player after a short delay.
  Warp.Timers[playerID] = timer.Once(self.Settings.Countdown, function()
    -- set the destination for the player.
    local destination = new(UnityEngine.Vector3._type, nil)
    destination.x = x
    destination.y = y
    destination.z = z

    -- Teleport the player to the destination.
    self:Go(player, destination)
    
    -- Modify the teleport amount and last teleport
    -- timestamp.
    Warp.Data.Usage[playerID].amount = Warp.Data.Usage[playerID].amount + 1
    Warp.Data.Usage[playerID].timestamp = timestamp
    -- Save data
    self.ox:SaveData()
    
    -- Show a message to the player.
    self:SendMessage(player, doneMessage)
    
    -- Check if we need send a "Back" message
    if sendBackSaveMSG then
      -- Send message to player
      self:SendMessage(player, self.Messages.BackSave)
    else
      -- Remove previous location 
      Warp.PreviousLocation[playerID] = nil
    end    
    
    -- Remove the pending timer info.
    Warp.Timers[playerID] = nil
    
    -- Update time
    timestamp = time.GetUnixTimestamp()
    currentDate = tostring(time.GetCurrentTime():ToString("d"))
    
    -- Update timer
    Warp.Data.Usage[playerID].date = currentDate
    Warp.Data.Usage[playerID].timestamp = Warp.Data.Usage[playerID].timestamp or 0
  end)
  
  -- Send message to player
  self:SendMessage(player, self.Messages.Started:format(self.Settings.Countdown))
end

-- -----------------------------------------------------------------------------------
-- Warp:Log(message)
-- -----------------------------------------------------------------------------------
-- Log normal
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function Warp:Log(message)
  UnityEngine.Debug.Log.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- Warp:LogWarning(message)
-- -----------------------------------------------------------------------------------
-- Log Warning
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function Warp:LogWarning(message)
  UnityEngine.Debug.LogWarning.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- Warp:LogError(message)
-- -----------------------------------------------------------------------------------
-- Log Error
-- -----------------------------------------------------------------------------------
-- Credit: HooksTest
-- -----------------------------------------------------------------------------------
function Warp:LogError(message)
  UnityEngine.Debug.LogError.methodarray[0]:Invoke(nil, util.TableToArray({message}))
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:Init()
-- -----------------------------------------------------------------------------------
-- On plugin initialisation the required in-game chat commands are registered and data
-- from the DataTable file is loaded.
-- -----------------------------------------------------------------------------------
function PLUGIN:Init ()
  -- Load default saved data
  self:LoadSavedData()

  -- Update config version
  Warp:UpdateConfig()
  
  -- Add chat command
  command.AddChatCommand("warp", self.Plugin, "cmdWarp")
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadSavedData()
-- -----------------------------------------------------------------------------------
-- Load the DataTable file into a table or create a new table when the file doesn't
-- exist yet.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadSavedData()
  Warp.Data = datafile.GetDataTable("warp-system")
  Warp.Data = Warp.Data or {}
  Warp.Data.WarpPoints =  Warp.Data.WarpPoints or {}
  Warp.Data.Usage = Warp.Data.Usage or {}
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SaveData()
-- -----------------------------------------------------------------------------------
-- Saves the table with all the warpdata to a DataTable file.
-- -----------------------------------------------------------------------------------
function PLUGIN:SaveData()
  -- Save the DataTable
  datafile.SaveDataTable("warp-system")
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:LoadDefaultConfig()
-- -----------------------------------------------------------------------------------
-- The plugin uses a configuration file to save certain settings and uses it for
-- localized messages that are send in-game to the players. When this file doesn't
-- exist a new one will be created with these default values.
-- -----------------------------------------------------------------------------------
function PLUGIN:LoadDefaultConfig()
  self.Config.Settings = Warp.DefaultSettings
  self.Config.Messages = Warp.DefaultMessages
end

-- -----------------------------------------------------------------------------
-- PLUGIN:OnRunCommand(args)
-- -----------------------------------------------------------------------------
-- Triggerd when any player send a chat message.
-- -----------------------------------------------------------------------------
function PLUGIN:OnRunCommand(arg)
  if not arg.connection then return end
  if not arg.cmd then return end
  local cmd = arg.cmd.namefull
  local chat = arg:GetString(0, "text")
  local player = arg.connection.player

  if cmd == "chat.say" and string.sub(chat, 1, 1) == "/" then
    -- Loop through all the saved locations and print them one by one.
    for location, _ in pairs(Warp.Data.WarpPoints) do
      -- Check for a Warp Location
      if chat == '/'..location then
        -- Use Warp
        Warp:Use(player, location)
      end
    end
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:cmdWarp(player, cmd, args)
-- -----------------------------------------------------------------------------------
-- In-game '/warp' command for server admins to be able to manage warps.
-- -----------------------------------------------------------------------------------
function PLUGIN:cmdWarp(player, _, args)
  -- Check if the Warp System is enabled.
  if not self.Config.Settings.Enabled then return end

  -- Setup default vars
  local cmd = ''
  local param = ''
  local x = 0
  local y = 0
  local z = 0

  -- Check and setup args
  if args.Length == 1 then
    cmd = args[0]
  elseif args.Length == 2 then
    cmd = args[0]
    param = args[1]
  elseif args.Length == 5 then
    cmd = args[0]
    param = args[1]
    x = args[2]
    y = args[3]
    z = args[4]
  end

  -- Check if the command is to add a new warp
  if cmd == 'add' then
    -- Check if the warp is at a current location
    if args.Length >= 2 then
      -- Test for empty strings
      if param ~= '' or param ~= ' ' then
        -- Add a new warp
        Warp:Add(player, param, x, y, z)
      end
    else
      -- Send message to player
      Warp:SendMessage(player, self.Config.Messages.SyntaxCommand)
      -- List all commands
      self:SendHelpText(player)
    end
    -- Check if the command is to delete a warp
  elseif cmd == 'del' then
    -- Check if param is valid
    if param ~= '' and param ~= ' ' then
      -- Delete a warp
      Warp:Del(player, param)
    else
      -- Send message to player
      Warp:SendMessage(player, self.Config.Messages.SyntaxCommand)
      -- List all commands
      self:SendHelpText(player)
    end
    -- Check if the command is to use a warp
  elseif cmd == 'go' then
    -- Check if param is valid
    if param ~= '' and param ~= ' ' then
      -- Use a Warp
      Warp:Use(player, param)
    else
      -- Send message to player
      Warp:SendMessage(player, self.Config.Messages.SyntaxCommand)
      -- List all commands
      self:SendHelpText(player)
    end
    -- Check if the command is to go back before warp
  elseif cmd == 'back' then
    -- Go Back to the Previous location to Warp
    Warp:Back(player)
  -- Check if the command is to list warps
  elseif cmd == 'list' then
    -- List Warps
    Warp:List(player)
  -- Check if the command is to list limits
  elseif cmd == 'limits' then      
      -- Send messages to player
      Warp:SendMessage(player, self.Config.Messages.Limits[1])
      Warp:SendMessage(player, self.Config.Messages.Limits[2]:format(Warp:ParseRemainingTime(self.Config.Settings.Cooldown)))
      Warp:SendMessage(player, self.Config.Messages.Limits[3]:format(self.Config.Settings.DailyLimit))  
  else
    -- Send message to player
    Warp:SendMessage(player, 'Command '..cmd..' is not valid!' )    
    -- List all commands
    self:SendHelpText(player)
  end
end

-- -----------------------------------------------------------------------------------
-- PLUGIN:SendHelpText(player)
-- -----------------------------------------------------------------------------------
-- HelpText plugin support for the command /help.
-- -----------------------------------------------------------------------------------
function PLUGIN:SendHelpText(player)
  -- Check if player is allowed
  if Warp:IsAllowed(player) then
    -- Send message to player
    Warp:SendMessage(player, self.Config.Messages.HelpAdmin)
  else
    -- Send message to player
    Warp:SendMessage(player, self.Config.Messages.HelpUser)
  end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:OnEntityAttacked(entity, hitinfo)
-- ----------------------------------------------------------------------------
-- OnEntityAttacked Oxide Hook. This hook is triggered when an entity
-- (BasePlayer or BaseNPC) is attacked. This hook is used to interrupt
-- a teleport when a player takes damage.
-- ----------------------------------------------------------------------------
-- Credit: m-Teleportation
function PLUGIN:OnEntityAttacked(entity, hitinfo)
    -- Check if the entity taking damage is a player.
    if entity:ToPlayer() then
        -- The entity taking damage is a player, grab his/her Steam ID.
        local playerID = rust.UserIDFromPlayer( entity )

        -- Check if the player has a teleport pending.
        if Warp.Timers[playerID] ~= nil then
            -- Send a message to the players or to both players.
            Warp:SendMessage(entity, self.Config.Messages.Interrupted)

            -- Destroy the timer.
            Warp.Timers[playerID]:Destroy()

            -- Remove the table entry.
            Warp.Timers[playerID] = nil
        end

    end
end

-- ----------------------------------------------------------------------------
-- PLUGIN:OnPlayerDisconnected(player)
-- ----------------------------------------------------------------------------
-- OnPlayerDisconnected Oxide Hook. This hook is triggered when a player leaves
-- the server. This hook is used to cancel pending the teleport requests and
-- pending teleports for the disconnecting player.
-- ----------------------------------------------------------------------------
-- Credit: m-Teleportation
function PLUGIN:OnPlayerDisconnected(player)
    -- Grab the player his/her Steam ID.
    local playerID = rust.UserIDFromPlayer( player )

    -- Check if the player has a teleport in progress.
    if Warp.Timers[playerID] ~= nil then
        -- The player is about to be teleported, cancel the teleport and remove
        -- the table entry.
        Warp.Timers[playerID]:Destroy()
        Warp.Timers[playerID] = nil
    end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\welcomegifts.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Welcome Gifts"
PLUGIN.Version = V(0, 1, 2)
PLUGIN.Description = "Gives new players one or more welcome gifts on first join."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/resources/703/"
PLUGIN.ResourceId = 703
PLUGIN.HasConfig = true

-- TODO:
---- Give player a choice if multiple gifts are available
---- Add command to reset welcome gift for player/steamid

function PLUGIN:Init()
    self:LoadDefaultConfig()
    self.DataTable = datafile.GetDataTable("welcomegifts")
    self.DataTable.Recipients = self.DataTable.Recipients or {}
end

function PLUGIN:OnPlayerInit(player)
    if not player then return end
    local inv = player.inventory
    local pref = inv.containerMain
    local gifts = self.Config.Settings.Gifts
    local recipients = self.DataTable.Recipients
    local steamId = rust.UserIDFromPlayer(player)
    for key, value in pairs(recipients) do if steamId == key then return end end
    local giftList = ""
    for key, value in pairs(gifts) do
        if not self.ItemTable then self:ItemDefinitions() end
        if self.ItemTable[string.lower(key)] then itemName = self.ItemTable[string.lower(key)] else itemName = key end
        local item = global.ItemManager.CreateByName(itemName, value)
        if not item then
            local message = self.Config.Messages.InvalidItem:gsub("{itemname}", itemName)
            print("[" .. self.Title .. "] " .. message)
            return
        end
        inv:GiveItem(item, pref)
        self.DataTable.Recipients[steamId] = {}
        recipients[steamId] = {}
        giftList = giftList .. ", " .. itemName
    end
    self.DataTable.Recipients[steamId].Gifts = giftList
    datafile.SaveDataTable("welcomegifts")
    local message = self.Config.Messages.GiftsGiven:gsub("{player}", player.displayName)
    print("[" .. self.Title .. "] " .. message)
    local message = self.Config.Messages.GiftsReceived:gsub("{player}", player.displayName)
    rust.SendChatMessage(player, "", message)
end

function PLUGIN:ItemDefinitions()
    self.ItemTable = {}
    local itemList = global.ItemManager.GetItemDefinitions()
    local itemEnum = itemList:GetEnumerator()
    while itemEnum:MoveNext() do
        local itemName = string.lower(itemEnum.Current.displayname, "%%", "t")
        self.ItemTable[itemName] = tostring(itemEnum.Current.shortname)
    end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.Gifts = self.Config.Settings.Gifts or { ["bandage"] = 3, ["apple"] = 5, ["can_tuna"] = 3 }
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.GiftsGiven = self.Config.Messages.GiftsGiven or "Welcome gift(s) given to {player}"
    self.Config.Messages.GiftsReceived = self.Config.Messages.GiftsReceived or "Enjoy your welcome gift(s) {player}!"
    self.Config.Messages.InvalidItem = self.Config.Messages.InvalidItem or "{itemname} is not a valid item!"
    self.Config.Settings.ChatName = nil -- Removed in 0.1.2
    self.Config.Settings.Recipients = nil -- Removed in 0.1.2
    self:SaveConfig()
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
c:\lua\whitelist.lua
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

PLUGIN.Title = "Whitelist"
PLUGIN.Version = V(0, 2, 4)
PLUGIN.Description = "Restricts access to your server, automatically rejecting users whose SteamID is not whitelisted."
PLUGIN.Author = "Wulfspider"
PLUGIN.Url = "http://forum.rustoxide.com/plugins/654/"
PLUGIN.ResourceId = 654
PLUGIN.HasConfig = true

local debug = false

-- TODO:
---- Add console command

function PLUGIN:Init()
    self:LoadDefaultConfig()
    command.AddChatCommand(self.Config.Settings.ChatCommand, self.Plugin, "cmdWhitelist")
    --command.AddConsoleCommand(self.Config.Settings.ConsoleCommand, self.Plugin, "ccmdWhitelist")
end

function PLUGIN:CanClientLogin(connection)
    local steamId = rust.UserIDFromConnection(connection)
    if debug then print(connection.username .. " (" .. steamId .. ") connected") end
    for key, value in pairs(self.Config.Settings.Whitelist) do if steamId == value then return end end
    return self.Config.Messages.Rejected
end

function PLUGIN:cmdWhitelist(player, cmd, args)
    if not self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.NoPermission) return end
    if args.Length ~= 2 then rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.ChatHelp) return end
    local action, argument = args[0], args[1]
    local whitelist = self.Config.Settings.Whitelist
    local steamId
    if string.len(args[1]) == 17 and argument:match("%d+") then
        steamId = argument
    else
        local targetPlayer = global.BasePlayer.Find(argument)
        if targetPlayer then
            steamId = rust.UserIDFromPlayer(targetPlayer)
        else
            rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.InvalidTarget)
            return
        end
    end
    if action == nil or action ~= "add" and action ~= "remove" then
        rust.SendChatMessage(player, self.Config.Settings.ChatName, self.Config.Messages.UnknownAction)
        return
    elseif action == "add" then
        local whitelisted
        for key, value in pairs(whitelist) do if steamId == value then whitelisted = true; break end end
        if whitelisted ~= true then
            table.insert(whitelist, steamId)
            self:SaveConfig()
            local message = self.Config.Messages.PlayerAdded:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        else
            local message = self.Config.Messages.AlreadyAdded:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
            rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
        end
    elseif action == "remove" then
        for key, value in pairs(whitelist) do
            if steamId == value then
                table.remove(whitelist, key)
                self:SaveConfig()
                local message = self.Config.Messages.PlayerRemoved:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
                rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
                break
            else
                local message = self.Config.Messages.NotWhitelisted:gsub("{player}", player.displayName .. " (" .. steamId .. ")")
                rust.SendChatMessage(player, self.Config.Settings.ChatName, message)
            end
        end
    end
end

function PLUGIN:ccmdWhitelist(args)
    -- TODO
end

function PLUGIN:PermissionsCheck(player)
    local authLevel
    if player then authLevel = player.net.connection.authLevel else authLevel = 2 end
    local neededLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    if debug then print(player.displayName .. " has auth level: " .. tostring(authLevel)) end
    if authLevel and authLevel >= neededLevel then return true else return false end
end

function PLUGIN:SendHelpText(player)
    if self:PermissionsCheck(player) then rust.SendChatMessage(player, self.Config.Settings.ChatNameHelp, self.Config.Messages.ChatHelp) end
end

function PLUGIN:LoadDefaultConfig()
    self.Config.Settings = self.Config.Settings or {}
    self.Config.Settings.AuthLevel = tonumber(self.Config.Settings.AuthLevel) or 2
    self.Config.Settings.ChatCommand = self.Config.Settings.ChatCommand or "whitelist"
    self.Config.Settings.ChatName = self.Config.Settings.ChatName or "WHITELIST"
    self.Config.Settings.ChatNameHelp = self.Config.Settings.ChatNameHelp or self.Config.Settings.HelpChatName or "HELP"
    self.Config.Settings.ConsoleCommand = self.Config.Settings.ConsoleCommand or "server.whitelist"
    self.Config.Settings.Whitelist = self.Config.Settings.Whitelist or { "76561197960634567", "76561197994144473" }
    self.Config.Messages = self.Config.Messages or {}
    self.Config.Messages.AlreadyAdded = self.Config.Messages.AlreadyAdded or "{player} is already whitelisted!"
    self.Config.Messages.ChatHelp = self.Config.Messages.ChatHelp or self.Config.Messages.ChatHelpText or "Use '/whitelist add|remove player|steamid'"
    self.Config.Messages.InvalidTarget = self.Config.Messages.InvalidTarget or "Invalid player or SteamID! Please try again"
    self.Config.Messages.NoPermission = self.Config.Messages.NoPermission or "You do not have permission to use this command!"
    self.Config.Messages.NotWhitelisted = self.Config.Messages.NotWhitelisted or "{player} is not whitelisted!"
    self.Config.Messages.PlayerAdded = self.Config.Messages.PlayerAdded or "{player} has been added to the whitelist!"
    self.Config.Messages.PlayerRemoved = self.Config.Messages.PlayerRemoved or "{player} has been removed from the whitelist!"
    self.Config.Messages.Rejected = self.Config.Messages.Rejected or "Sorry, you are not whitelisted!"
    self.Config.Messages.UnknownAction = self.Config.Messages.UnknownAction or "Unknown command action! Use add or remove"
    self.Config.Settings.HelpChatName = nil -- Removed in 0.2.3
    self.Config.Messages.ChatHelpText = nil -- Removed in 0.2.3
    self:SaveConfig()
end
